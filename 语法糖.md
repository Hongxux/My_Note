- 本质：编译器提供的快捷写法，在编译阶段会被转换为底层的基础代码
	- 解糖：
		- 时机：**编译阶段**
			- 零成本抽象：运行时候可以额外性能开销
		- 作用：将语法糖还原成底层的基础语法
- 设计目的：
	- 语法糖更符合人类直觉
	- 减少样板代码
- 常见语法糖和坑
	1. 泛型 ：通过**类型擦除**实现，泛型信息仅在编译阶段存在，用于类型检查，运行时 JVM 看到的只是原始类型。
		- **语法糖写法**：
		    ```
		    List<String> list = new ArrayList<>();
		    list.add("Hello");
		    String s = list.get(0); // 无需手动转换
		    ```
		- **解糖后近似代码**：
		    ```
		    List list = new ArrayList(); // 类型信息被擦除
		    list.add("Hello");
		    String s = (String) list.get(0); // 编译器插入强制转换
		    ```
		- **主要注意事项**：
		    - **类型擦除**：由于类型擦除，运行时无法得知 `List<String>`和 `List<Integer>`的区别，它们都是 `List.class`。
		    - **重载陷阱**：不能使用泛型类型不同来重载方法，因为编译后方法签名相同。例如 `method(List<String> list)`和 `method(List<Integer> list)`编译后都是 `method(List list)`，会导致编译错误 。
	2. 自动装箱与拆箱：自动在基本数据类型（如 `int`）和对应的包装类（如 `Integer`）之间进行转换。
		- **语法糖写法**：
			```
			Integer i = 10; // 自动装箱 (int -> Integer)
			int j = i;      // 自动拆箱 (Integer -> int)
			```
		- **解糖后代码**：
			```
			Integer i = Integer.valueOf(10); // 自动装箱
			int j = i.intValue();            // 自动拆箱
			```
		- **主要注意事项**：
			- **空指针风险**：如果包装类对象为 `null`，进行拆箱操作会抛出 `NullPointerException`。
				```
				Integer nullInteger = null;
				int n = nullInteger; // 运行时抛出 NullPointerException
				```
			- **性能开销与对象缓存**：装箱操作会创建对象。注意包装类的缓存机制（如 `Integer`默认缓存 -128 至 127），超出缓存范围会创建新对象 。
				```
				Integer a = 127;
				Integer b = 127;
				System.out.println(a == b); // true, 从缓存中取，是同一个对象
				
				Integer c = 128;
				Integer d = 128;
				System.out.println(c == d); // false, 超出缓存范围，是新创建的对象
				```
	3. 增强的 for 循环 (For-each Loop)：简化数组和集合的遍历。
		- **语法糖写法**：
		    ```
		    List<String> list = Arrays.asList("A", "B", "C");
		    for (String s : list) {
		        System.out.println(s);
		    }
		    ```
		- **解糖后代码（对于集合）**：
		    
		    ```
		    List<String> list = Arrays.asList("A", "B", "C");
		    for (Iterator<String> i = list.iterator(); i.hasNext(); ) {
		        String s = i.next();
		        System.out.println(s);
		    }
		    ```
		- **主要注意事项**：
		    - **修改异常**：在增强 for 循环中，**不能直接通过集合的 `add`、`remove`等方法修改集合结构**，否则会抛出 `ConcurrentModificationException`。需要修改时应使用 `Iterator`的 `remove()`方法 。
		    ```
		    // 错误示例
		    for (String s : list) {
		        if ("B".equals(s)) {
		            list.remove(s); // 可能抛出 ConcurrentModificationException
		        }
		    }
		    // 正确做法：使用 Iterator
		    Iterator<String> iterator = list.iterator();
		    while (iterator.hasNext()) {
		        String s = iterator.next();
		        if ("B".equals(s)) {
		            iterator.remove(); // 安全删除
		        }
		    }
		    ```
	4. Try-with-resources：优雅地自动管理资源关闭。
		- **语法糖写法**：
			```
			// 资源会在try块结束后自动关闭，即使发生异常
			try (FileInputStream fis = new FileInputStream("file.txt");
				 BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {
				System.out.println(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
			```
		- **解糖后逻辑**：编译器会生成复杂的 `try-catch-finally`块，确保每个资源都被正确关闭。如果 `try`块和 `close()`都抛出异常，后者的异常会被抑制并添加到前者的异常中（通过 `addSuppressed`方法），不会丢失异常信息 。
		- **主要注意事项**：
			- 资源类（如 `FileInputStream`）必须实现 `AutoCloseable`接口。
	5. 字符串拼接 (`+`)
		- **语法糖写法**：
		    ```
		    String str = "Hello, " + name + "!";
		    ```
		- **解糖后代码（非循环体内）**：
		    ```
		    String str = new StringBuilder().append("Hello, ").append(name).append("!").toString();
		    ```
		- **主要注意事项**：
		    - **循环体内的性能陷阱**：**绝对避免在循环体内使用 `+`拼接字符串**​ 。
		    ```
		    // 错误示范：低效！
		    String result = "";
		    for (int i = 0; i < 1000; i++) {
		        result += i; // 每次循环都会 new StringBuilder，然后 toString()
		    }
		    // 正确做法：在循环外创建一个 StringBuilder
		    StringBuilder sb = new StringBuilder();
		    for (int i = 0; i < 1000; i++) {
		        sb.append(i);
		    }
		    String result = sb.toString();
		    ```
	6.  匿名内部类：匿名内部类提供了一种便捷的方式来实例化接口或抽象类，而无需显式定义一个新类。编译后，它会成为一个独立的类文件。
		- **语法糖写法**：
		    ```
		    public class Outer {
		        public void doSomething() {
		            Runnable task = new Runnable() {
		                @Override
		                public void run() {
		                    System.out.println("匿名内部类在运行");
		                }
		            };
		            new Thread(task).start();
		        }
		    }
		    ```
		- **解糖后近似代码**：编译器会生成一个类似`Outer$1.class`的文件。反编译后，可以看到编译器添加了指向外部类的引用。
		    ```
		    // 编译器生成的 Outer$1.class
		    class Outer$1 implements Runnable {
		        final Outer this$0; // 编译器合成的字段，指向外部类对象
		    
		        Outer$1(Outer this$0) {
		            this.this$0 = this$0; // 编译器生成的构造器
		        }
		    
		        @Override
		        public void run() {
		            System.out.println("匿名内部类在运行");
		        }
		    }
		    ```
		    在使用处，代码被转换为：
		    ```
		    public class Outer {
		        public void doSomething() {
		            // 传入外部类引用`this`来实例化匿名内部类
		            Runnable task = new Outer$1(this);
		            new Thread(task).start();
		        }
		    }
		    ```
		- **主要注意事项**：
		    - **内存泄漏风险**：匿名内部类对象会**隐式持有外部类对象的引用**。如果这个内部类实例的生命周期长于外部类实例（例如被放入一个静态集合或正在执行的异步任务），会导致外部类实例无法被垃圾回收，从而造成内存泄漏。
			    - 解决措施：使用静态内部类 + 弱引用持有外部类引用
				    - 静态内部类：不持有外部类的隐式引用
				    - `WeakReference`包裹外部类：使得垃圾回收器在决定是否回收外部类实例时，可以忽略这个弱引用
				    - 示例代码：
						```
						public class MainActivity extends AppCompatActivity {
							private MyButton myButton;
						
							@Override
							protected void onCreate(Bundle savedInstanceState) {
								super.onCreate(savedInstanceState);
								myButton = findViewById(R.id.my_button);
								// 传递外部类引用时使用弱引用
								myButton.setOnClickListener(new MyClickListener(this));
							}
						
							// 1. 使用静态内部类，避免持有外部类引用
							private static class MyClickListener implements View.OnClickListener {
								// 2. 使用弱引用来持有外部类实例
								private final WeakReference<MainActivity> activityWeakReference;
						
								MyClickListener(MainActivity activity) {
									this.activityWeakReference = new WeakReference<>(activity);
								}
						
								@Override
								public void onClick(View v) {
									// 3. 使用前先获取活动实例，并检查是否有效
									MainActivity activity = activityWeakReference.get();
									if (activity != null && !activity.isFinishing()) { // 检查Activity未被销毁
										// 安全地使用activity，例如更新UI
										activity.updateUI();
									}
								}
							}
						
							private void updateUI() {
								// 更新界面
							}
						}
						```
		    - **性能考量**：每次执行到定义匿名内部类的地方，都会生成一个新的类对象（虽然类本身只加载一次）。在敏感的场景下，可能会考虑其他方式。
	7. 字符串 switch (`switch String`) 的哈希与相等检查：Java 7 开始支持在`switch`语句中使用`String`，这通过一个巧妙的双重检查机制实现。
		- **语法糖写法**：
		    ```
		    String fruit = "apple";
		    switch (fruit) {
		        case "apple":
		            System.out.println("It's an apple.");
		            break;
		        case "banana":
		            System.out.println("It's a banana.");
		            break;
		        default:
		            System.out.println("Unknown fruit.");
		    }
		    ```
		- **解糖后近似代码**：编译器会将上面的代码转换为以下形式，以确保高效和正确。
		    ```
		    String fruit = "apple";
		    int hashCode = fruit.hashCode(); // 先计算哈希值
		    int switchValue = -1;
		    
		    // 第一层switch：基于哈希值快速定位可能的分支
		    switch (hashCode) {
		        case 93029210: // "apple"的哈希码
		            if (fruit.equals("apple")) {
		                switchValue = 0; // 匹配到第一个case
		            }
		            break;
		        case -1396355227: // "banana"的哈希码
		            if (fruit.equals("banana")) {
		                switchValue = 1; // 匹配到第二个case
		            }
		            break;
		        default:
		            break;
		    }
		    
		    // 第二层switch：基于精确匹配后的结果执行代码
		    switch (switchValue) {
		        case 0:
		            System.out.println("It's an apple.");
		            break;
		        case 1:
		            System.out.println("It's a banana.");
		            break;
		        default:
		            System.out.println("Unknown fruit.");
		    }
		    ```
		- **主要注意事项**：
		    - **`null`值**：如果`switch`的表达式`fruit`为`null`，在调用`hashCode()`时会抛出`NullPointerException`。
		    - **性能**：虽然通常很快，但相比`switch`原生整数类型，多了一次哈希计算和可能发生的`equals`比较。
		    - **case 敏感性**：`case`标签是大小写敏感的，因为`equals`比较是大小写敏感的。
	8.  枚举 Switch (`switch enum`) 的序数转换：对枚举使用`switch`，底层会利用枚举常量的序数（`ordinal`，一个整数）来进行高效跳转。
		- **语法糖写法**：
		    ```
		    enum Day { MONDAY, TUESDAY, WEDNESDAY }
		    Day today = Day.MONDAY;
		    switch (today) {
		        case MONDAY:
		           .println("星期一");
		            break;
		        case TUESDAY:
		            System.out.println("星期二");
		            break;
		        default:
		            System.out.println("其他日子");
		    }
		    ```
		- **解糖后近似代码**：编译器会将`switch`转换为基于`Day.MONDAY.ordinal()`（返回0）这样的序数值操作。
		    ```
		    Day today = Day.MONDAY;
		    switch (today.ordinal()) { // 使用枚举常量的序数
		        case 0: // 对应 Day.MONDAY.ordinal()
		            System.out.println("星期一");
		            break;
		        case 1: // 对应 Day.TUESDAY.ordinal()
		            System.out.println("星期二");
		            break;
		        default:
		            System.out.println("其他日子");
		    }
		    ```
		    在某些更复杂的情况下，编译器可能会生成一个名为`外部类$1`的辅助类，其中包含一个静态数组，用于映射序数到连续的case数字，以处理不连续的序数或优化跳转表。
		- **主要注意事项**：
		    - **完整性**：如果`switch`语句没有覆盖枚举的所有值，并且没有`default`分支，编译器可能会产生警告。这是一个良好的代码实践检查点。
	9. 枚举类型的完整类结构`enum`关键字本身就是一个强大的语法糖，它让定义类型安全的常量变得非常简单。
		- **语法糖写法**：
			```
			public enum Color {
				RED, GREEN, BLUE
			}
			```
		- **解糖后近似代码**：编译器会生成一个丰富的类结构。
			```
			public final class Color extends Enum<Color> { // 自动继承Enum类
				// 预定义的枚举实例，都是public static final
				public static final Color RED = new Color("RED", 0);
				public static final Color GREEN = new Color("GREEN", 1);
				public static final Color BLUE = new Color("BLUE", 2);
			
				// 保存所有枚举值的数组
				private static final Color[] $VALUES = {RED, GREEN, BLUE};
			
				// 自动生成的方法
				public static Color[] values() {
					return $VALUES.clone();
				}
				public static Color valueOf(String name) {
					return Enum.valueOf(Color.class, name);
				}
			
				// 私有构造器，防止外部实例化
				private Color(String name, int ordinal) {
					super(name, ordinal);
				}
			}
			```
		- **主要注意事项**：
			- **单例性**：每个枚举常量都是唯一的单例实例，这使得枚举是实现线程安全单例模式的有效方式之一。
			- **无法继承**：枚举类已经隐式继承了`java.lang.Enum`，而Java不支持多继承，因此枚举类不能再显式继承其他类，接口。
    