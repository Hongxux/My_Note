- 定义
	- **内部碎片 (Internal Fragmentation):** 
		- 定义：指B+Tree页**内部**存在未被利用的空闲空间。
		- 来源：页分裂或删除了部分数据后留下的。
		- 问题：导致每个页承载的有效数据减少，扫描同样数量的记录需要读取更多的物理页 。
	- **逻辑碎片 (Logical Fragmentation):** 
		- 定义：指B+Tree叶子节点在逻辑上是连续的（通过双向链表），但在物理磁盘上的存储是不连续的。
		- 来源：页分裂
		- 问题：这使得范围扫描时，磁头需要进行更多的随机寻道，而不是平滑的顺序读取，从而降低I/O效率。
- 检测碎片的方式
	- **使用 `information_schema`：** 对于使用 `innodb_file_per_table` 设置的InnoDB表，可以通过查询 `information_schema.TABLES` 视图来获取碎片信息。
	    
	    `SELECT table_name, engine, data_free FROM information_schema.TABLES WHERE table_schema = 'your_database_name' AND data_free > 0;`
	    
	    这里的 `data_free` 字段表示已分配但未使用的空间大小，可以作为碎片程度的一个重要指标 。一个很大的 `data_free` 值通常意味着严重的内部碎片。
	    
- 修复方式：碎片整理
	- 本质：重建表，将数据和索引在一个新的、连续的物理空间中重新组织。
	- 方式：
		- **`OPTIMIZE TABLE` 命令：**
		    - 这是最直接的碎片整理方式。对于InnoDB表，`OPTIMIZE TABLE a;` 在内部被映射为 `ALTER TABLE a ENGINE=InnoDB;`（在新版本中可能是 `ALTER TABLE a FORCE;`），
		    - 工作模式：对表加锁，强制MySQL重建表 。
		    - 缺点：加表锁会暂停服务
		- **`ALTER TABLE` (Null-Op)：**
		    - 执行一个“空”的 `ALTER` 操作，例如 `ALTER TABLE table_name ENGINE = InnoDB;`，也能达到重建表的效果 。
		- **`mysqldump` 导入导出：**
		    - 最原始但有效的方法：使用 `mysqldump` 将数据导出为SQL文件，删除原表，然后重新创建表并导入数据。这会创建一个全新的、没有任何碎片的表 。
		- **在线DDL工具（生产环境推荐）：**
		    - 对于繁忙的生产系统，不能容忍长时间锁表，推荐使用 Percona Toolkit 中的 `pt-online-schema-change` 或 GitHub 的 `gh-ost` 等在线DDL工具。
		    - **工作原理：** 
			    1. **创建影子表**：首先，工具会创建一个与原表结构相同的新表（通常称为影子表）。
				2. **建立增量同步**：在原表上创建 **INSERT, UPDATE, DELETE 触发器**。这些触发器确保在工具运行期间，对原表的所有数据变更都会**实时地**应用到影子表上，这是保证数据最终一致性的关键。
				3. **全量数据迁移**：工具会以可控的**批处理（chunk）方式**将原表中的历史数据分批次拷贝到影子表中。这个过程会刻意放慢，以避免对数据库性能造成显著影响。
				4. **原子性切换**：当历史数据拷贝完成，并且增量数据也基本同步后，工具会执行一个**原子性的 RENAME 操作**，将原表重命名，再将影子表重命名为原表的名字。此操作通常仅需极短的锁表时间，对业务近乎无感。
				5. **清理工作**：在切换成功后，工具会删除被重命名的旧表以及之前创建的触发器。
