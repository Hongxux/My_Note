### 字段类型
- 选择原则：
	- **最小化原则**：用最小的数据类型满足业务需求，减少内存占用
	- **精度与性能平衡**：金融数据必须用`DECIMAL`，测量数据可用`FLOAT`
	- **避免隐式转换**：确保关联字段类型一致，防止索引失效
	- **存储效率**：`CHAR`比`VARCHAR`少1字节长度标识，大量数据时差异显著
- 数据类型分类与适用场景
	- **数值型**：
		- **整型**：根据数据范围选择合适类型
		    - `TINYINT`：适用于状态码、性别等小范围值（0-255）
		    - `INT`：通用整型，适合ID、年龄等（-21亿～21亿）
		    - `BIGINT`：超大范围场景，如分布式系统主键（-922亿亿～922亿亿）
		- **浮点型**：
		    - `FLOAT`/`DOUBLE`：适合科学计算等对精度要求不高的场景
		    - `DECIMAL`：**金融金额必用**，可精确控制小数位数（如`DECIMAL(18,2)`）2427
	- **字符型**：
		- **`CHAR(n)`**：固定长度，适合MD5、UUID等固定长度字符串，**查询性能更优**
		- **`VARCHAR(n)`**：变长字符串，适合用户名、地址等长度不一的数据，**节省存储空间**
		- **`TEXT`系列**：仅用于大文本（如文章内容），避免过度使用，**影响性能**
			- 优点：
				- **行外存储**：内容存储在独立于主记录的“溢出页”中，仅在行内保留一个指针。这避免了单条记录过大，影响数据页的存储效率
				- **内存友好**：由于行内只存指针，在进行排序、分组或创建临时表等操作时，MySQL在内存中为每条记录分配的空间很小，性能更高
				- **容量无忧**：从根本上避免了因评论内容意外超长而导致的数据截断或插入失败问题
			- **性能杀手**：`TEXT` 字段通常存储在溢出页中，查询时会产生额外的磁盘 I/O。
				- 只有确定存储的会超过3万个汉字
			- **排序慢**：对 `TEXT` 字段排序（`ORDER BY`）会使用磁盘临时表，非常慢。
			- **建议**：如果不需要全文检索，尽量不要给 `TEXT` 建索引；如果需要搜索，考虑使用 Elasticsearch
		-  `BLOB` 系列
			- **场景**：存储二进制数据，如图片、音频、PDF 文件。
			- **建议**：通常不建议直接存文件内容到数据库，建议存文件路径，数据库只存元数据。
	- **日期时间型**：
		- **`DATE`**：仅需年月日时使用
		- **`DATETIME`**：常规时间戳，精度到秒
		- **`TIMESTAMP`**：自动处理时区，适合跨时区业务，但**转换会增加CPU消耗**
		- **`DATETIME2`**：更高精度，推荐替代`DATETIME`
### 约束类型 
- 选择原则：
	- **检查约束（CHECK）的边界**：
	    - **原则**：只在数据库层面做**简单**的数值范围或格式校验（如 `age > 0`, `price >= 0`）。
	    - **避坑**：不要在 `CHECK` 中写复杂的正则表达式（如严格的邮箱格式、身份证号校验）或嵌套子查询。这不仅会导致 SQL 语句臃肿，还可能在低版本 MySQL 中不生效。复杂的格式校验应该放在应用层（Service 层）进行。
	- **避免过度索引**：
	    - **原则**：不要为了“以防万一”给所有字段都加索引。
	    - **理由**：一张表的索引（由主键、唯一、外键产生）最好不要超过 5-6 个。索引过多会导致插入、更新、删除变慢，且占用大量磁盘空间。
- 约束类型分类与适用场景
	1. 主键约束 (PRIMARY KEY)
		- 适用场景：
		    - 每张表都应该有一个主键，通常是逻辑上的唯一标识（如 `id`）。
		    - 推荐使用代理主键（无业务含义的自增 ID），而不是自然主键（如身份证号、手机号）。
		- 核心坑点：
		    - 避免乱序主键
				- 问题：页分裂现象
					- 出现时机：向一个**已满**的数据页插入新数据
					- 页分裂：InnoDB 申请一个新的数据页，并将原页的部分数据移动到新页，以容纳新插入的数据
					- 后果：![[Pasted image 20251030220531.png]]![[Pasted image 20251030220642.png]]
					    1. **性能下降**​： 涉及磁盘分配和数据移动。
					    2. ​**空间浪费**​： 页分裂后，每个页的填充率会降低（通常约为50%）。
					    3. ​**数据碎片化**​： 降低连续读取的效率。
				- 解决措施：使用自增主键
					- 效果：新数据总是追加到 B+Tree 的末尾，最大程度避免了中间数据页的分裂。
			- 降低主键长度​
				- 原理：主键值会出现在所有非主键索引的叶子节点中
				- 好处：主键长度越短，普通索引占用的空间就越小，整体性能越高。
			- 稳定性：
				- 含义：主键值应**不随时间或业务规则而改变**
				- 原因：修改主键会带来高昂的维护成本
		    - 复合主键的复杂性：虽然支持多个字段组合为主键，但会让索引变大，且在关联其他表时（作为外键）非常麻烦，**尽量避免**，除非是“多对多”关系的中间表。
		    - 自增主键的删除空洞：`AUTO_INCREMENT` 删除数据后，ID 不会回填，这在某些业务（如展示“第几万名用户”）中可能需要特殊处理。
	2. 外键约束 (FOREIGN KEY)
		- 选择原则：
	        - **小项目/低并发**：使用物理外键，由数据库保证参照完整性，省心且安全。
	        - **大项目/高并发**：**禁用物理外键**。由应用层代码来维护数据一致性。
	    - 理由：
		    - 物理外键在每次插入或删除时，数据库都需要去另一张表校验，会产生**行锁甚至表锁**，严重拖慢写入性能。
		    - 应用层维护可以将关联操作放在一个事务中，或者通过消息队列异步处理，解耦且高效。
		- 使用前提
			- 存储引擎支持：外键约束**仅在 InnoDB 引擎生效**。如果你用的是 MyISAM，外键语法虽然能写上去，但完全不起作用。
			- 数据类型必须严格一致：从表的外键字段类型必须和主表的被引用字段类型**完全一致**（包括是否有符号 `SIGNED/UNSIGNED`）
		- 核心坑点：
		    - 级联操作的误删风险：设置了 `ON DELETE CASCADE`（级联删除）后，删除主表一条数据，可能悄无声息地干掉从表几千条数据，操作需极度谨慎。
		    - 级联操作是阻塞的：会带来停顿
	3. 唯一约束 (UNIQUE)
		- 原则：只为确实需要唯一性校验且查询频繁的字段加 `UNIQUE`。
	    - 理由：
		    - 唯一约束会创建唯一索引，虽然提高了查询速度，但插入数据时需要校验唯一性（二次查询），会增加写入开销。
		    - 如果业务层已经做了充分校验，且数据量极大，可以考虑去掉物理层的唯一约束。
		- 核心坑点：
		    - NULL 值的特殊性：这是最容易被误解的地方！在 MySQL 中，`UNIQUE` 约束下，NULL 值不等于 NULL 值。这意味着你可以在该字段插入多个 `NULL`，而不会违反唯一约束。
		    - 重复索引浪费：如果你给一个字段加了 `UNIQUE`，它会自动建索引。如果你又手动在这个字段上建了一个普通索引，就造成了索引冗余，浪费存储和写入性能。
	4. 非空约束 (NOT NULL)
		- 适用场景：
		    - 所有业务逻辑上“必填”的字段。
		    - **强烈建议**：所有字段在设计时，默认都加上 `NOT NULL`，除非你明确知道这个字段确实可以为空。
		- 核心坑点：
		    - NULL 值导致索引失效：在包含 `NULL` 值的列上建立索引，查询效率会降低。最好将字段定义为 `NOT NULL` 并配合 `DEFAULT`（如空字符串 `''` 或 `0`）。
		    - NULL 参与运算的结果：任何值与 `NULL` 进行数学运算（`+`, `-`, `*`, `/`），结果都是 `NULL`。这在统计报表时容易产生“幽灵数据”。
	 5. 检查约束 (CHECK)
		- 适用场景：
		    - 限制字段的取值范围。例如：年龄 `CHECK (age >= 0)`，状态 `CHECK (status IN ('active', 'inactive'))`。
		- 核心坑点：
		    - 历史版本兼容性：在 **MySQL 8.0 之前**的版本（如 5.7），MySQL 会解析但忽略 `CHECK` 子句，即它不起任何作用。如果你用的是老版本 MySQL，必须在应用代码层做校验。
		    - 表达式限制：只能是针对当前行字段的简单逻辑判断。
			    - 不能使用子查询
			    - 不能使用某些函数（如 `NOW()`）
	6. 默认值 (DEFAULT)
		- 适用场景：
		    - 有默认状态的字段。如：用户注册默认状态为“启用”，创建时间默认为 `CURRENT_TIMESTAMP`。
		- 核心坑点：
		    - 插入 NULL 时的行为：如果你显式地执行 `INSERT INTO table (col) VALUES (NULL)`，即使你设置了 `DEFAULT`，MySQL 也会优先存入 `NULL`（除非该字段同时有 `NOT NULL` 约束）。
		    - 时间类型的陷阱：`TIMESTAMP` 的 `DEFAULT CURRENT_TIMESTAMP` 会受时区影响，而 `DATETIME` 不会。
