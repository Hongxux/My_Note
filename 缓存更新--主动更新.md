---
aliases:
  - 自动更新
  - 缓存更新
---
### 主动更新策略的三种选择---选择应用层更新
![[Pasted image 20251118123512.png]]

| 模式                     | 哲学思想                           | 数据最新位置                   | 优点                              | 缺点（您提到的核心问题）                                                                                         | 适用场景                                         |
| ---------------------- | ------------------------------ | ------------------------ | ------------------------------- | ---------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| **[[Cache Aside]]**    | **应用层驱动**：由应用代码显式管理缓存和数据库的读写。  | **缓存中可能是旧数据**（直到被删除或过期）。 | 实现简单、灵活性高、是业界最常用的模式。            | 需要应用代码处理一致性逻辑，可能发生缓存不一致的时间窗口。                                                                        | **绝大多数业务场景**，如用户信息、商品信息等。                    |
| **Read/Write Through** | **抽象服务层**：缓存作为数据库的代理，应用只和缓存交互。 | **缓存和数据保持同步**（在服务层内保证）。  | 对应用透明，简化了开发逻辑。                  | 实现更复杂，需要提供统一的缓存服务。                                                                                   | 对一致性要求较高，且希望简化应用代码的场景。                       |
| **Write Behind**       | **性能优先，最终一致**：应用只写缓存，异步批量刷库。   | **缓存是最新数据，数据库是旧数据**。     | **写入性能极高**（内存操作）、可合并写操作减少数据库压力。 | **1. 数据丢失风险**：缓存宕机则未持久化的数据全部丢失。  <br>**2. 实现复杂**：需实现异步任务、重试、批处理。  <br>**3. 一致性弱**：只能是最终一致性，且延迟时间不确定。 | **写入极其频繁，可容忍少量数据丢失**的场景，如：操作日志、用户行为追踪、点击量统计。 |
- **追求开发效率和强一致性/最终一致性**：选择 **Cache Aside**或 **Read/Write Through**。这是绝大多数业务场景（如您的短信登录、用户信息管理）的选择。
    
- **追求极致的写入性能，并能容忍数据丢失**：才考虑 **Write Behind**。

**如何规避 Write Behind 的风险？（如果必须使用）**
如果您确实遇到了必须使用 Write Behind 的场景，可以通过以下技术手段来**mitigate（减轻）**而非完全消除风险：

1. **应对数据丢失风险**：
    
    - **Write-Ahead Logging**：在将数据写入缓存的同时，先顺序追加写到磁盘的日志文件里。即使缓存宕机，重启后也可以从日志中恢复数据。这类似于数据库的 Redo Log，是保证数据不丢的关键技术。
        
    - **组合持久化**：使用支持数据持久化的缓存系统（如 Redis 的 AOF 或 RDB），但这仍然有丢失最后一次持久化后数据的风险。
        
    
2. **降低异步任务的编写和维护难度**：
    
    - 使用成熟的**流处理框架**，如 Apache Flink、Spark Streaming。它们天然提供了高吞吐的异步处理、精确一次（exactly-once）语义、容错和状态恢复机制，远比自行编写多线程或定时任务要可靠。
        
    
3. **保证最终一致性**：
    
    - 设计完善的**重试和告警机制**。当异步写入数据库失败时，必须能重试，并设置最大重试次数。如果最终失败，需要发出告警，由人工介入处理。

