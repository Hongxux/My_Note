- 核心目标：在保证索引功能（过滤、排序、覆盖查询）不受损的前提下，最大限度降低索引条目长度，提升 B+Tree 扇出数，减少树高和磁盘 IO 开销
- 方法1：字段类型轻量化优化（根源减少字段长度，最优优先方案）
	- 核心原理：在业务允许的前提下，选择「最小可行的字段类型」，避免大类型冗余，从根源上减少索引条目长度（无需额外表/查询优化，成本最低）。
	
	- 适用场景
		- 新建表设计（优先选型），或可修改原表字段类型的场景；
		- 所有长字段优化的「首选方案」（成本最低，收益最高）。
	
	- 量化优势&优劣
		- 优势：零额外维护成本，索引条目长度大幅减少，扇出数最大化提升，同时减少表数据存储体积；
		- 劣势：受业务场景限制（如需要存储超20亿数据时，无法将BIGINT转为INT）。
	- 常用优化映射（贴合MySQL场景）

| 原冗余字段类型           | 优化后轻量化类型      | 字节数减少 | 适用场景               |
| ----------------- | ------------- | ----- | ------------------ |
| VARCHAR(20)（枚举值）  | TINYINT       | 19字节  | 状态、类型等枚举字段（≤255值）  |
| BIGINT            | INT           | 4字节   | 主键、ID等（无需存储超20亿数据） |
| VARCHAR(30)（固定长度） | CHAR(11)（手机号） | 19字节  | 手机号、身份证号等固定长度字符串   |
| DATETIME          | TIMESTAMP     | 3字节   | 时间范围在1970-2038年的场景 |
| TEXT/VARCHAR(255) | VARCHAR(50)   | 205字节 | 仅需存储短文本（如用户名、地址摘要） |

- 方法2：联合查询+字典表（长字段→短编码映射，核心解决枚举型长字段问题）
	- 适用场景
		- 长字段为**枚举类型**（唯一值少，**通常≤20个**）、重复度高、区分度低；
			- 当长字段「非枚举类型（唯一值＞1 万）」时，即便区分度低，前缀索引也优于字典表
		- 业务不允许修改原长字段类型（历史遗留系统），或需要保留长字段的业务可读性。
	- 核心原理：将原表中的**长文本枚举字段**（如`pay_status`（VARCHAR(20)："unpaid"/"paid"/"refunded"）、`region`（VARCHAR(30)："Beijing"/"Shanghai"）），通过「字典表」映射为**短整型编码**（TINYINT/INT），原表仅存储短编码，索引基于短编码创建，从根源减少索引条目长度。
	- 操作步骤
		1. 新建字典表：存储「长字段值-短编码」的一一映射（如`pay_status_dict`：`id`（TINYINT，1字节）、`status_name`（VARCHAR(20)））；
		2. 原表优化：新增短编码字段（如`pay_status_code`，TINYINT，1字节），同步字典表编码值，建立基于编码字段的索引（如`(user_id, pay_status_code, create_time)`）；
		3. 查询优化：通过「原表+字典表联合查询」获取长字段含义，避免直接使用长字段建索引（如`SELECT t.*, d.status_name FROM order t JOIN pay_status_dict d ON t.pay_status_code = d.id WHERE t.user_id=1001`）。
	- 量化优势&优劣
		- 优势：索引条目长度大幅缩减（如20字节→1字节，索引条目长度减少95%），扇出数提升10倍以上（如从483→1092），彻底避免长字段导致的树高增加；
		- 劣势：增加字典表维护成本（写入/更新长字段时需同步编码），联合查询略有CPU开销（可忽略，远低于IO收益）。
- 方法3：前缀索引（截取长字段高区分度前缀，核心解决唯一型长字符串问题）
	-  适用场景
		- 长字段为**字符串类型**、唯一值多（区分度高）、查询以「等值查询」为主（如`WHERE email='xxx@xxx.com'`）；
	-  核心原理：针对**长字符串唯一型字段**（如`email`、`phone`、`username`），无需存储完整字段到索引，仅截取字段前N个字符（前缀）建索引，通过「前缀高区分度」保证过滤效率，同时大幅降低索引条目长度。
	-  操作步骤
		1. 量化计算前缀区分度：执行`SELECT COUNT(DISTINCT LEFT(column_name, n)) / COUNT(DISTINCT column_name) AS prefix_discrimination FROM table_name;`，筛选最优前缀长度`n`；
		2. 确定选型阈值：优先选择「前缀区分度≥0.95、索引长度减少≥50%、n≤25」的前缀长度（如`email`字段50字节→15字节，区分度0.95）；
		3. 创建前缀索引：`CREATE INDEX idx_email_prefix ON user(LEFT(email, 15));`（或直接`CREATE INDEX idx_email_prefix ON user(email(15));`）。
	- 量化优势&优劣
		- 优势：索引条目长度显著降低（如50字节→15字节，减少70%），扇出数提升约3倍（如302→868），无需额外表维护；
		- 劣势：
			- 前缀存在冲突时，会产生「索引扫描后内存过滤」开销（冲突率=1-前缀区分度，区分度0.95时冲突率5%，可接受）；
			- **不支持范围查询、排序**（前缀有序≠完整字段有序）。
- 方法4：哈希索引（针对长字符串等值查询，小众优化方案）
	- 核心原理：将长字符串字段通过「哈希函数」（如MD5、CRC32）转为短哈希值（如CHAR(32)、BIGINT），基于哈希值建索引，利用哈希值的短长度提升扇出数，仅支持等值查询。
	-  操作步骤
		1. 新增哈希字段：原表新增哈希值字段（如`email_hash`，CHAR(32)，存储`MD5(email)`的值）；
		2. 建立哈希索引：`CREATE INDEX idx_email_hash ON user(email_hash);`；
		3. 查询优化：`SELECT id FROM user WHERE email_hash=MD5('lisi@xxx.com') AND email='lisi@xxx.com'`（双重判断避免哈希冲突）。
	- 适用场景
		- 长字符串字段仅做「等值查询」，无需范围查询、排序；
		- 前缀索引区分度无法达标（如长随机字符串）。
	- 量化优势&优劣
		- 优势：哈希值长度固定（如32字节），索引条目长度可控，扇出数稳定；
		- 劣势：
			-  不支持范围查询、排序；
			- 存在哈希冲突，需额外字段验证
