- ​**功能：​**​ 创建一个新的进程（称为**子进程**）。这个新进程几乎是调用 `fork()`的那个进程（称为**父进程**）的**精确副本**。
    
- ​**工作原理：​**​
    
    - 当父进程调用 `fork()`时，操作系统会创建一个新的进程控制块 (PCB) 和地址空间。
        
    - 子进程的地址空间初始内容**完全复制**父进程的地址空间（包括代码段、数据段、堆、栈、环境变量、打开的文件描述符表等）。
        
    - 子进程从 `fork()`调用之后的**下一条指令**开始执行（因为它复制了父进程的程序计数器）。
        
    
- ​**返回值：​**​
    
    - 在父进程中：`fork()`返回新创建的子进程的 ​**PID (Process ID)​**​（一个正整数）。
        
    - 在子进程中：`fork()`返回 ​**0**。
        
    - 如果创建失败（例如系统资源不足），`fork()`返回 ​**​-1**​（给父进程）。
        
    
- ​**关键点：​**​
    
    - `fork()`只负责**复制**当前进程的状态。它**不**加载新的程序。
        
    - 父进程和子进程在 `fork()`调用后**并发执行**。操作系统调度器决定哪个先运行。
        
    - 由于复制了整个地址空间，`fork()`有时被称为“重量级”操作（现代操作系统使用写时复制 Copy-On-Write 技术优化，使得实际复制延迟到需要修改内存时才发生，大大提高了效率）。
        
    
- ​**示例代码片段：​**​
    
    ```
    pid_t pid = fork();
    if (pid == -1) {
        // 错误处理: fork 失败
        perror("fork");
        exit(1);
    } else if (pid == 0) {
        // 子进程代码
        printf("I am the child! My PID is %d\n", getpid());
    } else {
        // 父进程代码 (pid 是子进程的 PID)
        printf("I am the parent! My PID is %d, my child's PID is %d\n", getpid(), pid);
    }
    ```
    
