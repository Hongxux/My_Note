---
aliases:
  - 对象锁
---
- 需求背景：
	- 避免临界区的竞态条件发生
- 语法：
	- 加到代码块：
		- 对象（锁对象）：
			- 实现临界区代码的原子性的前提：确保多个进程锁住的是同一个对象
			- 互斥的范围：使用相同对象锁的线程
		- 临界区：对共享变量的操作指令流
	- 加到方法上：
		- 加到成员方法上：等价于把这个类的当前实例作为锁对象
			- 同一个实例的同步实例方法会互斥
			- 不同实例的同步实例方法互不干扰
		- 加到静态方法上：等价于把这个类的类对象作为锁对象
			- **全局锁**：所有调用该类任何同步静态方法的线程都会互斥。
				- 即使针对不同实例
- 问题：
	- 无法手动释放锁，依赖 JVM 自动释放（最易导致死锁）：如果代码块内出现**死循环、无限阻塞**（比如网络请求超时未处理），锁会被永久持有，导致其他线程永远获取不到锁，引发死锁。
		- 解决措施：确保 `synchronized` 块内无无限循环 / 阻塞逻辑，核心耗时操作（如 IO、网络请求）不要放在锁内。
	- 无超时机制，竞争失败的线程易永久阻塞
		- 解决措施：如果需要 “获取锁超时容错”，直接放弃 `synchronized`，改用 ReentrantLock。
	- 仅支持非公平锁，无法定制
	- 锁粒度控制不灵活：`synchronized` 只能修饰**方法**或**代码块**，锁的持有和释放范围被固定：修饰方法时，锁覆盖整个方法；修饰代码块时，锁从进入块到退出块全程持有。无法实现 “跨方法释放锁” 或 “部分逻辑释放锁”。
		- 解决措施：缩小 `synchronized` 代码块范围，只包裹**核心临界区**，非核心逻辑（日志、IO）移出锁块。
	- 早期 JDK 性能坑（1.6 前）：JDK 1.6 之前，`synchronized` 是 “重量级锁”，依赖操作系统互斥量，切换成本高；1.6 后虽引入偏向锁、轻量级锁、锁膨胀等优化，但如果锁竞争激烈（比如高并发下大量线程抢同一把锁），仍会退化为重量级锁，性能下降。
		- 解决措施：高并发场景下，优先考虑锁拆分（比如将一个全局锁拆分为多个局部锁），减少锁竞争。
- 效果：按照一定使用规范才能实现的共享变量可见性和有序性，临界区代码块的原子性
	- 实现临界区代码的原子性
		- 如果没有人获取锁，则直接获取对象锁，执行临界区代码
		- 如果发现这个对象锁被别人获取了，则进入阻塞状态，直至锁释放，进行锁的争抢
	- 实现共享变量的可见性：
		- 可见性的实现前提：这个共享变量的所有读写操作都被同一锁对象监控（Monitor）
		- 进入synchronized代码块的时候：从主内存更新工作内存的共享变量为最新值
		- 退出synchronized代码块的时候：把工作内存中的共享变量都更新到主内存中
	- 实现共享变量的有序性
		- 实现有序性的条件：这个共享变量的所有读写操作都被同一锁对象监控（Monitor）
		- 在synchronized中会发生重排序，但是如果所有读写操作都被同一锁对象监控，则可以实现最终的有序性
---

- 可见性和有序性的实现原理
	- 在获取锁（monitorenter）的时候加入读屏障
	- 在释放锁（monitorexit）的时候加入写屏障
- 原子性的实现原理：
	- 实现基础：
		- 对象监视器([[Monitor]])
		- [[JAVA对象头]]的Mark Word
	- ​**字节码层面**​：
		- 同步代码块
			- 实现方式：借助锁机制，同步块（`synchronized`）会被翻译成`monitorenter`和`monitorexit`指令
				- 执行到`monitorenter`指令时：会尝试获取对象的监视器锁，成功获取锁才能执行后续代码
				- 执行完同步代码块后：通过`monitorexit`指令释放锁
			- 效果：这把锁保证了在任一时刻，只有一个线程能执行被保护的代码块
		- 同步方法：
			- 实现方式：当你使用`synchronized`修饰一个方法时，方法的常量池中会设置一个`ACC_SYNCHRONIZED`标志
				- 当线程调用方法时，JVM会检查这个标志，如果设置了，则要求线程必须先成功获取对应的Monitor锁，才能执行方法体
	    
	- ​**操作系统层面**​：重量级锁使用操作系统的互斥量(mutex)，涉及用户态/内核态切换
- 锁升级：
	- 目的：根据竞争的激烈程度，找到合适的上锁方式
		- 越重量的锁，开销越大
	- 锁升级方式：**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**。
		- 无锁：有锁和无锁的性能差距有十几倍
			- 触发时机：锁对象不可能被共享
		- [[偏向锁]]：与轻量锁相比，减少重入锁的时候，CAS获取锁和释放锁的消耗
		- [[轻量锁]]：与重量级锁相比，减少线程阻塞和线程唤醒带来的上下文切换的消耗
		- 重量级锁：[[Monitor]]（监视器、管程）
			- 每个JAVA对象都可以关联一个Monitor对象
			- 获取锁，释放锁，等待，通知，本质上都是在与JAVA对象所关联的Monitor对象进行交互
	- 锁升级特点：过程是单向的，不可逆
- 




    