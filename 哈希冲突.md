### 什么是哈希冲突？

​**哈希冲突**，也叫哈希碰撞，是指**两个或多个不同的键（Key）经过哈希函数计算后，得到了相同的哈希值，从而被映射到哈希表同一个桶（Bucket）或位置**的情况。

简单来说：​**不同的key → 相同的地址**。

- ​**比喻**​：就像一个大型会议的签到处，本来计划是“姓氏首字母为A的去1号桌，B的去2号桌...”。但如果突然来了很多姓“李”（L）和“刘”（L）的人，1号桌就会排起长队。这个“排队”现象就是哈希冲突。

---

### 什么时候会出现哈希冲突？

哈希冲突是**必然会发生**的，几乎无法完全避免。原因如下：

1. ​**哈希函数的输出范围是有限的**​
    
    - 哈希函数会将任意大小（甚至无限）的输入数据（如一个长字符串、一个对象）映射到一个固定大小的整数范围内（比如 0 到 15）。这个范围就是哈希表桶数组的长度。
    - 根据**抽屉原理**，只要尝试插入的数据量超过桶的数量，就必然至少有两个不同的数据被放入同一个“鸽巢”（桶）中，从而发生冲突。
2. ​**哈希函数的设计难以达到完美均匀**​
    
    - 即使数据量小于桶的数量，一个不够完美的哈希函数也可能导致某些桶更“受欢迎”，从而提前发生冲突。例如，一个处理英文单词的哈希函数，如果只是简单地将首字母的ASCII码取模，那么所有以‘a’开头的单词都会发生冲突。

​**结论**​：设计哈希表的核心思想**不是避免冲突**，而是**高效地处理冲突**。

---

### 如何解决哈希冲突？

主要有两大类方法，你的回答中提到了第一类，但了解第二类会让你在面试中更出色。

#### 方法一：链地址法

这是你最熟悉、也是最常用的方法，Java中的`HashMap`就采用此法。

- ​**原理**​：不把每个桶看作一个单独的空位，而是看作一个**链表**​（或其它数据结构，如红黑树）的头指针。所有哈希到同一个桶的键值对，都会被放入这个链表中。
- ​**操作**​：
    - ​**插入**​：计算哈希值找到桶，遍历该桶的链表。如果key已存在则更新value；如果不存在，则将新节点插入到链表末尾（或头部，因实现而异）。
    - ​**查找**​：计算哈希值找到桶，遍历该桶的链表，用`equals()`方法逐个比对key。
    - ​**删除**​：计算哈希值找到桶，遍历链表找到对应节点并删除。
- ​**优点**​：
    - 实现简单，有效。
    - 对于负载因子（元素总数/桶数）的容忍度更高。
- ​**缺点**​：
    - 需要额外的空间存储指针。
    - 如果链表过长，性能会退化为`O(n)`。
- ​**重要优化**​：在Java 8的HashMap中，当链表长度超过阈值（默认为8）时，链表会转换为**红黑树**，将最坏情况下的查找时间从`O(n)`优化到`O(log n)`。当桶中节点数因删除而减少到另一个阈值（默认为6）时，又会转换回链表。

#### 方法二：开放寻址法

这种方法中，所有元素都存放在桶数组本身中，每个桶只放一个元素。

- ​**原理**​：当发生冲突时，通过一个**探测序列**来寻找数组中的“下一个”空位。
- ​**常见探测方法**​：
    1. ​**线性探测**​：如果位置`i`被占了，就依次尝试`i+1, i+2, i+3, ...`直到找到空位。
    2. ​**平方探测**​：为了解决线性探测的“聚集”问题，尝试`i + 1², i + 2², i + 3², ...`。
    3. ​**双重哈希**​：使用第二个哈希函数来计算探测的步长。
- ​**优点**​：
    - 所有数据都存储在数组中，​**缓存友好**​（CPU读取连续内存更快）。
    - ​**不需要额外的指针**，节省空间。
- ​**缺点**​：
    - ​**删除操作非常麻烦**​：不能直接删除，否则会切断后续的探测路径，导致查找失败。通常采用“惰性删除”（标记为已删除，但物理上仍存在）。
    - 对**负载因子更敏感**​：当负载因子接近1时，性能会急剧下降，因此需要更早地扩容。
- ​**典型应用**​：`ThreadLocalMap`

#### 其他方法（了解即可）

- ​**再哈希法**​：准备一组不同的哈希函数，如果第一个哈希函数发生冲突，就换第二个、第三个...直到不冲突为止。计算成本较高，不常用。