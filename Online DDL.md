- 需求背景：InnoDB 表建 / 删索引触发表级锁导致线上阻塞
	- 传统 InnoDB 索引操作（非 Online DDL 模式）会全程持有表级元数据锁（MDL 锁）的排他锁，阻塞所有读写操作
- 解决措施： **Online DDL（在线数据定义语言）**，该方案从 MySQL 5.6 版本开始引入并逐步完善，在 MySQL 5.7/8.0 中得到进一步增强，是实现索引操作线上无感知（低阻塞 / 无阻塞）的标准解决方案。
- 核心优势：
	1. **非全程锁表**：仅在 DDL 操作的**初始化阶段**（准备表结构、申请元数据锁）和**收尾阶段**（提交表结构变更、释放锁）持有**短暂的 MDL 共享锁**（或排他锁，时长毫秒级），中间的核心操作（扫描表数据、构建 / 删除索引、同步增量数据）不持有表级排他锁，**不会阻塞正常的 `SELECT`、`INSERT`、`UPDATE`、`DELETE` 操作**。
	2. **增量数据同步**：在索引构建 / 删除过程中，若有业务写入 / 更新数据，InnoDB 会通过 “**变更缓冲区**（Change Buffer）” 记录这些增量变更，待索引核心构建完成后，自动**同步这些增量数据到新索引**（或清理旧索引对应的增量变更），保证索引与数据的一致性。
	3. **高性能实现**：采用 `INPLACE` 算法（**原地操作**），无需像传统 `COPY` 算法那样全表拷贝数据（仅索引操作场景），**大幅降低磁盘 I/O、CPU 消耗和操作耗时**，进一步减少对线上业务的影响。
- 使用方式：为了确保索引操作达到 “线上无感知” 效果，官方推荐显式指定两个核心参数（避免依赖默认值，提升操作可控性），语法格式嵌入在 `ALTER TABLE` 语句中：
	- `ALGORITHM`（指定 DDL 执行算法）
		- 官方推荐值：`ALGORITHM=INPLACE`（索引操作首选）
			- 优势：原地执行索引操作，无需拷贝全表数据，性能优异，耗时短，对线上业务影响极小。
			- 问题：新增联合索引时，若索引列包含**大字段（如 VARCHAR (1000)）**，`INPLACE` 算法仍会消耗大量临时空间（约为索引大小的 2 倍），可能触发**磁盘空间**不足
			- 对比：`ALGORITHM=COPY`（传统算法）会拷贝全表数据，全程持有表级排他锁，阻塞所有读写，仅用于不支持 `INPLACE` 的特殊场景，**非官方推荐**。
		- 适用范围：InnoDB 二级索引的建、删、重建操作均完美支持 `ALGORITHM=INPLACE`；主键索引操作在 MySQL 8.0 中也已支持 `INPLACE`（5.7 部分场景不支持）。
	-  `LOCK`（指定锁策略，控制读写阻塞程度）
	  - 官方推荐值：`LOCK=NONE`（完全无阻塞，最优选择）
	    - 优势：执行索引操作期间，既不阻塞读操作（`SELECT`），也不阻塞写操作（`INSERT/UPDATE/DELETE`），真正实现线上无感知。
	    - 备选值（按需选择）：
	        - `LOCK=SHARED`：仅允许读操作，阻塞写操作，适用于对数据一致性要求极高、暂时不允许写入的场景；
	        - `LOCK=EXCLUSIVE`：阻塞所有读写操作，等同于传统 DDL，**不推荐线上使用**。
	- 适用范围：
		- **二级索引**的建 / 删操作支持 `LOCK=NONE`；索引重建操作在 MySQL 5.7+ 中也支持 `LOCK=NONE`
		- **主键索引**重建**不支持** `LOCK=NONE`，仅支持 `LOCK=SHARED`（读锁）