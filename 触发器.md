触发器是数据库管理中一项强大的自动化工具，它允许您**在数据变动时自动执行预定义的操作**。

#### 一、 什么是触发器？


> ​**触发器**是与表有关的数据库对象，指在 `INSERT`/`UPDATE`/`DELETE`操作**之前**或**之后**，自动触发并执行一段预定义的 SQL 语句集合。

​**核心价值**​：

- ​**保证数据完整性**​：自动执行业务规则校验。
    
- ​**日志记录**​：自动审计数据变更轨迹。
    
- ​**数据校验**​：在写入数据库前进行复杂逻辑检查。
    

​**重要特性**​：

- ​**行级触发**​：触发器针对**受影响每一行**数据分别激活一次。
    
- ​**OLD 和 NEW 别名**​：在触发器内部，使用特殊别名来引用数据变化前后的值。
    

#### 二、 触发器的类型与别名使用

第一张图的表格清晰说明了三种触发器类型及其对应的别名：

|触发器类型|触发时机|OLD 别名|NEW 别名|
|---|---|---|---|
|​**INSERT 型触发器**​|插入数据时|不可用（无旧数据）|引用**新插入**的数据|
|​**UPDATE 型触发器**​|更新数据时|引用**修改前**的数据|引用**修改后**的数据|
|​**DELETE 型触发器**​|删除数据时|引用**被删除**的数据|不可用（无新数据）|

​**示例说明**​（结合图中表格数据）：

- 当执行 `UPDATE users SET name='Spring Boot' WHERE id=2;`时，在触发器中：
    
    - `OLD.name`的值为 `'Spring'`（修改前）
        
    - `NEW.name`的值为 `'Spring Boot'`（修改后）
        
    

#### 三、 触发器的完整语法）

触发器的生命周期管理命令：

​**1. 创建触发器**​

```
CREATE TRIGGER trigger_name
    BEFORE|AFTER INSERT|UPDATE|DELETE    -- 定义触发时机和事件
    ON table_name FOR EACH ROW           -- 指定目标表，行级触发
BEGIN
    -- 触发器逻辑：可以使用OLD和NEW别名
    trigger_statement;
END;
```

​**关键参数**​：

- ​**`BEFORE|AFTER`**​：指定在事件**之前**还是**之后**触发
    
- ​**`INSERT|UPDATE|DELETE`**​：指定监听的数据操作类型
    
- ​**`FOR EACH ROW`**​：MySQL 固定语法，表示行级触发器
    

​**2. 查看触发器**​

```
SHOW TRIGGERS;
```

​**3. 删除触发器**​

```
DROP TRIGGER [schema_name.]trigger_name;
-- 示例：
DROP TRIGGER audit_user_changes;      -- 删除当前数据库的触发器
DROP TRIGGER company.audit_user_changes; -- 删除指定数据库的触发器
```

### 四、 完整实战示例

创建一个用户数据变更审计系统：

```
-- 1. 创建审计日志表
CREATE TABLE user_audit_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    action_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    old_data JSON,
    new_data JSON,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(50)
);

-- 2. 创建BEFORE UPDATE触发器：数据校验
DELIMITER $$
CREATE TRIGGER before_user_update
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    -- 业务规则：用户名不能为空
    IF NEW.username IS NULL OR NEW.username = '' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户名不能为空';
    END IF;
    
    -- 自动更新修改时间
    SET NEW.updated_at = NOW();
END
$$
DELIMITER ;

-- 3. 创建AFTER触发器：审计日志记录
DELIMITER $$
CREATE TRIGGER after_user_change
    AFTER INSERT ON users
    FOR EACH ROW
BEGIN
    INSERT INTO user_audit_log(user_id, action_type, new_data, changed_by)
    VALUES (NEW.id, 'INSERT', JSON_OBJECT('name', NEW.name, 'email', NEW.email), USER());
END
$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER after_user_update
    AFTER UPDATE ON users
    FOR EACH ROW
BEGIN
    INSERT INTO user_audit_log(user_id, action_type, old_data, new_data, changed_by)
    VALUES (NEW.id, 'UPDATE', 
            JSON_OBJECT('name', OLD.name, 'email', OLD.email),
            JSON_OBJECT('name', NEW.name, 'email', NEW.email), 
            USER());
END
$$
DELIMITER ;
```

### 五、 使用场景与最佳实践

​**典型应用场景**​：

1. ​**数据审计**​：自动记录所有敏感数据的变更历史
    
2. ​**引用完整性**​：实现复杂的业务级外键约束
    
3. ​**数据同步**​：在主表变更时自动更新汇总表或缓存
    
4. ​**计算字段**​：自动维护衍生字段（如订单总金额）
    

​**注意事项**​：

- ​**性能影响**​：触发器会增加数据库操作的开销，需谨慎使用
    
- ​**避免递归**​：注意触发器可能触发其他触发器，形成无限循环
    
- ​**错误处理**​：在触发器中进行适当的异常处理
    
- ​**事务特性**​：触发器执行在同一个事务中，失败会回滚主操作
    

### 总结

这两张图完整覆盖了触发器的核心知识：

1. ​**基本概念**​：触发器是响应数据变化的自动化工具
    
2. ​**类型划分**​：INSERT/UPDATE/DELETE 三种类型，BEFORE/AFTER 两种时机
    
3. ​**关键别名**​：OLD 和 NEW 的差异使用
    
4. ​**管理语法**​：创建、查看、删除的完整命令
    

掌握触发器可以让您实现许多业务逻辑的数据库层面自动化，显著提高数据一致性和系统可靠性。