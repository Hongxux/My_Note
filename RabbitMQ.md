![[Pasted image 20251209215604.png]]

- 基础部件
	- **生产者（Publisher/Producer）**：发送消息的应用程序。它将消息发布到**交换器**。
	- **消费者（Consumer）**：接收和处理消息的应用程序。它从**队列**中获取消息。
	- **交换器（Exchange）**：消息的**路由中心**。生产者将消息发送到交换器，交换器负责根据特定规则将消息路由到一个或多个队列中。它本身不存储消息。
	- **队列（Queue）**：消息的**缓冲区**，本质上是一个存储消息的邮箱。队列遵循先进先出（FIFO）的原则。消费者从队列中获取消息进行处理。
	- **绑定（Binding）**：连接**交换器**和**队列**的规则。你可以理解为交换器和队列之间的“一座桥”。
	- **虚拟主机（Virtual Host）**：用于在同一个 RabbitMQ 服务器内进行**逻辑隔离**。可以将它类比为操作系统中的文件夹。不同的应用可以拥有独立的 vhost，其中的交换器、队列等互不干扰。
- 消息路由
	- **路由键（Routing Key）**：生产者发送消息时附带的一个**属性**，可以看作是一个“标签”或“地址”。交换器会根据这个键来决定消息的路由方向。
	- **绑定键（Binding Key）**：在创建**绑定**时指定的一个**模式**。交换器会将消息的 **Routing Key**​ 与这个 **Binding Key**​ 进行匹配，从而决定消息应被路由到哪些队列
- 四种交换器类型：不同的路由策略
  
| 交换器类型           | 路由规则                                                     | 典型应用场景                                             |
| --------------- | -------------------------------------------------------- | -------------------------------------------------- |
| **Direct（直连）**​ | 将消息路由到那些 **Binding Key**​ 和 **Routing Key**​ 完全匹配的队列。    | 点对点精确发送，如将错误日志发送到特定的处理队列。                          |
| **Fanout（扇出）**​ | 将消息路由到所有与它绑定的队列，**忽略 Routing Key**。                      | 广播消息，如新闻更新需要同时通知多个系统。                              |
| **Topic（主题）**​  | 通过模式匹配路由消息。Binding Key 支持通配符：`*`（匹配一个单词），`#`（匹配零个或多个单词）。 | 实现消息的灵活分类和订阅，如监听特定区域（如`usa.#`）或所有类型的新闻（如`#.news`）。 |
| **Headers（头）**​ | 不依赖 Routing Key，而是根据消息头（Headers）中的键值对进行匹配。               | 基于复杂的多属性进行路由，但性能较差，使用较少。                           |
- 连接与信道：通信的桥梁
	- **连接（Connection）**：生产者/消费者与 RabbitMQ 服务器之间的一个 **TCP 连接**。建立连接的开销较大。
	- **信道（Channel）**：建立在 Connection 之上的**虚拟连接**。几乎所有的操作都在信道中进行。使用信道的好处是可以**复用**一个 TCP 连接，避免频繁创建和销毁 TCP 连接的巨大开销。
- 消息分发机制：
	-  **轮询分发（Round-Robin）**：这是默认策略。
		- 含义：它会将队列中的消息**依次、均匀地**分发给所有消费者，而不考虑每个消费者的处理能力
	    - 问题：这可能导致处理速度慢的消费者积压消息。
	- **公平分发（Fair Dispatch）**：为了解决轮询分发的缺陷，可以启用公平分发。
		- 开启方式：通过设置 `channel.basicQos(prefetchCount)`参数，可以限制每个消费者在未确认之前**最多能预取的消息数量**（通常设为1）。
		- 含义：只有在消费者处理完当前任务并发送确认（ACK）后，才会收到新的任务
		- 作用：确保了负载更加均衡
- [[Work  Queue模式]]
- 确保可靠性的关键机制
	- **消息确认（Message Acknowledgment）**：为了确保消息被消费者**成功处理**，RabbitMQ 提供了确认机制。消费者在处理完消息后，必须向 RabbitMQ 服务器发送一个确认回执（ACK），服务器才会将消息从队列中删除。如果消费者未发送 ACK 就断开连接，RabbitMQ 会认为该消息处理失败，并将其重新投递给另一个消费者。
	- **持久化（Persistence）**：为了防止 RabbitMQ 服务器重启或崩溃时消息丢失，可以将**队列**、**消息**和**交换器**都设置为持久化的。这样它们就会被保存到磁盘中。
	- **死信队列（Dead Letter Exchange, DLX）**：当一条消息由于某些原因（如被拒绝、过期、队列长度超限）无法被正常消费时，它可以被转发到另一个特殊的交换器——死信交换器。与之绑定的队列就是死信队列。这常用于处理失败的消息或实现延迟任务。
- Spring AMQP[[SpringBoot中使用RabbitMQ]]
	- Spring AMQP对JAVA操作RabbitMQ做的一层封装
	- AMQP是消息队列的消息通信协议