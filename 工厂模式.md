[[继承 接口的三种具体应用]]
### 工厂模式（以工厂方法模式为例）

#### 代表什么？

​**核心思想：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。​**​

- ​**接口的角色**​：工厂接口定义了创建产品对象的通用方法。具体工厂类实现这个接口，负责创建具体的产品对象。
- ​**模式结构**​：
    - ​**产品接口**​：定义了产品对象的接口。
    - ​**具体产品**​：实现了产品接口。
    - ​**工厂接口**​：声明了创建产品的工厂方法。
    - ​**具体工厂**​：实现了工厂接口，返回一个具体产品的实例。

#### 实际生活生产中的意义

​**意义：将对象的“创建”与“使用”分离。使用者只关心产品的接口，而不需要知道具体产品的类名和创建细节。​**​

​**生活例子：汽车4S店**​

- ​**产品接口**​：`Car` (有 `drive()` 方法)
- ​**具体产品**​：`BmwCar`, `AudiCar`
- ​**工厂接口**​：`CarFactory` (有 `createCar()` 方法)
- ​**具体工厂**​：`BmwFactory`, `AudiFactory`  
    你想买一辆车（使用产品），你不会自己去零件厂组装（直接 `new BmwCar()`）。你去了宝马4S店（具体工厂），告诉销售“我要一辆车”。销售（工厂方法）从背后的仓库里为你制造并交付一辆宝马车。你并不关心车是怎么造出来的，你只关心它是一辆能 `drive()` 的车。明天你想换奥迪，只需去奥迪4S店即可。

​**生产例子：数据库连接**​

- 你的程序需要连接数据库，但可能是MySQL、Oracle或SQL Server。
- 你定义一个 `Connection` 接口（产品）和 `ConnectionFactory` 接口（工厂）。
- 不同数据库厂商提供各自的实现，如 `MySqlConnection` (产品) 和 `MySqlConnectionFactory` (工厂)。
- 你的业务代码只面向 `Connection` 接口和 `ConnectionFactory` 接口工作。当需要切换数据库时，只需更换使用的具体工厂（通常通过配置文件改变），所有创建连接的地方自动升级到新的数据库连接，而业务代码一行都不用改。

​**核心价值**​：​**封装复杂对象的创建过程，实现“创建逻辑”与“使用逻辑”的解耦，提供极大的灵活性，是依赖倒置原则的典型体现。​**​