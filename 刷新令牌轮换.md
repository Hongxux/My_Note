 - 需求背景：
	 - **在单令牌（或无轮换）场景下**：这个RT在到期前始终有效，攻击者可以不断生成新的Access Token，系统难以察觉

 - 含义：每次使用 Refresh Token 换取新的 Access Token 时，**立即使旧 Refresh Token 失效，并同时颁发一个全新的 Refresh Token**​ 给客户端
 - 实现方式：
	 - **RT的存储**：与无状态的AT不同，为了实现轮换和状态管理，**RT的信息必须在服务端持久化**。
		 - 存储方式：Redis
		 - 数据结构：Hash结构来存储，
		 - 键
			 - `rt_state:user_id:<user_id>:device_id:<device_id>`，
			 - 或者直接用RT的`jti`作为键。
		 - 值：Hash中存储RT的`jti`、`fid`、过期时间、创建时间、IP地址、User-Agent等元数据。
	 - **RT轮换的原子性实现 (关键)**：当客户端使用一个旧RT (`old_rt`) 来请求续期时，服务端必须**通过lua脚本原子地**完成以下操作，以防止并发请求下的重用攻击
		1. **验证`old_rt`**：检查签名、`exp`、`aud`等。
		2. **查询Redis状态**：根据`old_rt`的`jti`或`sub`+`fid`，在Redis中查找其状态。
			- 如果找不到，或状态为“已作废”，则拒绝。
			- 如果找到且状态为“有效”，则继续。
		3. **生成新的AT和RT (`new_at`, `new_rt`)**：`new_rt`会继承`old_rt`的`fid`。
		4. **更新Redis状态**：将`old_rt`在Redis中的状态标记为“已作废”，并存入`new_rt`的新状态。
		5. **返回`new_at`和`new_rt`**给客户端。
		- 脚本实现：
			```
			-- a_refresh_token.lua
			-- KEYS[[534]]: old_rt_jti
			-- ARGV[[535]]: user_id
			-- ARGV[[536]]: new_rt_jti
			-- ARGV[[537]]: new_rt_exp_timestamp
			-- ARGV[[538]]: family_id
			
			local old_rt_key = "rt_state:" .. KEYS[[539]]
			local rt_info = redis.call("HGETALL", old_rt_key)
			
			-- 检查旧RT是否存在且有效
			if #rt_info == 0 or rt_info.status == "revoked" then
			  -- RT不存在或已被作废，可能发生重放攻击
			  -- 将该家族的所有RT都作废
			  local family_key = "rt_family:" .. ARGV[[540]]
			  local all_rt_jtis = redis.call("SMEMBERS", family_key)
			  for i, jti in ipairs(all_rt_jtis) do
			    redis.call("HSET", "rt_state:" .. jti, "status", "revoked_due_to_replay")
			  end
			  redis.call("DEL", family_key)
			  return "REPLAY_ATTACK_DETECTED"
			end
			
			-- 将旧RT标记为已作废（轮换掉）
			redis.call("HSET", old_rt_key, "status", "rotated")
			redis.call("EXPIRE", old_rt_key, 300) -- 给一个短暂的窗口期用于排查问题，之后自动删除
			
			-- 存储新RT的状态
			local new_rt_key = "rt_state:" .. ARGV[[541]]
			redis.call("HMSET", new_rt_key, "user_id", ARGV[[542]], "family_id", ARGV[[543]], "status", "active", "exp", ARGV[[544]]
			-- 设置新RT的过期时间
			redis.call("PEXPIREAT", new_rt_key, ARGV[[545]] * 1000)
			
			-- 更新令牌家族列表
			local family_key = "rt_family:" .. ARGV[[546]]
			redis.call("SREM", family_key, KEYS[[547]]
			redis.call("SADD", family_key, ARGV[[548]]
			
			return "SUCCESS"
			
			```
	- **盗窃检测 (Replay Attack Detection)**：
		- 此时，系统应认为`fid`对应的整个令牌家族都已泄露，立即将该家族下的所有RT（通过`rt_family:<fid>`集合查找）全部标记为作废，并通知用户其账户存在风险
 - 好处：安全性和滑动过期
	 1. **泄露检测**：在RT轮换场景下，令牌泄露的事实会主动被暴露
		 - 警报触发：有人使用了就RT
			 - **攻击者**首次使用盗取的RT申请新AT时，认证服务器会颁发一套**新的AT和新的RT**。
			 - **合法的用户**再次使用**旧的RT**来刷新时，请求会失败（因为旧的RT已在服务器端被标记为失效）。
		 - 触发后的行动：系统可以据此自动将相关用户的所有会话强制下线，并可能要求重新认证件
	2. **限制危害**：即使被盗，攻击者通常也只能成功使用一次，将危害窗口缩到最短
- 问题：
	- 引入状态，背离了 JWT 完全无状态的理想：
		- 服务器需要维护一个机制来跟踪哪些 Refresh Token 是有效的（通常是记录其唯一标识 `jti`），并在签发新令牌后立即让旧令牌失效。这在一定程度上**引入了状态**，背离了 JWT 完全无状态的理想
	- 需要借助分布式锁并发控制：
		- 需要处理好在极短时间内多个请求同时使用同一个 Refresh Token 来刷新的边界情况，通常需要借助分布式锁等机制来避免状态冲突。