- 需求背景：
	- **防止缓存穿透**：在查询前先经过布隆过滤器。如果过滤器判断数据不存在，则直接返回，避免了对底层数据库的无效查询，有效保护数据库
	- **海量数据去重**：例如，在网络爬虫中判断URL是否已爬取，或在日志系统中判断事件是否已处理。布隆过滤器可以高效完成去重判断
	- **安全与风险控制**：例如，快速判断一个邮箱地址或IP是否在已知的黑名单中。即使有少量误判（将正常地址判为黑名单），通常也可以通过二次验证解决，而系统的快速响应是首要目标
 - **原理：**
	- 布隆过滤器本质是一个很大的位数组（bitmap）和多个哈希函数。
		- **添加**一个商品ID时，会用多个哈希函数计算出多个位置，把这些位置置为1。
		- **查询时**，同样用这些函数计算位置，如果**所有位置都是1**，则说“可能存在”；如果**任何一个位置是0**，则说“肯定不存在”。
 - **做法**：
	 - 工作模式:
		 - ![[Pasted image 20251118140435.png]]
    1. **初始化**：**组合使用动态更新和定时同步**
	    1.  **全量初始化**：系统启动时，将当前所有已上架的商品ID加载到布隆过滤器中。适用于商品库相对稳定的情况。
		2. **动态更新**：当有新商品上架时，通过一个消息队列或直接调用一个服务，**实时地将新商品ID添加到布隆过滤器**。这是更优的方案。
		3. **定时同步**：还有一个兜底方案，可以有一个定时任务，定期（比如每天凌晨）从数据库同步全量商品ID到布隆过滤器，用于纠正可能的遗漏。
    2. **查询流程**：当请求到来时，先查询布隆过滤器。
        - 如果布隆过滤器说 **“一定不存在”**，则直接返回空结果，无需查询缓存和数据库。
        - 如果布隆过滤器说 **“可能存在”**，再继续执行正常的缓存查询流程。
	        - **为什么是“可能存在”**：因为不同ID的哈希值可能会发生冲突(哈希冲突)。当位数组变得很满时，误判率会升高。但**它绝不会误判“不存在”的情况**。这正是我们防穿透需要的特性——把“肯定不存在”的请求果断拦截掉。
- 要考虑的问题:
	- 应对删除操作：标准布隆过滤器不支持删除元素，因为清空一个位可能会影响其他元素。
			- 解决措施:可以考虑使用**[[计数布隆过滤器]]**，它用计数器代替位，支持元素的删除，但会占用更多内存
	- 部署方式:单机or分布式
		- **单机部署**：适用于数据量可控、无需多节点共享的场景。可以使用Guava等库在应用内存中实现，性能极高
		- **分布式部署**：当需要多个服务节点共享同一个过滤器状态时，通常基于Redis实现（如Redisson提供的布隆过滤器模块）。这解决了单点问题，但需要依赖外部中间件
	- 动态扩容与缩放：对于数据量不断增长的场景，可以考虑支持动态扩容的布隆过滤器实现，当当前位数组即将用满时，自动创建一个更大的位数组并迁移数据
- **优点**：
    - 内存占用极少.没有多余空值key
    - 从根本上解决了问题，恶意攻击请求在布隆过滤器层就被拦截。
- **缺点**：
    - 存在一定的误判率：种不确定性是通过牺牲绝对精确性，换取了极高的空间效率和极快的查询速度
        - 当它告诉你一个元素“一定不存在”​ 时，这个结果是**100%准确**的。
        - 当它告诉你一个元素“可能存在”* 时，则存在一定的误判概率（假阳性）
    - 需要维护布隆过滤器的数据，当数据库有新增数据时需要及时更新过滤器。
