- 需求背景：
	- 主要用于**解决单例 Bean 的循环依赖问题**
	- 并确保 Bean 在存在 AOP 代理等增强处理时也能被正确创建和注入。
-  三级缓存的组成

| 缓存级别     | 源码中的 Map 名称             | 存储内容                           | 核心作用                                       |
| -------- | ----------------------- | ------------------------------ | ------------------------------------------ |
| **一级缓存** | `singletonObjects`      | **已完全初始化好的 Bean**（成品）          | 对外提供可用的单例 Bean，是主要的获取源。                    |
| **二级缓存** | `earlySingletonObjects` | **已实例化但未初始化的 Bean**（半成品）       | 缓存 Bean 的早期引用，**防止重复创建代理对象**，保证依赖注入的一致性。   |
| **三级缓存** | `singletonFactories`    | **`ObjectFactory`（Bean 工厂对象）** | **延迟生成 [[Bean 的早期引用]]**，是解决 AOP 代理循环依赖的关键。 |
- 三级缓存解决循环依赖的方式
	1. **创建 Bean A，曝光工厂**
	    - Spring 实例化 A（调用构造方法），得到一个原始对象。
	    - 随后，Spring 将一个用于生产 A 的早期引用的 `ObjectFactory`工厂对象放入 **三级缓存**。这一步非常关键，它意味着**提前暴露了 A**，但并未直接创建代理对象，而是将创建的时机延迟。
	2. **为 A 注入属性，触发创建 B**
	    - Spring 准备为 A 注入属性，发现它依赖 B。
	    - 于是容器转向创建 B。
	3. **创建 Bean B，同样曝光工厂**
	    - 实例化 B，并将 B 的 `ObjectFactory`也放入 **三级缓存**。
	4. **为 B 注入属性，解决循环依赖（关键步骤）**
	    - Spring 为 B 注入属性，发现它依赖 A。此时，Spring 开始查找 A：
	        - 一级缓存：没有 A（A 还未初始化完成）。
	        - 二级缓存：没有 A（A 的早期引用还未被使用过）。
	        - 三级缓存：找到了 A 的 `ObjectFactory`。
	    - Spring 调用这个工厂的 `getObject()`方法。`ObjectFactory`提供的延迟创建能力
		    - 设计目的：保证了注入给 B 的是最终正确的对象（可能是代理）。
			    -  **如果只有二级缓存**：在将 Bean 的早期引用放入缓存时，**必须立即确定这个引用是原始对象还是代理对象**。但 Spring 的设计中，正常的代理创建时机是在 Bean 初始化之后（通过 `BeanPostProcessor`）。如果提前创建代理，可能会遇到 Bean 状态不完整等问题，违反设计原则，并可能造成资源浪费（如果没有循环依赖，这个代理就白创建了）。
				- **有了三级缓存的 `ObjectFactory`**：代理对象**仅在发生循环依赖、真正被需要时才被创建**。如果没有循环依赖，Bean 将按照正常的生命周期在初始化后创建代理。这既保证了正确性，也兼顾了性能。
		    - 工作流程：
			    - 如果 Bean A 需要被 AOP 代理，则在此刻生成并返回代理对象；
			    - 如果不需要，则返回原始对象
	    - 随后，将这个早期引用从三级缓存迁移到 **二级缓存**中。
	5. **完成 B 和 A 的创建**
	    - B 获得 A 的早期引用后，顺利完成属性注入和后续初始化，变成一个“成熟”的 Bean，被放入 **一级缓存**，并清理其在二、三级缓存中的记录。
	    - 随后，A 的注入流程得以继续，从一级缓存中获取到已成熟的 B，完成自身的初始化，最终也进入 **一级缓存**。

