---
aliases:
  - 版本号
  - CAS
  - 无锁并发
---
-  乐观锁的思想
	- 假设前提：**数据在并发访问时冲突的概率很低**
	- 在此前提下的举动：
		- 读取数据时不加锁
		- 在更新数据时，检查自读取后数据是否已被其他操作修改。
			- 如果未被修改，则更新成功；
			- 否则，根据策略（如重试、报错）处理冲突
-  适合场景
	- 读多写少、
	- 数据冲突概率低（操作数据库的时间短）的场景（如计数器、评论点赞）。
- 基于乐观锁思想的实现
	#### [[版本号法]]
	#### [[原子类]]




























### 乐观锁局限性与解决方式

| **ABA问题**​ | 这是CAS机制的一个经典问题：一个变量值从A变为B，后又变回A。CAS操作会误以为它没有变化。**解决方案**是使用带有版本号（或时间戳）的原子引用类，如 `AtomicStampedReference`。 |
| ---------- | ------------------------------------------------------------------------------------------------------- |
| **冲突处理**​  | 乐观锁在更新时可能失败。**必须**有相应的冲突处理策略，例如**有限次数的重试**、向用户抛出友好错误等。没有重试机制的乐观锁在实际应用中价值有限。                             |
| **适用场景**​  | 最适合**读多写少**、**冲突概率较低**的场景。在这种情况下，它避免了加锁的开销，能显著提升系统吞吐量。反之，在写操作非常频繁、冲突严重的场景下，大量的重试会消耗CPU资源，性能可能不如悲观锁。     |
| **范围限制**​  | 版本号机制通常针对单条数据记录。CAS操作通常只能保证一个共享变量的原子操作。如果需要同时检查多个变量，可能需要将它们合并到一个对象中，并使用 `AtomicReference`。              |


#### 实现有限次数重试---**Resilience4j**库使用
Resilience4j是一个轻量级的容错库，重试只是其功能之一。

- **添加依赖**：
    
    
    ```
    <dependency>
        <groupId>io.github.resilience4j</groupId>
        <artifactId>resilience4j-retry</artifactId>
    </dependency>
    ```
    
- **配置并使用**：
    ```
    import io.github.resilience4j.retry.Retry;
    import io.github.resilience4j.retry.RetryConfig;
    
    public class Resilience4jDemo {
        public static void main(String[] args) {
            // 1. 创建重试配置
            RetryConfig config = RetryConfig.custom()
                    .maxAttempts(3) // 最大尝试次数（包括第一次）
                    .waitDuration(Duration.ofSeconds(1)) // 重试间隔
                    .retryOnException(e -> e instanceof RuntimeException) // 只对RuntimeException重试
                    .build();
    
            // 2. 创建Retry实例
            Retry retry = Retry.of("myRetry", config);
    
            // 3. 使用Retry装饰你的业务逻辑（这里使用Supplier包装）
            String result = retry.executeSupplier(() -> {
                // 你的业务逻辑
                if (Math.random() < 0.7) {
                    throw new RuntimeException("Resilience4j 模拟异常");
                }
                return "Success";
            });
            System.out.println(result);
        }
    }
    ```
#### 原子性更新多个字段--[[AtomicReference]]
版本号机制通常针对单条数据记录。CAS操作通常只能保证一个共享变量的原子操作。如果需要同时检查多个变量，可能需要将它们合并到一个对象中，并使用 `AtomicReference`。

#### 避免ABA问题--[[AtomicStampedReference]]