---
aliases:
  - binlog
---
### 二进制日志（只记录DML和DDL，不记录select）


二进制日志是 MySQL 服务器级别的一种逻辑日志，它记录了所有对数据库结构和数据内容进行修改的操作（DML和DDL）。​**它不记录查询操作**，是实现数据复制和数据恢复的基石。

#### 一、 核心作用与价值

1. ​**数据恢复**​：
    
    - ​**场景**​：当发生数据误删除（如误执行 `DROP TABLE`或 `DELETE`语句）时，可以基于**全量备份**​ + ​**二进制日志**，将数据恢复到误操作前的某个时间点。
        
    - ​**价值**​：这是实现**时间点恢复**​ 的关键。
        
    
2. ​**主从复制**​：
    
    - ​**场景**​：构建高可用、可扩展的数据库架构。主库上的数据变更通过二进制日志传递给从库，从库重放这些日志，从而保持数据同步。
        
    - ​**价值**​：实现**读写分离、负载均衡、数据备份**。
        
    

​**查看状态**​：使用 `SHOW VARIABLES LIKE '%log_bin%';`可查看二进制日志是否开启及相关参数。

#### 二、 日志记录的三种格式
这是二进制日志最核心的特性之一，不同格式在**数据一致性、日志大小和性能**之间有不同的权衡。

|格式|工作原理|优点|缺点|适用场景|
|---|---|---|---|---|
|​**STATEMENT**​|记录**原始的SQL语句**​|日志文件小，节省空间|可能引发主从数据不一致（如使用 `NOW()`, `RAND()`等非确定性函数）|已逐渐被淘汰|
|​**ROW**​|记录**每一行数据如何被修改**​（如修改前、修改后的值）|​**数据安全可靠**，主从一致性高（默认格式）|日志文件大（尤其是批量更新时）|​**强一致性要求的场景**，如金融业务|
|​**MIXED**​|​**混合模式**。多数情况用 STATEMENT，在不安全的场景下（如使用不确定函数）自动切换为 ROW|在安全性和日志大小间取得平衡|逻辑相对复杂|通用场景|

​**查看格式**​：使用 `SHOW VARIABLES LIKE 'binlog_format';`查看当前格式。
基于`binlog_format = 'row '`行的二进制内容
![[Pasted image 20251104091201.png]]
基于`binlog_format = 'statement '`sql的二进制内容，以一个事务为单元地记录
![[Pasted image 20251104091804.png]]

#### 三、 如何查看日志内容

二进制日志是二进制格式，无法直接阅读，需使用官方工具 `mysqlbinlog`。

​**基本命令**​：`mysqlbinlog [options] logfilename`

​**常用参数**​：

- `-d database_name`：只查看指定数据库的日志。
    
- `-o n`：忽略日志中的前 n 个条目。
    
- `-v`：将 ROW 格式的日志“重构”为可读的 SQL 语句。​**这是最常用的参数**。
    
- `-vv`：在 `-v`基础上，增加更详细的注释信息。
    
- `--start-datetime=/--stop-datetime`：按时间范围筛选。
    
- `--start-position=/--stop-position`：按日志位置点筛选，更精确。
    

​**示例**​：`mysqlbinlog -v -d mydb binlog.000001`会以可读形式显示 `mydb`数据库在 `binlog.000001`文件中记录的所有变更。

#### 四、 日志清理策略

二进制日志会不断增长，占用大量磁盘空间，必须定期清理。

|命令|作用|风险|
|---|---|---|
|`RESET MASTER;`|​**删除所有**二进制日志文件，并**重置索引**，从 `binlog.000001`重新开始。|​**极其危险**​！仅在从库不需要、且无备份恢复需求的测试环境使用。|
|`PURGE MASTER LOGS TO 'binlog.000010';`|删除指定编号**之前**的所有日志（即删除 `binlog.000001`到 `binlog.000009`）。|相对安全，确保要删除的日志已经不再需要。|
|`PURGE MASTER LOGS BEFORE '2023-10-01 12:00:00';`|删除指定时间点**之前**生成的所有日志。|相对安全，需确认时间点。|

​**生产环境建议**​：设置参数 `expire_logs_days`，让 MySQL 自动清理过期的日志文件，这是最安全稳妥的方式。
#### undo-log和二进制日志的关系
![[Pasted image 20251106092515.png]]
##### 一、 核心区别：本质与目标的不同

这是理解两者为何并存的根本。我们可以通过下表进行核心属性的对比：

|特性|​**重做日志**​|​**二进制日志**​|
|---|---|---|
|​**所属层级**​|​**InnoDB 存储引擎层**​|​**MySQL Server 层**​|
|​**日志类型**​|​**物理逻辑日志**​|​**逻辑日志**​|
|​**记录内容**​|记录每个**数据页**的**物理变化**​|记录造成数据改变的**原始SQL语句**或事件|
|​**主要目标**​|​**崩溃恢复**​|​**数据复制**、**数据恢复**​（按时间点）|
|​**生命周期**​|循环写入，空间用完则覆盖|追加写入，按文件大小或时间切换|
|​**持久化时机**​|在事务提交时写入（WAL机制）|在事务提交后写入|
##### 二、二者执行的顺序
![[Pasted image 20251106092742.png]]


###### 第一步：准备阶段 - 写入 Redo Log (Prepare)

这个过程对应于上图中的步骤 1-5。

1. **执行 UPDATE**：客户端发送 `UPDATE users SET name = 'Alice' WHERE id = 1;`并执行 `COMMIT`。
    
2. **修改内存数据**：InnoDB 引擎在内存的 **Buffer Pool**中找到 `id=1`的这行数据所在的数据页，将其修改为 `name='Alice'`。此时数据页变“脏”，但**尚未刷盘**。
    
3. **写入 Redo Log (Prepare)**：InnoDB 立即将本次修改的**物理逻辑**信息（比如“在表空间X的页Y的偏移Z处写入值‘Alice’”）写入到 **Redo Log Buffer**，并最终**刷盘**到物理的 Redo Log 文件（`ib_logfile0`）中。
    
    - **关键点1**：此时 Redo Log 的记录状态被标记为 **`PREPARE`**（准备中）。
        
    - **关键点2**：写入 Redo Log 是**顺序追加**，比随机修改数据页要快得多（WAL机制的优势）。
        
    

**到这一步，即使数据库崩溃，我们也有能力重放这个修改。**

###### 第二步：提交阶段 - 写入 Binlog (Commit)

这个过程对应于上图中的步骤 6-7。

1. **写入 Binlog**：MySQL Server 层生成对应的 **Binlog**。Binlog 记录的是逻辑SQL语句（如 `UPDATE users SET name = 'Alice' WHERE id = 1;`）或行变更逻辑。然后将 Binlog 写入到 Binlog Cache，并最终**刷盘**到物理的 Binlog 文件（`bin.000001`）中。
    

**到这一步，这个事务的变更已经记录在了逻辑日志中，可以被复制到从库。**

###### 第三步：最终提交 - 修改 Redo Log 状态 (Commit)

这个过程对应于上图中的步骤 8-11。

1. **Redo Log 状态更改**：在确保 Binlog 已经成功落盘后，InnoDB 引擎会**再次修改 Redo Log**中对应记录的状态，将其从 `PREPARE`改为 **`COMMIT`**（已提交）。
    
2. **返回成功**：完成以上步骤后，MySQL 才向客户端返回“提交成功”。
    

**此后，脏页由后台线程在适当时机（如 Checkpoint）异步刷回表空间数据文件（.ibd）。**

---

###### 为什么需要这么复杂的两阶段提交？

核心目的是为了解决 **Redo Log 和 Binlog 是两个独立日志**所带来的**数据一致性问题**。如果没有两阶段提交，在崩溃恢复时会出现问题。

**崩溃恢复场景分析：**

假设在提交过程中的某个时间点数据库崩溃了，重启后 MySQL 会检查 Redo Log 和 Binlog：

|崩溃时间点|Redo Log 状态|Binlog 状态|恢复操作|解释|
|---|---|---|---|---|
|**在写入Binlog之前**|`PREPARE`|无记录|**回滚事务**|Binlog中没有记录，说明事务不完整，从库会丢失这个事务。为保证主从一致，主库也回滚。|
|**在写入Binlog之后，但在Redo Log Commit之前**|`PREPARE`|**有完整记录**|**提交事务**|Binlog中已存在记录，从库将会重放这个事务。为保证主从一致，主库必须提交。|
|**在Redo Log Commit之后**|`COMMIT`|有完整记录|**提交事务**|事务已完整提交，直接重做即可。|

**这种检查机制保证了：**

- **只要 Binlog 中有记录，事务最终一定会被提交。**这是数据一致性的关键。
    
- 避免了主库有数据而从库没有，或者主库回滚了而从库却提交了的数据不一致问题。
    

###### 总结

**两阶段提交（2PC）**是 MySQL 协调 Redo Log（存储引擎层）和 Binlog（Server 层）的**一致性协议**。

1. **Prepare 阶段**：让 Redo Log 先落盘，确保物理修改不会丢失。
    
2. **Commit 阶段**：让 Binlog 落盘，确保逻辑修改可被复制。
    
3. **最终状态更新**：在两者都确认落盘后，才标记事务为最终提交。
    

这种机制用**短暂的同步等待**（等两个日志都落盘）的代价，换来了**崩溃后数据的强一致性**，是数据库可靠性的基石。




