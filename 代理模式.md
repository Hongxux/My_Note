
| 前置知识领域           | 为什么重要                             | 如何用于代理模式                                             |
| ---------------- | --------------------------------- | ---------------------------------------------------- |
| **面向对象编程 (OOP)** | 理解抽象、封装、多态的基础                     | 代理模式的核心是通过接口或抽象类定义代理和真实对象的共同行为，利用多态实现透明替换。           |
| **Java 反射机制**    | 允许程序在运行时检视和操作类、方法、属性等信息           | 这是实现**动态代理**的关键技术，使得代理类可以在运行时动态生成，而无需在编译期预先编写具体的代理类。 |
| **JVM 类加载机制**    | 理解.class字节码文件如何被加载到内存并初始化为Class对象 | 动态代理的本质是在运行时动态生成代理类的字节码，并通过类加载器将其加载到JVM中。            |

### 💡 核心思想与关联概念

掌握了上述前置知识后，理解代理模式就会容易很多。代理模式的核心思想是：**提供一个代理对象来控制对另一个对象（目标对象）的访问**。它通常在访问目标对象时增加一个中间层，用于实现额外的控制或功能增强，比如权限检查、日志记录、延迟加载等。

- **与AOP的关联**：代理模式是实现**面向切面编程（AOP）** 的核心技术之一。AOP允许你将那些遍布在应用多个模块中的横切关注点（如日志、事务管理）集中起来处理，而代理模式正是实现这一目标的重要方式。
    
- **与装饰器模式的区别**：这是一个常见的困惑点。简单来说：
    
    - **代理模式**的重点在于**控制对对象的访问**，它可能对客户端隐藏真实对象的信息，或者管理真实对象的生命周期（如远程代理、虚拟代理）。代理关系通常在编译时就能确定。
        
    - **装饰器模式**的重点在于**动态地为对象添加新的功能**，它是对对象功能的增强。装饰者通常对客户端是透明的，并且装饰关系可以在运行时递归组合。
        
    
----

#### 一、 三大角色（对应图表）

|比喻概念|编程术语|核心职责与特点|
|---|---|---|
|**演员（明星）**|**目标对象 / 被代理对象**|1. 包含核心业务逻辑。  <br>2. 是最终完成实际工作的对象。|
|**替身演员**|**代理对象**|1. 控制对目标对象的访问。  <br>2. 在目标对象工作前后执行附加逻辑（增强）。|
|**演员合同（规定动作）**|**公共接口**|1. 定义了目标对象和代理对象都必须实现的方法。  <br>2. 保证客户端调用代理对象和目标对象的方式**完全一致**，从而实现“透明”替换。|
**关键设计：为什么要有公共接口？**
	“演员和替身演员要有相同的行为动作”，在编程中体现为**代理对象和目标对象必须实现相同的接口**。这是为了实现**里氏替换原则**，确保代理对象可以透明地替换目标对象，而客户端代码无需任何修改。
	**客户端无法察觉代理的存在**，因为它始终是针对接口编程，而非具体实现类。

#### 二、 使用代理模式的原因（动机）

| 比喻原因              | 编程动机                                     | 典型应用场景                                                                                                                        |
| ----------------- | ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **保护自己（怕受伤）**     | **控制访问 / 保护目标对象**                        | 1. **权限控制**：检查调用者是否有权限执行某方法。  <br>2. **安全代理**：屏蔽客户端直接访问敏感对象。                                                                  |
| **功能增强（完成高难度动作）** | **增强功能 / 添加横切关注点**                       | 1. **日志记录**：在方法调用前后记录日志。  <br>2. **事务管理**：在方法调用前开启事务，调用后提交或回滚。  <br>3. **性能监控**：计算方法执行耗时。  <br>4. **延迟加载**：在真正需要时才初始化昂贵的目标对象。 |
| **中介协调**          | **当客户端不能或不想直接引用一个对象时，代理可以作为中介，协调双方的关系。** |                                                                                                                               |
1. **职责清晰**：将**核心功能**（明星表演）与**横切关注点**（安全检查、日志记录等）分离，符合单一职责原则。
    
2. **高扩展性**：无需修改目标对象即可增强其功能，符合开闭原则。
    
3. **透明性**：对客户端隐藏了复杂性，客户端代码无需任何改动。


---

### 代码示例：静态代理

根据图片的比喻，我们来实现一个简单的静态代理示例。

**1. 公共接口 - `Actor`（演员合同）**

```
// 公共接口：定义了演员的标准动作
public interface Actor {
    void performAction();
}
```

**2. 目标对象 - `MovieStar`（明星演员）**

```
// 目标对象：真正的明星，完成核心表演
public class MovieStar implements Actor {
    private String name;
    
    public MovieStar(String name) {
        this.name = name;
    }
    
    @Override
    public void performAction() {
        // 核心业务逻辑：明星进行表演
        System.out.println(name + " 正在完成高难度的特技表演！");
    }
}
```

**3. 代理对象 - `StuntDouble`（替身演员）**

```
// 代理对象：替身，增强并控制对明星的访问
public class StuntDouble implements Actor {
    // 持有目标对象的引用
    private Actor movieStar;
    
    public StuntDouble(Actor movieStar) {
        this.movieStar = movieStar;
    }
    
    @Override
    public void performAction() {
        // **前置增强**：保护明星（检查安全性）
        System.out.println("【替身】检查场景安全性，确保无风险...");
        
        // **委托**：调用目标对象的核心方法
        movieStar.performAction();
        
        // **后置增强**：功能增强（记录日志）
        System.out.println("【替身】表演完成，记录本次特技数据。");
    }
}
```

**4. 客户端 - `Director`（导演/观众）**

```
// 客户端：使用演员的导演或观众
public class Director {
    public static void main(String[] args) {
        // 正常情况下，导演直接找明星
        Actor star = new MovieStar("巨星张三");
        star.performAction(); // 输出：巨星张三 正在完成高难度的特技表演！
        
        System.out.println("---------------");
        
        // 当需要替身时，导演找的是替身（代理），但他以为还是明星
        Actor starProxy = new StuntDouble(new MovieStar("巨星张三"));
        // 客户端调用方式完全不变，但背后已是代理在工作
        starProxy.performAction();
        
        /* 输出：
        【替身】检查场景安全性，确保无风险...
        巨星张三 正在完成高难度的特技表演！
        【替身】表演完成，记录本次特技数据。
        */
    }
}
```

**输出结果印证**：

正如代码所示，导演（客户端）调用 `performAction()`方法时，他并不知道背后是明星本人还是替身。替身（代理对象）在核心表演前后，成功地添加了“安全检查”和“日志记录”的功能增强，完美诠释了代理模式的价值。

---
### [[静态代理]]


---
### 动态代理
