---
aliases:
  - undo log
  - redo log
  - binlog
---
- 需求背景：实现事务的[[ACID]]![[Pasted image 20251102162346.png]]
- 组成结构：
	- [[重做日志]]（重做日志)
	- [[回滚日志|Undo Log]]（回滚日志）
	- [[二进制日志|binlog]]（二进制日志）
- 执行事务的流程
	1. 事务过程：执行一条SQL语句
		1. 执行前：
			1. 数据页从磁盘被加载到内存的Buffer Pool中
			2. 记录undo log：为了保证事务可以回滚，必须先记录 Undo Log
				- 为了保证Undo Log本身的持久性，它的生成也会产生对应的Redo Log
		2. 执行中：**更新内存数据**，标记为脏页
			- Buffer Pool 中的记录被发生修改，内存中的数据页与磁盘上的数据页不再一致，该页被称为 **“脏页”**
		3. 执行后：**为了保证持久性，修改操作需要被记录下来**：生成一条Redo Log并被写入**内存**中的 **Redo Log Buffer**
	2. 二阶段提交，记录binlog和redolog的刷盘成功，实现redo log 和 binlog 这两种日志数据一致性，
		- [[两阶段提交的目的]]：实现在主从复制、数据恢复等关键场景下的数据一致性
			- 在崩溃恢复后，通过redo log的标志，判断binlog和redo log的写入状态，执行正确的崩溃恢复决策
			- 顺序的合理性：先redo log，再写bin log，**避免主从不一致**
		1. Prepare阶段：redo log刷盘。redo log 记录状态为prepare
			- prepare：标志redo log已经刷盘，不属于已提交事务
				- 事务的修改已经持久化，但事务本身并未最终提交，对其他事务仍不可见
		2. Commit阶段：bin log 刷盘，redo log 记录状态为commit
			- commit：标志bin log已经刷盘，属于已提交事务
	3. 后续过程：
		- 脏页刷盘：Buffer Pool 中的脏页会由后台线程在合适的时机（如 Checkpoint 机制）异步地刷回到磁盘的数据文件中。这大大减轻了事务提交时的磁盘 I/O 压力
		- Undo Log 清理：对于 `UPDATE`操作产生的 Undo Log，不会在事务提交后立即删除。因为它可能还被其他事务的 **MVCC**​ 读操作所依赖。Purge 线程会在确定没有事务需要这些旧版本数据时，才将其清理
	4. 事务回滚时：使用undo log将数据恢复到事务开始前的状态
- 数据恢复
	- 人为误操作后的时间点恢复
		- 恢复目标：误删除数据，误更新数据
		- 恢复方式：
			1. 还原最近的全量备份
			2. 找到备份对应的二进制日志位置或时间点。
			3. 使用 `mysqlbinlog`工具重放备份时间点到误操作前的二进制日志事件
				- 如果需要跳过误操作，则需重放误操作之后的日志
	- MySQL实例崩溃恢复：
		- 恢复流程：
			- 已经提交的事务：保证事务的持久性
				- 恢复的对象：在崩溃前已经提交但更改可能还留在内存缓冲区（Buffer Pool）未来得及写入数据文件的事务
				- 恢复方式：从检查点开始扫描重做日志文件，重新执行所有已提交事务对数据页的物理修改
			- 未提交的事务：保证事务的原子性
				- 恢复的对象：所有在崩溃时处于活动状态（未提交）的事务
				- 恢复方式：
					- 如果发现一个事务的 redo log 处于 `PREPARE`状态
						- 如果 binlog 中存在该事务的记录：标记成已经提交
							- 与提交只差标记这一步
						- 如果 binlog 中不存在该事务的记录：由后台线程执行回滚操作

- MySQL实现ACID
	- 关系：一致性是最终目的，原子性和持久性和隔离性是实现的手段
	- 原子性：其核心实现依赖于**Undo Log（回滚日志）**
		- **开启事务的时候，记录逆操作**：在你进行任何数据修改（INSERT、UPDATE、DELETE）之前，数据库会先将数据修改前的映像记录到Undo Log中
		- **事务回滚**：如果事务执行失败或显式发出ROLLBACK命令，数据库会利用Undo Log执行逆向操作，将数据恢复到事务开始前的状态
		- **系统崩溃恢复**：在数据库系统崩溃后重新启动时，所有处于"未提交"或"未知状态"的事务也会利用Undo Log进行回滚，确保原子性
	- 持久性：通过 Redo Log（实现的基础）​ 和 Force-Log-at-Commit​ 机制（实现的机制）实现
	- 隔离性的实现：主要通**锁（Locking）机制**和**多版本并发控制（MVCC）**​ 实现
	- 一致性的实现
		- **数据库层面保障**：数据库通过预定义的约束（如主键、外键、唯一索引、数据类型检查）来保证数据符合业务规则。事务执行过程中若违反这些约束，事务会回滚
		- **应用层面保障**：数据库的一致性保障是基础，应用层需要正确设计业务逻辑（如转账时先扣款再存款）并合理使用事务，才能最终达成数据一致