---
aliases:
  - LRU
---
根据局部性原理，我们认为最近使用过的页面比很久未用的页面更有价值留在缓存中，因此有了LRU：
-  一种基于**历史访问行为**的缓存置换策略。
- 其核心原则是：​**淘汰最长时间没有被访问的页面（或缓存项）​**。

---
### LRU算法的实现
算法实现的核心：找出最长时间没有被访问过的页面
#### ​**1. 理想的、精确的LRU实现**​

精确实现LRU需要完整、精确地记录所有页面的访问顺序。

- ​**实现方法一：链表**​
    
    - ​**数据结构**​：维护一个所有驻留页面的**链表**。最近访问的页面在**链表头部（MRU端）​**，最久未访问的页面在**链表尾部（LRU端）​**。
        
    - ​**访问时**​：每当一个页面被访问（读或写），就将它从链表中当前位置**移动到头部**。此操作时间复杂度为O(1)。
        
    - ​**置换时**​：当需要淘汰页面时，直接选择**链表尾部**的页面。此操作时间复杂度为O(1)。
        
    - ​**开销**​：每次内存访问（包括指令获取）都需要修改链表，这是一个巨大的软件开销，​**在实际系统中无法承受**。
        
    
- ​**实现方法二：矩阵/计数器**​
    
    - ​**数据结构**​：为每个页面维护一个64位的“访问时间戳”计数器。每次系统产生一个全局时钟滴答时，计数器加1。当页面被访问时，将其计数器更新为当前时钟值。
        
    - ​**置换时**​：扫描所有页面，选择**计数器值最小**的页面（即最久未被访问）进行淘汰。
        
    - ​**开销**​：需要硬件支持高精度时钟和大量寄存器，​**硬件开销巨大**。
        
    

​**结论**​：精确的LRU虽然性能优异，但因其**高昂的实现开销**，在真实的通用操作系统中**不被直接使用**。

#### ​**2. 近似的LRU实现：时钟算法**​

为了以可接受的开销获得接近LRU的性能，操作系统普遍采用近似算法，其中最著名的是**时钟算法**。

- ​**硬件支持**​：
    
    - 每个页表项（PTE）中需要一个**访问位**。当页面被任何读或写操作访问时，​**内存管理单元（MMU）硬件会自动将该位置1**。这个操作对软件透明，零开销。
        
    
- ​**算法流程（“第二次机会”算法）​**​：
    
    1. ​**数据结构**​：
	    - 将物理页帧组织成一个**环形链表**​（类似钟表盘）。一个“时钟指针”指向链表中的某个页帧。
	    - 每个页面有访问位和修改位
		    - 访问位的更新：
			    - 如果被访问了则设置为1
			    - 如果被时钟算法扫描的时候为1，则被设置为0
			- 修改位：
				- 由硬件在页面被写入时置1，标记页面为“脏页”（换出脏页需要写回磁盘，开销更大）
	2. **淘汰的优先级**：
		1. 优先淘汰 (**访问位=0， 修改位=0**) ：因为无需写盘
		2. 其次是 (**访问位=0， 修改位=1**)：这减少了I/O操作，进一步优化了性能。
		3. 最后是(**访问位=1， 修改位=1**)
        
    3. ​**置换过程**​：
        
        - 当需要置换一个页面时，操作系统从时钟指针的当前位置开始**顺时针扫描**。
            
        - 检查当前页面的访问位：
            
            - 如果访问位为 ​**1**​：说明这个页面在最近一段时间内被访问过，​**不应该被立刻淘汰**。于是，操作系统将其访问位**清零**​（“给予第二次机会”），然后时钟指针移向下一个页面。
                
            - 如果访问位为 ​**0**​：说明这个页面自从上次被扫描以来，一直没有被访问过。它是一个理想的淘汰候选者。于是，选择该页面作为牺牲页。
                
            
        - 指针循环扫描，直到找到满足淘汰优先级的页面，然后淘汰掉。


---

### ​**4. 潜在问题与解决措施**​

- ​**潜在问题**​：
    
    1. ​**实现开销**​：精确LRU的开销无法承受，这是其根本问题。
        
    2. ​**缓存污染**​：对于**循环扫描**的访问模式（例如，访问一个比缓存大的数组），LRU表现很差，因为它会淘汰掉即将被再次访问的页面。在这种情况下，简单FIFO可能更好。
        
    3. ​**对访问频率不敏感**​：LRU只关心访问的“新近度”，而不关心“频率”。一个最近只被访问过一次的页面，可能会比过去被频繁访问但最近刚过期的页面更受保护。
        
    
- ​**解决措施**​：
    
    1. ​**使用近似算法**​：​**时钟算法**​ 是解决开销问题的标准答案，它在性能和开销之间取得了绝佳的平衡。
        
    2. ​**算法混合/自适应**​：一些系统会监控访问模式，在LRU和FIFO等算法之间动态切换，以应对不同的工作负载。
        
    3. ​**LRU-K等变种**​：这些更高级的算法不仅记录最近是否访问，还记录最近K次访问的历史，从而能更好地识别出“热点”页面，抵抗缓存污染。
        
    

---

### ​**5. 面试官可能关心的方面及答案**​

​**Q1: 为什么操作系统不实现精确的LRU，而是用时钟算法？​**​

​**A1**: 因为精确LRU的实现开销太大。无论是维护链表（每次内存访问都要更新）还是维护时间戳（需要硬件支持和大量存储），其成本都高到无法在通用操作系统中承受。时钟算法利用硬件自动设置的**访问位**，通过简单的扫描和清零操作，以极低的开销实现了非常接近LRU的性能，是工程上的最优折中。

​**Q2: 时钟算法中的“访问位”是由谁、在什么时候置1和清0的？​**​

​**A2**:

- ​**置1**​：由**硬件（MMU）​**​ 在每次页面被**读或写**时自动完成。对软件完全透明，零开销。
    
- ​**清0**​：由**操作系统软件**完成。具体是操作系统的**页面置换后台线程**​（如Linux的`kswapd`）在执行时钟算法扫描页面时，如果遇到访问位为1的页面，会将其清0。这个清0操作是算法“给予第二次机会”的关键。
    

​**Q3: LRU算法在什么情况下表现会不好？请举例说明。​**​

​**A3**: LRU在访问模式不符合“时间局部性”原理时会表现不佳。典型例子是**顺序扫描/循环访问一个比缓存容量大的数据集**。

- ​**场景**​：假设缓存（内存）只能容纳3个页面，程序需要循环访问A, B, C, D四个页面。
    
- ​**访问序列**​：A, B, C, D, A, B, C, D, ...
    
- ​**LRU行为**​：
    
    - 访问A, B, C：全部命中（加载）。
        
    - 访问D：缺页，淘汰A（因为A是最近最久未用的）。
        
    - 访问A：缺页，淘汰B。
        
    - ... 如此循环，​**每次访问都会缺页**，命中率为0%。
        
    
- ​**对比**​：如果是FIFO，在稳定状态下（缓存满后），也会是每次访问都缺页。但如果是随机置换，反而有可能获得非零的命中率。这说明没有“万能”的算法。
    

​**Q4: 增强型时钟算法是如何工作的？它为什么更好？​**​

​**A4**: 增强型时钟算法在扫描时同时检查**访问位（R）​**​ 和**修改位（M）​**。它将页面分为四类：(0,0), (0,1), (1,0), (1,1)。算法优先寻找`(R=0, M=0)`的页面进行淘汰，如果找不到再找`(R=0, M=1)`的页面。

- ​**优势**​：淘汰一个“干净”的页（M=0）比淘汰一个“脏”页（M=1）代价小得多，因为脏页换出时需要额外的磁盘写入操作。通过优先淘汰干净页，算法**减少了耗时的I/O操作**，从而进一步提升了系统性能。
    

希望这份严谨的剖析能帮助你深入理解LRU算法及其在实践中的应用。