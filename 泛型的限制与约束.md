### Java泛型限制全解析（基于类型擦除机制）

#### 一、类型参数与基本类型的互斥

1. ​**禁止使用基本类型实例化泛型**​
    
    - ​**规则**​：类型参数不能替换为基本类型（如 `Pair<double>`非法，必须用 `Pair<Double>`）。
        
    - ​**根本原因**​：类型擦除后，泛型字段变为 `Object`类型，无法存储基本类型值（如 `double`）。
        
    - ​**解决方案**​：
        
        - 使用包装类型（如 `Double`）替代基本类型。
            
        - 对8种基本类型单独设计非泛型工具类。
            
        
    

---

#### 二、运行时类型查询的限制

1. ​**类型查询仅返回原始类型**​
    
    - ​**`instanceof`失效**​：
        
        ```
        if (a instanceof Pair<String>)  // 编译错误！实际检测的是原始类型Pair
        ```
        
    - ​**强制转换警告**​：
        
        ```
        Pair<String> p = (Pair<String>) a;  // 警告：仅验证a是否为Pair
        ```
        
    - ​**`getClass()`行为**​：
        
        ```
        stringPair.getClass() == employeePair.getClass()  // 恒为true（均返回Pair.class）
        ```
        
    

---

#### 三、泛型数组的创建禁令

1. ​**直接创建泛型数组非法**​
    
    ```
    var table = new Pair<String>[10];  // 编译错误！
    ```
    
    - ​**原因**​：数组需记录组件类型以检查存储操作（`ArrayStoreException`），但擦除后类型信息丢失。
	    - ​**数组在内存中会记录其元素类型（组件类型），并在每次插入元素时执行类型检查**
        
        ```
        Object[] objarray = table;
        objarray[0] = new Pair<Employee>();  // 能通过检查但导致类型错误
        ```
        
    
2. **​解决方案​**
    
- **使用 `Object[]`然后进行强制转换（会产生警告，需用 `@SuppressWarnings`抑制）**​**​：
```java
        
public class GenericArray<T> {
    private T[] array;

    @SuppressWarnings("unchecked")
    public GenericArray(int size) {
        // 先创建 Object 数组，再强制转换为 T[]
        array = (T[]) new Object[size];
    }
}
```
- **安全替代**​：使用 `ArrayList<Pair<String>>`。它们内部就是这样处理的，更安全。​
        
    

---

#### 四、可变参数（Varargs）的警告处理

1. ​**泛型可变参数触发警告**​
    
    ```
    addAll(table, pair1, pair2);  // 隐含创建泛型数组，产生警告
    ```
    
2. ​**安全抑制警告的方法**​
    
    - ​**方案1**​：在调用方法处添加 `@SuppressWarnings("unchecked")`。
        
    - ​**方案2（推荐）​**​：在目标方法声明 `@SafeVarargs`：
        
        ```
        @SafeVarargs
        public static <T> void addAll(Collection<T> coll, T... ts)
        ```
        
    
    > ​**限制**​：`@SafeVarargs`仅适用于 `static`/`final`/`private`（Java 9+）方法。
    

---

#### 五、类型变量实例化的限制

1. ​**禁止 `new T()`构造对象**​
    
```java

public class Container<T> {
    private T value;

    public Container() {
        value = new T(); // 编译错误：Type parameter 'T' cannot be instantiated directly
    }
}
```

**原因**：在 `new T()`时，JVM 需要知道：
- ​**该调用哪个构造函数？​**​
    （`String`有 `String()`，`Integer`有 `Integer(int)`，构造方法不统一）
- ​**分配多少内存？​**​
    （不同对象大小不同，如 `String`包含 `char[]`，`Integer`只是一个 `int`包装）
    但是Object（）就不知道
1. ​**解决方案**​
    
- ​**使用 Supplier 函数式接口（Java 8+）​**​：
        
```java
    public Container(Supplier<T> supplier) {
        value = supplier.get();
    }
```
延后处理，在运行时候才调用接口方法
#待考证

- ​**反射模式**​：
        
    ```java
        public static <T> Pair<T> makePair(Class<T> cl) {
            return new Pair<>(cl.getConstructor().newInstance());
        }
        Pair<String> p = makePair(String.class);
     ```
        
    

---

    

---

#### 七、静态上下文的类型变量禁用

1. ​**静态成员不能引用类型参数**​
    
    ```
    public class Singleton<T> {
        private static T instance;  // 错误！
        public static T getInstance() { ... }  // 错误！
    }
    ```
    
    - ​**原因**​：**​**​ 静态成员属于类本身，而不属于某个实例。`MyClass<String>`和 `MyClass<Integer>`共享同一个静态成员，但 `T`却指向不同的类型，这会造成矛盾。
        
    

---

#### 八、泛型类与异常处理的限制

1. ​**泛型类不能继承 `Throwable`**​
    
    ```
    public class Problem<T> extends Exception { ... }  // 错误！
    ```
    
2. ​**`catch`子句禁用类型变量**​
    
    ```
    catch (T e) { ... }  // 错误！T为类型变量
    ```
    
3. ​**合法场景**​：类型变量可用于异常声明
    
    ```
    public static <T extends Throwable> void doWork() throws T { ... }
    ```
    

---

#### 九、绕过受检异常机制

1. ​**受检异常转未受检异常技巧**​
    
    ```
    @SuppressWarnings("unchecked")
    static <T extends Throwable> void throwAs(Throwable t) throws T {
        throw (T) t;  // 欺骗编译器
    }
    ```
    
    - ​**应用场景**​：将受检异常透传给Runnable线程
        
        ```
        Runnable task = () -> { throwAs(new IOException()); };
        ```
        
    

---

#### 十、擦除后的方法签名冲突

由于类型擦除，两个**看起来不同**的泛型方法在擦除后可能拥有相同的原始类型签名，导致冲突。

​**示例（错误）：​**​


```
public class Example {
    // 这两个方法的签名在擦除后都是：void print(List list)
    public void print(List<String> list) {}
    public void print(List<Integer> list) {} // 编译错误：方法冲突
}
```
    
2. ​**接口参数化冲突**​
    
    ```
    class Manager extends Employee implements Comparable<Manager> { ... }  
    // 错误！同时实现Comparable<Employee>和Comparable<Manager>
    ```
    
    - ​**根源**​：桥接方法冲突（生成两个相同的 `compareTo(Object)`方法）。
        
    

---

