---
aliases:
  - 监视器
  - 管程
  - 重量级锁
---

- Monitor本质：一个名为 `ObjectMonitor`的 C++ 对象，对象字段：
	- `_owner`：指针
		- 指针内容：当前正**持有**该 Monitor 锁的线程
		-  `null`：则表示这个 Monitor 目前是“空闲”的，没有线程持有它
	- `_EntryList`：队列，管理那些正在等待锁的线程
		- 更新方式：当多个线程同时竞争一个已被持有的锁时，那些未能立即获取锁的线程就会被放入这个队列中
	- `_WaitSet`：队列，管理那些已经拿到过锁，但因为某些条件不满足而主动放弃锁的线程
		- 更新时机：持有锁的线程调用 `Object.wait()`方法后，该线程会释放锁，并自身被转移到 `_WaitSet`队列中
	- `_recursions`：记录了同一个线程重复获取同一把锁的次数
		- 目的：实现可重入性
		- 更新方式：
			- 每当线程重入一次，计数器就加1；
			- 每当线程退出同步块时，计数器减1
		- 作用：只有当计数器归零时，线程才会真正释放该 Monitor 锁
-  关联方式：每个 Java 对象都可以关联一个 Monitor 对象
	- 如果使用 synchronized 给对象上锁(重量级)之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针
- 交互方式：![[Pasted image 20251130214011.png]]
	1. 线程尝试获取锁：
		- 尝试时机：当线程执行到 `synchronized(obj)`代码时
		- 尝试方式：比对与 `obj`关联的 Monitor的`_owner`字段
	2. 首次获取：
		- 条件：`_owner`为 `null`
		- 流程：
			1. CAS（Compare-And-Swap）​ 操作将 `_owner`设置为当前线程
			2. `_recursions`会被设置为1
			3. 线程开始执行同步代码块中的代码
	3. 锁重入：
		- 条件：`_owner`就是当前线程自己
		- 流程：
			1. `_recursions`计数器会递增
			2. 线程继续执行临界区代码。
			3. 临界区代码完成后，计数器会递减
	4. 竞争失败与等待：
		- 条件：`_owner`是其他线程
		- 流程：
			1. 被封装成一个 `ObjectWaiter`对象
			2. 加入到 `_EntryList`队列中
			3. 线程状态变为 `BLOCKED`
	5. 释放锁与唤醒：
		- 条件：计数器为0
		- 流程：
			1. 将 `_owner`设置为 `null`
			2. 从 `_EntryList`中唤醒一个或多个等待的线程（默认是非公平竞争），这些被唤醒的线程会尝试重新竞争这把锁
	6. 主动等待与通知
		- 条件：使用`obj.wait()`方法
			- 持有锁的线程在同步块内发现运行条件不满足
		- 流程：
			1. 将 `_owner`置为 `null`
			2. 自身被放入 `_WaitSet`队列
			3. 线程状态变成等待状态（WAITING）
	7. 通知：
		- 条件：其他线程调用 `obj.notify()`或 `obj.notifyAll()`
			- 其他线程改变了条件，使得该线程的运行条件符合了
		- 流程：将 `_WaitSet`中的一个或全部线程移动到 `_EntryList`中
			- 这些线程于是又有了竞争锁的资格

