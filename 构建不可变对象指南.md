
#### ​**核心原则**​

1. ​**状态永不改变**​：对象创建后，所有字段值固定不变
    
2. ​**自我封闭**​：对象内部状态不依赖外部可变对象
    
3. ​**安全发布**​：构造完成后，对象可安全共享给其他线程
    

---

### ​**具体实现步骤**​

#### 1. ​**类声明为`final`**​

```
public final class ImmutablePerson {
    // 防止子类覆盖方法改变行为
}
```

​**替代方案**​：私有构造函数 + 工厂方法（若需允许继承）

```
public class ImmutablePerson {
    private ImmutablePerson() {} // 私有构造
    
    public static ImmutablePerson create(...) {
        return new ImmutablePerson(...);
    }
}
```

#### 2. ​**所有字段设为`private final`**​

```
private final String name;
private final LocalDate birthDate;
private final List<String> addresses; // 引用类型需特殊处理
```

#### 3. ​**构造函数深度初始化**​

- ​**基本类型/不可变类型**​：直接赋值
    
    ```
    public ImmutablePerson(String name, LocalDate birthDate) {
        this.name = name;
        this.birthDate = birthDate;
    }
    ```
    
- ​**可变引用类型**​：必须创建防御性副本
    
    ```
    public ImmutablePerson(String name, List<String> addresses) {
        this.name = name;
        // 创建新集合（深度拷贝）
        this.addresses = new ArrayList<>(addresses); 
    }
    ```
    

#### 4. ​**不提供setter方法**​

```
// 禁止任何修改方法
// 没有 setName(), setAddress() 等方法
```

#### 5. ​**访问器方法返回防御性副本**​

```
public List<String> getAddresses() {
    // 返回不可修改的副本
    return Collections.unmodifiableList(new ArrayList<>(addresses));
}
```

#### 6. ​**特殊类型处理**​

- ​**数组**​：
    
    ```
    private final String[] tags;
    
    // 构造函数
    public ImmutablePerson(String[] tags) {
        this.tags = Arrays.copyOf(tags, tags.length);
    }
    
    // 访问器
    public String[] getTags() {
        return Arrays.copyOf(tags, tags.length);
    }
    ```
    
- ​**集合**​：
    
    ```
    // 返回不可修改集合
    public List<String> getAddresses() {
        return List.copyOf(addresses); // Java 10+
    }
    ```
    
- ​**嵌套可变对象**​：
    
    ```
    public final class ImmutableEmployee {
        private final ImmutablePerson person; // 嵌套不可变对象
        private final Department department;  // 必须确保Department也是不可变的
    }
    ```
    

#### 7. ​**防止`this`引用逸出**​

```
public ImmutablePerson(String name) {
    this.name = name;
    // 错误示例：在构造完成前发布引用
    EventBus.register(this); // 绝对禁止！
}
```

---

### ​**完整示例：不可变Person类**​

```
import java.time.LocalDate;
import java.util.*;

public final class ImmutablePerson {
    private final String name;
    private final LocalDate birthDate;
    private final List<String> addresses;
    private final String[] tags;
    private final Map<String, Integer> skills;

    public ImmutablePerson(String name, LocalDate birthDate, 
                          List<String> addresses, 
                          String[] tags,
                          Map<String, Integer> skills) {
        this.name = name;
        this.birthDate = birthDate;
        
        // 防御性拷贝集合
        this.addresses = new ArrayList<>(addresses);
        
        // 防御性拷贝数组
        this.tags = Arrays.copyOf(tags, tags.length);
        
        // 防御性拷贝Map
        this.skills = new HashMap<>(skills);
    }

    // 访问器方法
    public String getName() { return name; }
    
    public LocalDate getBirthDate() { return birthDate; }
    
    public List<String> getAddresses() {
        return Collections.unmodifiableList(new ArrayList<>(addresses));
    }
    
    public String[] getTags() {
        return Arrays.copyOf(tags, tags.length);
    }
    
    public Map<String, Integer> getSkills() {
        return Collections.unmodifiableMap(new HashMap<>(skills));
    }
    
    // 没有setter方法
    
    // 若需"修改"，返回新对象
    public ImmutablePerson withName(String newName) {
        return new ImmutablePerson(newName, birthDate, addresses, tags, skills);
    }
}
```

---

### ​**验证不可变性的测试方法**​

1. ​**反射测试**​：尝试通过反射修改字段值
    
    ```
    Field field = person.getClass().getDeclaredField("name");
    field.setAccessible(true);
    field.set(person, "NewName"); // 应该抛出IllegalAccessException
    ```
    
2. ​**多线程压力测试**​：
    
    ```
    ExecutorService executor = Executors.newFixedThreadPool(100);
    for (int i = 0; i < 100_000; i++) {
        executor.submit(() -> {
            person.getAddresses().add("Hack"); // 应该抛出UnsupportedOperationException
        });
    }
    ```
    
3. ​**引用相等性测试**​：
    
    ```
    String[] originalTags = {"A","B"};
    ImmutablePerson p1 = new ImmutablePerson("John", originalTags);
    originalTags[0] = "Hacked"; // 不应影响p1的内部状态
    assertNotEquals(originalTags, p1.getTags());
    ```
    

---

### ​**设计注意事项**​

1. ​**性能权衡**​：
    
    - 频繁拷贝可能影响性能
        
    - 解决方案：使用不可变集合（Guava/Java 9+）
        
        ```
        // Java 9+ 不可变集合
        private final List<String> addresses = List.of("Addr1", "Addr2");
        ```
        
    
2. ​**继承问题**​：
    
    - 如果允许继承，所有方法应为`final`
        
    - 或者使用组合代替继承
        
    
3. ​**序列化**​：
    
    - 实现`Serializable`时声明`serialVersionUID`
        
    - 重写`readObject`防止攻击
        
        ```
        private void readObject(ObjectInputStream ois) 
            throws InvalidObjectException {
            throw new InvalidObjectException("Proxy required");
        }
        ```
        
    
4. ​**构建复杂对象**​：
    
    - 使用Builder模式
        
    
    ```
    ImmutablePerson.builder()
        .name("Alice")
        .birthDate(LocalDate.of(1990, 1, 1))
        .addAddress("123 Main St")
        .build();
    ```
    

遵循这些准则，您可以创建真正不可变的对象，获得线程安全、避免同步开销、简化程序逻辑等优势，特别是在并发编程和函数式编程中价值显著。