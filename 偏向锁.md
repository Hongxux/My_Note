- **场景假设**：锁不仅不存在多线程竞争，而且总是由同一个线程多次获得（只存在重入现象）。
- **设计目的**：优化无竞争场景，单线程重复加锁
- **实现基础**：Mark Word的存储内容![[Pasted image 20251201091644.png]]
- **实现流程**：在对象头记录线程ID，下次同一线程访问只需比对ID![[Pasted image 20251130225527.png]]
	- 线程首次获取锁：JVM 用CAS方式将线程 ID 记录在对象的 Mark Word 中，并将对象头设置为偏向模式。
	- 线程再次进入临界区（关键优化点）：
		1. 检查状态：查看对象头 Mark Word 中的锁标志位和偏向锁标志，确认当前处于“可偏向”状态。
		2. 检查线程ID：比较 Mark Word 中存储的线程 ID 是否是当前线程的 ID。
		3. 快速通过：如果 ID 匹配，线程无需执行任何复杂的同步操作（如 CAS），即可直接进入同步块执行代码
		- 好处：再次使用时候，不需要进行任何同步操作（如 CAS），代价极小
			- 首次加锁CAS写ID，再次进入只需要读，解锁不进行读写操作：加锁解锁的开销降低到仅仅一次内存读写的量级
- **锁撤销和锁升级**：
	- 发生时机：
		- 调用hashcode
			- MarkWord的结构不匹配
		- 其他线程尝试竞争
		- 调用wait/notify
			- 这个机制只有重量级有
	- 实现流程：
		1. 暂停所有用户线程（STW, Stop-The-World）
		2. 检查原持有线程的状态
			- 撤销并且升级：
				- 发现时机：一个线程尝试获取被另一个线程偏向的锁（处理单次锁竞争）
				- 流程：
					- 偏向锁被撤销并升级为**轻量级锁**
					- 新的竞争线程会开始自旋等待
			- 批量重偏向
				- 出现时机：单个类的对象虽然被多个线程访问，但没有竞争（交替访问）
					- 达到撤销次数阈值（针对类的计数）：当一个类的对象实例的偏向锁，因为被不同线程竞争而发生撤销的次数累计达到 20次
					- 在时间衰减期内：在最后一次批量重偏向发生的 25秒内，该类的偏向锁撤销次数再次达到20次，则会直接触发批量重偏向。
						- 如果超过25秒没有新的撤销操作发生，已累积的撤销计数会被重置
				- 实现机制：`epoch`（时期值）机制​
					- 本质上相当于一个版本号
					- 更新机制：
						- 更新时机：触发批量重偏向，将类的epoch值+1
					- 检查：当有线程尝试获取该类一个对象的锁时，会检查对象头中的 `epoch`值是否与类的当前 `epoch`值相等
						- 如果相等：允许这个锁跳过撤销流程，直接修改对象头，将偏向的线程ID改为当前线程
							- 说明此时在进行批量重偏向的过程中
			- 批量撤销
				- 触发时机：认为这个锁竞争非常激烈
					- 撤销某个类的对象的偏向锁超过四十次之后
				- 含义：
					- 这个类的所有对象都变成不可偏向的（001）
					- 新建的对象也是变成不可偏向的
- **配置：**
	- 禁用偏向锁：
		- VM参数-XX:-UseBiasedLocking
		- 调用obj.hashcode()