### 💡 给开发者的建议

- **设置合理的过期时间**：为缓存数据设置过期时间是一个好习惯，这是数据能被自动清理的前提。
    
- **根据业务选择淘汰策略**：理解你的数据访问模式（是热点数据明显还是访问均匀），并据此配置合适的 `maxmemory-policy`。对于大多数缓存场景，`allkeys-lru`是一个不错的选择。
    
- **监控内存使用**：定期监控Redis的内存使用情况，确保设置了合理的 `maxmemory`限制，并关注是否有大量已过期但未被及时删除的键存在。

|机制类型|触发条件|工作方式|特点|
|---|---|---|---|
|**惰性删除**|当客户端**访问某个键**时触发。|Redis 会先检查该键是否已过期，如果过期则立即删除，并返回空值；未过期则正常返回数据。|**节约CPU资源**，但无法处理长期不被访问的过期键，可能导致内存浪费。|
|**定期删除**|Redis 服务器**周期性**地（默认每秒10次）主动运行。|每次运行时，会**随机抽取**一定数量（如20个）设置了过期时间的键进行检查和删除。|**减少内存浪费**，通过限制执行时长和频率来减少对CPU的影响。|
|**内存淘汰**|当内存使用达到 `maxmemory`限制且需要写入新数据时触发。|根据配置的淘汰策略（如 `allkeys-lru`, `volatile-ttl`），删除一些键以释放空间。|
#### 1. 惰性删除 (Lazy Expiration)

这是Redis处理过期键的**第一道关卡**。其核心逻辑是“不访问，不处理”。所有读写数据库的Redis命令（如 `GET`, `HGET`, `SET`）在执行之前，都会调用 `expireIfNeeded`函数来检查键是否过期。

这种方式非常高效，因为它只在实际需要使用这个键的时候才付出检查的成本。但它的缺点也很明显：如果一个键过期后永远不再被访问，那么它将一直占据着内存空间，直到永远，这实际上是一种内存泄漏。

#### 2. 定期删除 (Active Expiration)

为了弥补惰性删除的不足，Redis引入了**第二道关卡：定期删除**。这是一个由Redis后台线程主动执行的清理任务。

- **执行过程**：它会**分批次、随机地**扫描数据库中设置了过期时间的键，检查并删除其中的过期键。这个过程会循环进行，直到满足一定条件（如本次执行时间超过25毫秒，或过期键比例不高）才停止。
    
- **优点**：这种策略是**主动的**，在一定程度上减少了由惰性删除导致的内存浪费问题。
    
- **注意点**：由于是随机抽样，并且有执行时间限制，**它仍然无法保证100%立即删除所有过期数据**。可能会有一小部分过期键存活到下一个扫描周期。
    

#### 3. 内存淘汰机制 (Eviction Policy)

这是Redis的**安全网**。当Redis使用的内存达到配置的最大值（`maxmemory`）时，如果再有新的写入命令，就会触发内存淘汰机制。

你需要根据业务场景在 `redis.conf`文件中配置 `maxmemory-policy`来选择淘汰策略，常见的策略有：

- **`volatile-lru`**：从**设置了过期时间**的键中，淘汰**最近最少使用**的键。
    
- **`volatile-ttl`**：从**设置了过期时间**的键中，淘汰**剩余存活时间最短**的键。
    
- **`allkeys-lru`**：从**所有键**中，淘汰**最近最少使用**的键。这是最常用的策略之一。
    
- **`noeviction`**：不淘汰任何键。当内存不足时，新写入操作会返回错误。这是默认策略，生产环境通常不推荐。
    

