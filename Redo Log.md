可参考操作系统中的[[数据日志化]]
> ​**一种物理日志，记录的是事务对数据页的物理修改内容。​**​ 其唯一且最重要的目的，就是确保事务的持久性——一旦事务提交，它对数据所做的更改就永远不会丢失。

重要机制：WAL


#### 一、Redo Log 的组成结构

redo log的具体内容

Redo Log 由两部分组成，这对应了数据库的“内存-磁盘”两级存储结构：

1. ​**重做日志缓冲（Redo Log Buffer）​**​
    
    - ​**位置**​：​**内存**中一个易失性的连续空间。
        
    - ​**作用**​：作为临时缓冲区。当事务执行数据修改操作（`INSERT`/`UPDATE`/`DELETE`）时，首先会将产生的重做日志信息写入到此缓冲区中，以提升性能。
        
    
2. ​**重做日志文件（Redo Log File）​**​
    
    - ​**位置**​：​**磁盘**上的一组文件，通常命名为 `ib_logfile0`、`ib_logfile1`。
        
    - ​**作用**​：持久化存储。Redo Log Buffer 中的内容会按照一定策略刷盘，最终保存到这些文件里。​**即使数据库发生崩溃，这些文件也会存活**，用于崩溃恢复。
        
    

#### 二、Redo Log 的工作流程与核心价值

图中的文本描述了一个关键的工作流程，这背后是数据库领域一个至关重要的原则：​**[[WAL]]（Write-Ahead Logging，预写式日志）​**。

​**工作流程如下：​**​

1. ​**事务执行**​：事务对数据进行修改（例如，将 id=1 的用户的余额从 100 改为 200）。
    
2. ​**日志先行**​：(WAL)
    
    - 这个修改操作（物理变化）会首先被封装成一条 ​**[[Redo Log]]**，并写入内存中的 ​**Redo Log Buffer**。
        
    - ​**当事务提交时，核心步骤来了**​：为了保证持久性，事务必须确保其对应的所有 Redo Log 记录已经从 Buffer 中**持久化到磁盘**的 Redo Log File 中。
        
    
3. ​**后台刷脏**​：在事务提交后，内存**缓冲池（Buffer Pool）​**​ 中被修改过的“脏页”​**并不需要立即刷回磁盘**。InnoDB 有后台线程（Master Thread / Page Cleaner Thread）在合适的时机（如系统空闲、缓冲池满时）慢慢地将这些脏页刷新到表空间文件（.ibd）中。
    

​**核心价值：为什么需要这个“多余”的WAL步骤？​**​

- ​**性能极致优化**​：​**顺序 I/O vs. 随机 I/O**​
    
    - 将 Redo Log 刷盘是**顺序追加写入**，速度极快。
        
    - 将脏页刷盘是**随机写入**​（数据页在磁盘上分散存储），速度很慢。
        
    - WAL 机制通过将每次事务提交所需的**随机写磁盘**转换为一小批**顺序写日志**，极大地提升了数据库的写入吞吐量。
        
    
- ​**崩溃恢复（Crash Recovery）​**​
    
    - ​**场景**​：假设事务已提交，但脏页还未刷盘，此时数据库突然断电。
        
    - ​**恢复**​：数据库重启后，InnoDB 会检查 Redo Log。由于事务提交时其 Redo Log 已持久化，InnoDB 会根据 Redo Log 的记录，​**重做**​（redo）一遍所有已提交但未落盘的操作，将数据恢复到崩溃前的状态，从而保证了持久性。
        
    

#### 三、关键配置参数

图中虽未明确列出，但与 Redo Log 刷盘行为最相关的参数是 ​**`innodb_flush_log_at_trx_commit`**，它控制事务提交时日志缓冲区的刷盘策略，是在性能和数据安全性之间进行权衡的关键杠杆：

|取值|行为|安全性|性能|
|---|---|---|---|
|​**0**​|日志每秒写入并刷盘一次。|最低（崩溃可能丢失1秒数据）|最高|
|​**1**​（默认）|​**事务提交时立即写入并刷盘**。|​**最高**​（严格持久性）|最低|
|​**2**​|事务提交时立即写入系统缓存，但每秒才刷盘一次。|中等（系统崩溃会丢数据，服务器断电不会）|中等|

​**生产环境强烈建议保持默认值 1**，以确保数据的绝对安全。