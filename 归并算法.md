**核心**：归并操作+分而治之的思想
https://visualgo.net/zh/sorting?create=29%2C10%2C14%2C37%2C14&mode=Merge&run=true
---
### 归并操作
这个 `merge`函数是归并排序的核心，通过高效合并两个已排序的子数组来实现整体排序。
```java
// 输入：
//   arr[]: 原始数组
//   left: 左子数组起始索引
//   mid: 左子数组结束索引（右子数组起始索引为 mid+1）
//   right: 右子数组结束索引
method merge(array A, integer low, integer mid, integer high)  
  // 子数组1 = a[low..mid], 子数组2 = a[mid+1..high], 都已排序  
  int N = high-low+1  
  create array B of size N // 讨论：为什么我们需要一个临时数组b？  
  int left = low, right = mid+1, bIdx = 0  
  while (left <= mid && right <= high) // 合并过程  
    if (A[left] <= A[right])  
      B[bIdx++] = A[left++]   
    else  
      B[bIdx++] = A[right++]  
  while (left <= mid)  
    B[bIdx++] = A[left++] // 剩余部分，如果有的话  
  while (right <= high)  
    B[bIdx++] = A[right++] // 剩余部分，如果有的话  
  for (int k = 0; k < N; ++k)  
    A[low+k] = B[k]; // 复制回去
```
---
### 分治思想
划分步骤很简单：将当前数组分成两半（如果 **N** 是偶数，则将其完全平等，或者如果 **N** 是奇数，则一边多一项），然后递归地对这两半进行排序。  
解决步骤是主要的工作：使用[前面讨论的](https://visualgo.net/zh/sorting?slide=11-2)归并子程序合并两个（排序的）半部分以形成一个有序数组。

```java
method mergeSort(array A, integer low, integer high)  
  // 要排序的数组是 A[low..high]  
  if (low < high) // 基本情况：low >= high (0 或 1 个项目)  
    int mid = (low+high) / 2	  
    mergeSort(a, low  , mid ) // 分成两半  
    mergeSort(a, mid+1, high) // 然后递归排序它们  
    merge(a, low, mid, high) // 征服：合并子程序
```
---
### C代码

```c
void merge(int arr[],int low,int mid,int high){

        int N = high-low+1;

        int *tmp = (int *)malloc(sizeof(int)*N);

        int left = low,right = mid+1,tInx= 0;

        while(left <= mid && right <= high)

        {

            if(arr[left]<=arr[right])

            {

                tmp[tInx++] = arr[left++];

            }else{

                tmp[tInx++] = arr[right++];

            }

        }

        while(left <= mid){

            tmp[tInx++] = arr[left++];

        }

        while( right <= high){

            tmp[tInx++] = arr[right++];

        }

        for(int k=0;k< N;k++){

            arr[low+k] = tmp[k];

        }
        free(tmp);

    }

    void MergeSort(int arr[], int low, int high) {

        if(low < high){

            int mid = (low + high) / 2;

            MergeSort(arr, low, mid);

            MergeSort(arr, mid + 1, high);

            merge(arr, low, mid, high);

        }

    }
```