---
aliases:
  - AtomicIntegerFieldUpdater
  - AtomicLongFieldUpdater
  - AtomicReferenceFieldUpdater
---
- 需求背景：不要更新交换整个对象，只想要更新对象的某一个值
	- 无需将整个对象包装成`AtomicReference`，节省内存
	- 优化现有代码
	- 处理无法修改的第三方类
- 实现原理：基于反射，直接对已存在的volatile字段进行CAS操作
- 适用前提：
	- 要更新的字段必须用 `volatile`关键字修饰
	- 字段不能是 `static`的
	- 字段不能是 `final`的
- 实现类：
	- AtomicIntegerFieldUpdater
	- AtomicLongFieldUpdater
	- AtomicReferenceFieldUpdater
- 适用示例：注意如何创建，以及更新的时候如何指明字段所属的实例
	```
			import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
	
	class Task {
		// 1. 字段必须用volatile修饰
		private volatile String status = "INIT"; 
	
		// 2. 创建更新器（通常声明为static final以提升性能）
		private static final AtomicReferenceFieldUpdater<Task, String> statusUpdater =
				AtomicReferenceFieldUpdater.newUpdater(Task.class, String.class, "status");
	
		public void completeTask() {
			// 3. 使用CAS操作原子性地更新字段
			statusUpdater.compareAndSet(this, "INIT", "DONE");
		}
	
		public String getStatus() {
			return status;
		}
	}
	```