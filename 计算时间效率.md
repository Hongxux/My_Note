常常采用指令运行的次数来表示，这样可以排除电脑和编译器的性能差异。
有以下三种方式表示：
# 渐进分析
## Big Θ，Big O和big Omega
![[Pasted image 20250903092556.png]]

  。

虽然在实际的算法分析和讨论中，​**Big O 最为常见**​（因为人们通常关心最坏情况下的性能保证），但理解三者的区别对于更全面地评估算法至关重要。一个算法是 `O(n^2)` 并不意味着它每一步都需要 `n^2` 时间，只是说在最坏情况下它的增长不会超过 `n^2` 的常数倍。而 `Θ(n^2)` 则意味着该算法运行时间的本质就是平方级的。
### 🔍 深入理解三种符号

#### ⛔ Big O (上限 - 最坏情况)

Big O 表示算法运行时间或资源消耗的**上限**​（Upper Bound），用于描述**最坏情况**下的性能

。它告诉我们算法效率再差也不会差过这个界限。

​**数学定义**​：如果存在正常数 c 和 n0​，使得对所有 n≥n0​，有 0≤f(n)≤c⋅g(n)，则称 f(n)=O(g(n))

。

​**例子**​：若一个算法的时间复杂度是 O(n2)，意味着当输入大小 n 足够大时，其运行时间不会超过 c⋅n2

。

#### 🚀 Big Ω (下限 - 最好情况)

Big Ω 表示算法运行时间或资源消耗的**下限**​（Lower Bound），用于描述**最好情况**下的性能

。它告诉我们算法在最理想的情况下至少能达到这个效率。

​**数学定义**​：如果存在正常数 c 和 n0​，使得对所有 n≥n0​，有 0≤c⋅g(n)≤f(n)，则称 f(n)=Ω(g(n))

。

​**例子**​：若一个算法的时间复杂度是 Ω(n)，意味着即使是在最理想的情况下，其运行时间也至少需要 c⋅n 的时间

。

#### ⚖️ Big Θ (紧确界 - 平均情况)

Big Θ 同时表示算法运行时间或资源消耗的**上界和下界**​（Tight Bound），用于描述**平均情况**或**确切增长阶数**​

。当算法的 Big O 和 Big Ω 相同时，就可以用 Big Θ 来表示其精确的性能分类。

​**数学定义**​：如果存在正常数 c1​, c2​ 和 n0​，使得对所有 n≥n0​，有 0≤c1​⋅g(n)≤f(n)≤c2​⋅g(n)，则称 f(n)=Θ(g(n))

。

​**例子**​：若一个算法的时间复杂度是 Θ(n2)，意味着其运行时间随着输入规模 n 的增长而以平方的速度增长，且其增长趋势被严格限制在 c1​⋅n2 和 c2​⋅n2 之间
    。
- ​**Big O**​ 像是说“**最多需要这么久**”。
- ​**Big Ω**​ 像是说“**至少需要这么久**”。
- ​**Big Θ**​ 像是说“**基本上就需要这么久**”。

### 💎 结论

Big O、Big Ω 和 Big Θ 符号从不同角度描述了算法的效率特征：

- ​**Big O (O)​**​ 关注**最坏情况，但是则仅仅是个上界**，给出性能的上限 ==<= ===
    
    。
- ​**Big Ω (Ω)​**​ 关注**最好情况，但是则仅仅是个下界**，给出性能的下限 ==>===
    
    。
- ​**Big Θ (Θ)​**​ 关注**平均情况**，给出了性能的紧确界限，描述了算法的精确增长阶数。这种描述更加精确，**可以有两种说法，在最佳的情况下， Θ是xxx；在最差的情况下， Θ是xxx，这会比O和Ω 更加准确**
    ![[Screenshot_20250904_111823_tv_danmaku_bilibilihd_HDUnitedBizDetailsActivity.jpg]]
# 平摊分析

> [!NOTE] 平摊分析提出的价值
> 传统的最坏情况分析（例如使用 Big O 表示法）有时会**过于悲观**​。因为它假设每次操作都达到最坏情况，但实际中一系列操作里，代价高的操作不会频繁发生，其成本可以被许多低成本的操作所“平均”或“摊销”。平摊分析通过分析操作序列的整体行为，提供了对算法性能**更准确、更紧确的估计**，避免了传统最坏情况分析可能给出的过于宽松的上界。这对于评估和设计高效的数据结构尤为重要。

