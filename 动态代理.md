
- 需求背景：为了解决**静态代理**的固有缺陷，减少代理类的数量。解决代码复用的问题![[Pasted image 20251107141454.png]]
	- -**静态代理**：有多少个需要被代理的类，就需要手动编写多少个代理类。这会导致**类数量爆炸**，且每个代理类中的增强逻辑（如日志、事务）都是重复的，违反了**DRY（Don't Repeat Yourself）原则**，难以维护。
	    
	- **动态代理**：只需要编写一个**通用的代理处理逻辑**（例如，一个 `InvocationHandler`）。这个通用逻辑可以应对所有需要代理的接口。在运行时，根据接口信息动态生成代理类。**极大减少了代码量，实现了代码复用**。
	    
- 含义：在程序运行阶段，在内存中动态生成代理类，被称为动态代理。

	1. **时机**：发生在**程序运行时**，而非编译期。
	    
	2. **地点**：在 **JVM 内存**中动态生成类的字节码，而不是在源代码中预先定义好。
	    
- 作用：它允许我们在应用程序运行期间，“凭空”创建一个实现了特定接口的代理类，而无需程序员手动编写这个类的.java源码文件并编译它。
- 实现方式：

| 技术                 | 核心特点          | 工作原理                                                 | 适用场景                                       |
| ------------------ | ------------- | ---------------------------------------------------- | ------------------------------------------ |
| **[[JDK 动态代理]]**   | **只能代理接口**    | 在运行时，使用 `Proxy`和 `InvocationHandler`创建实现指定接口的代理类。    | 被代理的类已经实现了接口。这是 Java 标准库自带的功能。             |
| **[[CGLIB 动态代理]]** | **可代理普通类**    | 通过**继承**目标类，生成其子类作为代理类。底层使用 **ASM**字节码库直接操作字节码，性能较高。 | 代理没有实现接口的普通类。**Spring框架默认优先使用它**。          |
| **Javassist**      | **强大的字节码工具库** | 提供了更直观的 API 来动态修改和创建字节码。                             | 不仅用于代理，还可用于任何需要动态生成或修改类的复杂场景，如热部署、AOP框架实现。 |
**Spring框架中的选择**：

- 如果目标类实现了接口，Spring 默认使用 **JDK 动态代理**。
    
- 如果目标类没有实现接口，Spring 默认使用 **CGLIB**生成代理。
    
- 开发者可以配置强制 Spring 对所有情况都使用 CGLIB。
