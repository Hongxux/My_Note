

### ​**一、LFS 的目录结构设计**​

#### ​**1. 目录的本质**​

- ​**与传统 UNIX 相同**​：目录是 `(文件名, inode号)`的集合（如 `("foo", 123)`）。
    
- ​**示例**​：目录 `/home/remzi`包含条目 `("foo", k)`，表示文件 `foo`的 inode 号为 `k`。
    

#### ​**2. 目录的写入方式**​

- ​**永不原地更新**​：目录更新（如创建文件）会触发 ​**顺序追加写入**​：
    
    1. 写入文件数据块（如 `D[k]`在地址 `A0`）。
        
    2. 写入文件的新 inode（如 `I[k]`在地址 `A1`）。
        
    3. 写入目录数据块（如 `D[dir]`在地址 `A2`，包含条目 `("foo", k)`）。
        
    4. 写入目录的新 inode（如 `I[dir]`在地址 `A3`）。
        
    5. 写入 ​**imap 片段**​（在地址 `A4`，更新 `k`和 `dir`的 inode 位置）。
        
    

```
磁盘布局示例：
A0: 文件数据块 D[k]
A1: 文件 inode I[k]   → 指向 A0
A2: 目录数据块 D[dir] → 包含 ("foo", k)
A3: 目录 inode I[dir] → 指向 A2
A4: imap 片段        → 记录 [k→A1, dir→A3]
```

---

### ​**二、目录访问流程（以读取 `/home/remzi/foo`为例）​**​
![[Pasted image 20251013101247.png]]
1. ​**解析路径**​：
    
    - 拆分路径为：`home`→ `remzi`→ `foo`（此处简化以单级目录为例）。
        
    
2. ​**定位根目录**​：
    
    - 从 ​**检查点区域 (CR)​**​ 获取最新 imap 地址。
        
    - 读取 imap，找到根目录 inode 地址（假设为 `addr_root`）。
        
    
3. ​**逐级查找目录**​：
    
    - ​**读取目录 `dir`**​：
        
        - 通过 imap 找到 `dir`的 inode 地址（如 `A3`）。
            
        - 读取 `I[dir]`→ 获取目录数据块地址（如 `A2`）。
            
        - 读取 `D[dir]`→ 找到条目 `("foo", k)`。
            
        
    
4. ​**定位目标文件**​：
    
    - 通过 imap 找到 inode `k`的地址（如 `A1`）。
        
    - 读取 `I[k]`→ 获取文件数据块地址（如 `A0`）。
        
    - 读取 `D[k]`获取文件内容。
        
    

> ​**关键点**​：路径解析需 ​**逐级查询目录数据块**，每一步依赖 imap 定位 inode。

---

### ​**三、递归更新问题（Recursive Update Problem）​**​

#### ​**1. 问题根源**​
​**由单个文件更新触发的连锁元数据更新反应**，导致小修改可能引发大规模写入。
- ​**写时复制特性**​：任何更新（包括 inode）会改变其磁盘位置。
    
- ​**连锁反应风险**​：
    
    - 若文件 `foo`的 inode 位置改变（如从 `A1`→ `A5`）。
        
    - 则其父目录 `dir`的数据块需更新（原条目 `("foo", k)`需改为 `("foo", k)`+ 新地址）。
        
    - 目录 `dir`的 inode 位置因此改变（如从 `A3`→ `A6`）。
        
    - 进而需更新 `dir`的父目录，形成递归直到根目录。
        
    

#### ​**2. LFS 的解决方案：imap 间接层**​

- ​**目录只存储 inode 号**​：
    
    目录条目始终为 `("foo", k)`，​**不存储 inode 的物理地址**。
    
- ​**imap 解耦物理位置**​：
    
    - inode 位置变化时，​**只需更新 imap**​（如 `k→A1`改为 `k→A5`）。
        
    - 目录内容无需修改，因为其仅依赖 inode 号 `k`。
        
    
- ​**递归被阻断**​：
    
    https://i.imgur.com/R5kDcJg.png
    

---

### ​**四、设计优势与代价**​

|​**优势**​|​**代价**​|
|---|---|
|​**避免递归更新**​：imap 作为“缓冲层”隔离物理位置变化|​**额外 I/O**​：目录访问需多次查询 imap|
|​**路径解析与写入解耦**​：目录更新频率显著降低|​**内存依赖**​：需缓存 imap 以加速查询|
|​**崩溃一致性简化**​：目录无需因子文件更新而重写|​**空间开销**​：imap 需占用额外磁盘空间|

---

### ​**关键总结**​

1. ​**目录即映射表**​：LFS 目录存储 `(name, inode_number)`，而非物理地址。
    
2. ​**imap 的核心作用**​：
    
    - 将 ​**inode 号**映射到 ​**物理地址**。
        
    - 阻断递归更新链，使文件/目录可独立更新。
        
    
3. ​**路径解析流程**​：
    
    `路径名 → imap → 目录 inode → 目录数据 → imap → 文件 inode → 文件数据`
    
    （需 2 次 imap 查询 + 2 次 inode 读取 + 1 次数据读取）
    

通过 ​**imap 间接层**，LFS 在保持纯追加写入的同时，解决了目录更新的递归问题，为写时复制文件系统提供了核心设计范式。