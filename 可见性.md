### 概念
- **定义**​：一个线程对共享变量的修改，另一个线程不一定能**立即看到**，甚至可能永远看不到。
	- 根本原因：在Java内存模型中，每个线程都有自己的**工作内存**，对变量的操作可能不会立即同步到**主内存**中。
    
- ​**问题**​：防止由于CPU缓存导致的**内存一致性错误**，出现失效数据。
    
- ​**例子**​：线程A修改了变量，但修改还停留在CPU缓存中，线程B从主内存读取到的还是旧值。
    
```
public class VisibilityProblem {
    private boolean flag = false; // 没有volatile，可能出现可见性问题
    
    public void writer() {
        flag = true; // 线程A执行
    }
    
    public void reader() {
        while (!flag) { // 线程B可能永远看不到flag变为true
            // 循环
        }
    }
}

// 使用volatile解决可见性
public class VisibilitySolution {
    private volatile boolean flag = false; // 保证可见性
}
```
---
### 解决方法
#### 1. 加锁
**重要规则**：synchronized 不仅保证原子性，也保证了可见性。线程在释放锁前，对共享变量的修改会强制刷新到主内存；线程在获取锁后，会清空本地缓存，从主内存重新加载变量。
#### 2.**Volatile变量**
