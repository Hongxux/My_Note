- 需求背景：explain发现Using filesort
- 问题分析：Using filesort
	- ​**触发条件**​：当查询的排序条件无法直接通过索引满足时（例如，没有索引或索引顺序不匹配）。
	- ​**工作原理**​：MySQL 需要执行以下步骤：
	    1. 扫描表数据（全表扫描或索引扫描）找到满足条件的行。
	    2. 将这些行加载到内存的**排序缓冲区（sort buffer）​**中。
	    3. 在内存中对数据进行排序（如果数据量太大，可能涉及磁盘临时文件）。
	- ​**性能问题**​：这是一个 CPU 和内存密集型操作，尤其对于大数据集性能很差。
- 优化目标：`Using index`（高效排序）
	- ​**触发条件**​：当查询的排序条件与索引的顺序完全匹配时（例如，索引是 `(age, phone)`，查询按 `age, phone`排序）。
	- ​**工作原理**​：MySQL 可以直接按索引的顺序扫描数据，无需额外排序。
	- ​**优势**​：数据返回时已经有序，效率极高。
- 优化方式：
	1. 要创建索引，且要指定索引中字段的排序顺序
	```sql
		CREATE INDEX idx_user_age_pho_ad ON tb_user(age ASC, phone DESC);
	```
	2. order by要符合最左前缀原则，而且排序方式要与索引的创建保持一致
	3. 使用覆盖索引，避免回表
- 兜底方案：如果不可避免使用`Using filesort`，则可以增加排序缓冲区大小sort_buffer_size
