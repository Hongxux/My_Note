- 需求背景：
	- 【公共变量的必要性】在方法调用链中层层传递公共参数（如用户信息），代码冗余
		- 因此这类变量会被设置为成员变量或者静态变量
		- 但是这将变量暴露出来了，带来了并发安全问题
	- 【公共变量带来的问题】多线程并发修改共享变量，尝试解决：
		- 加锁
			- 会导致性能下降
		- 每次调用的时候创建新对象
			- 解决了并发安全
			- 频繁创建和销毁对象会带来巨大的性能开销

- 解决措施：ThreadLocal ![[Pasted image 20251203221525.png]]
	- 每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用，其他线程不可访问
		- 【满足使用的需求】作为Thread的全局变量，作为公共参数
		- 【满足使用的安全】不在线程中共享，从根源解决了并发问题

- 实现线程隔离的基础：![[Pasted image 20251203223903.png]]
	- Map(ThreadLocalMap)作为Thread的属性
		- ThreadLocalMap是Thread的内部类，Entry是ThreadLocalMap的内部类![[Pasted image 20251203224736.png]]
		- 每个Thread都有自己的Map
			- 线程之间相互隔离，不共享，不存在并发问题
			- Thread和Map的生命周期一样
				- Thread销毁的时候，Map也会随之销毁，减少内存的使用
				- 早先的设计：Thread销毁了，Entry并不会减少、
		-  【ThreadLocalMap的结构】
			- INITIAL_CAPACITY：初始容量
				- 默认是16
			- table：存放Entry数据的数据
			- size：表使用量
				- Entry数组中存放Entry的个数
			- threshold：进行扩容的阈值
				- 表使用量（size）大于扩容阈值（threshold）的时候进行扩容
				- 默认为0
			- 解决哈希冲突的方式：开放寻址发（线性）
		-  【Entry的结构】
			- key：ThreadLocal对象(key)
				- 是弱引用
					- 设计目的：在忘记手动回收的情况，比强引用多一层保险
						- 【多一层保险】：key和value最终都会变成null，即对应内存被回收
						- 实现原理：
							- 将ThreadLocal对象的生命周期和线程的生命周期解绑
								- ThreadLocal在当前线程中使用完后会被回收，对应Enrty的key为null
							- ThreadLocalMap中的set/getEntry方法中，会对key为null进行判断
								- 如果为null的话，那么是会对value置为null的。
									- 即回收了value
					- [[弱引用不是导致内存泄露的原因]]：

				- 好处：为什么不以Thread为变量
					- 这样使得Entry数量变少，尽量避免哈希冲突
						- Thread的数量远远多余ThreadLocal的数量
			- value：线程的变量副本(value)
				- 我们实际使用后的公共数据
		- 【谁来维护这个Map】ThreadLocal
			- 【维护的范围】获取和设置线程的变量值。
- 核心方法的实现
	- set方法
- 问题：内存泄露![[Pasted image 20251203232104.png]]
	- 含义：线程内ThreadLocal不用了，无用的Entry一直存在内存中
	- 根本原因：
		- ThreadLocalMap和ThreadLocal的生命周期一样长
	- 直接原因：
		- 没有手动删除Enrty（remove）
		- 或者当前线程还在运行
