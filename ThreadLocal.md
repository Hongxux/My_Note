- 需求背景：
	- 【公共变量的必要性】在方法调用链中层层传递公共参数（如用户信息），代码冗余
		- 因此这类变量会被设置为成员变量或者静态变量
		- 但是这将变量暴露出来了，带来了并发安全问题
	- 【公共变量带来的问题】多线程并发修改共享变量，尝试解决：
		- 加锁
			- 会导致性能下降
		- 每次调用的时候创建新对象
			- 解决了并发安全
			- 频繁创建和销毁对象会带来巨大的性能开销

- 解决措施：ThreadLocal ![[Pasted image 20251203221525.png]]
	- 每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用，其他线程不可访问
		- 【满足使用的需求】作为Thread的全局变量，作为公共参数
		- 【满足使用的安全】不在线程中共享，从根源解决了并发问题

- 实现线程隔离的基础：![[Pasted image 20251203223903.png]]
	- Map(ThreadLocalMap)作为Thread的属性
		- ThreadLocalMap是Thread的内部类，Entry是ThreadLocalMap的内部类![[Pasted image 20251203224736.png]]
		- 每个Thread都有自己的Map
			- 线程之间相互隔离，不共享，不存在并发问题
			- Thread和Map的生命周期一样
				- Thread销毁的时候，Map也会随之销毁，减少内存的使用
				- 早先的设计：Thread销毁了，Entry并不会减少、
		-  【ThreadLocalMap的结构】
			- INITIAL_CAPACITY：初始容量
				- 默认是16
			- table：存放Entry数据的数据
			- size：表使用量
				- Entry数组中存放Entry的个数
			- threshold：进行扩容的阈值
				- 表使用量（size）大于扩容阈值（threshold）的时候进行扩容
				- 默认为0
			- 解决哈希冲突的方式：开放寻址发（线性）
			- 哈希扩容的方式：
				- 触发条件：当 `ThreadLocalMap`中存储的 `Entry`数量达到阈值（`threshold`，初始为 `len * 2/3`）时，会尝试扩容
				- 扩容过程
					1. 先执行一次**全量探测式清理**:清理所有 `key`为 `null`的过期 `Entry`
					2. 清理后如果 `size`仍然 >= `threshold * 3/4`，才会真正执行扩容
						- 创建一个新的 `Entry`数组（大小为原来的 2 倍），并重新哈希所有有效的 `Entry`
		-  【Entry的结构】
			- key：ThreadLocal对象(key)
				- 是弱引用
					- 设计目的：在忘记手动回收的情况，比强引用多一层保险
						- 【多一层保险】：key和value最终都会变成null，即对应内存被回收
						- 实现原理：
							- 将ThreadLocal对象的生命周期和线程的生命周期解绑
								- ThreadLocal在当前线程中使用完后会被回收，对应Enrty的key为null
							- ThreadLocalMap中的set/getEntry方法中，会对key为null进行判断
								- 如果为null的话，那么是会对value置为null的。
									- 即回收了value
					- [[弱引用不是导致内存泄露的原因]]：

				- 好处：为什么不以Thread为变量
					- 这样使得Entry数量变少，尽量避免哈希冲突
						- Thread的数量远远多余ThreadLocal的数量
			- value：线程的变量副本(value)
				- 我们实际使用后的公共数据
		- 【谁来维护这个Map】ThreadLocal
			- 【维护的范围】获取和设置线程的变量值。
- 核心方法的实现
	- set方法
- 问题：
	- 内存泄露![[Pasted image 20251203232104.png]]
		- 含义：线程内ThreadLocal不用了，无用的Entry一直存在内存中
		- 根本原因：
			- ThreadLocalMap和ThreadLocal的生命周期一样长
		- 直接原因：
			- 没有手动删除Enrty（remove）
			- 或者当前线程还在运行
		- 解决措施：使用完 `ThreadLocal`后，在finaly块中必须调用 `remove()`方法，将当前线程的 `ThreadLocalMap`中对应的 `Entry`删除
	- 在异步或线程池环境中父线程中的 `ThreadLocal`数据无法自动传递给线程池中复用的工作线程
		- 原因：线程池中的线程是预先创建好的，与提交任务的父线程并非父子关系
		- 解决措施：
			- **手动传递**：在提交任务到线程池时，手动将父线程的上下文信息作为参数传递给 `Runnable`或 `Callable`任务
			- **使用 `InheritableThreadLocal`**：仅限于真正的父子线程（通过 `new Thread()`创建）场景，对线程池无效
