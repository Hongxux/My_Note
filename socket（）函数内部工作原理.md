## 一、`socket()`的作用
1. ​**功能**​：`socket()`向操作系统内核申请创建一个新的**通信端点**​（Endpoint）。
    
2. ​**返回值**​：
    
    - 成功时：返回一个**套接字描述符**​（Socket Descriptor），这是一个**非负整数**​（通常 ≥ 3，因为 0、1、2 已被标准输入、输出、错误占用）。
        
    - 失败时：返回 `-1`，并设置 `errno`指示具体错误。
        
    
3. ​**本质**​：该描述符是进程访问内核中**套接字结构体**的句柄（Handle）。后续所有针对该套接字的操作（如 `bind()`, `connect()`, `send()`, `recv()`, `close()`）都通过此描述符进行。

## 二、socket（）的内部过程

---

### 1. 分配内存空间：创建套接字的“容器”

- ​**动作**​：当应用程序（如浏览器）调用`socket`函数请求创建套接字时，协议栈首先会向操作系统的**内存管理模块**申请一块内存空间。这块空间的大小足以存放一个套接字所需的全部控制信息。
    
- ​**比喻**​：这就像是协议栈向操作系统“要”了一个空盒子（内存空间），准备往里面放东西。
    

### 2. 初始化控制信息：填写套接字的“档案”

- ​**动作**​：协议栈在这块新申请的内存空间中，写入一系列表示初始状态的控制信息。由于套接字是刚创建的，所以此时里面还没有任何具体的通信数据。
    
    - 通信状态会被设置为“未连接”（`未初始化`）。
        
    - 接收和发送缓冲区等资源会被清空或设为初始值。
        
    
- ​**比喻**​：协议栈在这个空盒子里放了一张表格（控制信息块），并在“状态”一栏填上“未使用”，其他很多栏目（如对方IP、端口号等）则暂时为空。
    

### 3. 生成描述符：给套接字一个“号码牌”

- ​**动作**​：协议栈完成套接字的创建和初始化后，会生成一个名为**描述符**的标识符，并将其返回给应用程序。
    
- ​**为什么需要描述符**​：一台计算机上可能同时存在多个套接字（例如，浏览器可能同时打开多个标签页与不同服务器通信）。应用程序（如浏览器）和协议栈都需要一种方法来区分和管理这些套接字。​**描述符**就是这个用于在应用程序内部识别不同套接字的“号码牌”。
    
- ​**比喻**​：协议栈把创建好的盒子（套接字）放进一个有很多格子的柜子里，然后给你一个**存包牌（描述符）​**。之后你只需要出示这个牌子，协议栈就知道你要操作的是哪个盒子，而不需要你知道盒子的具体内存地址。
    

---

### 总结与核心要点

|步骤|角色|动作|产出|比喻|
|---|---|---|---|---|
|​**1. 申请空间**​|协议栈|向操作系统申请内存|一块空的内存区域|要一个空盒子|
|​**2. 初始化信息**​|协议栈|写入初始控制信息|一个初始化的套接字实体|在盒子里放一张空表格|
|​**3. 返回标识**​|协议栈|生成并返回一个数字|套接字描述符|给你一个存包牌|

- ​**套接字的本质**​：正如书中所强调的，​**套接字并不是一个实实在在的物体，而是协议栈中一块记录了通信控制信息的内存空间**。这些信息包括但不限于：
    
    - 通信状态（如“未连接”、“连接建立中”、“已连接”）
        
    - 通信对象的IP地址和端口号（连接后填入）
        
    - 应用程序的端口号
        
    - 用于临时存放收发数据的**缓冲区**的内存地址
        
    
- ​**描述符的作用**​：它是一个应用程序级别的标识符，​**仅在应用程序和协议栈之间的本次交互中有效**。应用程序在后续调用`connect`, `write`, `read`, `close`等函数时，必须提供这个描述符，以便协议栈知道它应该操作哪个套接字。
    **关键点**​：描述符是应用程序级别的标识符，仅在应用程序和协议栈之间的本次交互中有效。应用程序在后续调用`connect`、`write`、`read`、`close`等函数时，必须提供这个描述符。


​**因此，调用`socket`函数并没有开始任何网络通信，它仅仅是在协议栈内部为未来的通信准备好了“档案”和“资源”，并给了应用程序一个用于后续操作的“句柄”。​**​ **真正的网络连接（如TCP三次握手）是在调用`connect`函数时才开始的。**
## 三、使用注意
1. ​**此时尚无网络地址**​：
    
    - `socket()`仅创建通信端点，尚未绑定 IP 或端口。
        
    - 后续需调用 `bind()`指定本地地址（服务器）或由内核自动分配（客户端）。
        
    
2. ​**协议未激活**​：
    
    - TCP 套接字需通过 `connect()`（客户端）或 `listen()`（服务器）激活协议状态机。
        
    - UDP 套接字创建后即可直接收发数据报。
        
    
3. ​**资源占用**​：
    
    - 每个套接字消耗内核内存（约 KB 级）和一个文件描述符。
        
    - 未关闭的套接字会导致资源泄漏（用 `close()`或 `shutdown()`释放）。