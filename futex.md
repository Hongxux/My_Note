- 需求背景：低性能的同步机制，在高并发情况下不够用
	- 纯用户态同步机制（spinlock）
		- 行为：自旋CAS获取锁
		- 【自旋】目的：在锁争用非常小、持有锁时间极短的场景下
			- 避免了一次系统调用的开销，速度很快
		- 【自旋】问题：在锁争用激烈或锁持有时间稍长时
			- 大量 CPU 时间会浪费在无意义的循环检查上
	- 内核态同步机制（ 信号量）
		- 行为：任何对锁的操作，都要陷入内核
			- 由内核来管理等待队列和进行线程调度
		- 优点：锁竞争大的时候，避免CPU空转
		- 缺点：陷入内核开销大
- 解决方案：futex
	- 实现基础：用户态中存放一个共享的整型变量
		- 为0，表示锁空闲
		- 为1，表示锁被占用
	- 实现思想：无竞争走用户态快速路径，有竞争才走内核态慢速路径
		- 第一阶段：快速路径（用户态）
			- 设计思想：在锁竞争小的情况下，不陷入内核态
			- 行为：获取锁的时候，首先尝试 cas修改futex
			- 优点：速度极快
				- 整个过程都在用户态完成，完全没有触发系统调用
		- 第二阶段 慢速路径
			- 设计思想：发现竞争的时候，不自旋，进入陷入内核态
			- 行为：发现锁被占用执行 `FUTEX_WAIT`，陷入内核
- 使用方式：
	1. ​**等待方（Waiter）​**​：线程 A 调用 `FUTEX_WAIT`前，会再次检查用户态的 futex 值。如果值已改变（条件已满足），则立即返回，避免不必要的系统调用。否则，它将线程状态和 futex 地址告知内核，然后休眠。
	2. ​**通知方（Waker）​**​：线程 B 修改 futex 值后，调用 `FUTEX_WAKE`。内核根据 futex 地址找到等待队列，将指定数量的线程状态设为可运行，并放入运行队列。
	3. ​**协作关键**​：`FUTEX_WAIT`在陷入内核前检查用户态值，与 `FUTEX_WAKE`修改用户态值，这两个操作通过内存屏障等机制保证顺序，防止唤醒丢失。
