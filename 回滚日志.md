---
aliases:
  - Undo Log
---
- 需求背景和核心目标：
	- 事务回滚需求：保证事务的原子性
		- 时机：当事务执行过程中发生错误或需要回滚时
		- 标准：将数据恢复到事务开始前的状态
	-  为 MVCC 提供数据的历史版本：（间接）保证事务的隔离性
		- 支持不同的事务隔离级别（如读已提交、可重复读）
---
- 实现事务回滚
	- 核心原理： 记录数据被修改前的状态（足以恢复该原始版本的信息）
	- 实现机制：
		- **对于 `INSERT` 操作**：记录insert undo logs
			- 内容：这条新纪录的主键（或者唯一能够定位到这条记录的信息）
			- 回滚方式：根据这个主键找到并删除该记录
		- **对于 `DELETE` 操作**
			- 内容：记录下被删除记录的 全部原始内容
			- 回滚方式：重新构建出这条记录并插入（或取消标记删除）
		- **对于 `UPDATE` 操作**
			- 内容：记录下被修改记录的 **主键** 和 **被修改字段的旧值**
			- 回滚方式：数据库根据主键找到记录，并使用Undo Log中保存的旧值覆盖当前的新值
- 支持多版本并发控制
	- 实现基础：[[undo log的版本链]]
	- 实现机制：当一个事务修改一行数据时，InnoDB并不会直接覆盖旧的数据，而是会：
		1. 将旧版本的数据（或其逆向操作）记录到Undo Log中。
		2. 在当前的数据行上应用新的修改。
		3. 通过一个特殊的指针，将当前的数据行与刚才写入的Undo Log记录关联起来。

---
回滚日志在数据库中的物理和逻辑实现
- 存储层次结构大致为：**表空间（Tablespace） -> 段（Segment） -> 区（Extent） -> 页（Page）**
	- 一个事务产生的Undo Log记录，会被写入其分配到的回滚段的某个Slot中的Undo页（Page）上
- 表空间
	- 位置演进：
		- MySQL 5.6及之前：回滚日志存储在**系统表空间**（ibdata1文件）中。
		- MySQL 5.7+：支持**独立的回滚表空间**
			- 设置rollback segment文件所在的路径：`innodb_undo_directory`
			- 设置回滚段的个数：`innodb_undo_logs:`
			- 设置构成rollback segment文件的数量：`innodb_undo_tablespaces:`
- 回滚段
	- 引入多个回滚段的目的：减少高并发下多事务争抢同一个回滚段写入的锁竞争
	- 回滚段分配：InnoDB中，默认有128个回滚段
		- 第0个分配给系统表空间
		- 第1-32个分配给临时表空间（用于临时表的事务）
		- 剩下的96个（33-127）则分配给用户事务使用的Undo表空间
	- 职责：负责管理一组Undo Log
	- 实现方式：当事务需要写入Undo Log时，会通过一种轮询（Round-Robin）的方式，从可用的回滚段中分配一个
- 回滚槽
	- 数量：每个回滚段内部包含1024个 **回滚槽**
	- 存储粒度：每个Slot可以存储一个事务的Undo Log版本链
-  Undo Log 记录的格式
	- 记录头部：包含一些元信息
	- 主键信息
	- 旧的事务ID和回滚指针
	- 旧值载荷：只记录了变更的部分

---

**回滚日志的生命周期管理**
1.  创建与分配
	- 触发时机：事务首次执行数据修改操作
	- 工作机制：
		1. **事务启动：** 当一个事务`BEGIN`时，它仅仅是启动了，并不会立即分配Undo Log资源。
		2. **首次修改：** 当该事务第一次尝试修改数据时，InnoDB会为在选定的回滚段中申请一个可用的回滚槽 。
		3. **写入记录：** 在实际修改数据页上的行记录之前
			1. InnoDB会先构造一条Undo Log记录（包含旧值等信息）
			2. 并将其写入分配到的回滚段的某个Undo页中
			3. 数据行上的`DB_ROLL_PTR`会指向这条新创建的Undo Log记录
2.  事务执行期间的使用
	- 重复执行：写入Undo Log -> 修改数据页
	- 产出结果：形成一个属于该事务的Undo Log链
3. 事务提交后的状态
	- 这些Undo Log记录并不会被立即删除
		- 原因：
			- 系统中可能还存在其他更早启动的、且尚未提交的事务。
			- 根据MVCC的可见性规则，这些“老”事务在读取数据时，可能需要看到本次已提交事务所修改之前的数据版本
			- 而这些旧版本，正存储在刚刚提交的事务的Undo Log中。
	- 这些记录会被放入一个特殊的链表，称为 历史链表（History List）
4. 清理与回收
	- 执行责任方： Purge线程
	- 回收机制：用协调线程（Coordinator）加工作线程（Worker）​ 的协同模式
		- 协调线程负责从History List中扫描已提交事务的Undo Log
		- 将清理任务分发给多个工作线程并行处理
	- 清理决策机制：
		1. **确定最早的Read View：
		2. **可见性判断：** 所有事务ID大于等于此ReadView的`low_limit_no`的Undo Log都不能被清理
			- 原因：它们可能仍被这个最老的事务所引用
	- Undo页的重用机制
		- 重用的前提：Undo页的使用空间低于3/4
		- 重用的实现机制：后续事务的Undo Log记录可以追加写入到此页的剩余空间中
		- 目的：避免了为每个短事务都分配和初始化新页的开销，提升了空间利用率和性能
	-  **不同类型 Undo Log**回收机制不同
		- **`INSERT`操作产生的Undo Log：** 在其所属事务提交后，**可以被立即标记为可清理**，无需等待Purge线程的复杂判断
		- **`UPDATE`和`DELETE`操作产生的Undo Log：** 必须遵循上述进入历史链表，等待Purge线程根据最老Read View来判断和清理的完整流程。