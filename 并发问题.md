
常见的并发问题通常被划分为两大类：​**死锁（Deadlock）​**​ 和 ​**非死锁并发错误（Non-Deadlock Concurrency Bugs）​**。在非死锁错误中，​**原子性违反（Atomicity Violation）​**​ 和 ​**顺序违反（Order Violation）​**​ 是最为普遍的类型。

## ​非死锁（Non-Deadlock）
### 原子性违反（Atomicity Violation）

^7b6c6e

#### 形成原因：
 - 程序员错误地假设一组对共享数据的访问（例如，检查 `proc_info`的状态然后基于该状态执行操作）会作为一个不可中断的原子单元执行。然而，在并发环境下，其他线程可能在检查和使用之间修改了共享数据（如 `proc_info`），导致程序行为不符合预期。”
#### 解决方案：
 - 使用**互斥锁（Mutex）​**​ 将涉及共享数据（如 `proc_info`）的**临界区（Critical Section）​**​ 保护起来。这确保了在任何时刻，只有一个线程能够访问或修改该共享数据，从而保证了该段代码逻辑的原子性。

### ​顺序违反（Order Violation）
#### 形成原因：
- 一个线程（线程A）的执行逻辑依赖于另一个线程（线程B）已经执行了某个特定操作（例如，初始化一个数据结构、设置一个标志位）。然而，由于线程调度的不确定性，线程B的操作可能尚未执行，导致线程A在错误的时机访问了未准备好或无效的状态。
#### 解决方案：
 - 使用**同步原语（Synchronization Primitives）​**​ 来强制保证操作执行的顺序。常用的方法包括：

	- ​**条件变量（Condition Variables）​**​：允许线程在某个条件不满足时等待，并在条件可能满足时被唤醒。
    
	- ​**信号量（Semaphores）​**​：特别是初始值为0的信号量（`sem_init(&sem, 0, 0)`），可用于表示“事件”是否已发生。依赖该事件的线程在 `sem_wait`上阻塞，直到提供事件的线程调用 `sem_post`。
    
	- ​**屏障（Barriers）​**​：用于确保一组线程都到达某个点后才继续执行。
### 虚假唤醒
### 唤醒丢失

## 死锁
[[死锁问题]]