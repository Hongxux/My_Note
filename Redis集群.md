Redis集群的核心思想非常巧妙，它通过**去中心化**的架构和**分而治之**的策略，将多个Redis实例组织成一个统一的、可扩展的、高可用的数据库服务。其设计目标直指单机Redis的痛点：
- **突破内存容量限制**和**提升写并发能力**，
	-  Redis所有数据都存放在内存中，单机的物理内存有限。
	-  即使挂载再多从节点，存储上限仍然受限于主节点的容量。
- **获得高可用性**
	- 如果单机Redis宕机，依赖该Redis的服务将完全不可用。
	- 即便配置了主从复制，如果主节点宕机，人工切换从节点成本很高。
### 核心架构：**多主多从**的去中心化架构
- 每个主节点**负责一部分数据**
- 每个主节点可以挂载若干**从节点**用于高可用。
  
**好处：**
- **分摊压力**：每个主节点负责一部分哈希槽，处理对应数据的读写请求。这样，写压力和存储压力就被分摊到了多个主节点上，实现了水平的写扩展
- **主从复制**：每个主节点都可以配置一个或多个从节点。从节点通过异步复制保持与主节点的数据同步，主要提供**数据冗余**和**故障恢复**的能力。
- **故障转移**：当某个主节点宕机时，集群会通过内置的共识算法，自动从其从节点中选举出一个新的主节点来接管槽位，继续提供服务，从而实现高可用
- **容易扩容**：当数据量增加时，只需要新加节点D，重新分配部分哈希槽，集群即可扩容。
### 数据切分的思想：哈希槽
Redis集群的核心思想是**数据切分**。数据太多，单机放不下，我们就把它拆开存。

#### 3.1 取模分片（不推荐）
最直观的做法是：

```
节点编号 = hash(key) % Redis节点总数
```
Redis总节点数 = 3
user1001 的 hash 值 = 5
5 % 3 = 2 → 存在节点2。

**问题**：
- **扩容后数据迁移代价高：** 如果后续增加或删除Redis节点，节点总数改变，所有Key的取模结果都会变，几乎所有数据都需要重新迁移，代价很高。

#### 3.2 哈希槽机制（推荐）
Redis集群引入了哈希槽（Hash Slot），本质上是在Key和节点之间增加了一层固定映射表。

集群中总共有16384个哈希槽（0 ~ 16383）。

每个Key通过CRC16算法计算出一个哈希值：

```
slot = CRC16(key) % 16384
```

每个Redis节点负责一部分哈希槽：

节点A → 0 ~ 5460
节点B → 5461 ~ 10922
节点C → 10923 ~ 16383
**优点：**
- 哈希槽数量固定不变，Key到槽的映射关系稳定。
- 新增或删除Redis节点时，只需要重新分配少量槽的数据即可，无需全量迁移。
