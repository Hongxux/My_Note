
### 线程安全性的定义
**线程安全性**​ 指的是：当多个线程同时访问某个类、对象或方法时，这个类、对象或方法总能表现出**正确的行为**，而不需要调用端做任何额外的同步或协调。
所谓“正确的行为”，是指：
- 程序运行的结果与单线程环境下的结果一致。
- 不会出现数据损坏、数据丢失等异常情况。




---
### 实现线程安全性
**核心思想**： **管理对共享、可变状态的访问**，
- 针对的对象：共享、可变状态
**正确观念**：程序状态的**封装性**越好，就**越容易实现程序的线程安全性**，并且代码的维护人员也越容易保持这种方式
**实现线程安全性通常需要同时考虑原子性和可见性，以及有序性**
#### 三大支柱
##### 原子性

##### [[可见性]]

##### [[有序性]]

#### 解决方案

| 技术手段                            | 到底保了什么                                            | 一句话记忆           |
| ------------------------------- | ------------------------------------------------- | --------------- |
| **线程封闭**的 栈封闭 和[[ThreadLocal]]类 | 可见性、原子性、有序性**全部搞定** ——因为**不共享**                   | “不出门，啥新闻都不需要”   |
| **不变性**                         | 可见性**自动 OK**（可安全发布），原子性**无需考虑**（只读）               | “只读文件随便发”       |
| **volatile**                    | 仅**可见性 + 有序性**；**不保证原子性**                         | “广播最新值，但不负责算账”  |
| **AtomicXXX**                   | 利用 **CAS** 保证**原子性**；**可见性**靠 `volatile` 内部字段顺带解决 | “算账用 CAS，广播顺手做” |
| **synchronized**                | **三性全包**：原子性 + 可见性（解锁前强制刷缓存） + 有序性（同步块串行）         | “大包大揽，性能换安全”    |
##### 线程封闭
​**核心思想**​：​**最好的同步就是避免同步**。如果数据不共享，自然就不需要同步。线程封闭技术将数据访问限制在**同一个线程**内。
    程序员需要负责确保封闭在线程中的对象不会从线程中逸出
##### [[不变性]]
**核心思想**​：​**不可变对象一定是线程安全的**。因为它的状态在创建后就不能被修改，所以不存在并发修改的问题。

##### 对象[[安全发布]]
#### 安全性检测

拿到任何一段并发代码，按顺序问：

1. **对象有没有可能被多条线程同时看见？**  
    ❌ 否 → **线程封闭**（如 ThreadLocal、栈变量）→ **安全结束**。
    
2. **看见后会不会被修改？**  
    ❌ 否 → **不变性**（final、不可变容器）→ **安全结束**。
    
3. **修改操作是单一动作吗？**（如简单赋值、替换引用）  
    ✔ 是 → **volatile** 就够 → **安全结束**。
    
4. **复合操作？**（先读后写、检查再执行）  
    ✔ 是 → **AtomicXXX**（无锁 CAS）或 **synchronized**（悲观锁）→ 二选一。
