
---

### ​**一、通配符的产生背景**​

1. ​**泛型体系的缺陷**​
    
    泛型类型在定义时具有**不变性（invariance）​**，即 `Pair<Manager>`与 `Pair<Employee>`无继承关系，即使 `Manager`是 `Employee`的子类。
    
    → 导致代码僵化：需为不同类型重复编写逻辑相同的方法（如 `printBuddies`）。
    

---

### ​**二、上界通配符基本语法**​

1. ​**上界通配符 `<? extends T>`**​
    
    表示可接受泛型类型参数为 ​**`T`或其子类**​ 的任意类型。
    
    ```
    Pair<? extends Employee>  // 可接受 Pair<Employee>、Pair<Manager> 等
    ```
    

---

### ​**三、上界通配符的实践案例**​

#### ​**示例：`printBuddies`方法**​

1. ​**原始方法（僵化版本）​**​
    
    ```
    void printBuddies(Pair<Employee> p) { ... }
    ```
    
    → 无法接受 `Pair<Manager>`参数（编译错误）。
    
2. ​**改进后（使用上界通配符）​**​
    
    ```
    void printBuddies(Pair<? extends Employee> p) {
        Employee first = p.getFirst();  // 安全读取
    }
    ```
    
    → 可接受 `Pair<Manager>`等子类型参数。
    

---

### ​**四、上界通配符的类型安全限制**​

#### ​**1. 安全访问器（Safe Accessors）​**​

- ​**`getFirst()`可正常调用**​
    
    编译器确保返回值是 `Employee`的子类 → 可安全赋值给 `Employee`引用。
    

#### ​**2. 非安全修改器（Unsafe Mutators）​**​

- ​**`setFirst()`调用失败原因**​
    
    ```
    void setFirst(? extends Employee value)  // 编译器视角
    ```
    
    - 编译器无法确定通配符的具体类型（可能是 `Employee`、`Manager`或其他子类）。
        
    - 传递 `Employee`对象时，若实际类型为 `Pair<Manager>`，将破坏类型安全 → ​**编译禁止**。
        
    

#### ​**3. 核心设计思想**​

上界通配符通过编译器限制，实现 ​**​“只读不写”的安全性**​：

- ✅ 允许读取为父类型（安全）
    
- ❌ 禁止写入（避免破坏类型约束）
    

---

### ​**关键结论**​

|​**特性**​|​**上界通配符 `<? extends T>`**​|
|---|---|
|​**接受类型**​|`T`及其子类的泛型实例（如 `Pair<Manager>`）|
|​**读取数据**​|安全（返回 `T`的子类对象）|
|​**写入数据**​|禁止（编译器无法确保类型安全）|
|​**设计目标**​|解决泛型不变性导致的代码僵化问题|