---
aliases:
  - StringTable
  - 串表
---
 - 需求背景：
	 - 在Java程序中，字符串是被大量使用的数据类型
	 - 如果没有常量池，每次出现相同的字面量（比如多次出现的`"hello"`）都会在堆内存中创建一个全新的`String`对象
		 - 会耗费大量内存和时间
 - 设计思想：字符串内存复用
	 - 字符串常量池通过确保内容相同的字符串只在内存中保留一份，让所有引用都指向这同一个对象
	 - 字符串常量池本质上是一个哈希表，保存指向堆中的引用
 - 实现基础：
	 - String类是不可变类
		 - 因此可以被多个引用安全地共享，而不用担心数据被意外修改
	 - 字符串常量池是大小固定的哈希表
		 - 存放的是指向堆中字符串对象的引用

	- 字符串常量池与运行时常量池的关系：![[Pasted image 20251207103652.png]]
		- 编译期间：类加载的时候，常量池中的信息都会被加载到运行时常量池中，
			- 懒加载：加载后，a b ab都是运行时的一个utf8符号，还没有变成java字符串对象
			- 字符串对象是在首次使用时（即“主动引用”时）才在堆（JDK7+）中被创建并驻留到字符串常量池
		- 运行期间：在执行到引用这些运行时常量池的变量中的时候
			 - 字符串字面量直接赋值：`String s1 = "hello"`
				 - 内存存储：对象在堆中，其引用存储在字符串常量池
				 - 创建机制：先检查字符串常量池，根据字符串常量池是否存在这个字面值，决定要不要在堆中创建string变量
					 - 如果不存在则创建
						 - 【创建】
							 1. 在堆内存中创建一个新的`String`对象
							 2. 将这个对象的引用驻留到字符串常量池
							 3. 返回这个引用
					 - 如果存在则复用，
						 - 【复用】即不创建新对象，将已存在对象的引用传给新的变量
							 - 性能更优，减少内存开销
			 - new关键字创建：`String s2 = new String("hello");`
				 - 内存存储：对象也在堆中，但是独立于常量池
				 - 创建机制：总会强制在堆上创建一个新的对象实例
					1. 首先处理字面量：`"hello"`
						- JVM遇到`"hello"`，会先将其作为字面量处理，确保字符串常量池中已有对应的String对象（无则创建，有则复用）。（设为字符串对象a）
					 2. 然后执行`new`：
						- new关键字会在堆上强制创建一个全新的、独立的String对象。（设为字符串对象b）
						- 这个新对象会使用上一步从常量池中获取的字符串对象的底层字符数组（value）来初始化自己
					 - 字符串对象a和字符串对象b：
						 - 字符串a和字符串b的值相同，但是是不同对象
						 - 字符串对象n是最终返回给字符串变量的引用
					 - 性能开销相对较大，可能造成内存浪费
			 - 字符串常量拼接：`String s = "a"+ "b"`
				 - 直接 去常量池中找ab这个utf8符号，和字符串字面量直接赋值的机理一样
					 - 并不是先找a，再找b，然后拼接
					 - 这是在编译期间进行的优化，因为s的结果是确定的
			 - 字符串变量拼接：`String s1 = "a";String s2 = “b”;String s3 = s1+s2`
				 - 编译期间无法确定具体的结果，无法在编译期间优化，只能用stringBuilder进行拼接
					 - stringBuilder拼接的字符串对象并不存在于串池中，只存在于堆中
					 - 调用intern方法：将字符串对象尝试放入串池，如果有则不会放入
				 - 对应字节码的方法：`new StringBuilder().append("a").append("b").toString()`
					 - `toString`方法：本质上是调用new关键字
						 - 将StringBuilder拼接好的字符串作为参数传入
					 - 如果大量调用`+`拼接字符串，会导致创建大量的StringBuilder，会引起垃圾回收，降低性能
 - 位置变迁：![[Pasted image 20251207123947.png]]
	-  JDK 1.6及之前：常量池位于永久代。
		- 永久代的大小有限且垃圾回收效率不高，容易导致内存问题。
			- 触发时机晚：要等待老年代的内存空间不足的时候才会垃圾回收永久代
	- JDK 1.7：字符串常量池被移到了堆内存中。
		- 这样字符串对象可以和普通对象一起得到更高效及时的垃圾回收，减少了内存溢出的风险
	- JDK 1.8及之后：
		- 永久代被彻底移除，取而代之的是元空间。
-  操作常量池的方法：`intern()`
	- 需求背景：字符串变量拼接调用stringBuilder对象创造字符串对象
		- 这个字符串对象只存在堆中，不存在串池中
	- 定位：String类提供了一个名为intern()的native方法
	- 使用场景：
		- 处理字符串冗余：从数据库或配置文件中频繁读取的、取值范围固定的状态码、类型枚举、地区编码等
		- 高效缓存键：intern()化后后续的键比较（使用 `==`）操作速度极快，因为只需要比较引用地址，不需要比较对应char数组
			- 需要评估：若键的种类有限可带来性能提升；若键是无限的，则危害巨大。可考虑使用 Guava `Interners`。
	- 问题：
		- 内存泄露：JDK1.6之前串表存在于堆内存中
			- 可以考虑使用​ Guava 库中的 `Interners**`。它提供了基于弱引用的 `Interner`，当 `intern`后的字符串没有其他强引用时，可以被 GC 回收，从而避免了永久性的内存泄漏，是一种更安全的选择
		- 对大量不同的字符串调用`intern()`，可能导致常量池的哈希冲突加剧，查询效率下降
			- 常量池的底层实现：大小固定的哈希表
	- 作用：允许开发者在运行时手动将字符串对象放入字符串常量池或从中获取引用
		- 作用机制：
			- 如果常量池中已经存在一个内容相等的字符串，则直接返回池中的那个引用。
				- 串池中 已经存在的字符串对象，和调用intern的字符串对象不是同一个堆中对象
			- 如果常量池中不存在，
				- JDK 1.6中：他会在永久代的字符串常量池创建字符串对象的副本，返回副本的引用
					- 【副本】值相同，但是堆中地址不同，本质上是一个新对象
				- JDK 1.7及以上：它会将这个字符串对象的引用存储在常量池中，然后返回这个引用
					- 这意味着`intern()`方法调用后，池中保存的是堆中已有对象的引用，而不是创建一个新对象。
					```java
					 // 堆中创建"ab"对象，但池中此时没有"ab"
					String s1 = new String("a") + new String("b");
					s1.intern();  // 1.7及以上将s1的引用放入常量池，1.6中创建一个副本放入常量池
					String s2 = "ab"; // 1.7及以上s2指向的正是s1在堆中的那个对象，1.6中是常量池中的副本
					System.out.println(s1 == s2); // 1.7输出 true；1.6输出false
					```

- 垃圾回收：字符串常量池会被垃圾回收
- 性能调优：
	- 调优检测：
		- 需要处理大量文本数据、日志分析、网络协议解析
			- 现象：监控到与字符串相关的方法（如 `equals`, `hashCode`, `intern`）耗时较长
		- 堆内存中字符串对象占比过高：
			- 分析工具：堆转储分析工具（如 JProfiler, MAT）
			- 现象：
				- `String`对象的数量和总内存占用名列前茅
				- 存在大量内容重复的字符串。
		- 频繁触发垃圾回收：
			- 由于字符串对象过多，导致年轻代回收频繁，甚至可能因为字符串常量池（在堆中）的引用导致一些本可回收的对象被意外保留，引发 Full GC
	- 调优衡量：基于数据
		- 在应用退出时打印字符串表的统计信息：
			- 信息包含：桶数量、条目数、链表平均长度等
			- 作用：判断哈希表密度
			- 方式：使用 `-XX:+PrintStringTableStatistics`JVM 参数
		- 在应用退出时观察GC行为
			- 方式：`-XX:+PrintGCDetails -verbose:gc`
	- 调优方式
		- 字符串拼接优化：
			- 对于循环内的字符串拼接，务必使用 `StringBuilder`​ 而非 `+`操作符
				- 后者在底层会创建大量临时的 `StringBuilder`和 `String`对象，增加 GC 压力
		 - 调整哈希表桶的个数
			 - 调优原理：哈希表桶的个数多，哈希冲突发生的概率少，在判断是否创建，能否复用的时候，查询哈希表的熟读更快 
			 - 调优方式：使用 JVM 参数 `-XX:StringTableSize=`（例如 `-XX:StringTableSize=1000003`）。建议设置为**质数**，以获得更好的哈希分布。
		 - 考虑是否让字符串入池（`intern()`）
			 - 要存储的到内存的字符串存在大量重复，于是可以让字符串进入串池
			 - intern()本身是一个耗时操作，因为它需要在池中查找或存入字符串。需确保在重复率高的场景下使用才能有正收益。
		 - 利用G1垃圾回收器的字符串去重功能
			 - 原理：G1 GC 提供了一项特性，能在垃圾回收过程中识别并合并内容相同的字符串底层的 `char[]`数组
			 - 使用场景：这对于处理大量内容重复但又不是通过字面量创建的字符串（如通过网络反序列化得到的字符串）非常有效，无需修改代码即可自动节省内存
			 - 如何开启：使用 JVM 参数 `-XX:+UseG1GC -XX:+UseStringDeduplication