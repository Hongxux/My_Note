# 项目介绍
你这个项目技术点很扎实，面试时完全可以自信地介绍。下面我帮你梳理一下**怎么介绍项目**、**面试官可能怎么深挖**，以及**如何突出你的优化亮点**。

---

### 🚀 项目介绍（1–2分钟精要版）
你可以按这个结构快速说明白项目价值：

> “我做的是一款类似小红书的社交分享平台，核心功能包括**短信登录注册**、**商户信息缓存**、**优惠券秒杀**、**达人探店**和**点赞排行榜**。
>
> 技术上我用 **SpringBoot+MyBatis‑Plus+MySQL** 做基础架构，**Redis** 承担了缓存、分布式锁、消息队列等多种角色。
>
> 尤其在**高并发场景**下我做了较多优化：
> - 商户查询通过**缓存空对象+随机过期时间**解决缓存穿透、雪崩[[1]][[2]]；使用**互斥锁**防止缓存击穿[[3]][[4]]。
> - 秒杀环节用 **Redis 分布式锁**保证一人一单，**乐观锁（CAS）** 防止超卖，并通过 **Lua 脚本**保证原子性，最后用 **Redis Stream** 做异步下单，提升吞吐。
> - 点赞排名直接用 **Redis ZSet** 实现，实时更新且性能很好。
>
> 整体项目在本地压测中能支撑千级 QPS，对缓存、锁、消息队列的使用都有落地经验。”

---

### ❓ 面试官会怎么“拷打”你？
他们不会只问“你做了什么”，而会追问**为什么选这个方案**、**有没有更好的办法**。下面列举常见问题：

| 模块 | 可能追问的问题 |
| :--- | :--- |
| **缓存** | • 缓存穿透除了缓存空值，还知道**布隆过滤器**吗？它的优缺点是什么？[[5]][[6]]<br>• 缓存雪崩的**随机过期时间**你设置的区间是多少？为什么选这个区间？[[7]][[8]]<br>• 缓存击穿时你用互斥锁，如果是**分布式环境**，锁的超时时间设多少？怎么避免锁过期但业务还没执行完？[[9]] |
| **秒杀** | • **乐观锁**在 MySQL 中怎么实现的？是不是通过 `version` 字段？有没有遇到**ABA问题**？[[10]][[11]]<br>• 为什么用 **Lua** 脚本？它比 **Redis 事务**强在哪？<br>• **Redis Stream** 和 **Kafka** 比，为什么选它？消息堆积了怎么办？ |
| **分布式锁** | • 你自己实现的分布式锁还是用 **Redisson**？如果是自己实现，**锁的续期**怎么处理？<br>• 如果 Redis 主从切换，锁可能丢失，你知道怎么解决吗？（可提 **RedLock**，但也要说明它的争议） |
| **数据库** | • **MyBatis‑Plus** 乐观锁插件是怎么工作的？更新失败你会重试吗？重试次数多少？<br>• 订单表和大文本（如探店内容）放在同一个 MySQL 表吗？有没有做分库分表？ |
| **项目整体** | • 你项目的 **QPS** 是多少？怎么压测的？<br>• 如果缓存全崩，数据库怎么扛住流量？（可答**限流降级**、**数据库连接池保护**） |

---

### ✨ 如何体现你的优化亮点
你要突出**不是你只是实现了功能，而是你做了对比和选型**。

1. **缓存方案对比**
   - 提到你考虑过**布隆过滤器**，但因为业务中**数据字典不大**，选用**缓存空对象**更简单高效[[12]]。
   - 设置**随机过期时间**时，你是在基础时间上 **+0-180秒** 的随机值，避免同一时刻大量缓存失效[[13]]。

2. **秒杀环节的层层优化**
   - 第一版用 **synchronized** → 问题：单机锁，分布式不行。
   - 第二版用 **MySQL 乐观锁** → 问题：更新失败率高，数据库压力大。
   - 第三版用 **Redis 分布式锁 + Lua 脚本** → 保证原子性，再用 **Redis Stream** 异步下单，数据库压力下降明显。

3. **技术选型的理由**
   - 为什么用 **Redis Stream** 而不是 Kafka？因为项目体量还没到 Kafka 级别，Redis 已经具备消息持久化、消费组功能，**技术栈统一**，维护简单。
   - 为什么用 **ZSet** 做点赞排名？因为它能天然按分数排序，且 **O(log N)** 的插入/查询效率高。

4. **你做的额外工作**
   - 写了 **Lua 脚本**保证 **判断库存→扣库存→生成订单** 的原子性。
   - 使用了 **Redis 集群**（哪怕本地搭的）来做数据分片、提升可用性。
   - 做了**本地压测**，对比了优化前后的 QPS、RT 数据。

---

### 💎 总结
介绍时把握三条线：
- **业务线**：项目是“小红书”类平台，有哪些核心功能。
- **技术线**：SpringBoot+MyBatis‑Plus+Redis 为技术底座，在高并发场景下用了缓存、锁、消息队列。
- **优化线**：你不仅实现了功能，还对比了不同方案，最终选择了**更适合当前业务**的解法，并且有**压测数据**佐证。

这样介绍，面试官会觉得你**有思考、有落地、有总结**，竞争力自然突出。祝你面试顺利！

# 配置基础数据
## 1.运行前端项目
![[Pasted image 20251117214726.png]]
## 2.导入后端项目
![[Pasted image 20251117214803.png]]
### 遇见的问题与解决方案
#### 版本不兼容问题
原来的项目是基于SpringBoot2建立的，我在这边改成了SpringBoot3，于是出现了组件不兼容问题
```yml
<parent>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-parent</artifactId>  
    <version>3.5.7</version>  
    <relativePath/> <!-- lookup parent from repository -->  
</parent>
```
1. MyBatis Plus对Spring3的兼容
	- MyBatis Plus拆分成了主要组件和一些插件（例如分页），于是引入版本管理
		```
		<dependencyManagement>  
		    <dependencies>
		        <dependency>
			            <groupId>com.baomidou</groupId>  
			            <artifactId>mybatis-plus-bom</artifactId>  
			            <version>3.5.14</version>  
			            <type>pom</type>  
			            <scope>import</scope>  
		        </dependency>
		    </dependencies>
		</dependencyManagement>
		```
	- 主要组件
	```
	<dependency>  
	    <groupId>com.baomidou</groupId>  
	    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>  
	</dependency>
	```
	- 分页所需插件，它的版本应由 MyBatis Plus BOM 自动管理，显式指定旧版本会导致冲突。
	```
	<dependency>  
	    <groupId>com.baomidou</groupId>  
	    <artifactId>mybatis-plus-jsqlparser-4.9</artifactId>  
	</dependency>
	```
2. @Resource在SpringBoot3中太老了被废弃，要额外引入api
	- `程序包javax.annotation不存在`错误，通常发生在使用较高版本的JDK（如JDK 9及以上）或Spring Boot 3.x时，因为在这些版本中，`javax.annotation`包已被移除或由新的规范替代。如果您的项目暂时需要继续使用 `javax`注解，最直接的方法是在 `pom.xml`中显式添加这个依赖
	```
	<dependency>  
	    <groupId>com.baomidou</groupId>  
	    <artifactId>mybatis-plus-jsqlparser-4.9</artifactId>  
	</dependency>	
	```
3. 将过时的 `mysql-connector-java`替换为新的官方驱动 `mysql-connector-j`
	```
	   <dependency>  
	    <groupId>com.mysql</groupId>  
	    <artifactId>mysql-connector-j</artifactId> <!-- 注意artifactId已改变 -->  
	    <scope>runtime</scope>  
	    <!-- 版本通常由spring-boot-starter-parent自动管理，无需手动指定 -->  
	    <!-- <version>8.0.33</version> --></dependency>
	```
4. 将 `<java.version>`修改为 17 或 21，因为 Spring Boot 3.x 是基于 Java 17 构建的，在 Java 8 上无法正常运行


#### **总结：**
使用第三方工具出现问题，很大可能由于以下原因：
1. 方法时效性：版本不兼容或者第三方工具的更新导致配置或者安装的方式改变了，而网上的方法过时了。因此最好去工具的官网阅读官网文档来解决。
2. 网路问题：需要镜像或者加速器
3. 依赖：还有相关依赖没有配置，需要安装完依赖后再进行配置


# 完成短信登陆、注册功能

## 对于controller
![[Pasted image 20251117220425.png]]
![[Pasted image 20251117220434.png]]

学到[[Controller的开发思想|Controller]]和[[Result|统一响应封装]]和[[DTO]]

## 对于Service
![[Pasted image 20251117225018.png]]
![[42d9c3d8ae3d40370b066e695b39589a.jpeg]
![[Pasted image 20251117223425.png]]


- 第三方的封装方法

| **`RegexUtils.isPhoneInvalid(phone)`**        | 自定义工具类             | **校验手机号格式**是否正确。这是一个封装好的方法，通常内部用正则表达式实现。                                     | `if (RegexUtils.isPhoneInvalid(phone)) { ... }`                   |
| --------------------------------------------- | ------------------ | ---------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| **`RandomUtil.randomNumbers(6)`**             | **Hutool**         | 生成指定位数的**纯数字随机字符串**，常用于生成短信验证码。                                              | `String code = RandomUtil.randomNumbers(6);`                      |
| **`RandomUtil.randomString(10)`**             | **Hutool**         | 生成指定长度的**随机字符串**（包含字母和数字），用于为用户生成随机昵称。                                       | `user.setNickName(RandomUtil.randomString(10));`                  |
| **`BeanUtil.copyProperties(source, target)`** | **Hutool**或 Spring | **对象属性拷贝**。将源对象（`User`）中的属性值复制到目标对象（`UserDTO`）的同名属性中。高效实现Entity到DTO的转换。      | `UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);` |
| **`BeanUtil.beanToMap(...)`**                 | **Hutool**         | 将Java Bean对象**转换为`Map<String, Object>`**。此代码中用于将UserDTO转换为Map以便存入Redis Hash。 | `BeanUtil.beanToMap(userDTO, new HashMap<>(), copyOptions)`       |
| **`UUID.randomUUID().toString(true)`**        | **JDK内置**          | 生成一个**唯一标识符**。参数`isSimple: true`表示生成不带短横线`-`的简化版UUID，常用作Token或临时键。           | `String token = UUID.randomUUID().toString(true);`                |
- Redis的两个作用:
	- **作为缓存（Cache）**：在`sendCode`方法中，将验证码以 `String`类型存入Redis，并设置键名 `LOGIN_CODE_KEY + phone`。这是一种标准的K-V缓存模式，读写速度快，适合存储临时数据。
	    
	- **作为会话存储（Session Store）**：在`login`方法中，将登录用户信息以 `Hash`类型存入Redis，并设置过期时间（TTL）。键名为 `LOGIN_USER_KEY + token`。这实现了**分布式会话**，用户状态不再依赖于服务器的本地内存，而是集中存储在Redis中，非常适合集群部署。
- 在将`UserDTO`对象存入Redis Hash时，代码没有使用简单的`BeanUtil.beanToMap(userDTO)`，而是使用了更高级的`CopyOptions`参数
```java
BeanUtil.beanToMap(userDTO, new HashMap<>(), CopyOptions.create()
    .ignoreNullValue(true) // 忽略空值，避免存储无效数据
    .setFieldValueEditor((fieldName, fieldValue) -> // 关键：统一将值转为String
        fieldValue == null ? null : fieldValue.toString()
    )
);
```

**这么做的原因是**：Redis Hash 的 field value 必须是 `String`类型（StringRedisTemplate的key和value都要是String）。如果`UserDTO`中有`Long`类型的`id`字段，不经过转换直接存入会报错。这个配置确保了无论什么类型的属性，最终都以`String`形式存储，**保证了操作的安全性和可靠性**。
- Redis的数据结构选择
	- ![[54966b2846e1b8eb44e2c18d44878357.jpeg]]

当然！这段实现登录验证码功能的代码虽然核心逻辑清晰，但其中蕴含了大量可供深入探讨的技术点和优化空间。这些点正是面试官喜欢深挖的地方，它们反映了开发者的设计思维、深度和对生产环境实践的认知。

以下是我为你梳理的**可深挖技术点**，按照优先级和考察方向分类：
    


## 对于登录拦截器
![[7f86d50c44d5d250af414b263e0ee3cb.jpeg]]
![[Pasted image 20251117225118.png]]![[Pasted image 20251117225135.png]]
![[Pasted image 20251117225350.png]]您提供的这两段代码展示了一个**双层拦截器**的经典实现，这是构建现代Web应用（尤其是前后端分离架构）中处理身份认证和会话管理的优雅方案。下面这个表格总结了其核心分工和面试官可能关注的重点。

|组件|核心职责|关键面试考察点|
|---|---|---|
|**AllInterceptor**|**全局令牌刷新**：拦截所有请求，尝试刷新有效token的存活时间。|设计初衷、执行顺序、Token刷新机制、与Redis的交互。|
|**LoginInterceptor**|**登录状态校验**：对需要登录的接口进行访问控制。|职责单一性、与ThreadLocal的配合、资源清理。|


## 面试官拷打

考虑**安全、性能、用户体验**

### 一、基础流程与设计（20分）

**1. 请描述一下短信验证码登录的完整业务流程，包括前端、后端和Redis的交互细节。**

**追问：** 验证码和Token在Redis中如何存储？Key和Value的结构是什么？过期时间怎么设置？

**期望答案：**

- **流程：**
    
    1. 用户输入手机号，前端请求发送验证码接口。
        
    2. 后端校验手机号格式 → 生成6位随机码 → 保存到Redis（Key如`login:code:138xxx`，有效期2分钟）→ 调用短信服务发送。
        
    3. 用户提交验证码，前端请求登录接口。
        
    4. 后端校验Redis中的验证码是否匹配 → 查询用户是否存在（不存在则自动注册）→ 生成Token（如UUID）→ 将用户信息存入Redis（Key如`login:token:xxx`，Hash结构，有效期30分钟）→ 返回Token给前端。
        
    5. 前端后续请求在Header中携带Token，后端通过拦截器校验并刷新Token有效期。
-  **Hash vs String：**
    
    - **Hash**可部分读写字段（如更新用户昵称），节省网络流量；适合频繁修改部分字段的场景。
        
    - **String**适合整体读写、数据结构简单的场景（如验证码）。
    
- **考察目的：**
    
    - 是否掌握核心流程的闭环设计（防刷、存储、校验）。
        
    - 对Redis数据结构的理解（String存验证码 vs Hash存用户信息）。
        
    - 对安全性和用户体验的权衡（过期时间设置）。
        
    

---

### 二、技术选型与深度（25分）

****追问2：“验证码怎么存储？存在数据库里吗？有效期多久？”**

**✅ 你的回答（展现安全存储意识）：**

“不，我们**绝对不把验证码明文存储在数据库**，因为这会带来严重的安全风险。我们使用 **Redis**来存储，原因有三：

1. **高性能**：读写速度快。
    
2. **自带过期时间**：可以轻松设置验证码的有效期，通常是**5分钟**，过期自动删除，无需手动清理。
    
3. **数据结构简单**：Key-Value结构非常适合这个场景。
    

**存储格式如下：**

- **Key**：`sms:login:{手机号}`或 `sms:reg:{手机号}`（将登录和注册分开，避免冲突）
    
- **Value**：生成的验证码（可以是明文，因为Redis本身需要安全配置）
    
- **TTL**：300秒（5分钟）
    

---

### 三、安全与防攻击（20分）

**追问1：“你怎么防止短信接口被恶意轰炸？比如有人用脚本频繁请求给某个手机号发短信。”**

“我们采用了**前端、后端、服务端三层防护**：

1. **前端层面**：按钮点击后置灰60秒，防止用户连续点击。
    
2. **后端层面（核心）**：
    
    - **手机号频率限制**：对同一个手机号，限制单位时间内的发送次数，比如1分钟1次，1小时5次，1天10次。超出则返回“请求过于频繁”。
        
    - **IP频率限制**：对同一个请求源IP，限制单位时间内的发送次数，防止攻击者通过更换手机号来攻击我们的服务。
        
    - **图形验证码**：在发送短信前，要求用户先输入并验证图形验证码。这是防御机器脚本最有效的手段之一，可以在攻击到达业务逻辑前就进行拦截。

**考察目的：**

- 是否具备安全思维，能预见常见攻击手段并设计防护措施。
    
**追问3：“你怎么保证验证码在传输过程中的安全？怎么防止验证码被泄露或重放攻击？”**

**✅ 你的回答（展现更深的安全思考）：**

- **传输安全**：全程使用 **HTTPS**协议，对请求体和响应体进行加密，防止中间人窃听。
    
- **防止重放攻击**：我们可以在后端为每个验证码请求生成一个唯一的Token（如UUID），在发送验证码的同时将这个Token返回给前端。前端提交验证码时，必须同时提交这个Token。服务器会校验Token的有效性和一次性。这样，即使请求被截获，攻击者也无法用旧的验证码和Token进行重放。”
---

### 四、高并发与缓存处理（25分）

**5. 明星带货场景下，瞬时高并发登录如何避免Redis缓存击穿或雪崩？**
**展现异步化和削峰填谷思想**
我们不会在请求到来时**同步**调用短信服务商接口，因为短信服务商接口的延迟和稳定性是不可控的，容易拖垮我们的应用服务。我们的方案是：

1. **请求异步化**：当收到发送验证码请求后，我们只做两件事：a) 生成验证码并存入Redis；b) 将发送任务作为一个消息扔进**消息队列**（如RabbitMQ、RocketMQ）。
    
2. **削峰填谷**：消息队列起到了缓冲作用，将瞬间的高并发转换为平稳的流量。
    
3. **独立消费者**：由一个或多个独立的消费者服务从消息队列中取出任务，**异步地**调用短信服务商接口。
    

这样，前端用户可以立即得到‘验证码已发送’的响应，而实际发送任务在后台平稳进行，即使短信服务商暂时不可用，任务也会在队列中重试，不会影响主流程。”

### 五、场景设计与开放性思考（10分）

**7. 如何实现Token自动续期？**
- 使用双重拦截器：第一层拦截所有请求，刷新Token有效期；第二层拦截需登录路径，校验用户状态。

**8.如果Redis挂了，整个短信服务就不可用了，有什么高可用方案？**
- **Redis集群**：使用Redis哨兵或集群模式，实现主从切换和数据冗余。
    
- **服务降级**：在监控到Redis连接超时或不可用时，触发降级策略。例如，可以降级为使用**本地缓存**（如Caffeine）暂存验证码，但设置很短的有效期（如2分钟），并明确告知用户‘系统繁忙，验证码有效期缩短’。这只是临时方案，为修复Redis争取时间。
    
- **熔断机制**：集成Hystrix或Sentinel，当短信服务失败率过高时，自动熔断，可以返回‘短信服务暂时不可用，请使用密码登录’等提示，保证核心登录链路不全盘崩溃。”



----

# 商户查询缓存

### 添加Redis缓存
![[Pasted image 20251118111902.png]]
![[Pasted image 20251118112104.png]]
### 缓存更新策略
采用[[Cache Aside|缓存旁路模式]]

![[Pasted image 20251118133524.png]]

1. 读缓存未命中后写缓存的时候，设置缓存的超时时间
   ![[Pasted image 20251118133945.png]]
2. 主要针对更新业务
  ![[Pasted image 20251118134255.png]] 


### [[缓存穿透]]

采用空对象的解决方式
原本的
![[Pasted image 20251118140854.png]]



![[Pasted image 20251118141016.png]]
![[Pasted image 20251118141128.png]]
![[Pasted image 20251118141205.png]]

### [[缓存雪崩]]

### [[缓存击穿]]
#### 基于互斥锁
![[Pasted image 20251118145008.png]]
修改的地方：未命中的时候获取互斥锁，根据互斥锁的持有再进行下一步操作

**使用setnx和del实现互斥锁**
![[Pasted image 20251118145325.png]]获取锁就是用setnx赋值
- 为了避免持有锁的线程出问题，而锁无法释放，就使用TTL
释放锁锁就是用del删除
![[Pasted image 20251118145643.png]]


![[Pasted image 20251118150227.png]]
![[Pasted image 20251118150249.png]]

最后修改一下，用try catch
在finally中释放锁
#### 基于逻辑过期
![[Pasted image 20251118184602.png]]
![[Pasted image 20251118184626.png]]![[c58f07a604956161878002088bdf3432.jpeg]]

![[Pasted image 20251118184846.png]]
![[Pasted image 20251118184832.png]]

### 封装缓存工具类
![[Pasted image 20251118184916.png]]
```java
package com.hmdp.utils;  
  
import cn.hutool.core.util.StrUtil;  
import cn.hutool.json.JSONObject;  
import cn.hutool.json.JSONUtil;  
import com.hmdp.dto.RedisData;  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.data.redis.core.StringRedisTemplate;  
import org.springframework.stereotype.Component;  
  
import java.lang.reflect.Method;  
import java.time.LocalDateTime;  
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  
import java.util.concurrent.TimeUnit;  
import java.util.function.Function;  
  
import static com.hmdp.utils.RedisConstants.CACHE_SHOP_KEY;  
import static com.hmdp.utils.RedisConstants.CACHE_SHOP_TTL;  
@Slf4j  
@Component  
public class RedisCacheUtils {  
    private StringRedisTemplate stringRedisTemplate;  
    private ExecutorService  executorService = Executors.newFixedThreadPool(10);  
  
    public RedisCacheUtils(StringRedisTemplate stringRedisTemplate) {  
        this.stringRedisTemplate = stringRedisTemplate;  
    }  
    public boolean set(String key, Object data, Long expireTime, TimeUnit timeUnit){  
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, JSONUtil.toJsonStr(data), expireTime, timeUnit);  
        return Boolean.TRUE.equals(flag);//避免空指针异常  
    }  
    private boolean trylock(String key, Long expireTime, TimeUnit timeUnit){  
        boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,"1",expireTime,timeUnit);  
        return Boolean.TRUE.equals(flag);  
    }  
    private boolean releaseLock(String key){  
        boolean flag = stringRedisTemplate.delete(key);  
        return Boolean.TRUE.equals(flag);  
    }  
    public void setWithLogicalExpire(String key,Object obj, Long LogicalexpireTime, TimeUnit timeUnit){  
        RedisData redisData = new RedisData();  
        redisData.setData(obj);  
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(LogicalexpireTime)));  
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));  
  
    }  
  
    public <R,ID> R queryWithLogicalExpire(String preKey, ID id, Class<R> cls, Function<ID,R> queryFromDBbyID,Long expireTime, TimeUnit timeUnit){  
        //1.从Redis中查询  
        String json = stringRedisTemplate.opsForValue().get(preKey + id);  
        //2.缓存未命中返回空  
        if(StrUtil.isBlank(json)){  
            return null;  
        }  
        log.debug("json:{}",json);  
        //3.缓存命中,判断是否逻辑过期  
        RedisData redisData = JSONUtil.toBean(json, RedisData.class);  
        R r = JSONUtil.toBean((JSONObject)redisData .getData(), cls);  
        LocalDateTime data_expireTime = redisData.getExpireTime();  
        if(data_expireTime.isAfter(LocalDateTime.now())){  
            //4.未过期,分装data后返回  
            return r;  
        }  
  
        //5.过期了,尝试获取互斥锁  
        if(trylock(RedisConstants.LOCK_SHOP_KEY + id,RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS)){  
            // 双重检查：获取锁后再次判断缓存是否已被更新  
            String latestJson = stringRedisTemplate.opsForValue().get(preKey + id);  
            if(StrUtil.isNotBlank(latestJson)){  
                RedisData latestData = JSONUtil.toBean(latestJson, RedisData.class);  
                if(latestData.getExpireTime().isAfter(LocalDateTime.now())){  
                    releaseLock(RedisConstants.LOCK_SHOP_KEY + id);  
                    return JSONUtil.toBean((JSONObject)latestData.getData(), cls);  
                }  
            }  
            //6.获取锁成功  
            //7.从线程池中取出线程,开启线程  
            executorService.submit(()-> {  
                try {  
                    log.debug("进入线程");  
                    //7.1根据id查数据库  
                    R dataFromDB = queryFromDBbyID.apply(id);  
  
                    //7.2将数据库数据导入Redis,并且设置过期时间  
                    setWithLogicalExpire(preKey + id,dataFromDB,expireTime,timeUnit);  
                } catch (Exception e) {  
                    log.error("缓存重建失败, key: {}", preKey + id, e);  
                }finally {  
                    //7.3释放互斥锁  
                    releaseLock(RedisConstants.LOCK_SHOP_KEY + id);  
                }  
  
  
  
            });  
        }  
        //8.主线程返回过期数据 9.获取互斥锁失败,直接返回过期数据  
        return r;  
    }  
    public <R,ID> R queryAvoidPassThrough(String preKey, ID id, Class<R> cls, Function<ID,R> queryFromDBbyID,Long NullexpireTime,Long expireTime, TimeUnit timeUnit){  
        //1.从Redis中查询商铺缓存  
        String json = stringRedisTemplate.opsForValue().get(preKey + id);  
        //2.判断缓存是否命中  
        if(json == null){  
            //4.缓存未命中  
            //4.1根据id查询数据库  
            R r = queryFromDBbyID.apply(id);  
            //4.2判断店铺是否存在  
  
            //4.2.1店铺存在,将商铺信息写入Redis后返回  
            if(r != null){  
                set(preKey+id,r,expireTime,timeUnit);  
                return r;  
            }  
            //4.2.2店铺不存在,将空值写入Redis后返回null  
            set(preKey+id,"",NullexpireTime,timeUnit);  
            return null;  
        }  
        //3.缓存命中  
        //3.1判断是否为空值  
        if(StrUtil.isBlank(json)){  
  
            //3.3是空值,结束返回空  
            return null;  
        }  
        //3.2不是空值,返回商铺信息  
        return JSONUtil.toBean(json, cls);  
  
  
    }  
  
  
}
```

###  面试官拷打
##### ⚔️第一层：缓存策略与设计方案（考察架构思维）

**面试官**：“你们商户数据是怎么做缓存的？比如缓存哪些数据？用什么策略？”

**✅ 你的回答要点（展现业务抽象能力）：**

“我们根据商户数据的**稳定性**和**访问模式**，设计了**分层缓存策略**：

1. **缓存粒度**：
    
    - **商户基础信息**（名称、地址、营业时间）：**全量缓存**。因为这类数据稳定，变更不频繁。采用 **「缓存旁路」** 模式，查询时先查缓存，未命中查DB并回写。
        
    - **商户统计信息**（销量、评分、评论数）：**增量缓存**。这类数据变化快，我们采用 **「Write-Through」** 思路，在更新DB后同步更新缓存，确保实时性。
        
    - **复杂查询结果**（如按地理位置、品类筛选商户列表）：**查询结果缓存**。将复杂的查询条件作为Key，缓存整个结果集，并设置较短的TTL（如1分钟），应对短时高频查询。”
        
    
2. **Key设计**：
    
    - 基础信息：`shop:info:{shopId}`
        
    - 统计信息：`shop:stats:{shopId}`
        
    - 查询结果：`shop:query:{geoHash}:{categoryId}:...`
        
**思考**：
缓存策略：
- 对于常用的信息，不容易变更的信息，进行[[全量缓存]]
- 对于变化快数据采用[[增量缓存]]
- 对于热点数据：避免[[缓存击穿]]而选择逻辑过期
- 对于复杂查询，缓存查询结果
更新策略：
- 较低的一致性要求：[[Cache Aside|缓存旁路模式]]
- 较高的一致性要：**[[直写缓存策略]]**



---

##### ⚔️ 第二层：深度拷打缓存问题（看你的技术功底）

这是核心环节，面试官会把你学过的缓存问题全部套到商户场景里问一遍。

**追问1：“商户信息万一有更新，比如改了营业时间，你们怎么保证用户看到的是最新数据？”**

**✅ 你的回答（展现数据一致性解决方案）：**

“我们采用 **「先更新数据库，再删除缓存」** 的策略。这是为了最大限度避免并发导致的数据不一致。

- **核心代码逻辑**：
    
    ```
    @Transactional
    public void updateShop(Shop shop) {
        // 1. 更新数据库
        shopMapper.updateById(shop);
        // 2. 删除缓存
        redisTemplate.delete("shop:info:" + shop.getId());
        // 可选步骤：3. 延迟一段时间后再次删除（双删策略，应对极端并发）
    }
    ```
    
- **为什么是删除而不是更新缓存？** 因为商户信息是一个聚合对象，直接更新可能涉及多个字段的复杂计算，**删除缓存**让下一次读请求回源数据库，能保证数据的最终一致性，且逻辑更简单。”
    

**追问2：“如果有个超级热门的商户（比如网红店），它的缓存突然失效了，会发生什么？怎么解决？”**

**✅ 你的回答（展现缓存击穿的实战解决方案）：**

“这就是 **[[缓存击穿]]** 问题。对于热门商户，我们采用 **「逻辑过期」** 方案，而不是物理过期。

- **实现方案**：
    
    1. 缓存Value中不单纯存商户对象，而是封装一个包含逻辑过期时间的对象。
        
    2. 当发现数据逻辑过期时，不是所有请求都去重建缓存，而是通过**互斥锁**让一个请求去DB查询并更新缓存，其他请求先返回旧数据。
        
    
- **代码示例**：
    
    ```
    public Shop queryShopWithLogicalExpire(Long shopId) {
        // 1. 查询缓存
        RedisData redisData = redisTemplate.get("shop:info:" + shopId);
        Shop shop = (Shop) redisData.getData();
        // 2. 判断逻辑是否过期
        if (redisData.getExpireTime().isAfter(LocalDateTime.now())) {
            return shop; // 未过期，直接返回
        }
        // 3. 已过期，尝试获取锁重建缓存
        if (tryLock("shop:lock:" + shopId)) {
            // 开启异步线程重建缓存...
            executor.submit(() -> {
                Shop newShop = getFromDB(shopId);
                setShopCache(newShop);
                releaseLock("shop:lock:" + shopId);
            });
        }
        // 4. 其他请求直接返回旧数据
        return shop;
    }
    ```
    

**追问3：“如果你们运维失误，导致大量商户缓存同一时间点过期，怎么办？”**

**✅ 你的回答（展现[[缓存雪崩]]的预防能力）：**

“我们通过**打散过期时间**来预防。在设置缓存时，TTL不是固定的30分钟，而是 `基础时间 + 随机偏移量`。

```
// 基础30分钟，加上一个随机的正负5分钟偏移
long ttl = 1800 + ThreadLocalRandom.current().nextLong(-300, 300);
redisTemplate.opsForValue().set(key, shop, ttl, TimeUnit.SECONDS);
```

这样，即使同时加载的缓存，也会在25-35分钟的不同时间点失效，避免了请求洪峰直接冲击数据库。”

---

##### ⚔️ 第三层：扩展场景与高阶问题（考察架构潜力）

**追问1：“如果商户列表页需要根据距离、评分、销量等多维度排序和筛选，这种复杂查询怎么做缓存？”**

**✅ 你的回答（展现复杂场景处理能力）：**

“这是个很好的问题。对于这种**多维度、动态查询**，直接缓存完整结果集效率很低（因为参数组合太多）。我们的策略是：

1. **缓存源头数据，而非结果**：优先保证每个商户的基础信息、经纬度、评分、销量等**原子数据**在缓存中是热的。
    
2. **应用层聚合**：接收到查询请求后，先从缓存中批量获取（`MGET`）符合条件的商户原子数据，然后在应用内存中进行排序、筛选、分页。这利用了应用服务器的计算能力，减轻了数据库的复杂查询压力。
    
3. **使用Redis GEO**：对于按距离排序，我们直接将商户的经纬度存入Redis的GEO数据结构中，可以高效地进行距离查询和排序，再结合缓存的商户详情进行组装。”
    

**追问2：“缓存数据越来越大，Redis内存不够了怎么办？你们怎么做缓存清理？”**

**✅ 你的回答（展现资源管理和运维意识）：**

“我们有一套完整的缓存治理方案：

1. **设置合理的淘汰策略**：使用 `volatile-lru`或 `allkeys-lru`，让Redis在内存不足时自动淘汰最近最少使用的Key。
    
2. **缓存预热**：在低峰期（如凌晨），通过定时任务将核心商户数据主动加载到缓存中。
    
3. **分级缓存**：对超大规模的商户数据，可以考虑按**热度分级**。最热的1%商户数据放在性能最高的Redis实例中，其余数据放在另一个实例或集群中。
    
4. **监控与告警**：监控Redis的内存使用率、Key数量，设置告警阈值，提前发现容量风险。”
    

---

##### 💎 总结与加分项

**最后，做一个有高度的总结：**

“总结来说，商户查询缓存的设计是一个系统工程，需要综合考虑：

- **业务特性**（数据变更频率、访问模式）
    
- **技术选型**（选择合适的缓存策略和过期机制）
    
- **问题防御**（击穿、雪崩、穿透）
    
- **资源治理**（内存、性能监控）
    

核心思想是：**用缓存抗住读流量，保证高并发下的系统稳定，同时通过合理的更新策略保证数据的最终一致性。**

**加分项**：

- 主动提及“**监控指标**”：“我们会重点监控缓存命中率，如果命中率过低，说明缓存策略可能有问题，需要优化。”
    
- 提及“**容灾降级**”：“如果Redis真的挂了，我们会有降级策略，比如直接读数据库，虽然慢但能保证服务基本可用，同时告警通知运维。”
    

记住，回答时要结合「商户」这个具体业务，把每个技术决策背后的**业务考量**讲清楚，这会让面试官觉得你的技术是真正为业务服务的，而不只是纸上谈兵。祝你面试顺利！
# 优惠卷秒杀
## 全局ID生成


#### 数据库自增ID的问题
![[Pasted image 20251118185103.png]]
#### 全局ID要满足的性质
![[Pasted image 20251118185122.png]]
![[Pasted image 20251118185140.png]]
#### 全局ID生成的实现之
![[Pasted image 20251118185220.png]]
##### Redis自增ID

![[825d764410aa1974326ca4ecfa572fed.jpeg]]
![[97bcaa0d9bddfbf8d92f949b758989d7.jpeg]]




##### [[snowflake算法]]

## 基本功能实现：优惠卷秒杀的下单功能
![[Pasted image 20251119103125.png]]
![[Pasted image 20251119103345.png]]
![[Pasted image 20251119104045.png]]*

![[Pasted image 20251119104013.png]]


### 超卖问题
- 超卖出现的原因：在线程1查询库存和扣减的窗口期线程2进行了查询库存
- 解决方案：使用[[乐观锁]]
会出现少买问题

![[Pasted image 20251119110516.png]]
只需要判断库存＞0即可


优化:提高成功率可以使用分段锁

### 一人一单
#### 数据库层面
**强制使用唯一索引**：无论是否用锁，都必须在数据库层为 `(user_id, voucher_id)`创建唯一约束。这是防止数据损坏的最后屏障。
#### 单机版
![[Pasted image 20251119111159.png]]
![[Pasted image 20251119111240.png]]

##### 1.乐观锁和悲观锁的选择
在检查和下单的窗口中，可能出现并发问题。因此需要使用锁![[Pasted image 20251120125627.png]]
而这个是写多读少的情况
没有办法使用乐观锁,只能使用悲观锁
从查询订单到下单

法一:对这段执行流程加锁
![[Pasted image 20251119111521.png]]
![[Pasted image 20251119111600.png]]

##### 2.加锁的对象问题
要保证对user_id的值加锁，而不是对对象加锁，减小锁的范围，提高性能
使用吗.toString().intern()
![[Pasted image 20251119111822.png]]

##### 3.**释放锁和提交订单的先后问题**
是先释放锁再提交订单，这个窗口期，可能会有别的线程获取锁，然后继续下单
因此更改加锁位置，变成先提交事务（确保数据库已经被更改），再释放锁
![[Pasted image 20251119112049.png]]


##### 4. 事务失效的问题
这里调用createVoucherOrder方法不是使用代理对象，会导致该方法的[[事务失效]]。
因此手动获取代理对象，调用代理对象的方法
![[Pasted image 20251119112534.png]]
![[Pasted image 20251119112600.png]]

![[Pasted image 20251119112509.png]]

#### 集群版本---分布式锁
与单机版不同之处在于加的锁不是普通锁，而是分布式锁
##### 配置集群
![[Pasted image 20251119122702.png]]![[Pasted image 20251119122740.png]]  ![[Pasted image 20251119122813.png]]



 ![[Pasted image 20251119123004.png]]

---
##### 并发安全问题再现
![[Pasted image 20251119123654.png]]

多JVM存在，多个JVM都有自己锁监视器，都有自己的互斥锁
解决方案：使用跨进程的锁--[[分布式锁]]


### 优化秒杀


![[Pasted image 20251120141514.png]]
由于多次写和读数据库，导致并发能力和性能较差

优化思想：![[Pasted image 20251120142402.png]]
- 分离读写，减少主线程需要进行的操作，从主线程剥离耗时操作，将耗时任务交给异步线程
	- 耗时短的：检查库存和判断购买资格交给主线程
	- 耗时长的：减库存和创建订单交给另一个线程
- 提高读写效率：使用Redis 判断库存和购买资格
- Redis和异步队列的联系：保存优惠卷id，用户id和订单id到阻塞队列
####  Redis判断库存和购买资格
- 使用数据结构：![[Pasted image 20251120142806.png]]
	- 购买某优惠卷的用户用Set记录，集合＋唯一
- 流程：![[Pasted image 20251120143017.png]]![[Pasted image 20251120143127.png]]
- 实现方式：编写lua脚本保证原子性，java调用lua脚本![[Pasted image 20251120143700.png]]
	- lua脚本![[Pasted image 20251120145131.png]]![[Pasted image 20251120145142.png]]
	- java
		- 加载lua脚本![[Pasted image 20251120145725.png]]
			- 设置脚本路径
			- 设置脚本返回值
		- 使用lua脚本（准备keys和values）![[Pasted image 20251120145818.png]]
			- 对于传入的参数要让其转化为字符串,不然会报错
		- ![[Pasted image 20251120150032.png]]


#### [[阻塞队列]]的实现
##### JDK实现的阻塞队列
![[Pasted image 20251120151317.png]]
- 主线程判断能下单后将订单加到阻塞队列![[Pasted image 20251120151552.png]]
- 我们在我们这个ControllerBean初始化完成后开启一个线程，负责阻塞队列的订单![[Pasted image 20251120151342.png]]
- 子线程的下单任务有一些需要注意
	- 代理对象获取不了（来自于ThreaLocal），要将代理对象放在类的局部变量中
- 改造创建订单的事务的方法

#### 消息队列

![[7abddca872c8e3f72771b9be398458aa.jpeg]]
![[c2f9b10fa4cf98d5a61f58ee62379c65 1.jpeg]]![[ec206230fc85862503da5b2457230c00.jpeg]]


# 达人探店功能
## 发布探店笔记
![[Pasted image 20251121153625.png]]

### 上传图片
1. 修改保存文件的位置
![[Pasted image 20251121153550.png]]
## 查看探店笔记
![[Pasted image 20251121154000.png]]
 
## 点赞功能
 ![[Pasted image 20251121154817.png]]
 ![[Pasted image 20251121154946.png]]
 ![[Pasted image 20251122093516.png]]
 ![[Pasted image 20251122120158.png]]
 ![[Pasted image 20251122120510.png]]
 ![[Pasted image 20251122120523.png]]
## 点赞排行榜--从set集合升级到Sortedset
![[Pasted image 20251122120800.png]]
![[Pasted image 20251122120929.png]]

先更改之前的点赞操作，再新加点赞排行榜
分数设置为时间戳
获取排行榜前五使用`ZREVRANGE key 0 4`实现获取
![[Pasted image 20251122122136.png]]


问题：redis的点赞顺序没错，但是把点赞的用户id给MySQL查询得到的返回值的顺序是乱序的，没有按照我给的顺序
因此使用 [[order by field]]自定义返回顺序
![[Pasted image 20251122122602.png]]
![[Pasted image 20251122122720.png]]

---

# 好友关注

## 关注和取关
![[Pasted image 20251122124311.png]]

![[Pasted image 20251122125202.png]]
![[Pasted image 20251122130251.png]]
![[Pasted image 20251122130506.png]]
![[Pasted image 20251122130612.png]]
## 共同关注--set的取交集
![[Pasted image 20251122131405.png]]
## 关注推送---[[Feed流]]
![[Pasted image 20251122133941.png]]
推送功能
![[Pasted image 20251122140455.png]]

#### 分页问题-从List和SortedSet中选择SortedSet的理由
由于我们的数据变化快
因此采用[[滚动分页]]
 Redis查询语句（采用ZSet数据结构）![[Pasted image 20251122141730.png]]![[Pasted image 20251122142234.png]]
		- max
			- 第一页：当前时间戳
			- 之后：上一次分页结果的最小时间戳
		- count：你每一页的个数
		- offset：在上一次分页，有几个和最小时间戳一样的时间戳，就跳过几个
    

![[Pasted image 20251122151533.png]]




