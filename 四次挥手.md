
### 四次挥手过程详解
^f09cf3

![[Pasted image 20250916201639.png]]

TCP使用四次挥手机制可靠地关闭连接，确保数据的完整传输和资源的优雅释放。整个过程如下：

1. ​**第一次挥手**​：服务器应用程序调用`close()`，协议栈创建FIN包（FIN比特=1）并发送给客户端，状态变为FIN-WAIT-1
    
2. ​**第二次挥手**​：客户端协议栈收到FIN包后，回送ACK包，状态变为CLOSE-WAIT，并通知应用程序连接已关闭
    
3. ​**第三次挥手**​：客户端应用程序调用`close()`，协议栈创建FIN包并发送给服务器，状态变为LAST-ACK
    
4. ​**第四次挥手**​：服务器收到FIN包后，回送ACK包，状态变为TIME-WAIT
    

### TIME-WAIT状态的重要性

服务器在发送最后一个ACK后进入TIME-WAIT状态，等待2MSL（最大报文段生存时间），这一设计有两个关键目的：

1. ​**可靠地终止连接**​：如果最后一个ACK包丢失，客户端会超时重传FIN包，处于TIME-WAIT状态的服务器可以重发最后一个ACK
    
2. ​**让旧的包在网络中消失**​：等待2MSL时间可以确保本次连接产生的所有网络包都因超时而在网络中消失，不会被之后复用了相同四元组（源IP、源端口、目的IP、目的端口）的新连接错误地接收。

### 减轻TIME-WAIT状态的副作用（端口耗尽）
#### 方案一：应用程序设计（首选且最优雅）

​**让客户端承担TIME-WAIT状态，服务器避免成为主动关闭方。​**​

- ​**原理**​：在典型的C/S架构中，由客户端来主动关闭连接。这样，TIME-WAIT状态就分布在成千上万的客户端上，而服务器的端口资源不会被占用。
    
- ​**如何实现**​：
    
    - ​**HTTP服务器**​：在HTTP/1.1中，默认是持久连接。可以在服务器端设置 `Connection: close`头部，但**让客户端先发起TCP关闭**​（即客户端先发送FIN）。服务器收到FIN后，回复FIN-ACK，然后进入CLOSE-WAIT状态。当服务器也调用`close()`时，它成为主动关闭方，但此时客户端已经进入TIME-WAIT，服务器会快速进入CLOSED状态。
        
    - ​**其他协议**​：在设计应用层协议时，明确约定由客户端负责发起关闭。
        
    
- ​**优点**​：无需修改系统参数，符合设计原则，分布式解决。
    

#### 方案二：使用Socket选项（最常用且有效）

通过设置Socket选项，允许内核**安全地重用**处于TIME-WAIT状态的套接字地址。

- **​`SO_REUSEADDR`​**：
    
    - ​**作用**​：允许一个正在监听的服务端套接字绑定到一个处于TIME-WAIT状态的地址（IP:Port）。这是**服务器重启后能立即绑定的关键**。
        
    - ​**代码**​：
        ```
        int optval = 1;
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
        bind(sockfd, ...);
        ```
        
    - ​**注意**​：`SO_REUSEADDR`主要解决了**绑定**问题，但对于客户端发起新连接的作用有限。
        
    
- **​`SO_REUSEPORT`​** (Linux 3.9+):
    
    - ​**作用**​：允许**多个套接字**​（包括来自不同进程的）绑定到**完全相同**的地址和端口。这对于负载均衡非常有用，并且间接帮助了端口复用。
        
    
- ​ **`net.ipv4.tcp_tw_reuse`**  (内核参数):
    
    - ​**作用**​：允许内核将处于TIME-WAIT状态的连接**重新用于新的出站连接**。这是**解决客户端端口耗尽问题的利器**。
        
    - ​**条件**​：内核必须确保这是安全的。它依赖于**时间戳选项**​ (`net.ipv4.tcp_timestamps=1`，默认开启)，新的时间戳必须严格大于该连接上次使用的时间戳。这保证了即使有旧连接的迷途报文，也会因为时间戳过期而被丢弃。
        
    - ​**设置**​：
        ```
        # 启用tcp_tw_reuse (仅用于出站连接)
        sysctl -w net.ipv4.tcp_tw_reuse=1
        ```
        
    - ​**效果**​：客户端可以快速复用处于TIME-WAIT状态的端口来发起新的对外连接。
        

#### 方案三：调整内核参数（需谨慎）

这些参数可以**减少**TIME-WAIT状态的持续时间或数量，但必须充分理解其含义。

-  ​ **`net.ipv4.tcp_max_tw_buckets`** ：
    
    - ​**作用**​：系统允许存在的TIME-WAIT连接的最大数量。超出后，系统会**强制销毁**最早的TIME-WAIT连接。
        
    - ​**风险**​：这是一种“蛮力”解决方案，破坏了TIME-WAIT的保护机制，可能导致不可预知的问题。​**一般不推荐在生产环境使用**，仅作为最后的手段。
        
    - ​**设置**​：
        
        bash
        
        复制
        
        ```
        sysctl -w net.ipv4.tcp_max_tw_buckets=20000
        ```
        
    
- ​ **`net.ipv4.tcp_tw_recycle`** ​ (**已废弃，切勿使用！​**):
    
    - 这是一个古老且危险的内核参数。它曾经用于快速回收TIME-WAIT连接，但它在NAT（网络地址转换）环境下有严重问题，会导致来自不同客户端的连接被错误地丢弃。​**在Linux 4.12及以后的内核中已被彻底移除**。在任何现代系统中都不应再使用它。
### 套接字删除时机

- ​**客户端**​：在收到服务器的最后一个ACK包后，立即删除套接字，释放资源
    
- ​**服务器**​：在TIME-WAIT状态结束后（等待2MSL时间后），才删除套接字，释放端口等资源
    
