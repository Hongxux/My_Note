

### 1. 核心基础：序列号与确认机制

所有判断都建立在两个基石之上：

- ​**序列号：​**​ 每个字节数据都有一个唯一序列号，每个TCP段的首部序列号表示该段的第一个字节的序列号。
    
- ​**累积确认：​**​ 接收方发送的确认号表示：​**所有小于此确认号的数据已按序成功接收**。例如，ACK 1001 意味着序列号 1000 及之前的所有字节都已收到。
    

基于此，我们来看TCP如何做出区分。

---

### 2. 区分失序与丢失

失序和丢失在发送方看来最初的表现是一样的：​**期望的ACK没有到来**。TCP主要通过**重复ACK**​ 和**超时定时器**​ 来协同判断。

| 机制          | 如何工作                                                                                      | 如何用于区分                                                                                                                                                                                                            |
| ----------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ​**重复ACK**​ | 当接收方收到一个**序列号大于期望值**的数据段时，它认为中间有数据段缺失（可能是失序或丢失）。它会**立即**为最后一个按序收到的字节**重新发送ACK**​（即重复ACK）。 | ​**失序：​**​ 如果只是短暂失序，缺失的数据段可能会在几个重复ACK之后到达。一旦到达，接收方会发送一个确认了所有数据的ACK，空洞被填上。  <br>​**丢失：​**​ 如果缺失的数据段是真的丢失了，接收方会**持续地**为同一个序列号发送重复ACK。发送方收到**3个或以上**的重复ACK（`dupthresh`，通常为3）时，则**强烈推断**该数据段已丢失，从而触发**快速重传**，而不必等待超时。 |
| ​**超时定时器**​ | 发送方每发送一个数据段（或一组），都会启动一个重传定时器。                                                             | 这是**最后的手段**。如果既没有新的ACK，也没有足够多的重复ACK（例如，丢失了多个数据段，导致无法触发3个重复ACK），定时器就会超时。​**超时意味着最严重的怀疑——数据包可能丢失了，或者网络路径发生了严重问题**，此时会触发**超时重传**。                                                                                    |

​**核心思想：​**​ TCP通过**重复ACK的频率**来区分。短暂的、少量的重复ACK很可能是失序；持续、大量的重复ACK则判定为丢失。超时是最终的判断。

​**现代增强：SACK**​

基础TCP机制可能会将多重失序误判为多重丢失。​**选择确认**​ 选项通过允许接收方在ACK中告知发送方**所有已成功收到的非连续数据块**，极大地改善了这一点。发送方可以清晰地看到哪些是真正丢失的（空洞），哪些只是失序但已到达的，从而只重传真正丢失的数据段。

---

### 3. 区分重复数据包

这主要是**接收方**的责任。接收方维护一个变量`RCV.NXT`，表示下一个期望接收的字节序列号。

对于每一个收到的数据段，接收方会检查其序列号：

1. ​**序列号 < `RCV.NXT`**​
    
    - ​**判断：​**​ 这是一个**完全重复**的旧数据包（或者是严重延迟的）。
        
    - ​**动作：​**​ ​**直接丢弃**这个数据段。然后，​**再次发送一个ACK**，其确认号仍然是当前的`RCV.NXT`，以通知发送方对方已收到哪些数据。
        
    
2. ​**序列号 >= `RCV.NXT`**​
    
    - 检查该数据段是否落在当前的接收窗口内。
        
    - 如果是新数据，则正常接收和处理。
        
    

​**例子：​**​

- 接收方期望接收序列号 1500 (`RCV.NXT = 1500`)。
    
- 它收到了一个序列号为 1000-1499 的数据段。
    
- 因为它已经确认过 1500 之前的所有数据（可能ACK在途中丢失，导致发送方重传），它知道这是一个重复包。
    
- 接收方会丢弃它，并再次发送 ACK 1500。
    

---

### 面试官可能关心的方面及参考答案

​**Q1: 为什么是3个重复ACK才触发快速重传，而不是2个或4个？​**​

​**A:​**​ 这是一个工程上的权衡，主要为了**抵御数据包失序**而非丢包。

- ​**设得太低（如2个）​**​： 网络中轻微的数据包失序很常见。如果阈值是2，很容易误将失序判断为丢失，导致不必要的重传。
    
- ​**设得太高（如4个）​**​： 虽然更能避免误判，但意味着需要更长的时间才能触发重传，增加了等待延迟。
    
- ​**3是经验值**​： 在大多数网络环境中，​**出现3次及以上重复ACK极大概率是因为数据包丢失**，而非简单的失序。这个值在响应速度和抗干扰性之间取得了良好平衡。
    

​**Q2: 如果接收方收到了一个序列号正确但校验和错误的数据包，会发生什么？​**​

​**A:​**​ 接收方会**直接丢弃**这个损坏的数据包，​**不会发送任何ACK**。对于发送方来说，这和**丢失**的表现是完全一样的：要么等待足够的重复ACK来触发快速重传，要么最终等待超时。TCP的可靠性机制同时处理**丢包**和**比特差错**这两种情况。

​**Q3: 除了重复ACK，现代Linux系统还用什么更先进的机制来检测丢包？​**​

​**A:​**​ ​**RACK**。传统重复ACK计数依赖于ACK本身的数量，而**RACK基于时间**。RACK的核心思想是：如果一个数据包在它**之后**发送的数据包都已经被ACK了，而它自己还没有被确认，那么就有理由认为它很可能已经丢失了。这种方法对重排序的容忍度更高，能更快地检测出丢失，正在逐渐成为新的标准（如Linux默认启用）。

​**总结：​**​ TCP并非能“未卜先知”，而是像一个侦探，通过**序列号、ACK、重复ACK、定时器**这些“线索”，基于一套严谨的规则（协议）来进行推理和判断。其设计哲学是：​**在无法确知网络状态的情况下，通过保守的规则和积极的重传来保证可靠性。​**
