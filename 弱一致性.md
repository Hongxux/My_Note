---
aliases:
  - 最终一致性
---
- 需求背景：
	- 强一致性的可用性弱，分区故障容忍程度低：
		- 在分布式系统（如全球化的电商网站、社交网络）中，任何组件的故障都不应导致整个服务不可用。
	- 强一致性需要同步阻塞，降低吞吐量，提高延迟
- 解决措施：弱一致性，改变了对于写入操作完成的判断标准
	- 对于写入操作完成的判断标准：写入操作只需在本地或一个节点成功即可立即返回
		- 剩余同步操作异步执行
		- 即使某个副本暂时不可用，写入操作仍然可以在可用的副本上成功完成，系统整体继续保持服务状态。
- 
- 特点：最终一致性
	- 确保是某个时间点的有效状态，绝不会返回一个损坏的、中间状态的数据
	- 不保证能绝对实时地反映当前最新的、精确的数据状态
- 核心思想：通过可靠的消息传递、变更捕获或数据库复制机制，将同步阻塞操作转化为异步操作，并辅以重试、幂等和监控告警，在保障系统可用性和性能的前提下，确保数据最终达成一致。
- 实现方式：
	- 基于消息队列的可靠异步通知：通过消息队列的持久化和重试机制，保证“更新通知”这个动作最终一定能被消费方接收到。
		- **技术组件**：Kafka, RocketMQ, RabbitMQ（持久化模式）, Pulsar。
	- 数据库变更日志捕获：读取数据库的二进制日志来感知数据变化，更新其他缓存
		- **技术组件**：Debezium, Canal, Maxwell + Kafka Connect
	- 写后读敏感的强制特定会话的读请求走主库：利用数据库自身的主从复制功能来实现的弱一致性
		- **场景**：写操作后，允许后续的读请求被路由到从库，而主从复制存在毫秒级的延迟。
		- **实现**：
			- 应用层或中间件（如ShardingSphere、数据库代理）根据SQL类型进行路由：写操作走主库，读操作走从库。
			- 对于“写后读”敏感的场景，可以强制特定会话的读请求走主库（如使用Spring的`@Transactional(readOnly=false)`）。
	-  冲突解决与状态收敛

		- 需求背景：对于多主复制的分布式数据库（如Cassandra、DynamoDB）或AP架构的系统，同一数据可能在多个节点被并发更新，产生冲突。弱一致性系统需要有能力解决冲突。
		- **技术**：
		    - “最后写入获胜”：简单但可能丢失更新，需要客户端提供高精度时间戳。
		    - 版本向量/CRDTs：更先进的数据结构，可以无冲突地合并并发更新，特别适合计数器、购物车等场景。
	- TCC：
		- 需求背景：对于跨服务的复杂业务逻辑，无法使用数据库事务保证强一致性。TCC是一种业务层面的最终一致性模式。