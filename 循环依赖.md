
循环依赖是指两个或多个 Bean 相互依赖，形成一个闭环。例如，Bean A 依赖 Bean B，而 Bean B 又依赖 Bean A。Spring 通过巧妙的设计解决了特定场景下的这个问题。

 Spring 解决循环依赖的核心机制——**[[三级缓存]]**

| 场景     | 依赖模式               | 结果  | 根本原因                             |
| ------ | ------------------ | --- | -------------------------------- |
| **成功** | Singleton + Setter | 正常  | 利用**三级缓存**和**提前曝光**机制，打破循环等待。    |
| **失败** | Prototype + Setter | 异常  | 原型模式**无缓存**，无法提前曝光引用，导致死循环。      |
| **特例** | 混合作用域（含Singleton）  | 正常  | 循环链中存在单例Bean作为“锚点”，可通过曝光其引用解决问题。 |

### 一、 成功 scenario：Singleton + Setter 模式
这种模式成功的关键在于 Spring 容器的 **“三级缓存”** 机制和 **“提前曝光”** 策略。
**核心原理**：Spring 将 Bean 的创建分为两个核心阶段：
1. **实例化**：调用构造方法创建一个“不完整”的 Bean（此时属性均为 null）。
2. **属性赋值**：为这个“不完整”的 Bean 注入它所需的依赖。
关键在于，在第一阶段完成后、第二阶段开始前，Spring 会**提前将这个“不完整”的 Bean 的引用（早期引用）暴露出来**，供其他 Bean 依赖。这样就打破了循环等待。
### 二、 失败 scenario：Prototype + Setter 模式

当 Bean 的作用域被定义为 `prototype`时，Spring 容器的行为发生了根本变化：
- 无缓存：Spring 容器**不会缓存**原型 Bean 的实例。每次请求都会创建一个全新的对象。
- 无法曝光：由于没有缓存，Spring 无法像处理单例 Bean 那样“提前曝光”一个正在创建中的原型 Bean 的引用。
- 死循环：当尝试创建原型 Bean A 时，发现它需要 B；去创建原型 Bean B 时，又发现它需要 A。由于没有提前暴露的引用，创建过程会陷入“A 等 B，B 等 A”的死循环。
	- “当两个 bean 的 scope 都是 prototype 的时候，才会出现死循环。如果其中任意一个是 singleton，就不会出现异常。”
### 三、失败 构造器注入

这与 Spring Bean 的创建流程和三级缓存机制有关：
1. **构造器注入的时机不可协调**：构造器注入发生在 Bean **实例化**的阶段。要调用 `new A(B b)`，就必须先有一个完整的 `B`的实例。反之，要创建 `B`，又需要先有完整的 `A`。双方都卡在第一步，无法继续 。
2. **三级缓存失效**：Spring 解决 Setter 注入循环依赖的秘诀在于**三级缓存**。它允许在 Bean 实例化后、属性填充前，提前将一个“半成品”Bean（早期引用）暴露出来。然而，构造器注入连“实例化”这一步都无法完成，根本来不及将工厂对象放入三级缓存，因此这个机制完全失效 。
- 解决措施：
	- 使用 `@Lazy`注解
		 - Spring不会立即初始化被`@Lazy`标记的依赖，而是会**注入一个代理对象**。只有当这个代理对象第一次被真正使用时，才会去初始化真正的Bean实例。
	- 重新设计代码（根治方法）
		-  抽取公共逻辑：将A和B相互依赖的部分提取到一个新的类C中，让A和B都依赖C。
		- 应用中介者模式：引入一个中介者来协调A和B之间的交互，避免它们直接互相引用
		-  使用事件驱动：让A完成某个动作后发布一个事件，由B来监听这个事件，从而替代直接的调用。