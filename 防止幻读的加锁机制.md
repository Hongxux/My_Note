### 默认临键锁的行为特征

#### 1. ​**锁范围更大**（左开右闭）​

每个锁都是 ​**行锁 + 间隙锁**​ 的组合，锁定左开右闭的区间。

​**示例**​：表中有 `id = 5, 10, 15`

- `SELECT * FROM t WHERE id = 7 FOR UPDATE;`
    
    - ​**退化后**​：间隙锁 `(5, 10)`
        
    - ​**无退化**​：临键锁 `(5, 10]`（额外锁定 `id=10`的行）
        
    

#### 2. ​**遍历到第一个不满足条件的值**​

无论什么查询，都会向右遍历直到找到第一个不满足条件的索引项，并对其加临键锁。

​**示例**​：

```
SELECT * FROM t WHERE id < 10 FOR UPDATE;
```

- ​**无退化**​：锁定 `(-∞, 10]`（找到 `id=10`并加锁）
    
- 这与优化后的行为一致，因为范围查询需要严格防止幻读
    

#### 3. ​**普通索引查询锁范围更大**​

对于普通索引的等值查询，会锁定所有相关记录和间隙，不会退化。

​**示例**​：`WHERE age = 20`

- ​**退化后**​：锁定所有 `age=20`的记录+间隙，对 `age=30`只加间隙锁
    
- ​**无退化**​：锁定所有 `age=20`的记录+间隙，对 `age=30`加临键锁 `(20, 30]`
### 第一步：定位起点（找到“第一把锁”从哪里开始）

InnoDB 会根据你的查询条件，在索引的 B+Tree 上进行查找，定位到**第一个满足查询条件的索引项**。这个索引项就是加锁的起点。

- ​**等值查询（`where id = 5`）​**​：直接查找 `id=5`的位置。
    
- ​**范围查询（`where id > 5`）​**​：找到第一个大于5的值，比如 `id=10`。
    

### 第二步：向右遍历并加锁（决定“锁到哪里结束”）

这是最关键的一步。从定位到的起点开始，InnoDB 会沿着索引顺序**向右（正方向）扫描**，并对扫描到的每一个索引记录加上临键锁。​**遍历不会在找到最后一条满足条件的记录时停止，而是会继续扫描，直到遇到第一个不满足查询条件的记录为止。​**​

这个 ​**​“第一个不满足条件的记录”​**​ 就是锁范围的右边界。

---

### 场景详解（对应流程图路径）

让我们用具体例子来解释流程图的各个路径。假设有表 `t`，主键索引 `id`有数据 `5, 10, 15, 20`。

#### 路径 ①: 等值查询 + 唯一索引 + 记录存在

- ​**查询**​：`SELECT * FROM t WHERE id = 10 FOR UPDATE;`
    
- ​**决策过程**​：
    
    1. 在唯一索引上精准定位到 `id=10`这条记录。
        
    2. 因为记录存在且索引唯一，可以确定不会有其他记录满足 `id=10`。
        
    3. ​**加锁范围**​：InnoDB 此时会进行优化，​**只对这一行加行锁**，而不会加临键锁。因为锁住这一行就足以保证数据一致性。
        
    

#### 路径 ②: 等值查询 + 唯一索引 + 记录不存在

- ​**查询**​：`SELECT * FROM t WHERE id = 7 FOR UPDATE;`
    
- ​**决策过程**​：
    
    1. 在索引中查找 `id=7`，发现不存在。
        
    2. 找到 `7`应该所在的位置，即在 `5`和 `10`之间。
        
    3. 为了防止其他事务插入 `id=7`（幻读），必须锁住这个间隙。
        
    4. ​**加锁范围**​：InnoDB 会找到 `7`的下一个记录 `10`，并对其加临键锁。但因为它不满足等值条件，所以优化为**间隙锁 `(5, 10)`**。
        
    

#### 路径 ③: 等值查询 + 普通索引

- ​**查询**​：假设在 `score`列上有普通索引，数据为 `...70, 70, 80, 80, 90...`。执行 `SELECT * FROM t WHERE score = 80 FOR UPDATE;`
    
- ​**决策过程**​：
    
    1. 找到第一个 `score=80`的记录。
        
    2. 由于是非唯一索引，后面可能还有多个 `80`，所以会锁住所有 `score=80`的记录及其前后的间隙。
        
    3. 继续向右遍历，直到找到第一个 `score != 80`的记录（比如 `score=90`）。
        
    4. ​**加锁范围**​：对第一个不满足条件的值 `90`，其临键锁会退化为间隙锁，即锁住 `(80, 90)`这个区间。所以最终锁定了所有 `80`相关的记录和间隙，以及 `(80, 90)`这个间隙。
        
    

#### 路径 ④: 范围查询（以唯一索引为例）

- ​**查询**​：`SELECT * FROM t WHERE id > 10 AND id < 20 FOR UPDATE;`
    
- ​**决策过程**​：
    
    1. 定位到第一个大于10的值，即 `id=15`，并加上临键锁 `(10, 15]`。
        
    2. 继续向右扫描，找到 `id=20`。
        
    3. 判断 `id=20`是否满足 `id < 20`？​**不满足**。
        
    4. ​**加锁范围**​：​**遍历到此停止**，但对这个“第一个不满足条件的记录” `id=20`依然要加临键锁 `(15, 20]`，以确保 `id=19`这样的值也无法插入。所以最终锁定了 `(10, 20]`。
        
    

### 特殊边界：Supremum Record（上确界记录）

如果一个查询条件覆盖了最大值之后的范围，比如 `id > 20`，InnoDB 在索引中定义了一个**伪记录**​（Supremum Record），它代表比索引中任何值都大的“无穷大”。这时，临键锁的范围就会是 `(20, +∞)`。

---

### 总结：决定临键锁范围的关键因素

|关键步骤|说明|示例（查询 `WHERE ...`）|锁范围右边界|
|---|---|---|---|
|​**1. 定位起点**​|在B+Tree中找到第一个可能满足条件的记录。|`id = 7`|记录 `10`|
|​**2. 向右遍历**​|沿索引向右扫描，给每个记录加临键锁。|`id > 10`|扫描经过 `15`, `20`...|
|​**3. 确定终点**​|​**遇到第一个不满足条件的记录时停止**，并对其加临键锁。|`id < 15`|第一个 `id >= 15`的记录（即 `15`）|
|​**4. 索引类型**​|​**唯一索引**可能触发优化（退化为行锁/间隙锁），​**普通索引**锁范围更大。|`score = 80`（普通索引）|第一个 `score != 80`的记录（如 `90`）|

​**核心口诀**​：​**找到起点，向右扫描，锁到第一个不满足条件的记录为止。​**​ 这个机制确保了查询范围内不会有新的“幻影行”插入，从而彻底解决了幻读问题。