## maven的作用

#### 一、 项目对象模型 - 项目的“身份证”与“蓝图”

图中左侧的 ​**POM**​ 是 Maven 工作的绝对核心，它是一个名为 `pom.xml`的配置文件。

- ​**项目信息**​：像身份证一样定义了项目的基本信息（`groupId`, `artifactId`, `version`等），这些坐标用于在仓库中唯一标识你的项目。
    
- ​**项目配置**​：
    
    - ​**依赖列表**​：声明项目所依赖的第三方库（Jar 包）。Maven 会根据这些声明**自动从仓库下载和管理**这些依赖，彻底解决了“Jar 包地狱”问题。
        
    - ​**插件配置**​：配置如何完成编译、测试、打包等构建环节的插件。
        
    
- ​**继承与聚合**​：支持多模块项目的管理，父POM可以管理子模块共用的依赖和配置。
    

​**简单来说，`pom.xml`告诉 Maven：“你是谁”、“你依赖谁”以及“如何构建你”。​**​

#### 二、 构建生命周期 - 标准化的“流水线”

图中部展示了 Maven 的**构建生命周期**，这是一套预设的、有序的构建阶段。

- ​**标准化**​：Maven 定义了清晰的生命周期阶段，如 `compile`（编译）、`test`（测试）、`package`（打包）、`install`（安装到本地仓库）、`deploy`（部署到远程仓库）。这保证了所有 Maven 项目都遵循同样的构建流程。
    
- ​**命令驱动**​：用户只需要执行简单的命令（如 `mvn compile`、`mvn package`），Maven 就会自动按顺序执行该阶段及其之前的所有阶段。
    
- ​**插件绑定**​：生命周期的每个阶段的具体任务（如 `compile`阶段调用 javac 编译器），实际上是由 Maven ​**插件**​ 完成的。生命周期本身只定义阶段，插件负责实现功能。
    

​**这相当于为软件构建定义了一条标准生产流水线，开发者只需下命令，Maven 会自动完成流水线上的所有工序。​**​

#### 三、 依赖管理与仓库体系 - 强大的“后勤系统”

这是图中右侧部分，也是 Maven 最广为人知的功能。

- ​**依赖管理**​：在 `pom.xml`中声明依赖后，Maven 会自动解决这些依赖的传递性（即依赖的依赖），并下载所有必要的 Jar 包。
    
- ​**三层仓库体系**​：
    
    1. ​**本地仓库**​：你本机磁盘上的一个目录（如 `~/.m2/repository`），用于缓存所有下载过的依赖。优先从这里查找，无需重复下载。
        
    2. ​**中央仓库**​：由 Maven 社区维护的全球唯一的、默认的远程仓库（地址：[https://repo1.maven.org/maven2/](https://repo1.maven.org/maven2/)），包含了绝大多数开源Java库。
        
    3. ​**远程仓库（私服）​**​：公司或团队在内网搭建的私有仓库。它作为中央仓库的代理和缓存，也用于部署公司内部的私有组件。​**工作流程通常是：项目优先从本地仓库查找依赖，未找到则请求远程仓库/私服，若仍未找到，私服会从中央仓库下载并缓存，再返回给用户。​**​
        
    

### 总结：Maven 的价值

这张图展示的 Maven 架构，通过标准化和自动化，为 Java 开发带来了巨大好处：

1. ​**简化构建过程**​：一条命令即可完成编译、测试、打包等复杂流程。
    
2. ​**高效的依赖管理**​：自动下载和管理依赖，解决版本冲突。
    
3. ​**项目信息透明化**​：`pom.xml`使项目结构、依赖关系一目了然。
    
4. ​**促进项目一致性**​：所有使用 Maven 的项目都遵循相同的结构和构建方式，易于理解和维护。
    

简单来说，​**Maven 将 Java 项目的构建、依赖和管理从一项复杂且易错的手工劳动，变成了一套高效、可靠、标准的自动化工程体系。​**​ 理解了这张图，就掌握了 Maven 最核心的思想。


## maven的安装和配置

#### 一、 解压安装包

- ​**操作**​：将下载的 `apache-maven-3.6.1-bin.zip`压缩包解压到一个**没有中文和空格**的路径下。
    
- ​**示例**​：`D:\Program Files\apache-maven-3.6.1`
    
- ​**要点**​：这相当于绿色安装，Maven 本身无需执行安装程序，解压即可用。
    

#### 二、 配置本地仓库（关键步骤）

- ​**配置文件**​：修改解压目录下 `conf/settings.xml`文件。
    
- ​**配置项**​：找到 `<localRepository>`标签，将其修改为一个自定义路径。
    
    ```
    <localRepository>E:\develop\apache-maven-3.6.1\mvn_repo</localRepository>
    ```
    
- ​**作用与重要性**​：
    
    - ​**本地仓库**是 Maven 在您电脑上的“本地依赖库”，所有从网上下载的 Jar 包（项目依赖）都会存储在这里。
        
    - ​**默认路径**通常为 `C:\Users\你的用户名\.m2\repository`，将其配置到非系统盘（如 `E:`）可以**避免占用C盘空间**，并便于管理。
        
    - 所有项目会共享这个本地仓库，​**避免相同依赖的重复下载**。
        
    

#### 三、 配置阿里云镜像（加速下载，至关重要）

- ​**配置文件**​：同样在 `conf/settings.xml`文件中。
    
- ​**配置位置**​：在 `<mirrors>`标签内，添加如下子标签：
    
    ```
    <mirror>
        <id>alimaven</id>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
        <mirrorOf>central</mirrorOf>
    </mirror>
    ```
    
- ​**作用与重要性**​：
    
    - Maven 默认从国外的**中央仓库**下载依赖，速度非常慢且可能失败。
        
    - 此配置将下载源**切换为国内的阿里云镜像服务器**，利用 `<mirrorOf>central</mirrorOf>`指明用它来代理所有对中央仓库的请求。
        
    - 这是在中国大陆网络环境下**大幅提升依赖下载速度、保证构建成功率**的关键一步。
        
    

#### 四、 配置环境变量（方便命令行使用）

- ​**操作**​：
    
    1. 新建系统变量 `MAVEN_HOME`，值为 Maven 的解压目录（如 `D:\Program Files\apache-maven-3.6.1`）。
        
    2. 修改系统变量 `PATH`，添加 `%MAVEN_HOME%\bin`。
        
    
- ​**作用与重要性**​：
    
    - 配置后，您可以在任何路径下的命令行终端（如 CMD、PowerShell）中直接输入 `mvn`命令来使用 Maven，而无需每次都进入 Maven 的安装目录。
        
    - 这是**实现全局命令调用的标准做法**。
        
    

### 验证安装

完成以上所有步骤后，​**需要打开一个新的命令提示符窗口**，执行以下命令来验证安装是否成功：

```
mvn -v
```

如果配置正确，命令行将显示 Maven 的版本、Java 版本等信息。

### 总结

这张图的核心价值在于，它不仅列出了安装步骤，更指出了两个**针对生产环境的优化配置**​：

1. ​**换源**​：通过配置阿里云镜像，解决网络问题，这是顺利使用 Maven 的前提。
    
2. ​**定制路径**​：通过配置本地仓库路径，合理管理磁盘空间，避免C盘爆满。
    

遵循这个流程，您可以快速搭建一个高效、可靠的 Maven 工作环境。

## IDEA中集成Meavn

#### 一、 进入配置界面

1. 打开或创建一个项目。
    
2. 点击顶部菜单栏：​**`File`（文件）​**​ -> ​**`Settings`（设置）​**。
    
3. 在左侧设置窗口中，依次展开：​**`Build, Execution, Deployment`**​ -> ​**`Build Tools`**​ -> ​**`Maven`**。
    

#### 二、 关键配置项详解

到达 `Maven`配置页面后，您需要关注以下三个核心配置，图中已用截图高亮显示：

|配置项|英文名|作用与配置说明|
|---|---|---|
|​**Maven 主路径**​|`Maven home path`|这里需要指定您**本地安装的 Maven 的根目录**。例如：`D:\Program Files\apache-maven-3.6.1`。指定后，IDEA 将不再使用其自带的 Maven。|
|​**用户设置文件**​|`User settings file`|这是**最关键的一步**。需要指向您本地 Maven 的 `conf/settings.xml`文件。​**务必勾选后面的 `Override`复选框**，以确保 IDEA 使用您修改过的配置（如阿里云镜像）。例如：`D:\Program Files\apache-maven-3.6.1\conf\settings.xml`。|
|​**本地仓库**​|`Local repository`|当您正确指定了 `User settings file`后，这个字段通常会**自动更新**为 `settings.xml`文件中 `<localRepository>`标签所配置的路径。它显示了您的依赖包最终存储在本地磁盘的哪个位置。|

#### 三、 附加配置：Java 编译器版本

图的右下角还展示了另一个重要配置，它虽不在 Maven 设置下，但与 Maven 项目构建密切相关：

- ​**路径**​：`Settings`-> `Build, Execution, Deployment`-> `Compiler`-> `Java Compiler`
    
- ​**配置项**​：`Project bytecode version`
    
- ​**作用**​：这里设置项目编译后生成的 `.class`文件的**目标字节码版本**。例如，设置为 `11`，即表示项目将使用 Java 11 的语言特性进行编译，并生成兼容 Java 11 虚拟机的字节码。
    
- ​**与 Maven 的关系**​：在 Maven 的 `pom.xml`中，我们也可以通过 `<maven.compiler.source>`和 `<maven.compiler.target>`属性来配置此选项。IDEA 中的这个设置会与 `pom.xml`中的配置交互，通常以 `pom.xml`的配置为准，但 IDEA 的配置可以作为覆盖或备用。
    

### 为什么要进行这样的配置？

1. ​**版本控制与一致性**​：确保团队所有成员使用**相同版本**的 Maven 和构建配置，避免因环境差异导致构建结果不一致。
    
2. ​**使用自定义配置**​：只有使用本地 Maven，您在 `settings.xml`中配置的**国内镜像源**​（如阿里云）才能生效，从而大幅提升依赖下载速度。
    
3. ​**资源管理**​：可以自定义**本地仓库**的位置，避免默认路径（C盘）空间不足的问题。
    

## Maven 坐标

Maven 坐标是 Maven 管理项目和各种库（Jar 包）的唯一身份标识系统。它类似于现实世界中的“地理坐标”，通过一组特定的标识符，可以在全球范围内唯一地定位到某一个项目或资源。

### 坐标的三大核心组成部分

坐标由三个基本元素构成，它们共同定义了一个项目的唯一身份：

| 坐标元素 | 含义与作用 | 示例 |
| :--- | :--- | :--- |
| `groupId` | 组织/公司标识。通常使用公司或组织域名的反写，以保证全球唯一性。 | `com.itheima`（表示 itheima 公司） |
| `artifactId` | 项目/模块名称。代表该组织下的一个具体项目或模块。 | `order-service`（订单服务模块） |
| `version` | 版本号。指定项目的当前版本，用于管理迭代和依赖。 | `1.0-SNACHSHOT`（1.0 的快照版） |

组合起来：`groupId:artifactId:version` 就像一个完整的地址：`国家.城市.街道.门牌号`。例如，`com.itheima:maven-project01:1.0-SNAPSHOT` 就唯一指向了“itheima 公司下的 maven-project01 项目的 1.0 快照版”。

### 坐标的两种核心用途

图中下方的两个代码框清晰地展示了坐标的两种应用场景：

#### 1. 声明本项目身份（“我是谁”）

在项目的 `pom.xml` 文件中，使用坐标来声明项目自身的身份。
```xml
<groupId>com.itheima</groupId>
<artifactId>maven-project01</artifactId>
<version>1.0-SNAPSHOT</version>
```
这告诉 Maven 和所有其他开发者：这个项目的唯一标识符就是 `com.itheima:maven-project01:1.0-SNAPSHOT`。

#### 2. 声明项目依赖（“我需要谁”）

当你的项目需要用到第三方库（如日志工具 `logback`）时，在 `pom.xml` 的 `<dependencies>` 节中，通过坐标来精确引入。
```xml
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```
这告诉 Maven：“请帮我找到 `ch.qos.logback:logback-classic:1.2.3` 这个库，并把它引入到我的项目中。” Maven 会根据这个坐标，自动从本地仓库或远程仓库（如 Maven中央库）找到并下载该依赖。

### 关于版本号 `SNAPSHOT`

示例中的 `1.0-SNAPSHOT` 是一个特殊版本标识：
•   `SNAPSHOT`（快照版）：表示该项目处于开发中的、不稳定的版本。Maven 会定期检查远程仓库是否有该快照版的新版本，并可能自动更新，适用于联调阶段。

•   相对应的是 `RELEASE`（发布版），如 `1.0`，表示稳定版本，一旦下载就不会自动更新。




## Meavn依赖管理
### 依赖配置
#### 一、 什么是依赖？

图中给出了明确定义：

> ​**指当前项目运行所需要的jar包，一个项目中可以引入多个依赖。​**​

- ​**本质**​：在 Java 项目中，几乎不可能所有功能都从零开发，需要依赖许多成熟的第三方库（如日志库、数据库驱动、网络框架等）。这些库就是项目的“依赖”。
    
- ​**Maven 的作用**​：Maven 的依赖管理功能可以**自动下载**这些 Jar 包，并管理它们之间的版本依赖关系，彻底解决了“手动下载 Jar 包、添加到构建路径”的繁琐和“Jar 包冲突”问题。
    

#### 二、 配置依赖的四个步骤

图中左侧列出了添加一个依赖的完整操作流程，这是一个非常标准的指南：

1. ​**在 `pom.xml`中编写 `<dependencies>`标签**​
    
    - 这是所有依赖声明的**根容器**。所有需要的依赖都要在这个标签内部声明。
        
    
2. ​**在 `<dependencies>`标签中使用 `<dependency>`引入坐标**​
    
    - 每一个需要的 Jar 包，都需要用一个独立的 `<dependency>`标签来声明。
        
    
3. ​**定义坐标的 `groupId`, `artifactId`, `version`**​
    
    - 这是最关键的一步，即在该 `<dependency>`标签内，通过 ​**Maven 坐标**来精确定位你需要的库。
        
    - ​**`groupId`**​：组织或公司名（如 `ch.qos.logback`）。
        
    - ​**`artifactId`**​：项目或模块名（如 `logback-classic`）。
        
    - ​**`version`**​：所需版本号（如 `1.2.3`）。
        
    
4. ​**点击刷新按钮，引入最新加入的坐标**​
    
    - 在 IDE（如 IntelliJ IDEA 或 Eclipse）中，修改 `pom.xml`文件后，​**必须手动触发**一个“刷新”或“重新导入”操作。
        
    - ​**目的**​：通知 IDE 和 Maven：“我的依赖列表更新了，请现在开始下载新的依赖并更新项目结构。”
        
    - 如果省略这一步，新添加的依赖将不会生效，代码中导入相关类会报错。
        
    

#### 三、 代码示例详解

图中右侧的代码是一个标准示例：

```
<dependencies>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.3</version>
    </dependency>
</dependencies>
```

- ​**解读**​：这段配置声明了该项目需要依赖 ​**Logback**​ 这个日志组件的经典版，具体版本是 ​**1.2.3**。
    
- ​**工作流程**​：
    
    1. 当你将这段配置加入 `pom.xml`并点击“刷新”后。
        
    2. Maven 会读取这个坐标。
        
    3. 首先在**本地仓库**查找是否已有 `logback-classic-1.2.3.jar`。
        
    4. 如果本地没有，则会根据配置（如 `settings.xml`中配置的阿里云镜像）连接到**远程仓库**​ 去下载。
        
    5. 下载成功后，该 Jar 包会被添加到项目的 Classpath 中，你就可以在代码里直接 `import`并使用 Logback 的类了。
        
    

#### 总结与最佳实践

这张图是 Maven 入门的关键。它告诉我们：

1. ​**声明式管理**​：你不需要手动“安装” Jar 包，只需在 `pom.xml`中**声明**你需要什么，Maven 会自动处理下载、添加和依赖传递。
    
2. ​**坐标是核心**​：精准的 `groupId`、`artifactId`和 `version`是找到正确依赖的钥匙。
    
3. ​**刷新是必要操作**​：修改 `pom.xml`后，​**切记刷新项目**，这是从配置到生效的触发开关。
    

#### 第一次添加依赖的包
第一次添加依赖的包可以上https://mvnrepository.com/去找
![[Pasted image 20251102205453.png]]![[Pasted image 20251102205618.png]]
然后同步后就会自动下载依赖了
![[Pasted image 20251102205719.png]]


### 依赖传递
![[Pasted image 20251102205957.png]]
![[Pasted image 20251102210213.png]]
简单来说，​**依赖传递性让你“一键获取”完整功能，而排除依赖则让你能“精准修剪”不需要的部分**。理解和掌握这两个概念，是进行高效、无冲突的 Maven 依赖管理的关键。
#### 依赖的传递性

- ​**核心观点**​：在 Maven 中，依赖关系会自动延伸，而不仅限于你直接声明的库。
    
- ​**直接依赖**​：
    
    - ​**定义**​：在当前项目的 `pom.xml`文件中，通过 `<dependency>`标签**直接声明**的依赖。
        
    - ​**示例**​：你的项目直接配置了依赖 A。A 就是你的直接依赖。
        
    
- ​**间接依赖**​：
    
    - ​**定义**​：你的**直接依赖**所依赖的其它资源，会**自动被引入**到你的项目中。
        
    - ​**示例**​：你依赖了 A，而 A 本身又依赖了 B。那么，B 就会成为你项目的**间接依赖**​（或“传递性依赖”）。Maven 会自动帮你把 B 也下载进来。
        
    

​**价值与问题**​：

- ​**价值**​：传递性依赖极大地简化了依赖管理。你不需要关心你所用库的底层依赖，Maven 会帮你自动处理，确保功能的完整性。
    
- ​**问题**​：这也可能引入**依赖冲突**​（例如，两个直接依赖都传递了不同版本的同一个 JAR 包）或**不想要的依赖**。
    

#### 排除依赖

​**主动切断不需要的传递性依赖**。

- ​**核心观点**​：你可以**主动地、精确地**排除掉某个传递性引入的依赖。
    
- ​**工作机制**​：在声明一个直接依赖时，使用 `<exclusions>`标签来指定要排除的间接依赖。
    
- ​**关键**​：排除依赖时，​**只需要指定 `groupId`和 `artifactId`**，而**不需要指定版本号**，因为要排除的是**通过当前这个直接依赖所引入的**特定构件，无论其版本是什么。
    

#### 完整的工作流程与示例

假设你的项目依赖了 `A`，而 `A`传递性地依赖了 `B`。但你不想引入 `B`，可以这样配置：

```
<dependency>
    <groupId>com.example</groupId>
    <artifactId>A</artifactId>
    <version>1.0</version>
    <exclusions>
        <exclusion> <!-- 排除依赖B，无需写version -->
            <groupId>com.example</groupId>
            <artifactId>B</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

#### 总结与应用场景

1. ​**依赖传递性**​ 是 Maven 的自动化特性，它简化了依赖管理。
    
2. ​**排除依赖**​ 是精细控制依赖关系的“手术刀”，用于解决传递性带来的问题。
    

​**典型应用场景**​：

- ​**解决版本冲突**​：当两个依赖传递了不同版本的相同 JAR 包时，可以排除掉不需要的版本。
    
- ​**剔除无用功能**​：如果一个依赖传递了一个你根本用不到的、庞大的模块（例如某个依赖传递了你不用的数据库驱动），可以排除它以减小项目体积。
    
- ​**避免许可证冲突**​：当传递性依赖的许可证与你的项目不兼容时，可以将其排除。
    
### 依赖范围

​**依赖范围**​ 通过 `<scope>`标签来设置，它决定了你声明的这个依赖在哪些环节可以被使用。其本质是**控制 classpath**​（类路径），即该依赖会被添加到哪种类路径中。

#### 四种依赖范围详解

图中的表格是核心，它详细对比了四种主要范围的行为：

| Scope 值            | 主程序（编译） | 测试程序（编译/执行） | 打包/运行 | 典型示例        | 含义与场景                                                                                         |
| ------------------ | ------- | ----------- | ----- | ----------- | --------------------------------------------------------------------------------------------- |
| ​**compile（默认）​**​ | ✅       | ✅           | ✅     | Log4j       | ​**全程有效**。这是默认范围。如果你不写 `<scope>`，就用它。表示该依赖在项目编译、测试、运行时都需要。最终会打包进部署文件（如 WAR/JAR）。              |
| ​**test**​         | ❌       | ✅           | ❌     | JUnit       | ​**仅测试有效**。只在编译和运行测试代码时被添加到 classpath。主程序代码无法使用它。​**不会**打包进最终部署文件。这保证了生产环境没有测试框架的冗余。          |
| ​**provided**​     | ✅       | ✅           | ❌     | Servlet-API | ​**已提供范围**。该依赖在编译和测试时需要，但你**预期目标运行环境（如 Tomcat 服务器）已经提供了这个依赖**。因此，Maven 不会将它打包进最终的部署文件，避免版本冲突。 |
| ​**runtime**​      | ❌       | ✅           | ✅     | JDBC 驱动     | ​**运行时需要**。在编译主代码时不需要该依赖（例如，你的代码只面向 JDBC 接口编程），但在**测试和运行时**需要具体的实现驱动来连接数据库。该依赖**会**被打包。       |

#### 工作原理与示例

​**1. 基础语法**​

在 `pom.xml`的 `<dependency>`标签内使用：

```
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope> <!-- 关键：指定范围 -->
</dependency>
```

​**2. 场景化解读**​

- ​**场景 A：开发 Web 应用**​
    
    - 你需要 `servlet-api`来编译代码（因为代码中用了 `HttpServlet`）。
        
    - 但当你把应用部署到 Tomcat 时，Tomcat 的 `lib`目录下**已经自带**了 `servlet-api.jar`。
        
    - ​**正确做法**​：将 `servlet-api`的 scope 设为 `provided`。
        
    - ​**效果**​：编译测试通过，打包成 WAR 文件时又不会包含它，完美避免与 Tomcat 自带 Jar 包冲突。
        
    
- ​**场景 B：单元测试**​
    
    - 你使用 `JUnit`来编写测试类。
        
    - 这些测试类**只在运行 `mvn test`时才需要**，主业务逻辑根本用不到。
        
    - ​**正确做法**​：将 `JUnit`的 scope 设为 `test`。
        
    - ​**效果**​：保证生产包体积最小化，且业务代码中误用测试框架时会直接编译报错。
        
    
- ​**场景 C：数据库驱动**​
    
    - 你的代码面向 `java.sql.*`接口编写，编译期不需要具体的 MySQL 驱动。
        
    - 但真正运行程序，连接数据库时，必须要有 `mysql-connector-java.jar`。
        
    - ​**正确做法**​：将驱动 scope 设为 `runtime`。
        
    - ​**效果**​：编译成功，且驱动会打包，确保运行时能正常连接数据库。
        
    


## 生命周期
只关注五个主要阶段即可
有三套生命周期：clean，default,site
![[Pasted image 20251102212651.png]]