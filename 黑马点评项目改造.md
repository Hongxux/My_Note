### 点赞评论功能
#### 产品分析：
- 我们的业务满足评论的使用场景
- 核心用户：我根据自我表达意愿的强度分为了三类
	- 内容创作者与深度爱好者：表达欲强
		- 表达方式：是高质量评论（包括“神评”）的主要生产者，乐于分享专业见解或情感共鸣
		- 作用：
			- 他们的分享能激发强烈的共鸣，引发剧烈的讨论，可以说他们就是一个打开倾诉欲望的口子。
			- 一些专业性高的博主，他们分享的知识能满足用户的求知渴望，而且他们的建议也会作为用户选择的一个很大依据。毕竟人性是懒惰的，喜欢跟从一些权威的人。
	- 互动参与型用户：表达欲中等。
		- 表达方式：通过点赞、回复、参与楼中楼讨论来互动
		- 作用：
			- 对于内容创作者与深度爱好者，互动参与型用户的互动能满足自己被认同的心理，能刺激他们发表高质量评论
			- 对于沉默的浏览者，互动参与型用户的互动能丰富他们的信息，验证他们的观点，在其中找到归属感。
			- 这类用户的互动（如B站的“一键三连”）本身会逐渐演变为一种社区集体符号和仪式
	- 沉默的浏览者：表达欲望低，是评论区的“基本面”
		- 参与方式：通过消费评论内容来寻找信息、验证观点或寻求归属感，
		- 作用：
			这类沉默的绝大多数，往往是我们广告和商品销售量的来源，因此我们需要多多促进他们的互动，多多影响他们的认知
		- 价值：理解他们的阅读习惯（如依赖排序、偏好快速浏览）至关重要。
#### 功能实现
- “神评”机制：其标准应多元化，可综合考量点赞数、回复数等互动数据，并引入时间衰减因子，确保能动态反映评论的即时热度和长期价值
- 楼中楼回复：支撑深度讨论的利器。
- 评论的排序机制：综合以下排序方式
	- “热度排序”​ ：适合大多数场景以筛选优质内容
	-  “时间排序”​ ：能保证信息的及时性和讨论的连贯性
	- 基于用户兴趣的个性化推送：让用户更可能看到感兴趣的高质量评论。
- - 需求：用户能怎么互动
	- 功能名称：发表评论
	- 发表评论
		- 盖新的楼
		- 在别人评论下面跟评
	- 查看评论
		- 按照热度查看
		- 按照时间顺序查看
	- 点赞评论
##### 数据模型设计：支撑楼中楼与热度计算
- 需求：支撑楼中楼与热度计算
- 最终决定：
  ```sql
use hmdp;  
-- 博客主表  
CREATE TABLE tb_blog (  
  blog_id BIGINT AUTO_INCREMENT PRIMARY KEY,  
  author_id BIGINT NOT NULL,  
  title VARCHAR(255) NOT NULL, -- 增加长度  
  content TEXT NOT NULL, -- 内容合并回来  
  cover_image_url VARCHAR(500), -- 增加长度，允许为空  
  `status` ENUM('draft', 'published', 'deleted') DEFAULT 'draft', -- 增加状态  
  like_count INT UNSIGNED DEFAULT 0,  
  comment_count INT UNSIGNED DEFAULT 0,  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  
  is_deleted TINYINT(1) DEFAULT 0, -- 软删除  
  FOREIGN KEY (author_id) REFERENCES tb_user(id)  
  -- 在author_id, status, created_at等字段上建立索引  
);  
  
-- 评论表  
CREATE TABLE tb_blog_comment (  
  comment_id BIGINT AUTO_INCREMENT PRIMARY KEY,  
  blog_id BIGINT NOT NULL, -- 关键：关联博客ID  
  user_id BIGINT NOT NULL,  
  parent_id BIGINT DEFAULT 0, -- 父评论ID，0表示顶级评论  
  root_id BIGINT DEFAULT 0, -- 根评论ID，方便查询整棵树  
  content TEXT NOT NULL, -- 内容直接存储，除非有特殊需求  
  like_count INT UNSIGNED DEFAULT 0,  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  
  FOREIGN KEY (blog_id) REFERENCES tb_blog(blog_id),  
  FOREIGN KEY (user_id) REFERENCES tb_user(id)  
  -- 在blog_id, parent_id, created_at等字段上建立索引  
);  
-- 为评论表添加索引  
CREATE INDEX idx_blog_id ON tb_blog_comment(blog_id);  
CREATE INDEX idx_user_id ON tb_blog_comment(user_id);  
CREATE INDEX idx_parent_id ON tb_blog_comment(parent_id);  
CREATE INDEX idx_root_id ON tb_blog_comment(root_id); -- 建议也加上，便于查询评论树  
  
-- 点赞流水表  
CREATE TABLE tb_blog_like_record (  
  id BIGINT AUTO_INCREMENT PRIMARY KEY,  
  blog_id BIGINT NOT NULL COMMENT '被点赞的博客ID',  
  user_id BIGINT NOT NULL COMMENT '点赞的用户ID',  
  action ENUM('liked', 'unliked') NOT NULL DEFAULT 'liked' COMMENT '操作类型: liked-点赞, unliked-取消点赞',  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',  
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',  
  UNIQUE KEY uk_blog_user (blog_id, user_id) COMMENT '防止用户对同一博客重复点赞',  
  FOREIGN KEY (blog_id) REFERENCES tb_blog(blog_id),  
  FOREIGN KEY (user_id) REFERENCES tb_user(id)  
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='博客点赞流水表';
-- 用户点赞或取消点赞 
INSERT INTO tb_blog_like_record (blog_id, user_id, action) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE action = VALUES(action), updated_at = CURRENT_TIMESTAMP;
```
##### 发表评论
- 功能分析：
	- **用户故事**
	    - **用户角色**
	        - **普通用户**：已注册登录，可在指定内容下发表评论。
	        - **游客用户**：未登录，可查看评论或需登录后才能评论。
	        - **内容创作者**：内容发布者，可管理（审核、删除）自己内容的评论。
	    - **用户状态**
	        - **普通用户**：已登录，处于浏览内容页面。
	        - **游客用户**：未登录，可能需引导注册/登录。
	        - **内容创作者**：查看自己发布内容的评论区。
	    - **用户需求**
	        - **普通用户**：表达观点、互动、获得社交认同。
	        - **游客用户**：希望参与讨论，但需先完成登录/注册。
	        - **内容创作者**：获取用户反馈，维护评论区秩序。
	- **使用场景**
	    - 用户阅读文章/观看视频后，在评论区输入文本/图片/表情发表反馈。
	    - 内容创作者在后台查看评论列表，审核或删除违规内容。
	- **执行条件与结果**
	    - **前置条件**：调用评论功能时，必须满足以下条件：
	        - 调用者必须为已登录用户（需提供有效 `user_id`）。
	        - 评论内容（`content`）需符合平台格式要求（如字数限制、禁止HTML代码）。
	        - 被评论内容需存在（需提供有效的 `target_id`）。
	        - 在方法开始处应使用断言（assert）检查这些条件。
	    - **后置条件**：方法成功执行后，应确保：
	        - 返回布尔值或状态码（`success`），确认评论已保存至数据库。
	        - 返回新评论的唯一ID（`comment_id`），便于后续查询或修改。
	        - 在方法返回前进行检查。
	- **业务规则**
	    - **评论内容**
	        - 支持纯文本、表情符号（如emoji），可选支持图片/视频附件。
	        - 禁止包含广告、恶意链接、违法信息。
	    - **内容安全**
	        - 实时敏感词过滤（如政治、色情、辱骂词汇），触发则禁止提交。
	        - 提供用户举报机制，由管理员审核处理。
	    - **评论类型**
	        - **普通评论**：直接回复内容本身。
	        - **子评论**：对已有评论的回复，形成层级对话结构（通常建议层级不超过3层）。
	    - **显示规则**
	        - 默认按发布时间倒序排列，可选按点赞数或热度排序。
	        - 内容创作者可置顶优质评论，或设置“精选评论”标签。
	        - 游客用户发表的评论需审核通过后才显示。
	- **异常处理**
	    - **用户未登录**：提示“请先登录后发表评论”，并跳转至登录页面。
	    - **内容违规**：拦截提交，提示“内容包含敏感信息，请修改后重试”。
	    - **目标内容不存在**：报错“无法找到被评论对象”，并返回特定错误码。
	    - **服务器异常**：记录日志并提示“系统繁忙，请稍后再试”，可加入自动重试机制。
	- **验收标准**
	    - **功能测试**
	        - 普通用户登录后能正常发表文本/图片评论，并正确显示。
	        - 游客用户无法发表评论，或能正确触发注册/登录引导流程。
	        - 子评论能形成嵌套结构，且层级控制有效。
	    - **安全测试**
	        - 输入敏感词时无法提交，且提示信息准确。
	        - 举报功能可正常触发，管理员后台能收到通知。
	    - **性能测试**
	        - 高并发场景下（如热门内容发布后），评论提交无显著延迟或丢失。
	        - 评论列表加载速度符合性能指标（如1秒内加载100条评论）。
	    - **兼容性测试**
	        - 评论功能在不同设备（PC、移动端）上显示和交互正常。
            
- 接口API设计：这是前后端交互的契约。设计时应遵循 RESTful 等规范，明确每个端点的URL、请求方法（GET/POST等）、参数和返回值。
  
| 功能描述        | 接口路径 (URL)              | 请求方法      | 关键请求参数/体                                    |
| ----------- | ----------------------- | --------- | ------------------------------------------- |
| **提交评论**​   | `/api/v1/comments`      | POST      | `{"article_id": 123, "content": "评论内容"}`    |
| **获取评论列表**​ | `/api/v1/comments`      | GET       | Query: `article_id=123&page=1&page_size=20` |
| **获取评论详情**​ | `/api/v1/comments/{id}` | GET       | Path: `id=789`                              |
| **更新评论**​   | `/api/v1/comments/{id}` | PUT/PATCH | `{"content": "更新后的内容"}`                     |
| **删除评论**​   | `/api/v1/comments/{id}` | DELETE    | Path: `id=789`                              |
- 数据操作逻辑和流程：需要仔细考虑数据库的读写操作
	- 满足什么条件，才会做什么（状态机）
- 错误与异常处理：网络超时、数据验证失败、数据库连接断开等都是可能发生的情况。健全的功能需要对可能出现的异常有充分的预案，并给用户或前端清晰的错误提示。
- 性能优化
##### 神品功能实现