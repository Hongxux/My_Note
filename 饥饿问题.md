---
aliases:
  - 饥饿
---
- 饥饿的含义：长时间无法获得执行所需的资源
- 发生背景：
	- 非公平的锁竞争：高并发情况下，某些运气不佳的线程可能一直抢不到锁
		- 【运气不佳】一直被新线程插队，而没有被唤醒参与竞争
	- 持有锁时间过长：一个线程持有锁后，执行非常耗时的操作（如复杂的计算、IO操作）
- 解决方式：
	- 使用公平锁：通过 `ReentrantLock(true)`创建公平锁
		- 公平锁按照先来先服务的方式
		- 缺点：吞吐量降低
	- 优化同步代码块：
		- 减小临界区耗时：避免在同步块内进行IO操作等耗时任务
		- 使用可轮询的锁：`ReentrantLock`提供了 `tryLock()`方法，可以尝试获取锁，如果失败不会阻塞，线程可以转而执行其他任务
	- 减小锁竞争：避免惊群效应，使用精确唤醒
		- 只让满足条件的进行锁争夺，避免竞争到锁却因为条件不满足而无法执行的情况