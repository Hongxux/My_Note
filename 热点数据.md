- 需求:
	- 确保其驻留在Redis，避免[[缓存击穿]]和缓存雪崩
	- 数据要有新鲜度
	- 性能要高
- 确保其驻留在Redis：
	- 被动保留热点数据
		- 选择合适的Redis内存淘汰机制
			- 选择`allkeys-lfu`(Least Frequently Used)
				- 淘汰**访问频率最低**的数据。这对于访问模式相对稳定、能明显区分出“热点”与“冷点”的场景非常有效，是当前比较推荐的方式
				- 但是可能有热点时效性的问题
			- 在 `redis.conf`文件中通过 `maxmemory-policy`参数进行配置
	- 主动保留热点数据
		- 预估的流量高峰（促销活动）：进行预热
			- 启动时候预热:：适合那些相对固定、变化不频繁的热点数据
			- 定时预热：
				- 方式：`@Scheduled`注解
				- 时机：在业务低峰期（如凌晨）定期执行
				- 目标：适合动态变化的热点，如每日热销商品榜单
			- 预热方式：使用Redis的管道Pipeline[[Redis批处理|批处理]]命令
		- 检查出的热点数据：
			- 数据库：
				- MySQL的慢查询日志
			- 缓存中间件：
				- Redis的 redis-cli --hotkeys
			- 应用层：
				- 使用ZSET，设置数据统计
	- 过期方式：
		- 使用逻辑过期时间，避免缓存击穿
		- 在基础过期时间上增加一个随机值，避免缓存雪崩
		- 考虑永不过期：通过后续缓存更新策略保证新鲜度
- 数据要有新鲜度：选择合适的[[缓存更新策略]]
	- **定时更新**：与定时预热结合，定期从数据库拉取最新数据更新到Redis
	- **主动更新**：当后台更新了某条热点数据时，在完成数据库操作后，同步或通过消息队列异步地更新Redis中的缓存
- 缓存性能：
	- 构建多级缓存
	- 热点key分片
		- 例如在原Key后增加后缀`_1`、`_2`，将访问流量分散到多个Key甚至多个Redis节点上