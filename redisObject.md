`redisObject`（通常缩写为 `robj`）是 **Redis 内部用于表示所有数据类型的一个统一的基础结构**。你可以把它理解为一个“包装盒”或者“元信息头”。Redis 数据库中存储的每一个值（不论是字符串、列表还是哈希等），在内存中都会被封装为一个 `redisObject`结构体。

### 🔩 核心结构解析

`redisObject`的定义包含了以下几个关键字段，它们共同协作，实现了 Redis 强大而灵活的功能：

|字段|数据类型（位宽）|核心作用与说明|
|---|---|---|
|**`type`**|`unsigned`(4 bits)|**标识对象的对外数据类型**。例如，它告诉用户或命令这个对象是字符串（STRING）还是列表（LIST）。|
|**`encoding`**|`unsigned`(4 bits)|**标识对象底层实现的具体数据结构（编码）**。这是 Redis 实现内存优化的关键，同一种数据类型可以根据情况采用不同的编码方式存储。|
|**`lru`**|`unsigned`(24 bits)|**记录对象与内存淘汰策略相关的信息**。根据配置，它可能记录的是对象最近一次被访问的时间（LRU模式），或者是一个结合了访问频率和时间的复合值（LFU模式）。|
|**`refcount`**|`int`(32 bits)|**引用计数**。用于内存的自动回收和对象共享。当引用计数降为0时，对象所占用的内存会被释放。|
|**`ptr`**|`void *`(指针)|**指向实际存储数据的内存地址**。它具体指向什么结构，完全由 `encoding`字段决定。|

### 💡 工作原理与精妙之处

`redisObject`的设计精髓在于 **`type`和 `encoding`的分离**。这种设计带来了两大核心优势：**多态**和 **内存优化**。

1. **接口统一与多态**
    
    Redis 的命令处理函数可以接收一个通用的 `robj*`指针。当执行一个命令（如 `LPOP`）时，Redis 会：
    
    - 检查 `type`以确保操作的对象类型正确（例如，确保对列表执行 `LPOP`）。
        
    - 根据 `encoding`选择对应的底层实现函数来操作 `ptr`指向的数据结构。
        
        这就实现了类似面向对象编程中的“多态”：同一个命令接口，对于不同编码的对象，会有不同的具体实现。
        
    
2. **内存与性能的平衡**
    
    `encoding`字段使得 Redis 能够为同一种数据类型选择最合适的底层数据结构，从而在内存使用和操作性能之间取得最佳平衡。下表展示了不同类型与编码的常见映射关系：
    

|数据类型 (`type`)|可能的底层编码 (`encoding`)|说明|
|---|---|---|
|**String (字符串)**|`INT`|存储整数值时，直接将数值存储在 `ptr`位置，无需额外分配内存。|
||`EMBSTR`|存储短字符串（≤44字节）时，将 `redisObject`和 SDS 结构在连续内存中分配，提升缓存效率。|
||`RAW`|存储长字符串时，使用标准的 SDS 动态字符串结构。|
|**Hash (哈希)**|`ZIPLIST`/`LISTPACK`|当字段数量少且字段/值长度短时，使用紧凑的列表结构以节省内存。|
||`HT`(哈希表)|数据量较大时，转换为哈希表，保证操作效率。|
|**List (列表)**|`QUICKLIST`|Redis 3.2 后，列表的默认实现，是双向链表和压缩列表的混合体，均衡了内存和性能。|
|**Set (集合)**|`INTSET`|当所有元素都是整数且数量较少时，使用整数集合存储，非常节省内存。|
||`HT`(哈希表)|包含非整数元素或数据量大时，使用哈希表（字典的 value 为 NULL）。|
|**ZSet (有序集合)**|`ZIPLIST`/`LISTPACK`|元素数量少且成员长度短时使用。|
||`SKIPLIST`(跳表)|数据量大时使用，支持高效的范围查询。|

### ⚙️ 其他字段的实际作用

- **内存管理 (`refcount`)**：Redis 通过引用计数自动管理内存。当 `refcount`降为 0 时，对象会被立即回收。此外，Redis 会预创建 0 到 9999 的整数对象供共享，以节省内存。
    
- **内存淘汰 (`lru`)**：当 Redis 内存使用达到上限时，会根据配置的淘汰策略（如 `volatile-lru`或 `allkeys-lfu`），参考 `lru`字段记录的信息来选择淘汰哪些数据。
    

