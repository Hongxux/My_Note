TCP NewReno 是 TCP Reno 拥塞控制算法的一个重要增强，它解决了 Reno 在多重丢包场景下的性能缺陷。理解 NewReno 对于掌握 TCP 拥塞控制的演进至关重要。
### 该算法的使用时机：
​**NewReno算法本身并不基于SACK**。恰恰相反，它是为了在**没有SACK**​（Selective Acknowledgment）功能的环境中，​**模拟出类似SACK的效益**而设计的。
1. ​**没有SACK时的困境（标准Reno）：​**​
    
    - ​**信息匮乏：​**​ 接收方只能发送**累积ACK**。例如，它收到了Seq=1,3,4,5，但它只能回复ACK=2（表示期望收到2），无法告知发送方它已经收到了3,4,5。
        
    - ​**恢复能力脆弱：​**​ 当发送方收到3个重复的ACK=2并重传Seq=2后，一旦收到一个ACK=3（确认了2），它就认为恢复完成并退出快速恢复。如果此时Seq=6也丢失了，发送方完全不知情，只能等待Seq=6超时。​**一次快速恢复只能修复一个丢包**。
        
    
2. ​**有SACK时的解决方案：​**​
    
    - ​**信息丰富：​**​ SACK选项允许接收方在ACK头部额外告知发送方所有已收到的**不连续的数据块**。例如，收到Seq=1,3,4,5后，它可以在回复ACK=2的同时，附带SACK信息指明“已收到3-5”。
        
    - ​**恢复能力强大：​**​ 发送方精确地知道只丢了Seq=2和Seq=6。它可以在一个恢复周期内，​**有选择地**优先重传Seq=2和Seq-6，然后一次性退出恢复。​**一次快速恢复可以修复多个任意位置的丢包**。
        
    
3. ​**NewReno的折中方案（在没有SACK的情况下）：​**​
    
    - ​**信息依然匮乏：​**​ 和Reno一样，NewReno只能收到累积ACK。
        
    - ​**更智能的推断：​**​ NewReno通过引入 ​**​“恢复点”​**​ 和 ​**​“部分确认”​**​ 的概念来弥补信息的不足。
        
        - ​**恢复点：​**​ 记录进入快速恢复时已发送的最高序列号。这定义了一个“窗口”。
            
        - ​**部分确认：​**​ 任何确认了数据但未能推进到“恢复点”的ACK，都被视为**还有数据包丢失的强信号**。
            
        
    - ​**模拟选择性重传：​**​ NewReno的策略是：“**我不知道具体丢了哪些包，但我知道肯定还有包没到。我就按顺序重传下一个我认为丢失的包，直到把这个‘窗口’内的空洞都填上为止**”。它通过持续的重传和观察ACK的推进情况，来**推断**出需要重传的所有包。
### 提升性能的关键：减少超时

​**超时**​ 对TCP性能的打击是毁灭性的。它不仅意味着至少等待一个RTT才能重传，还会将拥塞窗口`cwnd`重置为1，使TCP不得不重新开始慢启动，吞吐量呈断崖式下跌。

- ​**Reno：​**​ 在多重丢包场景下，极易发生超时。
    
- ​**NewReno：​**​ 通过其“坚持在快速恢复阶段直至填满所有空洞”的策略，​**极大地减少了不必要的重传超时**。
    

即使NewReno需要按顺序重传（可能重传了实际上已到达的包，不如SACK高效），但**避免超时所带来的性能收益，远远大于重复传输少量数据包带来的开销**。这就是它能在无SACK环境中显著提升性能的根本原因。



---

### 1. 核心定义

​**TCP NewReno**​ 是一种对 ​**TCP Reno**​ 拥塞控制算法的改进算法，由 Janey Hoe 在其论文中提出。其核心增强在于对 ​**快速恢复**​ 阶段的优化。

- ​**要解决的问题：​**​ 标准的 Reno 算法在**一个发送窗口内发生多个数据包丢失**时，性能会急剧下降。它通常需要等待重传超时才能恢复，导致连接长时间处于空闲状态，吞吐量暴跌。
    
- ​**核心思想：​**​ 在快速恢复阶段，通过跟踪**部分确认**来检测是否还有更多的数据包丢失，从而在一个恢复周期内重传多个丢失的包，避免多次进入快速恢复或陷入超时等待。
    

​**定位：​**​ NewReno 是介于经典 Reno 和基于 SACK 的算法之间的一种优化，在没有 SACK 支持的环境中能显著提升性能。

---

### 2. 触发条件

NewReno 的触发条件与 Reno ​**完全一致**。其算法主要在**快速恢复**阶段发挥作用，因此其触发就是快速恢复的触发。

触发条件为：

​**发送方连续收到 3 个重复的 ACK。​**​

这个事件被 TCP 解释为**网络发生拥塞丢包**的信号（尽管可能是乱序引起的）。此时，TCP 不会等待重传定时器超时，而是进入**快速重传**和**快速恢复**阶段。**NewReno 的改进就体现在快速恢复阶段。**

---

### 3. 工作原理 / 具体实现

NewReno 与 Reno 在**快速重传**阶段的行为完全相同，区别在于**快速恢复**阶段。我们通过一个经典的多重丢包场景来对比说明。

#### 共同前提（快速重传）：

1. 发送方发送了一个数据包序列，例如 Seq1, Seq2, Seq3, Seq4, Seq5。
    
2. 假设 Seq2 和 Seq4 丢失。
    
3. 接收方收到 Seq1, Seq3, Seq5。由于期望收到 Seq2，它会为每个到达的失序包（Seq3, Seq5）都回复一个对 Seq1 的重复 ACK。
    
4. 发送方收到第 3 个重复 ACK（对 Seq1 的 ACK），判定 Seq2 丢失。
    
5. 发送方执行：
    
    - ​**快速重传：​**​ 立即重传 Seq2，而不等待超时。
        
    - ​**拥塞控制：​**​ 将 `ssthresh`设置为当前拥塞窗口 (`cwnd`) 的一半，并将 `cwnd`设置为 `ssthresh + 3`（因为有 3 个重复 ACK，代表有 3 个包已离开网络）。
        
    - 进入**快速恢复**阶段。
        
    

#### 快速恢复阶段（区别所在）：

^81b3ae

| 步骤              | ​**TCP Reno 的行为**​                                                                                                                                                                                                  | ​**TCP NewReno 的行为**​                                                                                                 |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| ​**6. 重传后**​    | 重传 Seq2 后，等待新的ACK。                                                                                                                                                                                                  | 重传 Seq2 后，​**记录一个“恢复点”​**，即进入快速恢复时已发送的最大序列号（本例中为 Seq5）。                                                               |
| ​**7. 收到新ACK**​ | 接收方收到重传的 Seq2，​**累积确认**到 Seq2。它会发送一个 ​**ACK3**​（确认 Seq2 及之前的所有数据）。                                                                                                                                                  | 接收方收到重传的 Seq2，发送 ​**ACK3**。                                                                                           |
| ​**8. 处理ACK**​  | 发送方收到 ACK3。这个 ACK ​**确认了重传的包**。Reno 认为恢复已完成。                                                                                                                                                                        | 发送方收到 ACK3。NewReno 检查这个 ACK：它确认了 Seq2，但**没有确认到“恢复点” (Seq5)​**。这被称为 ​**​“部分确认”​**。                                     |
| ​**9. 决策**​     | Reno ​**退出快速恢复**​：将 `cwnd`设为 `ssthresh`，进入拥塞避免阶段。                                                                                                                                                                   | NewReno 将**部分确认视为还有包丢失的信号**​（本例中 Seq4 还未被确认）。                                                                         |
| ​**10. 行动**​    | 此时，Seq4 仍然丢失。在Reno算法中，收到前进的ACK（ACK4）后，它会**立即退出快速恢复状态**，并将拥塞窗口`cwnd`设置为新的阈值（通常是很小的值）。此时，发送方被允许发送的数据量非常少，它可能根本没有足够的“额度”来发送足够多的新数据包，以**诱使接收方产生3个重复的ACK4**。因为无法接受到duck ack，所以无法触发快速重传＋快速恢复机制，发送方只能等待 Seq4 超时，​**性能受损**。 | NewReno ​**不退出快速恢复**。它推断 Seq4 也丢失了，于是：  <br>1. ​**重传**下一个被认为是丢失的包（Seq4）。  <br>2. 将 `cwnd`再减少一个段大小（或根据实现略有不同），以补偿重传的包。 |
| ​**11. 后续**​    | 超时发生后，`cwnd`被重置为 1，性能损失巨大。                                                                                                                                                                                          | 重复步骤 7-10，直到收到一个**确认到或超过“恢复点”的 ACK**​（如 ACK5 或 ACK6），才最终退出快速恢复，将 `cwnd`设为 `ssthresh`，进入拥塞避免。                          |
|                 |                                                                                                                                                                                                                     |                                                                                                                       |

​**NewReno 核心：​**​ 通过“部分确认”来推断并重传多个丢失的包，从而**尽可能地将快速恢复周期延长**，避免昂贵的超时。

---

### 4. 潜在问题与解决措施

|潜在问题|描述|解决措施|
|---|---|---|
|​**过于激进**​|在快速恢复阶段，每收到一个部分确认就重传一个包并减小 `cwnd`，可能导致 `cwnd`缩减得过多。|这是 NewReno 的设计权衡。它用略微激进的窗口缩减**换取了对超时的避免**，总体收益远大于损失。|
|​**无法匹敌SACK**​|NewReno 是**推断性**的，它不知道具体丢了哪些包，只能按序列号顺序重传。如果丢失的不是连续包（如丢 Seq2 和 Seq5），NewReno 可能无法在一个周期内恢复。|​**启用TCP SACK选项**。SACK 允许接收方明确告知发送方所有已收到的非连续数据块，发送方能**精确地只重传真正丢失的包**。SACK 的性能优于 NewReno，是现代系统的默认选择。NewReno 是 SACK 不可用时的优秀备选方案。|

---

### 5. 面试官可能关心的方面及参考答案

​**Q1: TCP NewReno 主要解决了经典 Reno 算法的什么问题？​**​

​**A:​**​ NewReno 主要解决了 Reno 在一个发送窗口内发生**多重丢包**时性能急剧下降的问题。Reno 在快速恢复阶段收到一个确认重传包的ACK后就会立即退出，如果还有其它包丢失，只能等待超时，导致连接空闲和吞吐量暴跌。NewReno 通过引入“部分确认”的概念，能够在一个快速恢复周期内推断并重传多个丢失的包，极大地减少了不必要的超时，改善了多重丢包环境下的性能。

​**Q2: NewReno 是如何判断是否还有更多数据包丢失的？​**​

​**A:​**​ NewReno 在进入快速恢复时，会记录一个“恢复点”，即当时已发送的最大序列号。在快速恢复阶段，如果收到一个ACK，其确认号**小于**这个恢复点，则这是一个“部分确认”。NewReno 将部分确认视为还有数据包未被确认（很可能已丢失）的信号，从而触发对下一个可能丢失的包的重传。

**Q: NewReno算法能否完全避免重传超时？​**​

​**A:​**​ 不能。NewReno极大地减少了在**一个窗口内发生多个丢包**时导致的超时，但它无法处理**尾部丢包**等边界场景。当丢失的数据包之后没有足够的数据包来激发接收方返回重复ACK时，快速重传机制就无法被触发，发送方最终只能依赖重传定时器超时作为最后的保障机制。

​**Q: 有哪些技术可以进一步减少超时重传？​**​

​**A:​**​ 主要有两种思路：

1. ​**主动探测：​**​ 如 **[[尾部丢失探测（TLP）​]]** 。它在连接空闲时主动发送探测包，旨在人为地制造触发快速重传的条件，从而在超时之前“抢救”连接。
    
2. ​**更精确的丢包信息：​**​ 使用**TCP SACK**选项。接收方可以明确告知发送方所有已收到的数据块，因此发送方能精确知道哪些包丢失了（包括尾部包），从而可以直接重传，无需依赖重复ACK的触发条件。
​**Q3: 为什么现代操作系统通常使用基于 SACK 的算法而不是 NewReno？​**​

​**A:​**​ 因为 SACK 提供了更精确的丢包信息。NewReno 是**推断性**的，它只能按序列号顺序重传，并且无法处理非连续的多重丢包。而 SACK 允许接收方**明确告知**发送方所有已成功接收的数据块，使发送方能够**精确地、选择性地**只重传那些真正丢失的数据包，无需猜测，效率更高。因此，在支持 SACK 的环境中，基于 SACK 的恢复算法是更优的选择。NewReno 可以看作是 SACK 被广泛采用前的一个重要过渡算法。