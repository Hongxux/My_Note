### 代码注释与思路分析

```c
#include <stdlib.h>

// 归并排序的合并函数
void Merge(int *A, int low, int mid, int high) {
    int N = high - low + 1;
    int *B = (int*)malloc(sizeof(int) * N); // 临时数组用于合并
    int left = low, right = mid + 1, Bindex = 0;
    
    // 合并两个有序子数组
    while (left <= mid && right <= high) {
        if (A[left] <= A[right]) 
            B[Bindex++] = A[left++];
        else 
            B[Bindex++] = A[right++];
    }
    
    // 复制剩余元素
    while (left <= mid) B[Bindex++] = A[left++];
    while (right <= high) B[Bindex++] = A[right++];
    
    // 将排序结果复制回原数组
    for (int i = 0; i < N; i++) 
        A[low + i] = B[i];
    
    free(B); // 释放临时数组
}

// 归并排序主函数
void MergeSort(int *A, int low, int high) {
    if (low >= high) return; // 递归终止条件
    
    int mid = (low + high) / 2;
    MergeSort(A, low, mid);    // 左半部分排序
    MergeSort(A, mid + 1, high); // 右半部分排序
    Merge(A, low, mid, high);  // 合并结果
}

/**
 * 三数之和求解函数
 * 
 * @param nums 输入数组
 * @param numsSize 数组大小
 * @param returnSize 返回结果数组的大小
 * @param returnColumnSizes 返回每个子数组的大小
 * @return 包含所有三元组的数组
 */
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    // 初始化返回大小
    *returnSize = 0;
    
    // 特殊情况处理：数组元素不足3个
    if (numsSize < 3) {
        *returnColumnSizes = NULL;
        return NULL;
    }
    
    // 1. 排序数组（升序）
    MergeSort(nums, 0, numsSize - 1);
    
    int ansCount = 0; // 结果计数器
    
    // 2. 分配结果存储空间（保守估计最大解数量）
    int maxPossible = numsSize * 6; // 最大可能解的数量估计
    int** result = (int**)malloc(sizeof(int*) * maxPossible);
    *returnColumnSizes = (int*)malloc(sizeof(int) * maxPossible);
    
    // 3. 外层循环遍历每个元素（作为三元组的第一个元素）
    for (int i = 0; i < numsSize - 2; i++) {
        // 跳过重复元素（避免重复解）
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        
        // 4. 提前终止条件优化：
        // a. 当前最小值已大于0，后续不可能有解
        if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;
        // b. 当前最大值仍小于0，需要跳过当前元素
        if (nums[i] + nums[numsSize - 1] + nums[numsSize - 2] < 0) continue;
        
        int x = nums[i]; // 当前固定元素
        int target = -x; // 需要寻找的目标和
        int left = i + 1; // 左指针
        int right = numsSize - 1; // 右指针
        
        // 5. 双指针法寻找两数之和等于target
        while (left < right) {
            int sum = nums[left] + nums[right];
            
            if (sum == target) { // 找到有效三元组
                // 分配内存存储三元组
                result[ansCount] = (int*)malloc(sizeof(int) * 3);
                result[ansCount][0] = x;
                result[ansCount][1] = nums[left];
                result[ansCount][2] = nums[right];
                (*returnColumnSizes)[ansCount] = 3; // 每行3个元素
                ansCount++;
                
                // 移动指针并跳过重复值
                left++;
                while (left < right && nums[left] == nums[left - 1]) left++;
                
                right--;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } 
            else if (sum < target) { // 和太小，左指针右移
                left++;
            } 
            else { // 和太大，右指针左移
                right--;
            }
        }
    }
    
    // 6. 设置返回大小
    *returnSize = ansCount;
    
    // 7. 调整内存到实际大小
    if (ansCount > 0) {
        result = (int**)realloc(result, sizeof(int*) * ansCount);
        *returnColumnSizes = (int*)realloc(*returnColumnSizes, sizeof(int) * ansCount);
    } else { // 无解时释放内存
        free(result);
        free(*returnColumnSizes);
        *returnColumnSizes = NULL;
        return NULL;
    }
    
    return result;
}
```

### 思路分析

1. ​**排序预处理**​：
    
    - 使用归并排序将数组升序排列，为双指针法创造条件
        
    - 排序后相同元素相邻，便于跳过重复解
        
    
2. ​**外层循环**​：
    
    - 遍历每个元素作为三元组的第一个元素
        
    - 跳过重复元素避免重复解
        
    - 添加提前终止条件优化性能
        
    
3. ​**双指针法**​：
    
    - 固定第一个元素后，在剩余数组中使用双指针寻找两数之和
        
    - 左指针从i+1开始，右指针从数组末尾开始
        
    - 根据当前和与目标值比较移动指针
        
    
4. ​**结果处理**​：
    
    - 找到有效解时分配内存存储三元组
        
    - 移动指针并跳过重复值
        
    - 最后调整内存到实际解的数量
        
    

### 时间复杂度分析

1. ​**排序阶段**​：
    
    - 归并排序时间复杂度：O(n log n)
        
    
2. ​**求解阶段**​：
    
    - 外层循环：O(n)
        
    - 内层双指针：O(n)
        
    - 总体：O(n²)
        
    
3. ​**总时间复杂度**​：
    
    - O(n log n) + O(n²) = O(n²)（主导项）
        
    

### 空间复杂度分析

1. ​**排序空间**​：
    
    - 归并排序需要O(n)临时空间
        
    
2. ​**结果存储**​：
    
    - 最坏情况下解的数量为O(n²)
        
    - 每个解需要O(1)空间
        
    - 列宽数组需要O(n²)空间
        
    
3. ​**总空间复杂度**​：
    
    - O(n²)（结果存储主导）
        
    

### 优化建议

1. ​**排序优化**​：
    
    ```
    // 使用更快的qsort代替归并排序
    int cmp(const void* a, const void* b) {
        return (*(int*)a - *(int*)b);
    }
    qsort(nums, numsSize, sizeof(int), cmp);
    ```
    
2. ​**内存分配优化**​：
    
    ```
    // 使用动态增长策略
    int capacity = 100; // 初始容量
    int** result = (int**)malloc(sizeof(int*) * capacity);
    *returnColumnSizes = (int*)malloc(sizeof(int) * capacity);
    
    // 需要时扩容
    if (ansCount >= capacity) {
        capacity *= 2;
        result = realloc(result, sizeof(int*) * capacity);
        *returnColumnSizes = realloc(*returnColumnSizes, sizeof(int) * capacity);
    }
    ```
    
3. ​**提前终止优化增强**​：
    
    ```
    // 更精确的提前终止条件
    if (nums[i] > 0) break; // 已为正数，后续不可能有解
    if (i > 0 && nums[i] == nums[i-1]) continue;
    ```
    
4. ​**添加内存分配检查**​：
    
    ```
    if (!result || !*returnColumnSizes) {
        *returnSize = 0;
        return NULL;
    }
    ```
    
5. ​**指针操作优化**​：
    
    ```
    // 减少重复计算
    int L = i + 1, R = numsSize - 1;
    while (L < R) {
        int sum = nums[L] + nums[R];
        // ...
    }
    ```
    

这些优化可以在保持算法核心逻辑不变的情况下，显著提高性能和健壮性，特别是对于大型输入数组。