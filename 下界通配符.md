​

通配符边界（Wildcard bounds）与类型变量边界（type variable bounds）类似，但它们增加了一项功能——**可以指定超类型边界**，例如：

```
? super Manager
```

这个通配符被限制为 `Manager`的所有超类型。（幸运的是，现有的 `super`关键字非常准确地描述了这种关系。）

​**一、 目的与行为 (Purpose and Behavior)​**​

- ​**目的：​**​ 为什么需要这样做？带有超类型边界的通配符提供了与第8.8节“通配符类型”（第475页）中描述的通配符相反的行为。
    
- ​**行为特征：​**​
    
    - ​**可以**向方法提供参数（写入）。
        
    - ​**不能**使用方法的返回值（读取受限）。
        
    
- ​**示例说明 (`Pair<? super Manager>`):​**​
    
    ```
    void setFirst(? super Manager) // 可以写入 Manager 或其子类型对象
    ? super Manager getFirst()     // 读取返回的对象只能赋值给 Object
    ```
    
    - 这并非实际的Java语法，但说明了编译器所知道的信息。
        
    - `setFirst`的参数类型 `? super Manager`表示某个特定类型 `T`，其中 `Manager`是 `T`的子类型。
        
    - 对于 `T`的确切选择（在本例中）有三种：`Object`、`Employee`或 `Manager`（如果 `Manager`或 `Employee`实现了接口，则选择会更多）。
        
    - 编译器无法知道具体应用了哪种选择（`T`可能是 `Manager`）。因此：
        
        - ​**写入 (`setFirst`):​**​ 只能传递 `Manager`类型或其子类型（如 `Executive`）的对象。编译器不能接受 `Employee`或 `Object`类型的参数。
            
        - ​**读取 (`getFirst`):​**​ 无法保证返回对象的类型。只能将其赋值给 `Object`。
            
        
    

​**二、 典型应用示例 (Typical Example)​**​

- ​**场景：​**​ 有一个经理数组，希望将奖金最低和最高的经理放入一个 `Pair`对象。这个 `Pair`可以是 `Pair<Employee>`或 `Pair<Object>`。
    
- ​**方法实现 (`minmaxBonus`):​**​
    
    ```
    public static void minmaxBonus(Manager[] a, Pair<? super Manager> result) {
        if (a.length == 0) return;
        Manager min = a[0];
        Manager max = a[0];
        for (int i = 1; i < a.length; i++) {
            if (min.getBonus() > a[i].getBonus()) min = a[i];
            if (max.getBonus() < a[i].getBonus()) max = a[i];
        }
        result.setFirst(min);  // 写入：可以安全地设置 Manager 对象
        result.setSecond(max); // 写入：可以安全地设置 Manager 对象
    }
    ```
    
- ​**行为总结：​**​
    
    - ​**超类型边界通配符 (`? super`):​**​ 允许你**写入**泛型对象。
        
    - ​**子类型边界通配符 (`? extends`):​**​ 允许你**读取**泛型对象。
        
    

​**三、 在 `Comparable<T>`接口中的应用 (Application with `Comparable<T>`)​**​

- ​**背景：​**​ `Comparable`接口本身是泛型类型：
    
    ```
    public interface Comparable<T> {
        public int compareTo(T other);
    }
    ```
    
- ​**问题：​**​ 对于 `ArrayAlg`类的 `minmax`方法，更“彻底”的声明似乎是：
    
    ```
    public static <T extends Comparable<T>> Pair<T> minmax(T[] a)
    ```
    
    这对于像 `String`（实现 `Comparable<String>`）这样的类有效。但对于 `LocalDate`会出问题：
    
    - `LocalDate`实现 `ChronoLocalDate`。
        
    - `ChronoLocalDate`扩展 `Comparable<ChronoLocalDate>`。
        
    - 因此，`LocalDate`实现 `Comparable<ChronoLocalDate>`，但**不直接**实现 `Comparable<LocalDate>`。
        
    
- ​**解决方案：​**​ 使用超类型边界通配符
    
    ```
    public static <T extends Comparable<? super T>> Pair<T> minmax(T[] a)
    ```
    
    - 现在 `compareTo`方法的形式是 `int compareTo(? super T)`。
        
    - 它可能被声明为接受类型 `T`的对象，或者（例如当 `T`是 `LocalDate`时）接受 `T`的超类型对象。
        
    - 无论如何，将类型 `T`的对象传递给 `compareTo`方法是安全的。
        
    
- ​**说明：​**​ 像 `<T extends Comparable<? super T>>`这样的声明可能看起来很复杂，但其目的是通过消除对调用参数不必要的限制来帮助应用程序员。库程序员需要习惯使用通配符。
    

​**四、 在函数式接口参数中的应用 (Application with Functional Interface Arguments)​**​

- ​**常见用法：​**​ 超类型边界的另一个常见用途是作为函数式接口的参数类型。
    
- ​**示例 (`Collection.removeIf`):​**​
    
    ```
    default boolean removeIf(Predicate<? super E> filter)
    ```
    
    - 该方法移除所有满足给定谓词（`Predicate`）的元素。
        
    
- ​**优势：​**​ 超类型通配符 (`? super E`) 允许传递更通用的谓词。
    
    ```
    ArrayList<Employee> staff = . . .;
    Predicate<Object> oddHashCode = obj -> obj.hashCode() % 2 != 0; // 谓词作用于 Object
    staff.removeIf(oddHashCode); // 可以传递 Predicate<Object>，而不仅仅是 Predicate<Employee>
    ```
    
    - 你希望能够传递 `Predicate<Object>`，而不仅仅是 `Predicate<Employee>`。超类型通配符使之成为可能。
        
    

---