![[Pasted image 20251209215604.png]]
### RabbitMQ的基础部分
- 基础部件
	- **生产者（Publisher/Producer）**：发送消息的应用程序。它将消息发布到**交换器**。
	- **消费者（Consumer）**：接收和处理消息的应用程序。它从**队列**中获取消息。
	- **交换器（Exchange）**：消息的**路由中心**。生产者将消息发送到交换器，交换器负责根据特定规则将消息路由到一个或多个队列中。它本身不存储消息。
	- **队列（Queue）**：消息的**缓冲区**，本质上是一个存储消息的邮箱。队列遵循先进先出（FIFO）的原则。消费者从队列中获取消息进行处理。
	- **绑定（Binding）**：连接**交换器**和**队列**的规则。你可以理解为交换器和队列之间的“一座桥”。
	- **虚拟主机（Virtual Host）**：用于在同一个 RabbitMQ 服务器内进行**逻辑隔离**。可以将它类比为操作系统中的文件夹。不同的应用可以拥有独立的 vhost，其中的交换器、队列等互不干扰。
- 四种交换器类型：不同的路由策略
  
| 交换器类型           | 路由规则                                                              | 典型应用场景                                                                                                                                              |
| --------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Direct（直连）**​ | 精准匹配：Routing Key 必须**完全等于**​ Binding Key，消息才会被路由到该队列              | 点对点精确发送，如将错误日志发送到特定的处理队列。                                                                                                                           |
| **Fanout（扇出）**​ | 忽略：交换机会**忽略**这两个Key，将消息**广播**到所有绑定到此交换机的队列                        | 广播消息，如新闻更新需要同时通知多个系统。<br>这是实现“一个消息被多个独立消费者同时处理”的最佳方式                                                                                                |
| **Topic（主题）**​  | 模糊匹配：Binding Key 可使用通配符（`*`匹配一个词，`#`匹配零个或多个词）与 Routing Key 进行模式匹配 | 实现消息的灵活分类和订阅，如监听特定区域（如`usa.#`）或所有类型的新闻（如`#.news`）。<br>复杂的业务通知：例如，路由键可以设计为 `业务.模块.动作`，如 `order.payment.success`，消费者可以灵活订阅自己关心的模式，如 `order.*.success` |
| **Headers（头）**​ | 不依赖 Routing Key，而是根据消息头（Headers）中的键值对进行匹配。                        | 基于复杂的多属性进行路由，但性能较差，使用较少。                                                                                                                            |
### Rabbit的消息传递和路由和分发机制
- 连接与信道：通信的桥梁
	- **连接（Connection）**：生产者/消费者与 RabbitMQ 服务器之间的一个 **TCP 连接**。建立连接的开销较大。
	- **信道（Channel）**：建立在 Connection 之上的**虚拟连接**。几乎所有的操作都在信道中进行。使用信道的好处是可以**复用**一个 TCP 连接，避免频繁创建和销毁 TCP 连接的巨大开销。
- 消息路由
	- 运作规律：生产者通过 Routing Key 给消息贴上一个“地址标签”，而 Binding Key 则是队列在交换机那里设置的“收件规则”。​ 当消息到达交换机后，交换机会将消息的“地址标签”（Routing Key）与每个队列设置的“收件规则”（Binding Key）进行比对。匹配成功的，消息就会被投递到对应的队列中。
	- **路由键（Routing Key）**：
		- 定义方：**生产者**​ 在发送消息时设定
		- 设定时机：消息发送时候
		- 作用：标识消息的路由目标
			- 交换器会根据这个键来决定消息的路由方向。
	- **绑定键（Binding Key）**：
		- 定义方：**消费者**（或管理员）在**绑定**队列到交换机时设定
		- 设定实际：建立绑定时候
		- 作用：定义队列接收消息的条件
			- 交换器会将消息的 **Routing Key**​ 与这个 **Binding Key**​ 进行匹配，从而决定消息应被路由到哪些队列
	- 二者匹配规则由交换器类型决定
- 消息分发机制：
	-  **轮询分发（Round-Robin）**：这是默认策略。
		- 含义：它会将队列中的消息**依次、均匀地**分发给所有消费者，而不考虑每个消费者的处理能力
	    - 问题：这可能导致处理速度慢的消费者积压消息。
	- **公平分发（Fair Dispatch）**：为了解决轮询分发的缺陷，可以启用公平分发。
		- 开启方式：通过设置 `channel.basicQos(prefetchCount)`参数，可以限制每个消费者在未确认之前**最多能预取的消息数量**（通常设为1）。
		- 含义：只有在消费者处理完当前任务并发送确认（ACK）后，才会收到新的任务
		- 作用：确保了负载更加均衡
### RabbitMQ的工作模式
- [[Work  Queue模式]]
### RabbitMQ的企业考虑
- 确保可靠性的关键机制
	- 消息丢失的三种可能
		- 发送消息的过程中丢失了，消息代理没有受到消息
		- 消息代理把消息弄丢了
		- 消费者把消息弄丢了
	- 发送者的可靠性
		- [[生产者连接MQ失败重连]]
		- [[生产者确认]]
	- MQ的可靠性
		- [[RabbitMQ持久化]]
		- [[Lazy Queue]]
	- 消费者的可靠性
		- [[消费者确认机制]]
			- 消费失败处理：移交死信队列，确保消息至少被消费一次，不会丢失
			- 业务幂等性：失败重试的基础
	- [[延迟消息]]
- 消息顺序性：
	- 含义：确保同一业务序列的消息只能被单一线程按顺序处理​
	- 需求背景：消息顺序可能被打乱的主要原因
		- 多消费者竞争同一队列：多个消费者并行处理同一队列中的消息
		- 消息重试或进入死信队列：处理失败的消息重发后可能滞后。
		- 使用优先级队列：高优先级消息会插队。
	- 解决措施：消息分组/分区实现一个队列只有一个消费者+单一活跃消费者实现自动故障转移
		- 消息分组/分区有序方案：按业务ID（如订单ID）哈希将消息分到不同队列，每个队列单消费者。
		- 单一活跃消费者（SAC）方案：既维持了顺序性又提供了故障转移能力
			- 该队列允许多个消费者订阅，但同一时刻只有一个消费者是活跃的并处理消息。
			- 如果该活跃消费者故障，RabbitMQ会自动在其余订阅者中选择一个接替工作
				```
				Channel ch = ...;
				Map<String, Object> arguments = new HashMap<>();
				arguments.put("x-single-active-consumer", true); // 启用SAC
				ch.queueDeclare("my_order_queue", true, false, false, arguments);
				```
- 消息堆积：
	- 原因：消费速度持续落后于生产速度、
	- 解决措施：
		- 提升消费者端消费速度：
			- 配置多消费者，需要同步增加队列数量
				- 纵向切分：将一个复杂任务拆解为多个独立的小任务。，每个小任务用不同队列完成
				- concurrency：**控制并发消费者数量**。设置每个 `@RabbitListener`监听容器启动的初始消费者线程数
				- max-concurrency：**控制最大并发消费者数量**。设置监听容器可动态扩展到的最大消费者线程数。
				- prefetch：**控制单个消费者预取消息量**。设置每个消费者一次性从 RabbitMQ 服务器预取的消息数量，这些消息会缓存在客户端的阻塞队列中。
					- 对于处理慢速任务（如图片处理、邮件发送），应将 `prefetch`设为较小值（如 1 到 10）
						- 这能防止单个消费者预取过多消息而导致堆积，促使 RabbitMQ 将新消息分发给空闲的消费者，实现负载均衡
					- 若处理速度非常快，可适当增大 `prefetch`以减少网络请求。
			- 优化单线程消费速度
				- 异步化与缓存：将非必需的I/O操作（如写日志、更新非关键状态）异步化处理
				  
				- 对于频繁读取的数据，使用本地缓存或分布式缓存来减少对数据库等组件的直接访问次数
				- 简化消费逻辑：检查并优化消费逻辑的代码，避免不必要的复杂计算、循环或递归
				- 批量操作：对于支持批量处理的下游服务（如数据库批量插入），可以考虑在消费端实现批量处理逻辑，将多次I/O合并为一次，显著提升效率
		- 生产者端：
			- 限流：采用生产者确认机制，监控消息生产速度。如果生产速度远大于消费能力，应考虑在生产端进行限流，或在业务层面降低非关键消息的发送频率
			- 服务降级：在系统压力极大时，暂时关闭非核心业务，减少消息生产，集中资源处理核心业务和积压消息
			-

- Spring AMQP[[SpringBoot中使用RabbitMQ]]
	- Spring AMQP对JAVA操作RabbitMQ做的一层封装
	- AMQP是消息队列的消息通信协议