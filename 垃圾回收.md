---
aliases:
  - GC
---
- 需求背景：
	- 面对多线程、高并发及动态创建大量临时对象的现代应用，手动内存管理挑战巨大。
- 解决措施：垃圾回收
	- 判断垃圾：
		- 引用计数法：当对象引用计数为0时候，可以被回收
			- 弊端：循环引用问题![[Pasted image 20251207142055.png]]
				- 两个对象都不被其他对象引用，但是因为循环引用，引用计数器不为0，不能被垃圾回收
		- 可达性分析算法（JAVA中采用的）：如果一个对象没有被根对象直接或间接引用，则可以被回收 
			- 需求背景：解决循环引用带来的无法回收问题
			- 实现机制：扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象
				- 找不到，表示可以回收
			- [[根对象]]（GC root）：一系列肯定不能被垃圾回收的对象
	- 垃圾回收算法：根据不同情况采用不同的算法
		- [[标记清除]]
		- [[标记整理]]
		- [[复制回收]]
		- 三种算法协同工作:分代内存回收机制![[Pasted image 20251207162758.png]]
			- 设计思想：根据对象的不同生命周期，划分不同的区域，采用不同的垃圾回收算法
			- 工作机制：
				- 对象首先分配在伊甸园区
				- 新生代空间不足时候，触发minor gc
					- 会引发一次[[stop the world]]
					- 工作机制：
						- 对于伊甸园和幸存区To存活的对象，copy到幸存区From
						- 对这些存错对象年龄+1
							- 年龄达到15会被移入老年代
						- 并且交换from 和 to
				- 当老年代空间不足
					- 先尝试触发Minor gc
					- 如果之后空间仍然不足，那么会触发full gc
						- 会引发一次[[stop the world]]，且相比minor gc时间更长
							- 老年代的内存中对象多
							- 可能使用标记清楚的垃圾回收方式，用时长
					- 如果仍然空间不足，触发OOM异常
			- 相关参数![[Pasted image 20251207163634.png]]
	- 垃圾回收器
		- 串行
			- 含义：单线程的垃圾回收器
			- 工作模式：![[Pasted image 20251207165618.png]]
			- 使用场景：堆内存较小，适合个人电脑，cpu核数少
			- 开启方式：`XX:+UseSerialGC=Serial + SerialOld`
				- Serial工作在新生代，采用复制的回收算法
				- SerialOld工作在老年代，采用标记整理算法
				  
		- 吞吐量优先
			- 含义：多线程的垃圾回收器，STW在单位时间内最短
				- 垃圾回收在单位时间占比越低，吞吐量越高 
			- 工作模式：![[Pasted image 20251207170121.png]]
				- 垃圾回收线程数量：
					- 默认：在一个范围内，和cpu核数一样
					- 配置：`-XX:ParallelGCThreads=n`
				- 垃圾回收发生时候，会出现极高的cpu占有率
				- 相关配置：
					- 动态调整各个区域大小和晋升的阈值：`-XX:+UseAdaptivesizePolicy`
					- 根据目标，进行动态调整
						- 调整垃圾回收时间占工作时间的百分比：`-XX:GCTimeRatio=ratio`
							- 默认99，推荐19
							- ratio值越大，GC时间占比越小，应用吞吐量目标越高
							- 计算公式：GC时间占比 = 1 / (1 + ratio)
						- 调整单次垃圾回收时间：`-XX:MaxGCPauseMillis=ms`
							- 默认200
						- 两个目标相互冲突
			- 使用场景：
				- 多核cpu
				- 堆内存较大
			- 开启方式：JDK1.8默认开启 `XX:+UseParallelGC和XX:+UseParallelOldGC`
				- 开启一个，连带开启另一个
		- 响应时间优先
			- 含义：多线程的垃圾回收器，单次的STW尽可能短
			- 工作模式：![[Pasted image 20251207181556.png]]
				- 初始标记：标记根对象 
				- 重新标记：在并发标记的时候，用户线程更改了引用关系
			- 问题：
				- 吞吐量会下降
					- 因为有一部分cpu用于垃圾回收，用于用户线程的cpu就少了
				- 不能等到内存不够用的时候才开始垃圾回收：需要预留空间保存浮动垃圾，
					- 浮动垃圾：在清理垃圾的时候，还会有新的垃圾产生，这些垃圾称为浮动垃圾 
				- 并发模式失败：
					- 发生时期：CMS并发周期执行期间
					- 原因：老年代预留的空间被快速填满
						- 浮动垃圾产生过快
						- 对象晋升速度超预期
					- 后果：JVM会不得不停止并发周期，并启动一次Serial Old Full GC
						- 停顿时间通常会很长
				- 可能退化成串行，执行Serial Old Full GC，进行垃圾碎片整理
					- 原因：
						- CMS是标记清楚，会导致内存碎片化
						- 即使总剩余内存足够，也无法找到连续空间分配大对象
						- 从而触发晋升失败或并发模式失败
					- 后果：停顿时间加长
			- 相关配置：
				- 设定了老年代空间使用率达到百分之多少时（N）就开始执行CMS回收：`-XX:CMSInitiatingOccupancyFraction=<N>`
					- 原因：避免由于浮动垃圾导致的并发模式失败
					- 建议值：70
				- 强制JVM始终使用你设定的阈值：`-XX:+UseCMSInitiatingOccupancyOnly`
				- 在CMS重新标记前先进行一次年轻代GC：`-XX:+CMSScavengeBeforeRemark`
					- 减少年轻代的对象数量，从而减少需要扫描标记的对象，缩短停顿时间
				- 开启重新标记阶段的并行执行:`-XX:+CMSParallelRemarkEnabled`
			- 使用场景：
				- 多核cpu
				- 堆内存较大
			- 开启方式：
				- 启用基于复制的ParNew收集器负责新生代回收：`-XX:+UseParNewGC`
				- 启用CMS收集器负责老年代回收:`-XX:+UseConcMarkSweepGC`
					- 用户线程和垃圾回收线程并发运行 
				- 在现代JDK 8中，通常只设置 `-XX:+UseConcMarkSweepGC`，JVM会自动启用ParNew与之配合
		- [[Garbage First]] （G1）
- [[GC调优]]
	- 
- 问题：
	- 性能开销：GC过程消耗计算资源，可能引起应用短暂停顿
		- 对实时性要求高的应用需谨慎选择GC算法并调优
	- 内存使用效率：内存排列不紧凑，有空间牺牲
		- 为便于垃圾回收和减少碎片