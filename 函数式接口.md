

1. ​**定义与约束**​：
    
    - **函数式接口**和**普通接口**——前者必须是单一抽象方法（可包含默认/静态方法）
	    - Object`类方法重声明（如`toString()`）不计入抽象方法
    - **函数式接口本质**：函数式接口是**Lambda的类型载体**，Lambda表达式**自动实现**（因为函数式接口就是）函数式接口的抽象方法
	    -  示例：`(first, second) -> first.length() - second.length()`自动实现`Comparator.compare()`
		
    - **目的**：是为了解决**Lambda与Java类型系统兼容**的问题
        
| ​**知识点**​  | ​方法签名匹配≠可直接使用                                                |
| ---------- | ------------------------------------------------------------ |
| ​**语言设计**​ | Java 选择强化接口的**语义化设计**​（如 `Runnable`、`Comparator`），而非新增函数类型   |
| ​**实践原则**​ | 写 Lambda 时需关注**接口的用途**​（如排序用 `Comparator`，条件判断用 `Predicate`） |
| ​**错误预防**​ | 避免滥用通用接口（如 `BiFunction`），优先选择**语义明确的专用接口**​                  |

1. ​**工具接口**​：
    
    - [[Predicate函数式接口]]：断言型接口，用于条件判断（如集合过滤）
        ![[Pasted image 20251021110132.png]]
    - [[Supplier函数式接口]]：供给型接口，支持延迟计算（惰性求值）
        ![[Pasted image 20251021110153.png]]
    



---

### 面试官可能关心的方面及答案

​**问题1：什么是函数式接口？如何验证一个接口是函数式接口？​**​

​**答案：​**​ 函数式接口是仅包含**一个抽象方法**的接口。可通过`@FunctionalInterface`注解验证（非强制），编译器会检查接口是否符合条件，如：

```
@FunctionalInterface // 编译时会验证方法数量
interface MyComparator {
    int compare(String a, String b); 
}
```

​**问题2：为什么Lambda表达式不能直接赋值给Object变量？​**​

​**答案：​**​ Lambda表达式需通过函数式接口实现类型匹配。`Object`不是函数式接口，无法提供所需的抽象方法签名。必须通过接口承载：

```
Comparator<String> comp = (a,b) -> a.length()-b.length(); // 正确
Object obj = (Comparator<String>) comp; // 需显式转型
```


​**问题3：Supplier接口如何实现延迟计算？​**​

​**答案：​**​ `Supplier`通过封装代码块延迟执行。仅当调用`get()`方法时才执行计算，避免不必要的资源消耗：

```
// 传统立即初始化
LocalDate date = Objects.requireNonNullElse(day, LocalDate.now()); 

// Supplier延迟初始化（day为null时才计算）
LocalDate date = Objects.requireNonNullElseGet(day, () -> LocalDate.now());
```