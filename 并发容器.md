![[Pasted image 20251215160058.png]]

1. **ConcurrentHashMap**
    
    这是最常用的并发Map，其核心目标是**在高并发读写间取得平衡**。
    
    - **实现原理**：在JDK 8之前采用**分段锁**，将数据分成多个段，每个段独立加锁，不同段的操作可并行执行。JDK 8及之后改为使用 **`CAS`（比较并交换）操作和`synchronized`同步代码块锁定单个桶（桶指的是数组中的一个位置或链表/红黑树的头节点）**，进一步细化了锁粒度，提升了并发性能。
        
    - **优点**：高吞吐量，读写性能优异。迭代器提供**弱一致性**，不会抛出`ConcurrentModificationException`。
        
    - **潜在风险与问题**：
        - **弱一致性**：`size()`、`isEmpty()`等方法返回的结果可能是近似值，因为它们在计算时不会锁定整个Map，其他线程可能正在并发修改。
        - **复合操作非原子性**：虽然单个方法是线程安全的，但一些需要连续调用的复合操作（如"若不存在则添加"`if (!map.containsKey(k)) map.put(k, v)`）并非原子操作，仍需借助`putIfAbsent`、`computeIfAbsent`等原子方法保证安全。
            
1. **CopyOnWriteArrayList**
    专为**读多写极少**的场景设计。
    - **实现原理**：采用**写时复制**技术。每次修改操作（增、删、改）都会**复制底层数组，在新副本上操作，完成后将原数组引用指向新数组**。读操作直接访问当前数组，无需加锁。
    - **优点**：**读性能极高**，完全无锁，且迭代器不会抛出`ConcurrentModificationException`。
    - **潜在风险与问题**：
        - **内存开销大**：写操作需要复制整个数组，若数组较大或写操作频繁，会导致**显著的内存占用和GC压力**。
        - **数据延迟**：读操作可能无法立即读到最新数据，因为读的是写操作开始前的旧数组快照，存在**短暂的数据不一致性**。
2. **并发队列 (ConcurrentLinkedQueue 和 BlockingQueue)**
    - **ConcurrentLinkedQueue**：基于链表的**非阻塞**无限队列，使用CAS算法实现线程安全。适用于高吞吐量的生产者-消费者场景，但**不提供阻塞操作**。
    - **BlockingQueue**（阻塞队列）：这是一个接口，其实现类在队列满或空时，会让操作（`put`/`take`）的线程阻塞等待。
        - **ArrayBlockingQueue**：基于数组的**有界**阻塞队列，内部使用单个ReentrantLock进行同步。
        - **LinkedBlockingQueue**：基于链表的阻塞队列，默认无界（容量为`Integer.MAX_VALUE`），也可设为有界。吞吐量通常高于`ArrayBlockingQueue`。
        - **PriorityBlockingQueue**：支持优先级排序的**无界**阻塞队列。
        - **SynchronousQueue**：不存储元素的阻塞队列，每个插入操作必须等待对应的移除操作，适合直接传递任务。

1. **弱一致性的影响**
    
    许多并发容器（如`ConcurrentHashMap`、`CopyOnWriteArrayList`）提供的迭代器是**弱一致性**的。这意味着在迭代过程中，如果容器被其他线程修改，迭代器不保证能反映所有修改，但也**不会**抛出`ConcurrentModificationException`。如果你的业务逻辑依赖迭代过程中数据的绝对准确性和实时性，这可能是个问题。
    
1. **性能与开销的权衡**
    - `ConcurrentHashMap`通过降低锁粒度提升并发性能，但CAS操作在高竞争下可能导致CPU空转。
    - `CopyOnWriteArrayList`以写操作的巨大开销换取读操作的高性能。
    - 无界队列（如默认的`LinkedBlockingQueue`、`PriorityBlockingQueue`）在任务生产速度远超消费速度时，可能导致**内存耗尽**。
2. **规避死锁风险**
    虽然并发容器自身不会导致死锁，但在**复合操作或与多个容器配合使用**时，若顺序不当，仍可能产生死锁。例如，线程A锁定了容器1并尝试锁定容器2，而线程B锁定了容器2并尝试锁定容器1。

|场景特征|推荐容器|关键理由|
|---|---|---|
|**高频并发读写K-V数据**​|`ConcurrentHashMap`|锁粒度细，CAS优化，高吞吐量|
|**读多写极少**（如监听器列表、配置）|`CopyOnWriteArrayList`|读操作无锁，性能极高|
|**高吞吐生产者-消费者**（非阻塞）|`ConcurrentLinkedQueue`|无锁，CAS实现，高性能|
|**有界阻塞生产者-消费者**（线程池常用）|`ArrayBlockingQueue`, 有界`LinkedBlockingQueue`|控制资源消耗，防止内存溢出|
|**需要按优先级或延迟处理任务**​|`PriorityBlockingQueue`, `DelayQueue`|支持优先级调度和延迟任务|
|**需要强一致性迭代**​|使用`Collections.synchronizedList/Map`包装，或业务层加锁|牺牲部分性能，保证数据强一致性|
