---
aliases:
  - condition variables
---

---

### 1. 核心总结

#### ① 定义

条件变量是一种线程同步机制，它允许一个线程在某个条件不满足时进入阻塞状态，并在其他线程改变该条件后，被唤醒并重新检查条件。

#### ② 关系

- ​**因果链**​：它解决了线程在等待条件成立时 ​**​“忙等待（Busy-Waiting）”​**​ 导致的CPU资源浪费问题，但其引入的副作用是 ​**​“丢失唤醒（Lost Wake-up）”​**​ 和 ​**​“虚假唤醒（Spurious Wake-up）”​**，这两个副作用通过将条件检查置于 ​**`while`循环**​ 并结合 ​**互斥锁（Mutex）​**​ 使用的范式来解决。
    
- ​**补充增强**​：它是 ​**互斥锁（Mutex）​**​ 的**补充**。互斥锁用于保证对共享资源的互斥访问，而条件变量用于在线程之间传递状态变化信号，两者结合才能安全、高效地实现复杂的同步逻辑。
    
- ​**易混淆概念**​：常与**信号量（Semaphore）​**​ 混淆。核心区别在于：信号量维护一个状态（计数值），而条件变量本身不维护状态，它只是一个通信机制，状态（条件）由程序员通过共享变量（受互斥锁保护）来维护。
    

#### ③ 定位

条件变量属于**操作系统/并发编程**领域的**线程同步**原语。它建立在**互斥锁（Mutex）​**​ 的基础之上，因为对共享条件（共享变量）的检查与修改必须在互斥锁的保护下进行，以确保原子性。

#### ④ 涉及理念

- ​**设计理念**​：遵循“协作式”并发模型。其核心设计是**解耦“等待条件”和“持有锁”​**。当条件不满足时，线程能原子性地释放锁并进入睡眠，避免其他线程因无法获取锁而无法改变条件，从而死锁。唤醒后再自动重新获取锁。
    
- ​**优缺点权衡**​：
    
    - ​**优点**​：高效。与忙等待相比，在条件可能长时间不满足时，能大幅降低CPU占用。
        
    - ​**缺点**​：复杂性高。程序员必须正确地管理互斥锁和条件变量之间的关系（如`wait`操作的内部逻辑），否则极易引入死锁、竞争条件等问题。这种复杂性的代价是为了换取性能优势。
        
    

---

### 2. 触发条件/经典使用情景

条件变量的经典使用场景是 ​**生产者-消费者问题（Producer-Consumer Problem）​**。

- ​**场景描述**​：一个或多个生产者线程向一个固定大小的缓冲区添加数据，一个或多个消费者线程从缓冲区取出数据。
    
- ​**触发条件**​：
    
    1. ​**消费者线程**​：当缓冲区**为空**时，消费者线程必须**等待**，直到生产者放入数据后**唤醒**它。
        
    2. ​**生产者线程**​：当缓冲区**已满**时，生产者线程必须**等待**，直到消费者取走数据后**唤醒**它。
        
    
- **易错点**：
	- 有个原则，即生产者只能唤醒消费者，而消费者只能唤醒生产者。具体措施是使用两个环境变量。[[生产者-消费者问题中双条件变量的必要性]]
	- 可能会被捷足先登，被唤醒的consumer1处于ready状态，想要consume新的数据，然而被consumer2捷足先登，导致c2running的时候已经没数据了却尝试获得数据，从而触发警告。
在此场景中，“缓冲区非空”和“缓冲区非满”就是需要等待的条件。

---

### 3. 工作原理/具体实现

以下以C++的`std::condition_variable`为例，展示其标准工作流程。

#### 核心流程（生产者-消费者模型片段）

​**共享数据与同步原语：​**​

```
std::queue<int> buffer; // 共享缓冲区
const unsigned int max_size = 10;
std::mutex mtx; // 互斥锁，用于保护buffer和条件判断
std::condition_variable cond_not_empty; // “非空”条件变量
std::condition_variable cond_not_full;  // “非满”条件变量
```

​**消费者线程代码：​**​

```
std::unique_lock<std::mutex> lock(mtx); // 1. 获取锁

// 2. 检查条件（必须用循环，原因见下方“潜在问题”）
while (buffer.empty()) { 
    cond_not_empty.wait(lock); // 3. 条件不满足：原子地【释放锁】并【进入阻塞】
}
// 4. 此时条件已满足，且线程已重新持有锁
int data = buffer.front();
buffer.pop();

// 5. 改变可能使其他线程满足的条件（例如：缓冲区现在肯定不满了）
lock.unlock(); // 可提前解锁，减少锁的持有时间
cond_not_full.notify_one(); // 6. 唤醒一个可能正在等待“非满”的生产者
```

​**生产者线程代码：​**​

```
std::unique_lock<std::mutex> lock(mtx);
while (buffer.size() == max_size) {
    cond_not_full.wait(lock);
}
buffer.push(new_data);
lock.unlock();
cond_not_empty.notify_one(); // 唤醒一个可能正在等待“非空”的消费者
```

#### 潜在问题与解决措施

1. ​**丢失唤醒（Lost Wake-up）​**​
    
    - ​**问题描述**​：在消费者线程检查`buffer.empty()`之后，调用`wait()`之前，CPU时间片被切换走。此时生产者线程可能获取CPU，生产了数据并调用了`notify_one()`，但这个唤醒信号发送时消费者还未进入等待队列，因此信号被丢失。当消费者线程再次被调度并执行`wait()`时，它将永远阻塞。
        
    - ​**解决措施**​：​**使用`while`循环而非`if`语句检查条件**。这是条件变量使用的**铁律**。即使因为上述原因导致唤醒丢失，当消费者被其他原因唤醒后，`while`循环会再次检查条件，如果条件依然不满足（数据仍然为空），它会继续等待。
        
    
2. ​**虚假唤醒（Spurious Wake-up）​**​
    
    - ​**问题描述**​：即使没有线程调用`notify`，等待在条件变量上的线程也可能被操作系统**莫名其妙地唤醒**。这是出于性能考虑，某些操作系统实现允许的行为。POSIX和C++标准都明确允许这种现象。
        
    - ​**解决措施**​：同样，​**使用`while`循环而非`if`语句检查条件**。虚假唤醒后，线程会重新检查条件，如果不满足则继续等待，从而保证了正确性。
        
    
3. ​**`wait`操作的原子性**​
    
    - ​**问题核心**​：`cond_not_empty.wait(lock)`必须是一个**原子操作**，它需要同时完成“释放锁”和“进入等待队列”。如果不是原子的，就会回到“丢失唤醒”的问题上。
        
    - ​**内部机制**​：`wait`的内部伪代码大致如下：
        
        ```
        template<typename Predicate>
        void condition_variable::wait(std::unique_lock<std::mutex>& lock, Predicate pred) {
            while (!pred()) { // 使用while循环检查谓词
                // 原子地将当前线程加入等待队列并释放互斥锁
                internal_wait_queue.add(this_thread);
                lock.unlock();
                // 线程在此处挂起...
        
                // 被唤醒后，在返回前会重新获取锁
                lock.lock();
            }
        }
        ```
        
    - ​**重要性**​：这个原子操作是条件变量正确性的基石，由标准库/操作系统保证。
        
    

---
### 4.a covering condition`[拓展]`
[[Covering Condition]]
### 5. 面试官可能关心的方面与答案

1. ​**Q：为什么`wait`函数需要和一个互斥锁一起使用？​**​
    
    - ​**A**​：主要两个原因：1) ​**保证条件检查的原子性**​：检查条件（如`buffer.empty()`）和进入等待状态`wait()`必须是一个原子操作，防止“丢失唤醒”。这个原子性就是通过`wait`函数内部在释放锁前将线程放入等待队列来实现的。2) ​**保护共享条件**​：条件（如`buffer`）本身就是共享资源，必须用互斥锁保护。
        
    
2. ​**Q：`wait`的`while`循环和`if`语句有什么区别？为什么必须用`while`？​**​
    
    - ​**A**​：`if`只检查一次条件，无法应对“丢失唤醒”和“虚假唤醒”。线程被唤醒后，它假设条件已经满足，直接执行后续代码。而`while`循环在线程被唤醒后、继续执行前，会**重新检查条件**。只有当条件真正满足时，才会退出循环。这是确保程序健壮性的关键。
        
    
3. ​**Q：`notify_one`和`notify_all`有什么区别？如何选择？​**​
    
    - ​**A**​：`notify_one()`只唤醒一个等待在该条件变量上的线程（具体哪个由调度器决定），效率高。`notify_all()`会唤醒所有等待的线程。选择依据：
        
        - 使用`notify_one`：当一次条件改变**最多只能让一个等待线程继续执行**时。例如，生产者生产了一个数据，只需要唤醒一个消费者。
            
        - 使用`notify_all`：当一次条件改变**可能让所有等待线程都能继续执行**时。例如，一个资源池从“不可用”变为“可用”，可能需要唤醒所有等待该资源的线程。
            
        
    
4. ​**Q：条件变量和信号量（Semaphore）有什么区别？​**​
    
    - ​**A**​：
        
        - ​**状态**​：信号量内部有一个计数器，它本身带有状态。而条件变量本身不带状态，状态由外部的共享变量（如`buffer`）表示。
            
        - ​**操作**​：对信号量的`wait`（P）和`post`（V）操作是独立的，通常会改变内部计数。对条件变量的`wait`和`signal`必须与一个互斥锁以及一个外部条件变量配合使用。
            
        - ​**用途**​：信号量更适用于控制对**特定数量资源**的访问（如限流）。条件变量更适用于等待**某个复杂条件**成立（如“缓冲区非空”），更具通用性。可以说，信号量可以用条件变量+一个计数器来实现。
            
        
    
5. ​**Q：调用`notify`时，互斥锁是否必须被持有？​**​
    
    - ​**A**​：不强制要求。无论是在持有锁还是不持有锁的情况下调用`notify`，都是正确的。但**通常建议在持有锁的情况下调用**。这是因为，如果在不持有锁的情况下调用`notify`，被唤醒的线程可能会立即开始运行并尝试获取你刚刚释放的锁，如果它获取成功并发现条件仍未满足（例如，在`notify`和`wait`唤醒获取锁的间隙，另一个线程修改了条件），它可能又得继续等待，这会导致一些性能损耗，但不会引起正确性问题。持有锁调用可以使代码行为更可预测。然而，在持有锁时调用`notify`，被唤醒的线程会立刻在`wait`函数内部阻塞，试图重新获取你正持有的锁，所以通常会在调用`notify`后立即释放锁，以减少锁的争用。