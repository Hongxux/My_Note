Spring 框架的**三级缓存机制**是其 IoC 容器的核心设计之一，主要用于**解决单例 Bean 的循环依赖问题**，并确保 Bean 在存在 AOP 代理等增强处理时也能被正确创建和注入。


###  三级缓存的组成

Spring 的三级缓存由 `DefaultSingletonBeanRegistry`类中的三个 Map 构成：

| 缓存级别     | 源码中的 Map 名称             | 存储内容                           | 核心作用                                       |
| -------- | ----------------------- | ------------------------------ | ------------------------------------------ |
| **一级缓存** | `singletonObjects`      | **已完全初始化好的 Bean**（成品）          | 对外提供可用的单例 Bean，是主要的获取源。                    |
| **二级缓存** | `earlySingletonObjects` | **已实例化但未初始化的 Bean**（半成品）       | 缓存 Bean 的早期引用，**防止重复创建代理对象**，保证依赖注入的一致性。   |
| **三级缓存** | `singletonFactories`    | **`ObjectFactory`（Bean 工厂对象）** | **延迟生成 [[Bean 的早期引用]]**，是解决 AOP 代理循环依赖的关键。 |

###  三级缓存解决循环依赖的方式

结合流程图，三级缓存解决循环依赖（以 A 依赖 B，B 依赖 A 为例）的核心步骤如下：

1. **创建 Bean A，曝光工厂**
    
    - Spring 实例化 A（调用构造方法），得到一个原始对象。
        
    - 随后，Spring 将一个用于生产 A 的早期引用的 `ObjectFactory`工厂对象放入 **三级缓存**。这一步非常关键，它意味着**提前暴露了 A**，但并未直接创建代理对象，而是将创建的时机延迟。
        
    
2. **为 A 注入属性，触发创建 B**
    
    - Spring 准备为 A 注入属性，发现它依赖 B。
        
    - 于是容器转向创建 B。
        
    
3. **创建 Bean B，同样曝光工厂**
    
    - 实例化 B，并将 B 的 `ObjectFactory`也放入 **三级缓存**。
        
    
4. **为 B 注入属性，解决循环依赖（关键步骤）**
    
    - Spring 为 B 注入属性，发现它依赖 A。
        
    - 此时，Spring 开始查找 A：
        
        - **一级缓存**：没有 A（A 还未初始化完成）。
            
        - **二级缓存**：没有 A（A 的早期引用还未被使用过）。
            
        - **三级缓存**：**找到了 A 的 `ObjectFactory`**。
            
        
    - Spring 调用这个工厂的 `getObject()`方法。**在这个方法内部，会执行一个关键逻辑：如果 Bean A 需要被 AOP 代理，则在此刻生成并返回代理对象；如果不需要，则返回原始对象**。这样就保证了注入给 B 的是最终正确的对象（可能是代理）。
        
    - 随后，将这个早期引用从三级缓存迁移到 **二级缓存**中。
        
    
5. **完成 B 和 A 的创建**
    
    - B 获得 A 的早期引用后，顺利完成属性注入和后续初始化，变成一个“成熟”的 Bean，被放入 **一级缓存**，并清理其在二、三级缓存中的记录。
        
    - 随后，A 的注入流程得以继续，从一级缓存中获取到已成熟的 B，完成自身的初始化，最终也进入 **一级缓存**。
        
    

###  为何需要三级缓存？

一个常见的疑问是：**能否只用二级缓存（比如合并二、三级缓存）？**

答案是不能，尤其是在需要处理 **AOP 代理**的情况下。三级缓存的核心优势在于 **`ObjectFactory`提供的延迟创建能力**。

- **如果只有二级缓存**：在将 Bean 的早期引用放入缓存时，**必须立即确定这个引用是原始对象还是代理对象**。但 Spring 的设计中，正常的代理创建时机是在 Bean 初始化之后（通过 `BeanPostProcessor`）。如果提前创建代理，可能会遇到 Bean 状态不完整等问题，违反设计原则，并可能造成资源浪费（如果没有循环依赖，这个代理就白创建了）。
    
- **有了三级缓存的 `ObjectFactory`**：代理对象**仅在发生循环依赖、真正被需要时才被创建**。如果没有循环依赖，Bean 将按照正常的生命周期在初始化后创建代理。这既保证了正确性，也兼顾了性能。
    

###  局限性：构造器循环依赖

需要特别注意的是，**三级缓存无法解决通过构造器注入产生的循环依赖**。因为 Spring 为了创建一个 Bean 的实例，必须先获得其构造器所需的所有参数。如果 A 和 B 都在构造器中相互依赖，那么 Spring 在实例化 A 时就需要一个完整的 B，而实例化 B 时又需要一个完整的 A，导致无法进行到“实例化后曝光工厂”这一步，从而形成死锁，抛出 `BeanCurrentlyInCreationException`。

对于这种场景，常见的解决方案是使用 **`@Lazy`注解**，将其加在其中一个构造参数上，让 Spring 注入一个代理，延迟真正 Bean 的获取，从而打破死锁。

希望这个详细的解释能帮助你彻底理解 Spring 的三级缓存机制。