- **场景假设**：锁不仅不存在多线程竞争，而且总是由同一个线程多次获得（只存在重入现象）。
- **设计目的**：优化无竞争场景，单线程重复加锁
- **实现基础**：Mark Word的存储内容![[Pasted image 20251201091644.png]]
- **实现流程**：在对象头记录线程ID，下次同一线程访问只需比对ID![[Pasted image 20251130225527.png]]
	- 线程首次获取锁：JVM 用CAS方式将线程 ID 记录在对象的 Mark Word 中，并将对象头设置为偏向模式。
	- 线程再次进入临界区（关键优化点）：
		1. 检查状态：查看对象头 Mark Word 中的锁标志位和偏向锁标志，确认当前处于“可偏向”状态。
		2. 检查线程ID：比较 Mark Word 中存储的线程 ID 是否是当前线程的 ID。
		3. 快速通过：如果 ID 匹配，线程无需执行任何复杂的同步操作（如 CAS），即可直接进入同步块执行代码
		- 好处：再次使用时候，不需要进行任何同步操作（如 CAS），代价极小
			- 首次加锁CAS写ID，再次进入只需要读，解锁不进行读写操作：加锁解锁的开销降低到仅仅一次内存读写的量级

- 偏向锁的撤销与升级
	- 触发时机：第二个线程尝试通过CAS操作去获取锁
	- 触发条件：发现锁对象的Mark Word中记录的线程ID不是自己，并且锁处于已偏向状态
	- 核心判断：先进行STW，再判断原线程是否活跃且正在执行同步代码块
		- 原线程仍在同步块中：进行**锁升级**，升级成轻量级锁
			- 这个轻量级锁会由原持有者线程A继续持有
			- 自己则会进入自旋等待，尝试通过CAS获取这个轻量级锁
				- 如果线程B自旋成功，则继续执行
				- 如果自旋失败，则会进一步升级为重量级锁，线程B被阻塞
					- 自旋失败的情况：
						- 自旋次数超过阈值
						- 又有新线程竞争
		- 线程A已不在同步块中：进行**锁撤销**，重新偏向
			- JVM会先将锁对象撤销偏向锁，变为不可偏向的无锁状态
			- 第二个线程对锁对象进行重现偏向
- 批量重偏向
	- 需求背景：
		- 解决“一个线程创建大量对象并执行初始同步，之后另一个线程将这些对象作为锁进行操作”所带来的性能问题
	- 解决措施：批量重偏向，不需要进行锁撤销，直接进行锁偏向，大大提升了效率
	- 实现基础
		- 以类为单位：JVM会为每个类维护一个**偏向锁撤销计数器**。
		- 每个类对象和一个处于偏向锁状态的对象Mark Word中都有一个`epoch`字段
	- 实现机制：
		- 触发时机：当某个类的对象发生偏向锁撤销的次数达到默认阈值（20次）
		- 触发反应：epoch（纪元）机制
			1. 类的`epoch`值会+1
			2. 当线程B再次尝试获取该类对象的锁时，发现对象头的`epoch`值小于类的`epoch`值
			3. 这会允许线程B**直接通过CAS**操作将锁**重偏向**到自己身上
		- 产生结果：无需走复杂的撤销流程，大大提升了效率
- 批量撤销
	- 需求背景：当竞争变得非常激烈，偏向锁的存在已经弊大于利时，JVM会采取更极端的措施。
	- 核心思想：**及时止损**。JVM会判定这个类的使用场景存在**剧烈的多线程竞争**，偏向锁已不再适用
	- 触发条件：当某个类的偏向锁撤销计数器继续增加，达到一个更高的阈值（默认**40次**）
	- 触发反应：JVM会对该类执行**批量撤销**。
		1. 标记这个类为**不可偏向**。
		2. 之后，对于这个类**新创建的所有对象**，其锁状态会直接进入轻量级锁逻辑，完全**跳过偏向锁**阶段。
		3. 对于已存在的该类对象，在下次被使用时也会被撤销偏向锁。
- **配置：**
	- 禁用偏向锁：
		- VM参数-XX:-UseBiasedLocking
		- 调用obj.hashcode()