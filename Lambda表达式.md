---
aliases:
  - Lambda
---
### Lamdba与匿名类的关系以及其价值
**与匿名类的关系**

- **Lambda其实是匿名内部类的替代或增强**
	- **Lambda**只适用于函数式接口（单一抽象方法），且不创建新对象。它让代码更简洁，支持函数式编程风格。Lambda更轻量，只关注代码块本身，而不是对象状态。
	- **匿名内部类**可以包含状态和多方法。

举个**现实中的困境**：假如你想给一个按钮添加点击事件，但必须创建一个实现ActionListener的类，哪怕只有一行代码！这种繁琐会让你抓狂。学完这章，你就能用Lambda一行搞定，代码清爽多了。这就是为什么这节内容如此重要——它直接提升你的编码效率和可读性。
- 之前Java必须通过对象传递代码块，例如实现接口的类，这导致冗长的匿名内部类。Lambda通过直接定义代码块语法解决，允许将代码作为参数传递，使API调用更直观。

---
### **Lambda表达式**
由三部分组成：参数列表、箭头符号`->`和表达式体。参数列表与传统方法参数类似，箭头是固定分隔符，表达式体可以是一个表达式或代码块。
1. ​**基本语法结构**​：`(parameters) -> expression`或 `(parameters) -> { statements; }`
    
2. ​**类型推断机制**​：编译器能够根据上下文自动推断参数类型，允许省略显式类型声明
    
3. ​**代码体形式差异**​：单表达式可省略大括号和return，多语句必须使用代码块结构

| 场景   | 标准写法                                                 | 简化写法                                   | 适用条件    |
| ---- | ---------------------------------------------------- | -------------------------------------- | ------- |
| 多参数  | `(String s1, String s2) -> s1.length()-s2.length()`  | `(s1, s2) -> s1.length()-s2.length()`  | 类型可推断   |
| 单参数  | `(ActionEvent e) -> System.out.println(e.getWhen())` | `e -> System.out.println(e.getWhen())` | 参数类型可推断 |
| 无参数  | `() -> { System.out.println("Hello"); }`             | 无简化                                    | 必须保留空括号 |
| 多行代码 | `(x) -> { if(x>0) return 1; else return 0; }`        | 无简化                                    | 必须使用代码块 |
#### [[lambda的变量作用域]]
**变量作用域**是什么？简单说就是Lambda能访问哪些外部变量，以及为什么有些变量不能修改。比如在`repeatMessage("Hello", 1000)`中，Lambda能读取外部方法的`text`参数，但如果尝试修改它就会报错。
#### lambda表达式的延伸
##### [[方法引用]]
方法引用是Lambda表达式的**语法简化**，不是功能替代
##### **[[构造器引用​]]**
**造器引用**是什么？简单说就是用`类名::new`替代`new 类名()`。比如把字符串列表转成Person对象列表，原本要写`map(s -> new Person(s))`，现在只需`map(Person::new)`。

----
### [[函数式接口]]
函数式接口本质是**Lambda的类型载体**，目的是为了解决**Lambda与Java类型系统兼容**的问题
- **函数式接口**和**普通接口**——前者必须是单一抽象方法
而副作用是可能混淆通用接口与特定接口，这个通过明确设计意图来规避；
注意区分

---
### [[“消费”Lambda方法]]
让方法接收并灵活执行Lambda表达式

