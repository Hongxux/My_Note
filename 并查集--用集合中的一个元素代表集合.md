

[算法学习笔记(1) : 并查集 - 知乎](https://zhuanlan.zhihu.com/p/93647900)
# P1551 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 输入格式

第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。

以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le n$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。

接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。

## 输出格式

$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。

## 输入输出样例 #1

### 输入 #1

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```

### 输出 #1

```
Yes
Yes
No
```

```c++
#include <cstdio>
#include <iostream>

using namespace std;
int n,m,p;//分别表示有 n 个人，m 个亲戚关系，询问 p 对亲戚关系。
int par[5010];//记录父节点
int val[5010];//记录这个树有几个节点
void init(int lenth){
    for(int i = 0; i < n; i++){
        par[i] = i;//表示该节点自己是根节点
        val[i] = 1;
    }
}
int find(int i){
    int p = par[i];
    while(p != par[p]){
        p = par[p];
    }
    par[i] = p;//路径压缩优化：保存结果
    return p;
}
void unio(int i, int j){
    int r1 = find(i);
    int r2 = find(j);
    if(val[r1] <= val[r2]){//秩合并优化：避免单链过长的情况
        par[r1] = r2;
        val[r2] += val[r1];
    }else{
        par[r2] = r1;
        val[r1] += val[r2];
    }
	
}


int main(){
	
	scanf("%d %d %d",&n,&m,&p);
	init(n);
	for(int i = 0; i < m; i++){
		int m1,m2;
		scanf("%d %d",&m1,&m2);
		unio(m1,m2);
	}
    
	for(int i = 0; i < p; i++){
		int q1,q2;
		scanf("%d %d",&q1,&q2);
		if(find(q1) == find(q2)){
			cout << "Yes" << endl;
		}else{
			cout << "No" << endl;
		}
	} 
	
	return 0;
}
```