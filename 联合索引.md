### 联合索引生效的前提--[[最左前缀法则]]
### 单列索引和联合索引的选择
联合索引的B+Tree，键为多个字段的组合，先按照最左边字段排序，接着依次往后排序（排序优先级）
![[Pasted image 20251030212910.png]]

设计合理的联合索引能避免回表查询

实践推荐：根据业务需求选择联合索引的组合，并且根据区分度选择哪个在更前面
#### 1. 索引类型对比

首先明确了两种索引的定义：

- ​**单列索引**​：一个索引只包含一个列。
    
- ​**联合索引**​：一个索引包含多个列。
    

重要建议：​**当查询条件有多个时，建议建立联合索引，而不是为每个列创建单列索引。​**​

#### 2. 实例分析：单列索引的局限性

图中的 SQL 语句和其执行计划（`EXPLAIN`结果）完美地演示了单列索引的问题。

- ​**查询语句**​：
    
    ```
    EXPLAIN SELECT id, phone, name FROM tb_user 
    WHERE phone = '17799990010' AND name = '韩信';
    ```
    
    这是一个包含两个查询条件（`phone`和 `name`）的语句。
    
- ​**表上的索引情况**​：从 `possible_keys`列可以看出，表 `tb_user`上存在两个单列索引：`idx_user_phone`和 `idx_user_name`。
    
- ​**优化器的选择**​：`key`列显示，优化器**最终只选择了**​ `idx_user_phone`索引来执行查询。它无法同时利用两个单列索引。
    

#### 3. 为什么会这样？—— 底层原因

这是因为数据库对于单列索引的处理方式：

1. MySQL 在大部分情况下，​**对于多个查询条件，只会选择一个它认为最有效的索引**​（此处选择了区分度可能更高的 `phone`索引）。
    
2. 对于 `name = '韩信'`这个条件，MySQL 无法使用 `idx_user_name`索引进行检索，只能在通过 `idx_user_phone`索引找到候选记录后，再**回表**到主键索引中取出完整的 `name`字段值进行过滤（这体现在 `Extra`列虽然没有显示 `Using where`，但过滤确实发生了）。
    
3. 这种机制效率较低，因为另一个条件 (`name`) 没有索引加速。
    

### 结论与优化建议

这个例子揭示了单列索引在多条件查询时的核心短板：​**数据库优化器通常难以高效地合并使用多个单列索引**。

​**正确的做法**​：

根据这个查询模式，应该创建一个 `(phone, name)`的联合索引（或者 `(name, phone)`，取决于哪个条件区分度更高）。

```
CREATE INDEX idx_user_phone_name ON tb_user(phone, name);
```

创建此联合索引后，数据库可以直接在一个索引树中同时处理 `phone`和 `name`两个条件，查询效率会远高于使用两个单列索引。

​**总结**​：在进行数据库索引设计时，不应孤立地为每个查询列创建索引，而应**根据实际的、频繁使用的多列组合查询条件来创建联合索引**，这样才能发挥索引的最大效能。