- 需求背景：原本的链表结构不连续，会有大量内存碎片
- 解决方案：ZipList 是一种特殊的“双端链表”，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作,并且该操作的时间复杂度为 0(1)。

- ZipList数据结构：查询方式和链表类似，但是由于利用元数据记录长度而不是记录地址，更节省内存更紧凑![[Pasted image 20251126183707.png]]
	- zlbytes：记录整个 ziplist 占用的总字节数
	- zltail：记录尾节点到 ziplist 起始位置的偏移量
		- 支持 O(1) 时间复杂度访问尾节点，便于反向操作
	- zllen：记录当前 ziplist 包含的 entry（节点）数量
	- entries：存储实际的各个节点数据
		- 节点的长度由节点保存的内容决定，值越大，占的内存越多（节省内存的原因）
		- 如何遍历：根据entry的组成结构
	- zlend：固定为 0xFF（255），标记 ziplist 的结束
		- 用于遍历时识别列表末尾
	- ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如:
		- 数值0x1234，采用小端字节序后实际存储值为:0x3412
- entry数据结构：记录长度而不是记录地址，更节省内存更紧凑
	- prevlen：记录前一个节点的长度，是个变长的
		- 如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值
		- 如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据
	- encoding：记录当前节点所保存数据的类型和长度
		- 根据数据内容自动选择最紧凑的编码格式
		- 存储是字符串：如果encoding是以“00'或者10”开头，则证明content是字符串![[Pasted image 20251126200803.png]]
		- 存储是整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节![[Pasted image 20251126201233.png]]
	- data：存储节点的实际数据
		- 储存类型： 可能是整数或字符串，有时 encoding 本身已包含数据（如小整数）
- ZipList的连锁更新
	
	- 根本原因：前一个节点的长度不可控，而导致prevlen长度不可控，根据前一节点的长度而选择要么是一字节，要么是四字节
	- 导火索：
		- 插入大节点![[Pasted image 20251126202303.png]]![[Pasted image 20251126202406.png]]
		- ![[Pasted image 20251126202707.png]]
		- 删除小节点
	- 解决方法：
		- 降低发生概率，配置节点最大数量
		- 改变构型：ListPack
			- 不记录上一个节点的长度，只记录自己这个节点的长度