- **常见场景**：适用于多个线程**交替执行**同步块，很多线程访问的实现错开，不存在竞态条件
    
- **实现流程**：
	1. 创建锁记录
		- 时机：线程在执行到synchronized时候
		- 实现方式：JVM 会在线程的栈帧中创建一个名为锁记录的空间，
			- 锁对象的引用地址
			- MarkWork数据块：
				- 初始：30位的锁记录的地址和2位的轻量锁标识
					- 用于和锁对象的MarkWork进行交换
				- 交换后：锁对象normal状态下的Mark Word
	2. 尝试使用 **CAS 操作**将对象头的Mark Word 与锁记录的MarkWork数据块进行交换![[Pasted image 20251130220432.png]]
		- 如果交换成功（Mark Word的状态标识为00），当前线程获得锁；![[Pasted image 20251130221015.png]]
		- 如果交换失败，失败的情况：
			- 其它线程持有了该 Object 的轻量级锁：这时表明有竞争，进入自旋（循环尝试获取）
			- 锁重入：再添加一条 Lock Record 作为重入的计数![[Pasted image 20251130221236.png]]
	3. 解锁（退出synchronized块）：
		- 如果有取值为null的锁记录：将这个锁记录清除
			- 代表有重入锁
		- 如果取值不为null的所记录：使用cas方式将Mark Word的值恢复给对象头
			- 成功，则解锁成功
			- 失败，则说明轻量级锁进行了[[锁膨胀]]或已经升级为重量级锁，进入重量级锁解锁流程
- 自旋优化：
	- 发生时机：获取轻量锁失败
	- 含义：不放弃CPU（进入阻塞状态），而是进行一个忙循环（即“自旋”）反复检查锁是否已被释放
	- 设计目的：避免了由线程阻塞和唤醒操作带来的上下文切换的消耗
	- 缺点：空转带来CPU消耗
	- 实现方式：自适应自旋，即由JVM根据运行时的实际情况动态决定自旋次数。
		- 核心权衡：权衡空转CPU消耗和上下文切换消耗
		- 具体规则：
			- 某个锁**最近自旋成功获得过**（说明持有时间短）：允许更长的自旋时间。
				- JVM会认为这次自旋成功的可能性也高，
			- 某个锁**很少自旋成功**：直接减少自旋次数，甚至跳过自旋
				- 避免无谓的CPU浪费。

- 锁升级：
	- 含义：从轻量锁到重量级锁
	- 触发时机：JVM认为竞争激烈，自旋只会白白消耗CPU
		- 自旋失败：竞争线程CAS尝试一定次数（默认十次）后仍未获锁
		- 多线程竞争：在自旋期间，等待锁的线程超过一个（如第三个线程加入竞争）
	- 设计目的：
		- 避免CPU空转：将竞争失败线程状态转变为BLOCKED状态
	- 设计缺点：
		- 引入线程上下文切换开销，性能成本高
			- 锁膨胀会让自旋的线程进入阻塞状态，要进行上下文切换
			- 锁释放后唤醒等待队列的线程也要进行上下文切换
	- 实现流程：![[Pasted image 20251130222415.png]]
		1. 为 Object 对象申请 Monitor 锁
			- Monitor的Owner设置为Object的Mark Word指向的锁记录所在的线程
			-  然后自己进入Monitor的EntryList，进入BLOCKED状态
		2. 让 Object 指向重量级锁地址