[G1 垃圾收集器详解G1 垃圾收集器原理详解 theme: smartblue 1 G1的内存模型 传统的GC收集器将连 - 掘金](https://juejin.cn/post/7209266987049844791)
- 适合场景：
	- 同时注重吞吐量和低延迟
	- 适合有超大堆内存的服务器（4G到64G）
- 核心思想：分片、预测、并行
	- 分片： 把堆分成 2048 个 region（默认 1~32MB）；
	- 预测：通过 Region 优先级排序（Garbage-First）回收垃圾最多的区域
	- 并行：同时进行年轻代与老年代混合回收。

- 回收阶段：![[Pasted image 20251207185935.png]]
	- 新生代垃圾回收![[Pasted image 20251207190415.png]]
		- 分片： 把堆分成 2048 个 region（默认 1~32MB）；
			- 有多个伊甸园和老年代区域，
			- 但是只有两个幸存区，分别是To和From
		- [[新生代的跨代引用]]问题（老年代引用新生代）
	-  新生代垃圾回收+并发标记
		1. 在新生代垃圾回收，会进行 GC Root 的初始标记
		2. 并发标记：找到垃圾含量最多的老年代，进行优先级排序（G1）
			- 触发时机：老年代占用堆空间比例达到阈值时
				- 触发阈值配置：`-XX:initiatingHeapOccupancyPercent=percent`(默认45%)
	- 混合收集：对三类区域进行垃圾回收![[Pasted image 20251207191406.png]]
		1. [[G1重标记阶段]]（Remark）：会STW
		2. 拷贝存活：会STW
			- 对老年代：根据最大暂停时间配置，从老年代区域中挑出回收价值最大的区域，进行垃圾回收
- 优化：
	- 字符串去重
		- 需求背景：字符串冗余
			- 大量动态创建字符串
		- 解决措施：
			- 字符串入池
				- 使用[[字符串常量池|StringTable]]去重，共享 `String`对象本身在字符串常量池中的引用
				- 可以使用 `==`来快速比较内容是否相同
					- 比 `equals()`方法更快，因为 `==`只比较引用地址
			- G1字符串去重
				- 仍然是不同的字符串对象，共享字符串对象底层的 `char[]`字符数组
		- 开启方式：`-XX:+UsestringDeduplication`
		- 工作流程：
			- 将所有新分配的字符串放入一个队列
			- 当新生代回收时，G1并发检查是否有字符串重复
				- 如果它们值一样，让它们引用同一个 char数组![[Pasted image 20251208103514.png]]
	- 并发标记类卸载
		- 需求背景：传统类卸载（非并发），通常在Full GC的STW阶段进行
			- 增加Full GC的停顿时间
			- 频率低且耗时
		- 核心思想：在几乎不增加应用线程停顿时间的前提下，安全地回收不再使用的类及其元数据，从而有效控制元空间（Metaspace）的内存增长。
		- 工作模式：在并发标记阶段完成识别卸载后选（与应用线程并发执行），在下次垃圾回收的STW阶段完成卸载，
			- 几乎不产生额外的STW停顿
			- 更及时、高效
		- 开启方式：`-XX:+ClassUnloadingWithConcurrentMark`默认启用的
	- 回收巨型对象![[Pasted image 20251208110003.png]]
		- 巨型对象定义：占据region的一半及其以上
		- 回收巨型对象的时候：G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉
			- 回收的时候优先考虑，越早回收越好
			- G1不会对巨型对象进行拷贝
	- 并发标记开始时间调整
		- 需求背景：减少Full GC
		- 核心思想：提早开始并发标记，提早开始混合回收，减少FullGC的发生机率
		- 配置：JDK9之后，能动态调整触发阈值（老年代占用堆空间比例达到阈值）
			- 设置初始值`-XX:InitiatingHeap0ccupancyPercent `用来设置初始值
			- 垃圾回收的时候进行数据采样并动态调整，总会添加一个安全的空间