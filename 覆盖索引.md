### 覆盖索引（优化查询返回的字段）
查询使用了索引，​**并且需要返回的列，在该索引中已经全部能够找到**。

![[Pasted image 20251030191255.png]]
覆盖索引是一种**用空间换时间**的优化策略。通过创建合理的联合索引，并养成 `SELECT 具体字段`而非 `SELECT *`的习惯，可以避免耗时的回表操作，使查询性能获得数量级的提升。这是数据库索引优化中最有效的手段之一。
#### 一、核心概念

​**覆盖索引**​ 指的是：一个 SQL 查询**只需要通过扫描索引**，就能获取到所有需要的数据字段，而**无需再回到主键索引（聚簇索引）中进行“回表”查询**。

图片中的定义非常关键：

> “查询使用了索引，​**并且需要返回的列，在该索引中已经全部能够找到**。”

#### 二、为什么覆盖索引能大幅提升性能？

要理解其优势，首先要明白没有覆盖索引时的查询过程（回表查询）：

1. ​**索引扫描**​：在辅助索引（如 `idx_name`）的 B+Tree 中找到符合条件的记录。
    
2. ​**回表操作**​：由于辅助索引的叶子节点只存储了当前索引字段和对应的主键 ID，如果要获取 `SELECT *`中的其他字段，就必须根据找到的主键 ID，再回到主键索引的 B+Tree 中重新查找一遍，以获取完整的行数据。
    
3. ​**性能开销**​：这个“回到主表”的过程就是**回表**。每一条符合条件的记录都可能产生一次磁盘 I/O，当数据量巨大时，性能开销非常大。
    

而**覆盖索引避免了回表**​：

- 因为需要返回的所有列都包含在索引中，所以数据库引擎在扫描完辅助索引的 B+Tree 后，​**已经得到了全部所需数据**，无需再访问主键索引。这极大地减少了磁盘 I/O 操作，从而显著提升查询速度。
    

#### 三、实践建议：`减少 SELECT *`

图片中给出的建议 `减少select *`是使用覆盖索引最直接、最有效的方法。

- ​**`SELECT *`的问题**​：它要求返回所有列。除非你为所有查询字段建立了极其庞大的联合索引，否则几乎必然导致**回表查询**。
    
- ​**正确的做法**​：只查询业务逻辑真正需要的列。
    

​**对比示例：​**​

假设有一张 `user`表，有主键 `id`，并在 `(name, age)`上建立了联合索引 `idx_name_age`。

```
-- 查询1：低效查询（需要回表）
SELECT * FROM user WHERE name = '张三';

-- 查询2：高效查询（覆盖索引）
SELECT name, age FROM user WHERE name = '张三'; 
-- 以及
SELECT id, name, age FROM user WHERE name = '张三';
```

​**分析**​：

- ​**查询1**​：虽然 `name`条件用到了 `idx_name_age`索引，但要获取 `*`（如 email, phone 等未在索引中的列），数据库必须进行**回表**操作。
    
- ​**查询2**​：要返回的 `name`, `age`（以及主键 `id`默认存在）​**全部包含在 `idx_name_age`索引中**。数据库引擎在扫描 `idx_name_age`索引后就直接得到了结果，无需回表，速度极快。
    
