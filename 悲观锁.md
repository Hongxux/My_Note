---
aliases:
  - synchronized
  - ReentrantLock
---
## 核心思想
假设前提：**在操作数据之前，总是假设最坏的情况会发生，认为其他线程很可能会同时修改这份数据**。
基于这个前提采取行动：它会先强制获取独占锁，确保在持有锁的整个期间，其他任何线程都无法修改该数据，从而避免并发冲突。

## 适合场景
- **写多读少**，**数据竞争激烈**、
- **临界区操作耗时较长**的场景（如金融转账、库存扣减）。

## 实现方式
### java中
#### `synchronized`关键字
这是 Java 语言内置的、最基本的悲观锁机制。它可以用来修饰方法或代码块，确保同一时间只有一个线程能执行该段代码。
```java
// 同步代码块
public class SynchronizedExample {
    private final Object lock = new Object(); // 锁对象

    public void criticalMethod() {
        synchronized(lock) { // 获取锁
            // 临界区代码，同一时间只有一个线程可以执行
        } // 自动释放锁
    }
}
```
可以通过设置合适的锁对象提高准确性和效率

#### `ReentrantLock`类
这是 `java.util.concurrent.locks`包下提供的显式锁。它比 `synchronized`更灵活，支持尝试获取锁、超时中断、公平锁等高级功能
```
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void criticalMethod() {
        lock.lock(); // 手动获取锁
        try {
            // 临界区代码
        } finally {
            lock.unlock(); // 必须在finally块中手动释放锁，确保锁一定被释放
        }
    }
}
```
### 数据库中
在数据库层面，悲观锁通常通过 SQL 语句实现，最经典的是 `SELECT ... FOR UPDATE`
```
-- 在事务中执行：
START TRANSACTION;
-- 查询并锁定这条记录，其他事务无法修改或再加写锁
SELECT * FROM accounts WHERE id = 123 FOR UPDATE;
-- ... 执行余额检查、扣款等业务逻辑 ...
UPDATE accounts SET balance = balance - 100 WHERE id = 123;
COMMIT; -- 提交事务，释放锁
```
在使用 JPA 或 Hibernate 等 ORM 框架时，可以通过 `@Lock(LockModeType.PESSIMISTIC_WRITE)`注解来声明式地使用数据库悲观锁
## 实践建议与最佳实践

为了高效且安全地使用悲观锁，有几个关键点需要牢记：

1. **尽量缩小锁的粒度**：只锁定真正共享的资源，而不是一大段代码或整个表。锁的粒度越细，并发性能越好。
    
2. **尽量减少锁的持有时间**：在锁内只执行必要的操作，避免执行耗时的 I/O 操作（如网络请求、文件读写），尽快释放锁。
    
3. **避免嵌套锁**：尽量避免在持有一个锁的情况下去获取另一个锁，如果无法避免，必须保证所有线程以**相同的顺序**获取锁，这是预防死锁的有效方法。
    
4. **使用 `try-finally`确保释放**：在 Java 中使用显式锁（如 `ReentrantLock`）时，务必在 `finally`块中调用 `unlock()`方法，以确保即使在临界区代码发生异常时，锁也能被正确释放，防止锁泄漏。