- 需求背景：默认队列
	- 换页阻塞：默认情况下，RabbitMQ将消息存储在内存中以实现快速处理。但当内存不足时，Broker会启动“**换页**”操作，将部分消息从内存批量转移到磁盘。这个过程**耗时较长且会阻塞队列**，导致消息处理暂停，影响整体性能
	- 队列阻塞隔离：如果一个队列因生产过快或消费停滞导致消息大量堆积，占用了过高内存，可能会 **“殃及池鱼”**，影响同一Broker上其他队列的正常工作
- 解决措施：Lazy Queue
	- **消息直接持久化**：当生产者将消息发送到惰性队列时，RabbitMQ会**尽可能地立即将消息写入磁盘**，而不是优先保留在内存中
	- **按需加载**：当消费者准备处理消息时，RabbitMQ才会将对应的消息从磁盘加载到内存中，然后传递给消费者。**动态缓存机制**：
		-  当消费者处理速度较慢时，消息直接从磁盘加载。
		- 当系统检测到消费者处理速度很快时，会**尝试将后续的一批消息（最多2048条）预加载到内存中**，以减少消费过程的延迟。
	- **异步刷盘**：为了平衡性能与可靠性，惰性队列通常采用异步刷盘机制。
		- 异步刷盘的含义：消息可能先存在于操作系统的缓存中，然后由操作系统决定何时写入物理磁盘。这提供了比默认模式更好的持久性保证
		- 风险：在极端情况下（如服务器断电）仍有极小概率丢失少量尚未落盘的消息
- 使用方式：创建Lazy Queue，生产者发送持久化数据
	```
	@Configuration
	public class RabbitMQConfig {
	
	    @Bean
	    public Queue lazyQueue() {
	        Map<String, Object> args = new HashMap<>();
	        // 关键参数：将队列设置为惰性模式
	        args.put("x-queue-mode", "lazy");
	        // 参数说明：队列名，是否持久化，是否独占，是否自动删除，其他参数
	        return new Queue("business.lazy.queue", true, false, false, args);
	    }
	}
	```
- 问题：写入磁盘，速度慢，有延迟，不适合高吞吐场景
	- **直接存入磁盘导致更高的延迟**：与内存操作相比，磁盘写入速度要慢几个数量级。因此，对于单条消息的**写入延迟（P99 Latency）会显著高于普通队列**​
		- 这意味着从生产者发送消息到消息被RabbitMQ成功存储的时间会变长
	- **吞吐量受限于磁盘**：队列的总体吞吐量（如每秒处理的消息数TPS）将受限于磁盘的持久化速度。虽然Lazy Queue能稳定支持较大的消息积压，但其峰值性能通常低于消息全在内存中的普通队列
		- 官方文档提及它更适合TPS一万以下的场景
- 权衡：
	- 在生产环境中，建议**将Lazy Queue隔离到专用的RabbitMQ节点**上，避免影响对延迟敏感的业务队列。
	- **日志收集、离线任务、审计事件**等允许延迟、可能突发大量消息的场景，是惰性队列的典型用武之地
	- **实时交易、即时通讯**等高吞吐低延迟场景，则应使用默认队列。