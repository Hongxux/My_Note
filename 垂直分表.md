### 根据
- 尤其是数据量较大的场景下，通常不建议将所有信息放在一张大表里。而采用分表存储
- 好处：单表宽度减少，单行数据量变小
	- 索引性能提升和IO次数下降，提高查询效率：一个数据页就能存放更多数据了，减少IO次数
		- 推论的原因：
			- 数据页能存储的行数和行的数据大小有关：
				- 关系公式：数据页每页能存储的行数 = 16KB ÷ 每行数据大小
				- 相关公式：每行数据大小 = 所有字段长度之和 + 额外开销（约27字节）
			- IO次数和页数的关系：查询数据时，数据库需要读取包含目标数据的页
				- 每次IO能读取的页数：
					- 每次I/O操作至少读取一页数据
					- 一次IO至多读取64个连续的页
						- 不连续能读取的页数更少
				- 需要读取的页数 = 查询的行数 ÷ 每页能存储的行数
		- 推论：每行的数据少，一页数据页能存储的行数就多，每次需要读取的页数就少，需要进行的IO次数就少
		- 举例：宽表 vs 窄表对比示例
			- 假设原始表结构：
				- **宽表**：每行1KB → 每页可存16行 → 查询100万行需62,500页
				- **窄表**：垂直拆分后每行64字节 → 每页可存256行 → 查询100万行仅需3,900页
			- **优化效果**：
				- **页数减少约16倍** → IO次数相应减少
				- **查询速度提升5-10倍**（实测数据，取决于硬件和查询模式）
	- 提高缓存命中率：更多热点数据可以被缓存到内存中，避免了大字段对缓存空间的占用
	- 大字段影响
		- 降低查询性能
			- 行溢出：大字段数据会被分割存储在多个页中，查询时需要额外I/O操作获取完整数据
			-  大字段难以建立有效索引，查询优化器可能被迫选择全表扫描
			- 锁竞争加剧：大字段的更新操作（如替换头像、修改文档）可能引发长事务
			- 出现不必要的数据读取： 当用户仅需查询主表的基本信息（如用户ID、姓名）时，数据库仍需扫描包含LOB字段的完整记录
				- - 这种**不必要的数据传输**造成大量资源浪费
		- 降低数据传输
		- 
### 使用场景
- 查询常**仅需部分字段**（如用户表只需ID/姓名，无需头像）
- 大字段（BLOB/TEXT）与核心字段分离
### 实现方式：
1. 前期规划和分析
	- 识别表的可拆分点：将常常一起绑定需要的内容放在一块，减少多表联查
	- 拆分方式：
		- 拆成主表（热数据）和扩展表（冷数据）
		- 分析主表和拓展表的字段分配
2. 表结构的设计
	1. **主表设计**：保留高频访问的核心字段（如ID、用户名、状态等）
	2. **扩展表设计**：将低频访问或大字段（如TEXT、BLOB）放入扩展表
	3. **确保主键一致性**：所有子表必须包含相同的主键或唯一索引
3. 数据迁移策略
	- **批量迁移**：使用INSERT INTO ... SELECT语句迁移历史数据
		```
		-- 迁移基础数据
		INSERT INTO users_basic (id, username, password, email)
		SELECT id, username, password, email FROM users;
		
		-- 迁移联系方式
		INSERT INTO users_contact (id, phone, address)
		SELECT id, phone, address FROM users;
		
		-- 迁移头像信息
		INSERT INTO users_profile (id, profile_pic)
		SELECT id, profile_pic FROM users;
		```
	- **双写过渡**：在应用层同时写入新旧表，确保数据一致性
	- **数据校验**：迁移后进行数据完整性检查
- 