---
aliases:
  - 卡表
---
- 作用：跟踪并发阶段的引用变更
- 数据结构：卡表（Card Table），即一个字节数组
	- 每个元素对应老年代的一块固定大小的内存区域（称为 “卡页”）
	- 卡表的核心更新方式：
		- 标记脏卡：用户线程修改老年代对象引用时，通过写屏障触发，计算该对象所在的卡页索引，将卡表中对应位置的字节设为 “脏”（如 0x01）。
		- 清理脏卡：重新标记阶段结束后，将卡表中所有 “脏” 的字节重置为 “干净”（如 0x00），为下一次 GC 做准备。
	- 脏卡管理器的核心需求：
		- 快速记录：用户线程修改引用时需要快速记录变更的区域
		- 批量遍历：重新标记阶段，能快速遍历所有变更的内存区域。
		- 低内存开销：不能因记录变更而占用过多内存。
	- 字节数组的好处：
		- 通过卡页能快速记录变更区域
		- 数组的遍历速度快，而哈希表有哈希冲突
		- 无锁并发，而链表并发修改时候需要加锁
	- 
- 并发标记阶段
	- 并发标记时期，为了跟踪并发过程中对象引用关系的变化，G1为所有写操作插入了**写屏障**。当你执行类似 `objA.field = objB`这样的操作时，写屏障会执行以下关键逻辑：
		- 它会检查这是否是一个跨Region的引用（即 `objA`和 `objB`是否不在同一个Region）。
		- 如果是跨Region引用，写屏障并不会直接更新RSet，因为这样性能开销太大。相反，它会将`objA`所在的**卡**在卡表中标记为“脏”，这是一个非常快速的操作。
	- 后台会有专门的GC线程（通常是`RefineThread`）来处理卡表中积累的“脏卡”。
		- 这些线程会扫描每一个“脏卡”对应的内存块，精确找出其中所有的跨Region引用。
		- 然后，它们会将这些引用关系**更新到目标Region的RSet中**。例如，如果Region A中的对象引用了Region B中的对象，那么这个关系会被记录到Region B的RSet里。
-   最终标记阶段
	- 并发标记阶段的基础：由于RSet已经包含了完整的跨Region引用信息，G1在进行可达性分析时，要确定一个Region中的对象是否存活，就**无需从GC Roots开始扫描整个堆**。
	- 它只需要以GC Roots为起点，并**额外检查该Region的RSet**。RSet指明了所有可能指向该区域存活对象的外部引用，G1只需扫描这些引用即可精确判断对象的存活状态。
	- 作用：这极大地缩小了扫描范围，从“全堆扫描”变成了“**局部扫描**”，从而显著缩短了STW停顿时间。

