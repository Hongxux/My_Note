---
aliases:
  - CMS
---
# CMS 垃圾回收器（JDK 8 完整版笔记）

# CMS垃圾回收器笔记（完整版·基于JDK 8官方文档）

核心定位：JDK 8专属老年代低延迟收集器，仅负责老年代垃圾回收，默认搭配ParNew新生代收集器，专为响应时间敏感型应用设计。

---

## 一、设计目的

针对传统串行/并行老年代收集器（Serial Old、Parallel Old）STW停顿过长的痛点，通过“大部分流程与用户线程并发执行”的核心设计，最大限度缩短老年代GC的STW时间，满足电商交易、金融支付、实时接口等对响应延迟敏感的场景需求——核心目标是“将老年代GC的总STW时间控制在百毫秒级”，避免长停顿影响用户体验或业务连续性。

## 二、设计要求与约束（官方不可妥协铁律）

1. **仅关键步骤触发短时间STW**
    
    1. 严格限定STW阶段：仅保留“初始标记”“重新标记”两个短STW阶段，总STW时长需控制在100ms内；“并发预清理”“并发标记”“并发清除”三个核心阶段必须与用户线程并行执行，全程不暂停应用。
        
    2. 约束逻辑：若扩大STW范围，CMS将失去低延迟核心优势，与传统收集器无本质区别，违背设计初衷。
        
    3. 特殊场景兼容：单核心CPU环境下，并发线程会自动降级为1个，避免CPU资源抢占导致用户线程无响应。
        
2. **标记准确性兜底，杜绝漏标/错标**
    
    1. 核心要求：并发标记阶段用户线程修改引用关系时，必须实时追踪所有变化，确保“存活对象不被漏标（避免程序崩溃）、垃圾对象不被错标（避免内存泄漏）”。
        
    2. 技术支撑：通过“写屏障+卡表+增量更新队列”的三重机制兜底，覆盖所有引用更新场景，无标记盲区。
        
    3. 验证标准：每次GC后需确保存活对象标记率100%，垃圾对象误标率0%，符合JVM内存管理规范。
        
3. **并发阶段CPU资源占用可控**
    
    1. 线程数约束：并发收集线程数默认按`(CPU核心数 + 3) / 4`计算，核心原则是“不抢占超过50%的CPU资源”，避免影响用户线程执行效率。
        
    2. 优先级控制：并发收集线程优先级略低于用户线程（默认优先级5，与用户线程一致但调度时优先让渡），确保业务请求优先被处理。
        
    3. 灵活调整：支持通过参数手动调整线程数，适配不同CPU核心数场景（如单核心环境强制使用1个并发线程）。
        
4. **仅支持老年代，依赖新生代收集器联动**
    
    1. 功能边界：CMS无新生代回收能力，必须搭配新生代收集器（JDK 8默认ParNew，也可手动指定Serial），形成“ParNew + CMS”固定组合。
        
    2. 联动逻辑：新生代执行Minor GC后，存活对象按晋升规则进入老年代；当老年代内存占用达到阈值时，触发CMS老年代GC，二者通过卡表协同避免跨代引用扫描冗余。
        

## 三、核心组件（官方文档详细说明）

### 1. MarkBitMap（标记位图）

- 核心作用：精准记录老年代对象的存活状态，为并发清除阶段提供明确的回收依据。
    
- 数据结构：基于字节数组的位图结构，每个比特位对应老年代一个512字节的内存块（与卡页大小严格对齐，官方为优化操作效率设计）。
    
- 状态标识：
    
    - 0：对应内存块中的对象为垃圾，可回收；
        
    - 1：对应内存块中的对象为存活，需保留。
        
- 关键操作：
    
    - 标记：通过CAS原子操作修改比特位（避免并发标记线程竞争冲突），确保多线程标记安全；
        
    - 查询：通过位运算快速判断对象存活状态（O(1)复杂度，无性能开销）；
        
    - 清除：并发清除阶段，遍历位图将0对应的内存块加入空闲列表，不影响存活对象；
        
    - 重置：GC结束后批量清空位图（逐字节而非逐位重置，提升效率），为下一次GC做准备。
        

### 2. CMSConcurrentThread（并发收集线程）

- 核心作用：专门执行并发预清理、并发标记、并发清除任务，与用户线程并行运行。
    
- 线程特性：
    
    - 生命周期：与JVM进程一致，空闲时处于阻塞状态（等待CMS触发信号），避免空耗CPU；
        
    - 调度机制：采用“唤醒-执行-阻塞”循环，触发CMS时由JVM主动唤醒，执行完并发阶段后再次阻塞；
        
    - 容错能力：单个并发线程异常终止时，JVM会自动重启线程并沿用原配置，不影响GC流程。
        

### 3. CardTable（卡表）& RSet（记忆集）

- 核心关联：卡表是RSet在CMS中的具体实现形式，官方明确定义为“跨代引用追踪与老年代引用变化记录的核心组件”。
    
- 卡表细节：
    
    - 数据结构：固定长度的字节数组，数组长度=老年代内存大小/卡页大小（512字节），内存开销极低（老年代8GB时，卡表仅占用16KB）；
        
    - 状态标识：仅两种核心状态——`0=干净卡`（卡页内对象引用无变化）、`1=脏卡`（卡页内对象引用已修改），无额外中间状态（简化逻辑、提升效率）；
        
    - 双重核心作用：
        
        1. 支撑Minor GC：标记“持有新生代对象引用的老年代卡页”，Minor GC时仅扫描这些卡页，无需遍历整个老年代（大幅减少Minor GC耗时）；
            
        2. 支撑CMS GC：追踪老年代内部及跨代的引用变化，为并发预清理、重新标记阶段提供“需要修正的引用范围”，避免漏标。
            
- 脏卡标记流程：
    
    - 用户线程执行引用更新操作（如a=b、对象属性赋值）；
        
    - JVM自动计算引用所在对象对应的老年代卡页索引（通过内存地址偏移量计算）；
        
    - 通过原子操作将卡表对应位置设为1（避免多线程并发修改导致的状态不一致）；
        
    - 标记后无需等待处理，由并发线程在后续阶段异步扫描。
        

### 4. WriteBarrier（写屏障）

- 官方定义：JVM在用户线程执行“引用赋值操作”（含对象创建时的引用绑定、属性引用更新、变量引用替换）时，自动注入的后置轻量级代码片段——无方法调用开销，单次执行耗时纳秒级，对用户线程性能影响可忽略。
    
- 核心功能（双重保障，覆盖所有引用更新场景）：
    
    - 标记脏卡：针对“老年代对象的引用更新”（包括新→老跨代引用、老→老内部引用），联动卡表标记对应卡页为脏卡，确保引用变化被追踪；
        
    - 补充兜底：针对卡表无法覆盖的场景（如对象被移动、临时引用变更），将更新后的引用记录到增量更新队列，避免标记遗漏。
        
- 触发场景：所有引用赋值操作，包括但不限于：
    
    - 局部变量引用更新（如User u = new User()）；
        
    - 对象属性引用更新（如order.setUser(u)）；
        
    - 数组元素引用更新（如users[0] = u）；
        
    - 静态变量引用更新（如User.INSTANCE = u）。
        

### 5. 增量更新队列（Incremental Update Queue）

- 核心作用：存储并发标记阶段所有未被卡表完全覆盖的引用更新记录，为重新标记阶段提供“漏标修正清单”，确保标记结果100%准确。
    
- 数据结构：无锁并发队列（ConcurrentLinkedQueue），支持多线程同时入队/出队，无锁竞争开销。
    
- 操作逻辑：
    
    - 入队：写屏障触发时，若引用更新无法通过卡表标记覆盖（如临时引用变更），自动将更新后的引用对象入队；
        
    - 出队：重新标记阶段，多线程并行从队列中取对象，遍历其引用链补全标记（确保所有可达对象被标记）；
        
    - 清空：重新标记结束后，批量清空队列（而非逐元素删除），提升效率，为下一次GC做准备。
        

## 四、完整工作流程（5个阶段，官方标准流程）

CMS老年代GC全程分为5个阶段（2个STW阶段+3个并发阶段），各阶段衔接紧密，无流程冗余，所有步骤均为官方明确的核心流程：

### 1. 初始标记（STW：短停顿，通常<10ms）

- 触发时机：老年代内存占用达到设定阈值（默认92%），或JVM检测到老年代内存增长过快（动态预判可能触发OOM）。
    
- 核心作用：标记“根对象”及根对象的“直接引用对象”（仅老年代对象，新生代对象由ParNew独立负责）。
    
- 根对象具体范围（官方明确定义）：
    
    - 虚拟机栈中所有活跃栈帧的局部变量表引用；
        
    - 方法区中的静态变量引用、常量池引用；
        
    - 本地方法栈中的JNI（Java Native Interface）引用；
        
    - 活跃线程的栈引用、JVM内部的系统引用（如类加载器引用）。
        
- STW原因：确保根集引用状态稳定——若标记过程中根对象引用被用户线程修改，会导致初始标记结果不准确，进而引发后续漏标。
    
- 优化方式：启用`-XX:+CMSParallelInitialMarkEnabled`（JDK 8+支持），通过多线程并行标记根对象及直接引用，进一步缩短STW时间（多核环境下可降至5ms内）。
    
- 产出结果：得到初始存活对象集合，作为后续并发标记的“起点清单”。
    

### 2. 并发预清理（无STW：预处理阶段，时长通常<100ms）

- 核心目的：减少重新标记阶段的工作量，缩短后续STW时间（官方设计的“前置优化阶段”）。
    
- 核心操作：
    
    - 扫描脏卡：遍历卡表中所有脏卡，遍历卡页内的对象，补全存活对象标记（提前处理部分引用更新）；
        
    - 重新标记脏卡：若扫描过程中，卡页内对象引用再次更新（用户线程并发执行），则重新标记该卡页为脏卡，确保后续不遗漏；
        
    - 触发Minor GC：若新生代内存占用达到阈值，主动触发ParNew GC，清理新生代垃圾——减少后续重新标记阶段需要扫描的跨代引用数量。
        
- 时长控制：官方默认最大执行时长500ms（通过`-XX:CMSMaxAbortablePrecleanTime`配置），超时则直接进入重新标记阶段，避免过度占用CPU。
    
- 关键特性：与用户线程并行执行，不影响应用响应，仅占用少量CPU资源（单个并发线程）。
    

### 3. 并发标记（无STW：核心阶段，占GC总时长70%+）

- 核心作用：从初始标记的存活对象出发，多线程广度优先遍历老年代所有引用链，标记全部存活对象，为清除阶段提供完整依据。
    
- 执行逻辑：
    
    - 初始化标记队列：将初始标记阶段得到的“根对象直接引用对象”全部放入并发队列；
        
    - 多线程并行标记：每个并发线程从队列中取对象，标记为存活后，将其所有子引用对象入队（广度优先遍历，避免递归深度过大导致栈溢出）；
        
    - 实时处理脏卡：并发标记过程中，写屏障触发产生的新脏卡会被实时扫描，补全标记（确保用户线程修改的引用不被遗漏）；
        
    - 队列排空：循环执行标记-入队操作，直至队列中无待标记对象，此时老年代大部分存活对象已被标记。
        
- 线程协作：多个并发线程共享全局标记队列，同时支持本地队列缓存（减少线程间竞争），标记效率最大化。
    
- 固有产物：浮动垃圾——此阶段用户线程持续运行，新产生的垃圾无法被本次GC回收，需预留内存容纳。
    

### 4. 重新标记（STW：短停顿，通常<50ms）

- 核心作用：修正并发标记阶段因用户线程修改引用导致的漏标问题，最终确认老年代所有存活对象，确保标记结果100%准确（官方称为“最终标记阶段”）。
- 完整流程（官方明确步骤，按优先级执行）：
    1. 预处理：若启用`-XX:+CMSScavengeBeforeRemark`，先触发一次Minor GC，清理新生代垃圾（减少跨代引用扫描量）；
    2. 扫描剩余脏卡：遍历并发预清理、并发标记阶段未处理的脏卡，补全存活对象标记（覆盖新→老、老→老引用更新）；
    3. 处理增量更新队列：多线程并行遍历队列中的引用更新记录，遍历引用链补全标记（兜底修正，避免漏标）；
    4. 重新扫描根集：再次扫描所有根对象，确保根集最新引用未被遗漏（最终兜底步骤）；
    5. 特殊引用处理（按官方优先级）：
        1. 虚引用：直接取消标记，将对象加入虚引用回收队列（后续触发对象finalize方法）；
        2. 弱引用：若对象仅被弱引用关联，取消标记（标记为可回收）；
        3. 软引用：若老年代内存不足，取消标记；内存充足则保留标记（遵循“内存不足时回收”规则）。
- 优化方式：启用`-XX:+CMSParallelRemarkEnabled`（JDK 8默认开启），多线程并行执行重新标记，缩短STW时间。
### 5. 并发清除（无STW：回收阶段，时长随垃圾量变化）
- 核心作用：基于重新标记后的MarkBitMap，精准清除老年代中未被标记（比特位0）的垃圾对象，释放内存。
- 执行逻辑：
    - 遍历MarkBitMap：按老年代内存地址顺序遍历位图，识别未被标记的垃圾对象；
    - 释放垃圾内存：将垃圾对象对应的内存块加入空闲列表（按内存块大小分类，如小对象块、中对象块、大对象块），方便后续对象快速分配；
    - 跳过存活对象：标记为1的存活对象不做任何处理，保留其内存空间及引用关系。
- 安全保障：无需担心并发修改导致的误删，原因如下：
    - 新增存活对象：要么是新生代晋升（分配在新内存块，不在本次标记范围），要么是用户线程新建（分配在空闲列表的内存块，未被标记位图覆盖）；
    - 引用更新：仅修改对象引用关系，不改变对象的存活状态标记，不会导致存活对象被误判为垃圾；
    - 大对象分配：优先使用空闲列表中的大内存块，避免内存碎片影响分配。
- 核心缺陷：采用“标记-清除”算法，回收后会产生大量不连续的内存碎片（官方明确的固有缺陷）。
## 五、核心问题及官方解决方案
### 1. 内存碎片问题（固有缺陷）
- 问题本质：标记-清除算法仅释放垃圾内存，不移动存活对象，导致老年代中出现大量不连续的内存空洞——即使总内存充足，也可能因无足够大的连续空间分配大对象，最终触发Full GC。
- 官方解决方案（内存压缩，权衡低延迟与碎片问题）：
    - 核心参数配置：
        1. `-XX:+UseCMSCompactAtFullCollection`（默认开启）：Full GC时自动执行内存压缩（切换为标记-整理算法），将存活对象移动到内存起始地址，形成连续空间；
        2. `-XX:CMSFullGCsBeforeCompaction`（默认0）：每执行N次无压缩Full GC后，执行1次带压缩的Full GC（如设为5，即每5次Full GC后压缩1次）。
    - 压缩逻辑：
        1. 暂停所有用户线程（STW），将老年代存活对象按内存地址递增顺序移动；
        2. 更新所有引用指向（确保对象移动后引用不失效）；
        3. 清空末尾垃圾内存，形成连续空闲空间。
    - 注意事项：压缩会增加Full GC的STW时间（通常是普通Full GC的2-3倍），需根据业务场景平衡延迟与碎片问题。
### 2. 浮动垃圾问题（并发阶段固有产物）
- 官方定义：在并发预清理、并发标记、并发清除三个阶段，用户线程持续运行产生的新垃圾——这些垃圾无法被本次GC回收，需等待下一次CMS GC。
- 核心风险：浮动垃圾占用老年代内存，可能导致老年代空间快速耗尽，触发并发模式失败。
- 官方解决方案（预留空间+提前触发）：
    - 提前触发CMS：通过`-XX:CMSInitiatingOccupancyFraction`降低触发阈值（推荐70%-80%），为浮动垃圾预留足够内存（官方建议预留老年代内存的10%-20%）；
    - 强制固定阈值：启用`-XX:+UseCMSInitiatingOccupancyOnly`，禁止JVM动态调整阈值（避免阈值自动升高导致预留空间不足）；
    - 增大老年代内存：官方建议老年代内存至少为活跃对象的2-3倍，确保有足够空间容纳浮动垃圾和正常晋升对象。
### 3. 并发模式失败（Concurrent Mode Failure，高频异常）

- 官方定义：CMS并发阶段（预清理/标记/清除）中，老年代内存被快速占满，无法容纳新生代晋升的对象或用户线程新建的大对象，导致并发GC流程无法继续。
    
- 直接后果：JVM暂停并发流程，切换为Serial Old收集器执行全程STW的Full GC（标记-整理算法），停顿时间可达数秒（严重影响响应时间）。
    
- 官方分层解决方案：
    
    - 短期参数调优（快速缓解）：
        
        1. 降低CMS触发阈值（如70%），预留更多内存缓冲；
            
        2. 增大老年代内存（调整`-Xmx`/`-Xmn`，减少新生代占比，为老年代扩容）；
            
        3. 启用`-XX:+ParallelCMS`：并发失败时使用多线程Full GC（而非单线程），缩短STW时间；
            
    - 中期应用优化（减少根本诱因）：
        
        1. 减少大对象创建：避免直接在老年代分配大对象（如超大字符串、大型集合），可拆分大对象为小对象，或使用堆外内存存储；
            
        2. 优化对象生命周期：减少新生代对象提前晋升（增大Survivor区，调整`-XX:SurvivorRatio`为4-6，延长对象在新生代的存活时间）；
            
    - 长期收集器替换（彻底解决）：迁移至G1/ZGC等现代收集器——G1通过Region分区和标记-整理算法，从根本上避免并发模式失败和内存碎片问题。
        

### 4. 晋升失败（Promotion Failure，易与并发模式失败混淆）

- 官方定义：Minor GC时，新生代存活对象无法在Survivor区容纳（Survivor区溢出），尝试晋升到老年代，但老年代无足够连续空间（或总空间不足），导致Minor GC失败。
    
- 与并发模式失败的核心区别：
    
    - 触发阶段不同：晋升失败触发于Minor GC阶段，并发模式失败触发于CMS并发阶段；
        
    - 诱因不同：晋升失败源于“新生代对象晋升压力”，并发模式失败源于“老年代空间耗尽”。
        
- 官方解决方案：
    
    - 优化新生代配置：增大Survivor区（降低`-XX:SurvivorRatio`值），让更多对象在新生代存活并被回收，减少晋升压力；
        
    - 解决老年代碎片：启用CMS内存压缩，确保老年代有足够连续空间容纳晋升对象；
        
    - 增大老年代内存：为对象晋升预留更多空间，避免总空间不足。
        

### 5. 吞吐量下降问题

- 问题本质：并发阶段收集线程与用户线程竞争CPU资源，导致用户线程可使用的CPU核心数减少，处理能力下降（官方实测：高负载下吞吐量可能下降5%-10%）。
    
- 官方缓解方案：
    
    - 合理配置并发线程数：CPU核心数≤4时设为1，4-8核设为2，8核以上设为4（避免过度竞争）；
        
    - 避开高负载时段触发GC：通过监控调整CMS触发阈值，避免在业务高峰期（如电商秒杀）触发CMS；
        
    - 限制并发阶段CPU占用：禁用增量模式（JDK 9已废弃），避免并发阶段频繁抢占CPU；
        
    - 替换收集器：G1通过Region分区和动态线程调度，减少CPU竞争，平衡延迟与吞吐量。
        

## 六、开启方式与核心参数（官方推荐配置）

### 1. 基础开启方式（JDK 8）

```Bash
# 核心参数：启用CMS老年代收集器（自动搭配ParNew新生代收集器）
-XX:+UseConcMarkSweepGC
# 可选参数：手动启用ParNew（JDK 8默认自动启用，无需额外配置）
-XX:+UseParNewGC
```

### 2. 核心调优参数（官方推荐值+作用）

|   |   |   |   |
|---|---|---|---|
|参数名|官方默认值|核心作用|推荐配置|
|`-XX:CMSInitiatingOccupancyFraction`|92|设定CMS老年代触发阈值（百分比）|70-80（预留浮动垃圾空间）|
|`-XX:+UseCMSInitiatingOccupancyOnly`|关闭|强制使用设定阈值，禁止JVM动态调整|开启（确保阈值稳定）|
|`-XX:ConcGCThreads`|`(ParallelGCThreads + 3) / 4`|设定CMS并发收集线程数|按CPU核心数调整（见上文）|
|`-XX:CMSMaxAbortablePrecleanTime`|500ms|设定并发预清理阶段最大时长|300-500ms（平衡预处理效果与耗时）|
|`-XX:+CMSParallelInitialMarkEnabled`|关闭|初始标记阶段多线程并行执行|开启（缩短初始标记STW）|
|`-XX:+CMSParallelRemarkEnabled`|开启|重新标记阶段多线程并行执行|保持开启（默认优化）|
|`-XX:+UseCMSCompactAtFullCollection`|开启|Full GC时执行内存压缩|保持开启（解决碎片）|
|`-XX:CMSFullGCsBeforeCompaction`|0|每N次无压缩Full GC后执行1次压缩|3-5（平衡压缩频率与STW时间）|
|`-XX:+CMSScavengeBeforeRemark`|关闭|重新标记前触发Minor GC|开启（减少重新标记工作量）|

### 3. 参数依赖关系（官方明确）

- `UseCMSInitiatingOccupancyOnly`必须与`CMSInitiatingOccupancyFraction`搭配使用，否则JVM仍会动态调整阈值；
    
- `CMSParallelInitialMarkEnabled`仅在多核CPU环境下有效，单核心环境启用无意义；
    
- `CMSScavengeBeforeRemark`启用后，重新标记阶段STW时间会缩短，但会增加一次Minor GC的耗时，需整体权衡。
    

## 七、官方废弃原因（JEP 291 + JEP 363）

CMS在JDK 9被标记为废弃，JDK 14正式移除，官方明确核心原因如下：

1. **核心设计缺陷无法根治**：
    
    1. 内存碎片问题：标记-清除算法固有缺陷，压缩需牺牲STW时间，违背低延迟目标；
        
    2. 并发模式失败：浮动垃圾与对象晋升压力无法完全规避，高负载场景下仍可能触发长停顿；
        
    3. 大堆支持不足：官方建议最大堆内存≤8GB，超过后并发失败概率显著上升，无法适配现代大内存服务器。
        
2. **维护成本过高**：
    
    1. HotSpot团队需投入大量资源维护CMS代码，与G1、ZGC等现代收集器的开发进度冲突；
        
    2. CMS与JDK新特性（如模块化、垃圾回收日志优化、ZGC）兼容性较差，适配成本高。
        
3. **存在更优替代方案**：
    
    1. G1：JDK 9+默认收集器，通过Region分区平衡低延迟与吞吐量，无内存碎片问题，支持大堆内存（推荐4-32GB）；
        
    2. ZGC/Shenandoah：极致低延迟（STW<10ms），支持TB级堆内存，满足更高要求的低延迟场景。
        

## 八、面试高频考点

1. CMS完整工作流程（5个阶段，2个STW阶段的作用、区别及优化方式）；
    
2. CMS核心组件的协同逻辑（写屏障+卡表+增量更新队列如何避免漏标）；
    
3. CMS三大核心问题（内存碎片、并发模式失败、浮动垃圾）的原因与官方解决方案；
    
4. 并发模式失败与晋升失败的区别（触发阶段、诱因、后果）；
    
5. CMS与G1的核心区别（设计目标、数据结构、垃圾回收算法、适用场景）；
    
6. CMS核心参数的含义及推荐配置（如`CMSInitiatingOccupancyFraction`、`UseCMSCompactAtFullCollection`）；
    
7. CMS被废弃的官方核心原因。