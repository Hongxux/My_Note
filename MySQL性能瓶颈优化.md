---
aliases:
  - 数据库性能瓶颈
  - 优化数据库
---
- 排查方法
	1. 开启并分析慢查询日志
	2. 实时监控
		- 查看当前正在执行的SQL：SHOW FULL PROCESSLIST;
	3. 使用 `EXPLAIN`分析慢SQL的执行计划
		- - **type**：访问类型，从优到劣大致是 `const > eq_ref > ref > range > index > ALL`。如果出现 `ALL`，意味着全表扫描，需要优化
		- **key**：实际使用的索引。如果为 `NULL`，则表示未使用索引
		- **rows**：预估需要扫描的行数。这个值越大，性能通常越差。
		- **Extra**：额外信息。如果出现 `Using filesort`（文件排序）或 `Using temporary`（使用临时表），通常意味着性能瓶颈
	4. **使用 `SHOW PROFILE`进行深度诊断**
		- 查看SQL执行过程中每个步骤的详细时间消耗，从而精确定位是哪个环节耗时最



- 应用层优化
	- 引入缓存中间件：缓存热点数据
	- 优化SQL语句：特别是查询语句
		- 使用覆盖查询，避免回表查询
		- 大数据翻页用游标
		- 谨慎多表联查和子查询
		- 查询条件中的范围查询，不等条件查询，or，like，数据类型不匹配判断，出现函数，都会导致索引失效
	- 使用连接池：
		- 通过连接池复用数据库连接，可以避免频繁创建和销毁连接带来的巨大开销，这对于短时高并发场景尤为重要
- 数据库优化：
	- 围绕索引
		- 创建合适的索引：索引创建原则
		- 正确使用索引：[[查询中正确使用索引]]
	- 优化表结构
		- 分库分表
	- 数据库配置：
		- 适当提高InnoDB的缓冲池大小innodb_buffer_pool_size
		- 调整最大连接数
- 数据库架构优化：带来运营成本，**性能 vs 数据一致性**
	- 读写分离：MySQL主从
	- 进行分库分表：当单表数据量达到千万级并持续增长时，需要考虑分库分表。
	- 引入专用数据组件：对于复杂的搜索、聚合分析等需求，可以将其卸载到专用组件上。
		- 复杂的搜索查询：使用Elasticsearch处理
		- 分析型查询：ClickHouse或StarRocks等OLAP数据库