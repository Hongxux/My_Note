
- 需求背景：重复造轮子、易出错、不透明，在没有统一框架时，每个同步器都需要自己处理：
	1. **代码冗余**：不同同步工具的核心逻辑（排队、阻塞、唤醒）高度重复，但无法复用；
	2. **正确性风险**：手动实现线程排队和状态同步容易出错（如死锁、唤醒丢失、状态不一致）。
- 设计目标：提供一个**通用同步器框架**，封装多线程竞争中的**状态管理、线程排队、阻塞唤醒**等共性逻辑，让具体同步工具（如锁、信号量）只需关注自身的**状态含义**和**资源分配规则**。
- 设计要求：
	- 同步状态的原子性与可见性：同步状态（`state`）必须通过`volatile`修饰保证可见性，通过 CAS 操作保证修改的原子性，不依赖重量级锁（如`synchronized`）。
	- 等待队列的高效管理：等待队列必须支持**快速入队**、**快速出队**和**快速删除取消等待的节点**，操作时间复杂度为 O (1)。
	- 模式无关的通用框架：框架核心逻辑（排队、唤醒、状态检查）必须与具体同步模式（独占 / 共享）解耦，通过钩子方法让子类实现模式相关逻辑。
---
- **核心抽象**「同步状态 + 等待队列 + 模式标记」的三元组
	- 同步状态（`state`）：是同步的 “核心数据”，用于表示同步资源的状态
		- 数据结构：volatile int state
			- `volatile`保证可见性
			- CAS保证更新的原子性共和
		- 修改方式：CAS 操作（`compareAndSetState`）实现原子修改
			- 获取状态：`getState()`（直接返回`state`，`volatile`保证可见性）；
			- 设置状态：`setState(int newState)`（直接修改`state`，用于无竞争场景）；
			- 原子修改状态：`compareAndSetState(int expect, int update)`（CAS 操作，用于竞争场景）。
	- 等待队列（基于`Node`）：是 “调度中心”，管理 `Node` 的入队 / 出队和唤醒顺序；
		- 数据结构：双向链表
			- 支持快速入队、出队：队尾添加节点、队首移除节点
			- 支持快速删除中间节点：线程取消等待时
		- 等待队列节点（`Node`）：是等待队列的基本单元。封装了等待资源的线程、节点状态（如等待中、取消、唤醒）以及前后节点引用。
			- 节点状态的作用：
				- `SIGNAL`状态：有需要唤醒的后继。完全避免了 “遍历队列判断后继是否需要唤醒”：
					- 当线程获取资源失败、加入队列后，会先将**前驱节点**的状态改为`SIGNAL`（通过`shouldParkAfterFailedAcquire`方法）；
					- 后续当前驱节点释放资源时（如`release`/`releaseShared`），**无需遍历队列**，只需检查头节点的`waitStatus`是否为`SIGNAL`：
						- 若为`SIGNAL`：直接调用`unparkSuccessor`唤醒后继；
						- 若不为`SIGNAL`：说明无需要唤醒的后继，直接跳过。
				- `CANCELLED`状态：节点因中断 / 超时取消等待。是实现 “不用遍历判断是否有没有取消的节点” 的关键
					- 在唤醒后继（`unparkSuccessor`）、清理队列（`cancelAcquire`）等操作中，**通过状态直接跳过 CANCELLED 节点**，而非遍历整个队列检查每个节点的有效性：
				- `PROPAGATE`状态：唤醒操作需要向下传播。强制后续释放操作继续检查唤醒状态，避免唤醒传播断层
					- `doReleaseShared`方法中，只需检查头节点状态是否为`PROPAGATE`，即可判断是否需要继续唤醒后继，无需遍历队列确认剩余资源是否充足。
				- 初始状态（0）：该节点没有需要唤醒的后继或者已经在进行后继唤醒操作
					- 能避免多次唤醒一个后继
		- 更新方式：
			- 入队：CAS 将节点添加到队尾，若队尾为空则初始化队列）
			- 出队：移除队首节点，唤醒后继节点
			- 删除节点：通过前驱和后继引用将节点从链表中移除，修改节点状态为 “取消”
	- 钩子方法（Hook Methods）：框架提供的抽象方法，由子类实现。实现框架与具体同步模式的解耦，框架仅处理通用逻辑，子类通过钩子方法实现模式相关细节。
---
通用的私有方法：实现约定唤醒和实行唤醒

当前线程**是否可以安全阻塞**的核心方法:shouldParkAfterFailedAcquire(Node pred, Node node)
- 调用路径：acquire(int arg) → acquireQueued(Node node, int arg)  // 排队阻塞核心→ shouldParkAfterFailedAcquire(pred, node)  // 判断是否可阻塞→ 若返回true → parkAndCheckInterrupt()  // 真正阻塞线程
- 核心作用：检查当前节点的**前驱节点状态**，确保 “前驱节点释放资源时会唤醒当前节点”，并据此判断当前线程是否可以安全阻塞
	- 避免线程阻塞后永远不被唤醒
- 核心逻辑拆解（分 3 个场景）
	- 场景 1：前驱节点状态为`SIGNAL`（最常见）：此时返回`true`：当前线程可以放心阻塞（因为前驱会唤醒自己）；
		- `Node.SIGNAL`的含义：前驱节点明确承诺 “我释放资源时，一定会唤醒后继节点”；
		- 这是线程能进入阻塞状态的**唯一条件**。
	- 场景2：前驱节点状态为`CANCELLED`（ws > 0）
		- 向前遍历队列，跳过所有`CANCELLED`节点，找到第一个 “有效前驱”（ws ≤ 0）；
		- 然后更新队列引用（让有效前驱的后继指向当前节点），保证队列链路连续；
		- 最后返回`false`：不阻塞，回到`acquireQueued`的循环中重试（因为刚调整了前驱，需要重新检查）
	- 场景 3：前驱节点状态为`0/PROPAGATE/CONDITION`（ws ≤ 0 且≠SIGNAL）
		- 核心思路：前驱节点是 “有效节点”，但未承诺唤醒当前节点 → 需要 “提前约定”；
		- 通过`CAS`将前驱节点状态改为`SIGNAL`，强制前驱节点承诺 “释放时唤醒我”；
		- 最后返回`false`：不阻塞，回到循环重试（因为 CAS 可能失败，需要再次检查前驱状态）。

**唤醒等待队列里节点后继线程**的核心方法`unparkSuccessor(Node node)`
- 定位：它是独占 / 共享模式下唤醒逻辑的 “通用执行器”，也是`release`、`doReleaseShared`、`cancelAcquire`等方法的核心依赖
	- 场景1：独占模式释放资源：release(int arg) → unparkSuccessor(head)
	- 场景2：共享模式唤醒传播：doReleaseShared() → unparkSuccessor(head)
	- 场景3：节点取消时兜底唤醒：cancelAcquire(Node node) → unparkSuccessor(node)
- 作用：找到传入节点`node`的**第一个有效后继节点**（排除`CANCELLED`取消节点），通过`LockSupport.unpark()`唤醒该节点关联的线程；若没有有效后继，则无操作（防御性设计）。
- 核心逻辑：
	1. 重置当前节点状态
		- 目的：标记 “唤醒已执行”，防止其他线程（如另一个释放资源的线程）重复调用`unparkSuccessor`。
		- 只有节点状态为`ws < 0`（非取消）时，才 CAS 重置为 0；
	2. 查找有效后继：从后往前找
		- 先尝试取`node.next`：如果是有效节点（非空 + 非取消），直接用；
		- 若`node.next`无效，从`tail`开始向前遍历，直到`node`为止，找到第一个`waitStatus ≤ 0`的节点（有效节点）；
	3. 唤醒线程 → 核心是唤醒 “线程” 而非 “节点”
		- 唤醒方式：`LockSupport.unpark(s.thread)`：解除线程的阻塞状态
		- 线程被唤醒后，会回到`acquireQueued`/`doAcquireShared`的循环中，重新尝试获取资源；
		- 若`s == null`（无有效后继），直接跳过，无任何副作用。

---
**独占核心方法**

- 独占模式的核心获取资源方法`acquire(int arg)`
	- 核心作用：独占模式下，尝试获取资源，获取失败则加入等待队列，直到获取成功或被中断。
	- 情况一：无竞争，直接获取资源
		- 该路径的核心流程是：`调用tryAcquire(arg)` → `tryAcquire返回true` → `方法直接返回`
		- 进入方式：
			- 同步状态（`state`）处于 “可获取” 状态（如 ReentrantLock 中`state=0`）；
			- 无其他线程竞争资源，`tryAcquire(arg)`能成功修改`state`。
		- 效果：
			- `state`被修改为 “已占用” 状态（如 ReentrantLock 中`state=1`）；
	- 情况二：有竞争，加入等待队列并阻塞
		- 该路径的核心流程：
			1. 尝试获取：调用 tryAcquire（子类实现，比如 ReentrantLock 判断 state 是否为 0）；
			2. 失败入队：获取失败→addWaiter 创建 Node 节点→CAS 加入队列尾；
			3. 阻塞等待：acquireQueued 循环判断→shouldParkAfterFailedAcquire（检查前驱是否为 SIGNAL，确保会被唤醒）→parkAndCheckInterrupt（阻塞线程）；
			4. 唤醒后重试：被唤醒后，再次尝试获取资源，成功则成为新头节点。
		- 进入路径的条件：同步状态（`state`）处于 “已占用” 状态：`tryAcquire(arg)`返回`false`（获取失败）；
		- 效果：
			- 状态变更：
				- 新节点被添加到等待队列队尾；
				- 当前线程被阻塞（通过`LockSupport.park(this)`）；
			- 方法返回方式：被唤醒并获取资源后，方法返回；
		- 核心设计
			- 获取资源失败后，如何快速创建节点并加入队尾？
				- 决策点：获取资源失败后，如何快速创建节点并加入队尾？
				- 核心问题：处理高并发下的竞争
				- 最终方案：实现`addWaiter`方法，先尝试快速入队（CAS 修改队尾），失败则调用`enq`方法循环入队，确保节点最终被加入。
					- 在无竞争时也需循环，快速入队
					- 在有竞争时，循环尝试CAS入队
				- 决策成功：
					- 状态变更：新节点被添加到等待队列队尾
					- `addWaiter`方法返回：返回新创建的节点；
				- 决策后果：节点加入队列后，如何让线程阻塞并等待被唤醒？
			- 如何让队列中的线程高效阻塞并被唤醒后尝试获取资源？
				- 决策点：节点加入队列后，如何让当前线程阻塞，且被唤醒后能再次尝试获取资源？
				- 核心问题：
					- 阻塞和唤醒操作需保证低开销
					- 线程被唤醒后能快速尝试获取资源
				- 最终方案：实现`acquireQueued`方法，循环检查前驱节点是否为队首，若是则尝试获取资源，否则阻塞当前线程。
					-  通过循环检查，确保线程被唤醒后能快速尝试获取资源
				- 决策成功：
					- 状态变更：当前线程被阻塞；
					- 方法返回方式：被唤醒并获取资源后，方法返回；
				- 决策后果：如何处理线程在阻塞过程中的中断
			- 如何处理线程的中断状态？
				- 决策点：线程在阻塞过程中被中断，框架应如何处理？
				- 核心要求：
					- 框架应不强制处理中断，由子类决定是否响应，保证可扩展性
				- 最终方案：`acquireQueued`方法默认不响应中断，仅记录中断状态，由子类决定是否响应中断
				- 决策成功：
					- 状态变更：仅记录中断状态，不响应中断
					- 方法返回：被唤醒并获取资源后，方法返回
				- 决策后果：若子类响应中断，则切换至路径 3（被中断）
	- 情况三：获取过程中被中断
		- 该路径的核心流程：`调用acquireInterruptibly(arg)` → `tryAcquire返回false` → `addWaiter` → `acquireQueued`中被中断 → `抛出InterruptedException`
		- 进入路径的条件：
			- 子类调用的是响应中断的获取方法（如`acquireInterruptibly`）。
			- 线程在`acquireQueued`方法中被中断；
		- 效果：
			- 状态变更：线程未获取资源
			- 方法返回：抛出`InterruptedException`，方法终止；
		- 核心设计
			- 如何保证中断的正确传递？
				- 决策点：子类响应中断时，如何保证中断状态被正确捕获并抛出异常？
				- 核心要求 和约束：
					- 框架应提供统一的中断处理逻辑，由子类决定是否使用。
				- 最终方案：- `acquireQueued`方法返回是否被中断的布尔值，响应中断的方法（如`acquireInterruptibly`）根据该值抛出`InterruptedException`。
- 独占模式的核心释放资源方法 `release(int arg)`
	- 核心作用：独占模式下，当前线程释放持有的资源，释放成功后唤醒等待队列中的后继线程
	- 情况一：无竞争，成功释放资源并唤醒后继线程；
		- 该路径的核心流程：`调用tryRelease(arg)` → `tryRelease返回true` → `获取头节点` → `唤醒头节点的有效后继线程` → `方法返回true`
		- 进入路径的条件：
			- 当前线程**持有独占资源**
			- 同步状态（`state`）可被修改为 “空闲” 状态：`tryRelease(arg)`返回`true`
			- 有后继线程需要唤醒：等待队列的头节点（`head`）不为空，且头节点的`waitStatus`（节点状态）不为 0
		- 效果：
			- 状态变更：
				- 同步状态`state`被修改为 “空闲” 状态
				- 头节点的`waitStatus`被重置
				- 后继线程被唤醒
			- 方法返回：方法返回`true`，表示释放成功；
		- 核心设计
			- 如何高效找到并唤醒等待队列的有效后继线程
				- 决策点：释放成功后，如何快速找到等待队列中 “最应该被唤醒” 的有效线程（未被取消的后继线程）？
				- 核心要求 和约束：
					- 要求：能正确跳过已取消的线程。
				- 最终方案：实现`unparkSuccessor(Node node)`方法，逻辑为
					1. 获取当前节点的`waitStatus`，重置为 0（表示无需再唤醒）；
					2. 从队尾向前遍历，找到**最靠近当前节点的有效后继节点**（`waitStatus <= 0`，未被取消）；
						- 从前往后存在的问题：
							- 节点**取消**时的 next 指针失效：当某个节点因超时 / 中断取消等待（`waitStatus=CANCELLED`），它会清理自己的`next`指针，但这个操作不是原子的，可能导致`head.next`指向已取消的节点，甚至`null`
							- 节点**入队的并发**不一致：新节点入队的流程是：
								1. 新节点的prev指向当前tail 
								2. CAS将tail更新为新节点 
								3. 原tail的next指向新节点
								- 步骤 3 是最后执行的，这意味着存在短暂的 “tail 已更新，但原 tail 的 next 仍为 null” 的状态。如果此时从 head 往后遍历，会误以为队列到这里结束，遗漏后续有效节点。
						- 从后往前的好处：从 tail 往前遍历，能精准找到离 head 最近的、未被取消的有效节点
							- 节点入队时，第一步就设置`prev`（指向当前 tail），这个操作是前置的，且 CAS 更新 tail 的逻辑能保证`prev`指针的正确性；
							- 即使节点被取消，`prev`指针也不会被清理，始终指向有效的前驱节点。
					3. 调用`LockSupport.unpark(thread)`唤醒该后继线程。
				- 决策成功：
					- 状态变更：头节点的`waitStatus`被重置为 0，后继线程被唤醒；
					- 方法返回：`release`方法返回`true`，表示释放成功；
				- 决策后果：若释放成功但无有效后继线程，如何处理？这引出路径 2。
			- 当 AQS 同步队列中的等待节点，因为前驱线程释放资源并触发唤醒操作后
				1.  线程从挂起状态恢复运行：AQS 中等待的线程会通过`LockSupport.park()`被挂起（阻塞），当被前驱节点唤醒时，线程会从`park()`方法的位置恢复执行，回到`acquireQueued`方法的循环逻辑中。
				 2. 尝试获取同步状态：这是被唤醒后的**首要操作**，线程会调用 AQS 子类实现的`tryAcquire()`方法（比如 ReentrantLock 的公平 / 非公平获取锁逻辑），尝试抢占资源：
					- **情况 1：获取资源成功**：这是最理想的结果，线程会执行以下操作：
						1. 将自己的节点设置为 AQS 队列的**新头节点**（原头节点已释放资源并出队）；
						2. 清空新头节点的`thread`引用（头节点不再关联线程，标记为 “已完成”）；
						3. 断开与原前驱节点的引用（帮助 GC 回收）；
						4. 结束等待队列的循环逻辑，线程退出 AQS 的等待流程，继续执行自己的业务代码。
					- **情况 2：获取资源失败**：可能因为竞争（比如非公平锁下被新线程抢占）、资源不足等原因失败，此时会：
						1. 检查前驱节点的状态：过滤掉状态为`CANCELLED`（取消）的前驱节点，找到队列中有效的前驱；
						2. 重新调整节点的等待状态（设置`SIGNAL`标记，确保后续能被正确唤醒）；
						3. 再次调用`LockSupport.park()`挂起自己，等待下一次被唤醒；
						4. 若过程中检测到线程被中断，会记录中断状态（AQS 默认不响应中断，仅记录）。
				 3. 辅助操作：清理无效节点：在尝试获取资源的过程中，线程会检查当前节点或前驱节点的状态：
					- 如果发现前驱节点是`CANCELLED`状态，会将其从队列中 “剔除”（调整节点的前驱 / 后继引用，跳过无效节点）；
					- 保证 AQS 队列中只保留 “等待中”（`SIGNAL`）、“条件等待”（`CONDITION`）等有效状态的节点，避免队列中存在垃圾节点。
	- 情况二：成功释放资源，但无有效后继线程可唤醒；
		- 该路径的核心流程：`调用tryRelease(arg)` → `tryRelease返回true` → `获取头节点` → `头节点无后继或后继已被取消` → `方法返回true`
		- 进入路径的条件：
			- 当前线程持有独占资源，`tryRelease(arg)`返回`true`
			- 等待队列的头节点（`head`）为空，或头节点的`waitStatus=0`（表示无后继线程需要唤醒）
			- 头节点的后继线程已被取消（`waitStatus>0`），且无其他有效后继线程。
		- 效果：
			- 状态变更：同步状态`state`被修改为 “空闲” 状态；
			- 方法返回：方法返回`true`，表示释放成功；
		- 核心设计
			- 如何判断是否需要唤醒后继线程？
				- 决策点：释放成功后，如何快速判断是否存在需要唤醒的后继线程？
				- 最终方案：通过检查头节点的`waitStatus`是否为 0 来判断 —— 若`waitStatus!=0`，表示有后继线程需要唤醒；若`waitStatus=0`，表示无后继或后继已被处理。
					- 性能：遍历队列，检查是否存在有效后继线程，高并发下性能差
					- 正确性：如果有队列新加入，在阻塞前肯定会把其前面节点的状态设为SIGNAL
	- 情况三：释放失败（如当前线程未持有资源）。
		- 该路径的核心流程：`调用tryRelease(arg)` → `tryRelease返回false` → `方法返回false`
		- 进入路径的条件：
			- `tryRelease(arg)`返回`false`。
		- 效果：
			- 状态变更：同步状态`state`保持不变
			- 方法返回：方法返回`false`，表示释放失败；
		- 核心设计
			- 如何处理释放失败的情况？
				- **决策点**：框架是否应该对释放失败的情况（如未持有资源）抛出异常？
				- **最终方案**：框架不抛出异常，仅返回`false`，由子类决定是否处理（如 ReentrantLock 在`unlock`方法中，若`release`返回`false`，则抛出`IllegalMonitorStateException`）。
		- 
----
**共享模式核心方法**
- 共享模式下实现**唤醒传播**的核心方法：`doReleaseShared()`
	- 定位：`doReleaseShared()`是 AQS 的私有方法，仅在共享模式下被调用
		- `releaseShared()`：当前节点释放资源成果，并且当前队列非空或有后继节点需要被唤醒后
		- `setHeadAndPropagate()`：当前头结点被唤醒后获取资源，且设立自己为头结点后
	- 核心作用：
		- 保证共享模式下资源释放后，**链式唤醒所有可获取资源的等待线程**（即 “唤醒传播”）
		- 通过循环 + CAS 保证高并发下唤醒操作的原子性和可靠性。
	- 情况一：头节点状态为`Node.SIGNAL`（最常见）
		- `Node.SIGNAL`的含义：当前节点的后继节点处于等待唤醒状态，当前节点释放后必须唤醒后继；
		- 核心流程：
			1. 第一步：CAS 将头节点状态从`SIGNAL`改为`0` → 核心目的是**避免重复唤醒**（如果不重置，其他线程可能重复调用`unparkSuccessor()`）；
			2. 第二步：CAS 成功后调用`unparkSuccessor(h)` → 唤醒头节点的有效后继线程（跳过已取消的节点）；
			3. 第三步：若 CAS 失败（比如其他线程已修改头节点状态），则`continue`重试 → 保证高并发下操作不丢失。
	- 情况二：头节点状态为`0`（唤醒传播的关键）
		- 头节点状态为`0`说明：后继线程可能已被唤醒，但还未完成 “获取资源 + 成为新头节点” 的操作；
		- 执行`CAS(0, PROPAGATE)`：将状态改为`PROPAGATE`（传播）→ 核心目的是**标记当前处于 “唤醒传播中”**
			- 问题根源：**后继线程 被唤醒后，存在一个 “获取资源 + 成为新头节点” 的时间差**，在这个时间差内，头节点还是旧的 头结点，状态是 0。
			- 可能出现的问题：在这个时间差中，如果有别的线程释放资源，看到头节点状态为`0`，则会认为无需要唤醒的后继，导致没有新的唤醒操作了，出现唤醒传播断层
			- PROPAGATE的作用：一个弱标记，它不会影响正常的唤醒逻辑，但是能强制后续释放操作继续检查唤醒状态，避免唤醒传播断层；
		- 若 CAS 失败，同样`continue`重试 → 保证状态修改的原子性。

	- 情况三：循环退出：`h == head`
		- 若头节点未变更（`h`还是当前`head`）→ 说明本次唤醒操作已完成，无新的头节点需要处理，退出循环；
		- 若头节点已变更（比如被唤醒的线程获取资源后成为新`head`）→ 继续循环 → 对新头节点重复唤醒逻辑，实现**链式传播**。
	- 核心设计决策：
		- 为什么用 “循环 + CAS”： 保证即使多线程竞争，唤醒操作也能原子完成，且不会丢失；
		- 为什么要设置`PROPAGATE`状态？：将`0`改为`PROPAGATE` → 标记 “唤醒传播中”，后续线程释放时会继续处理该节点；
- 共享模式获取资源核心方法： `acquireShared(int arg)`
	- 核心作用：**共享模式下，尝试获取资源（支持多线程同时持有），获取失败则加入等待队列，直到获取成功或被中断**
		- 与独占模式的核心区别是：共享模式允许多个线程同时获取资源，因此其返回值和队列处理逻辑与独占模式存在差异。
	- 情况一：无竞争，直接获取资源（剩余资源充足）
		- 该路径的核心流程：`调用tryAcquireShared(arg)` → `返回值 >= 0`（获取成功） → `方法直接返回`
		- 进入路径的条件：
			- 同步状态（`state`）表示的资源数**充足**：`tryAcquireShared(arg)`能成功修改`state`并返回`>= 0`的结果
				- 返回值含义：正数表示获取后剩余资源数，0 表示获取成功但无剩余资源
		- 效果：
			- 状态变更：`state`被原子修改
			- 方法返回：方法立即返回，当前线程继续执行；
		- 核心设计
			- 如何通过返回值区分共享模式的获取结果？
				- 决策点：共享模式下，如何设计`tryAcquireShared`的返回值，让框架能判断获取是否成功，且能传递剩余资源信息？
				- 核心要求 和约束：
					- 框架需通过返回值判断是否进入排队逻辑
					- 共享模式需要传递剩余资源信息（用于后续唤醒传播）
				- 最终方案：将`tryAcquireShared`的返回值设计为`int`类型，规则为：
					- 返回值 `>= 0`：获取成功（正数 = 剩余资源数，0 = 无剩余）；
					- 返回值 `< 0`：获取失败。
				- 决策成功：
					- 状态变更：`state`被原子修改为剩余资源数；
	- 情况二：有竞争，加入等待队列并阻塞
		- 该路径的核心流程：`调用tryAcquireShared(arg)` → `返回值 < 0` → `doAcquireShared(arg)`
			- doAcquireShared(arg)方法中
				- addWaiter(Node.SHARED);
				- 进入循环
					- 前驱节点是头结点则尝试获取资源，获取成功则设置当前节点为新头节点，并触发唤醒传播（setHeadAndPropagate(node, r)）
					- 检查是否需要阻塞，且阻塞后检查是否被中断
		- 进入路径的条件：
			- 同步状态（`state`）表示的资源数**不足**：`tryAcquireShared(arg)`返回`< 0`（获取失败）；
		- 效果：
			- 状态变更：
				- 新的共享节点被添加到等待队列队尾；
				- 当前线程被阻塞（通过`LockSupport.park(this)`）；
				- 被唤醒后，`state`被修改为剩余资源数，且可能触发**唤醒传播**（唤醒后续共享节点）；
			- 方法返回：被唤醒并获取资源后，方法返回；
		- 核心设计
			- 如何区分共享模式和独占模式的节点？
				- 决策点：等待队列中需要区分共享节点和独占节点，避免唤醒时错误地唤醒不匹配模式的线程，如何设计节点的模式标识？
				- 核心要求 和约束：队列需能快速区分节点模式，避免唤醒时的无效操作
					- 独占模式下只能唤醒一个节点
					- 共享模式下可唤醒多个
				- 最终方案：在`Node`类中添加`nextWaiter`属性，用于标识节点模式：
					- `Node.SHARED`：共享模式节点；
					- `Node.EXCLUSIVE`：独占模式节点。
				- 状态变更：新的共享节点被添加到等待队列队尾，`nextWaiter`标识为`Node.SHARED`；
			- 如何实现共享模式特有的 “唤醒传播” 逻辑？
				- 决策点：共享模式下，当前线程被唤醒并且获取资源成功后，若还有剩余资源，如何自动唤醒后续共享节点（即 “唤醒传播”）？
				- 核心要求 和约束：共享模式需要实现 “一次释放，多次唤醒” 的传播逻辑
				- 最终方案：实现`setHeadAndPropagate(node, r)`方法，逻辑为：
					1. 将当前节点设置为新的头节点；
					2. 判断 “传播” 条件：只有满足以下任一条件，才会触发后续的传播唤醒：
						1. 还有剩余的同步状态可以分配：`propagate > 0`
						2. 同步队列中有等待的有效节点：<0
					3. 先检查后继节点是否为**共享模式**，如果是则调用`doReleaseShared()`唤醒后继节点；
						- doReleaseShared()：方法会通过`unparkSuccessor`唤醒后继节点，且会处理并发场景下的唤醒丢失问题，保证 “传播” 能持续下去
				- 决策成果：
					- 状态变更：当前节点被设置为头节点，后续共享节点可能被唤醒；
			- 如何处理共享模式下的线程中断？
				- 最终方案：独占模式一致，`doAcquireShared`方法默认不响应中断，仅记录中断状态，由子类决定是否响应（如`acquireSharedInterruptibly`方法）。
- 共享模式释放资源的核心方法： `releaseShared(int arg)`
	- 核心作用：共享模式下，当前线程释放持有的资源，释放成功后触发「唤醒传播」逻辑，唤醒等待队列中所有可获取资源的共享线程
	- 情况一：成功释放资源并触发唤醒传播；
		- 该路径的核心流程：`调用tryReleaseShared(arg)` → `返回true`（释放成功） → `执行doReleaseShared()`（触发唤醒传播） → `方法返回true`
		- 进入路径的条件：
			- 当前线程持有共享资源，`tryReleaseShared(arg)`返回`true`
			- 头节点状态为`Node.SIGNAL`（表示需要唤醒后继）或可被设置为`Node.PROPAGATE`（传播状态）。
			- 等待队列非空，且存在可被唤醒的共享节点；
		- 效果：
			- 状态变更：
				- 同步状态`state`被原子修改
				- 头节点状态被重置为`0`或设置为`Node.PROPAGATE`（触发传播）
				- 后继共享线程被唤醒，且可能触发链式唤醒（唤醒传播）
			- 方法返回指
		- 核心设计
			- 如何实现共享模式的「唤醒传播」逻辑
				- 决策点：共享模式下，释放资源后可能有多个线程可获取资源，如何设计唤醒逻辑以保证**链式唤醒**（一个线程被唤醒后，若还有剩余资源，继续唤醒下一个线程）
				- 核心要求 和约束：
				- 最终方案：实现`doReleaseShared`方法，通过**循环 CAS**保证唤醒操作的原子性，
	- 情况二：成功释放资源，但无需唤醒传播；
		- 该路径的核心流程：`调用tryReleaseShared(arg)` → `返回true` → `执行doReleaseShared()` → `队列无有效后继节点` → `方法返回true`
		- 进入路径的条件：
			- 当前线程持有共享资源，`tryReleaseShared(arg)`返回`true`
			- 等待队列为空，或仅包含头节点（无后继节点）
			- 后继节点为独占模式节点（共享模式释放不唤醒独占节点）
		- 效果：
			- 状态变更：同步状态`state`被原子修改为新的资源数；
			- 方法返回:方法返回`true`，表示释放成功；
	- 情况三：释放失败（如资源释放后状态无效）
		- 该路径的核心流程：`调用tryReleaseShared(arg)` → `返回false` → `方法返回false`
		- 进入路径的条件：
			- `tryReleaseShared(arg)`返回`false`
				- 例如：`CountDownLatch`中，计数器未到 0 时调用`releaseShared`，`tryReleaseShared`返回`false`
		- 效果：
			- 状态变更：同步状态`state`保持不变
			- 方法返回：方法返回`false`，表示释放失败；

---
**节点取消**
- 触发场景：节点被标记为`CANCELLED`（值为 1）的常见场景：
	- 超时取消：超时后主动取消
		- 比如：`tryAcquireSharedNanos`（带超时的共享获取）、`tryAcquireNanos`（带超时的独占获取）
	- 中断取消：线程被中断后，响应中断的获取方法（如`acquireSharedInterruptibly`）会触发取消；
	- 主动取消：极少数场景下，子类手动调用取消逻辑（如 Condition 的超时等待）；
	- 异常取消：获取资源过程中抛出未捕获异常，`doAcquireShared`/`doAcquire`的`finally`块会触发取消。

- 核心方法： `cancelAcquire`
	- 定位：是 AQS 处理节点取消的 “总入口”，所有取消场景最终都会调用这个方法。
	- 核心步骤： 保证队列连续性
		1. 标记失效，清空线程引用
			- 标记失效：`node.waitStatus = Node.CANCELLED`
			- 清空线程引用：`node.thread = null`
		2. 找 “有效前驱”，跳过已取消节点
			- 目的：避免队列中存在连续的取消节点，保证队列的 “有效链路” 不中断。
			- 找寻方式：从当前节点的前驱`pred`开始，向前遍历
			- 找寻目标：第一个`waitStatus ≤ 0`的节点（非取消节点）；
		3. 处理节点引用，保证队列链表连续:分两种场景
			- 场景一：当前节点是尾节点：
				- 目的：队列尾节点回归有效节点
				- 方式：直接将尾节点更新为 “有效前驱”，并把前驱的后继设为 null ；
			- 场景二：当前节点不是尾节点：
				- 若前驱不是头节点：将前驱的后继指向当前节点的 “有效后继”（跳过当前取消节点）
					- 但是其后继的前驱还是这个被取消的节点，而自己的前驱仍然是这个有效前驱
					- 如果前驱是头结点，这样会导致阻断唤醒链路
				- 若前驱是头节点：主动调用`unparkSuccessor(node)`唤醒当前节点的后继
					- 目的：防止因为取消节点阻断唤醒链路。
		4. 自引用标记，彻底脱离队列
			- 让取消节点的后继指向自己，作为 “已失效” 的额外标记，后续遍历队列时能快速识别并跳过。
- 节点取消后的核心影响
	- 对当前节点：永久失效，不再参与任何操作
	- 对队列结构：逻辑移除，保持有效链路连续
		- 示例：队列`h → A（CANCELLED）→ B → C`，取消 A 后，队列有效链路变为`h → B → C`，A 的前驱指向 h，后继指向自己，不再参与队列操作。
	- 对等待线程：被取消的线程不再阻塞，直接退出竞争
		- 节点被取消后，对应的线程会从`LockSupport.park()`中唤醒（或不再被阻塞）；
		- 线程唤醒后，在`doAcquire`/`doAcquireShared`的循环中会发现自己的节点已取消，最终退出循环，返回 “获取资源失败”。


---
- 设计思想：
	- 重写 AQS 的特定“钩子”方法（Hook Methods）来定义同步状态（state）的获取与释放规则
		- 钩子方法：你要实现的方法
			- 独占
				- `boolean tryAcquire(int arg)`：定义资源何时能被单个线程独占。
					- `true`表示获取成功；`false`表示失败。
				- `boolean tryRelease(int arg)`：定义如何释放独占资源。
					- `true`表示已完全释放；`false`表示否。
			- 共享：
				- `int tryAcquireShared(int arg)`：定义资源何时能被多个线程共享。
					- **负数**：获取失败；
					- **0**：成功，但无剩余资源；
					- **正数**：成功，且还有剩余资源。
				- `boolean tryReleaseShared(int arg)`：定义如何释放共享资源。
					- `true`表示释放后可能允许其他线程获取；`false`表示否。
			- `boolean isHeldExclusively()`：判断当前资源是否被当前线程**独占**。
				- 通常用于实现 Condition 条件变量
		- 这些方法设计思路
			- 首先AQS是个abstract抽象方法：意味着无法new这个类
			- 其次这些钩子方法并不是abstract方法，而是protected方法，内部抛异常UnsupportExeception
				- 因为钩子方法中，有些是需要实现，有些是不需要实现的， 这样可以让子类按需实现
				- UnsupportExeception异常是为了让你不小心调用了的时候提醒你
	- 线程排队、阻塞、唤醒等复杂操作则由 AQS 的模板方法（如 `acquire`和 `release`）自动完成
		- 模板方法：定义了获取/释放资源的固定算法骨架（如尝试获取、入队、阻塞、唤醒）
			- 设计目的：定义了核心的工作流程
				- 【钩子方法】其中关键的资源获取与释放逻辑留给你来实现
			- 独占式：
				- acquire(int arg)
					- 获取资源，若失败则将线程加入同步队列等待，不响应中断
				- acquireInterruptibly(int arg)
					- 支持响应中断的独占式获取
				- tryAcquireNanos(int arg, long nanosTimeout)
					- 在可中断基础上，增加了**超时等待**功能
				- release(int arg)
					- 释放资源，并唤醒同步队列中的后继节点
			- 共享式：
				- acquireShared(int arg)
				- acquireSharedInterruptibly(int arg)
				- tryAcquireSharedNanos(int arg, long nanosTimeout)
				- releaseShared(int arg)
	- 工具方法：辅助你实现钩子方法的方法
		- 状态操作
			- `getState()`获取当前同步状态值。
			    - 在 `tryAcquire`或 `tryAcquireShared`中，首先调用此方法判断资源是否可用。
			- `setState(int newState)`直接设置状态值，此操作**不具备原子性**保证。
			    - 通常用于资源初始化，或在已持有锁、不存在竞争的单线程安全场景下更新状态。
			- compareAndSetState(int expect, int update)通过 CAS（比较并交换）操作原子性地更新状态，是实现线程安全的核心。`
			    - 在 `tryAcquire`中尝试获取锁或资源时（例如，在非重入锁中尝试将 state 从 0 改为 1）。
		- 线程管理
			- `setExclusiveOwnerThread(Thread thread)`记录当前独占模式下载的持有线程。
			    - 实现可重入锁时，在成功获取锁后，调用此方法记录锁的持有者。
			- `getExclusiveOwnerThread()`获取当前独占模式下载的持有线程。
			    - 在 `tryRelease`中验证执行释放操作的线程是否正确，以及实现可重入功能时判断当前线程是否为锁的持有者。
		- 队列状态查询
			- `hasQueuedThreads()`检查同步队列中是否有线程正在等待。
			    - 监控或诊断，了解是否存在资源竞争。
			- hasQueuedPredecessors() 检查同步队列中是否存在比当前线程**更早**开始排队等待的线程，这是实现公平性的核心。`
			    - 实现公平锁时，在 `tryAcquire`中先调用此方法，如果有排队者，则当前线程不应抢锁，而应乖乖排队，防止插队。
		- 内部类支持
			- `ConditionObject` AQS 提供的内部类，实现了 `Condition`接口，提供比 `Object.wait()/notify()`更强大、灵活的等待/通知机制。
			    - 实现 `Lock`接口的 `newCondition()`方法，返回此类的实例，以支持多个条件队列。