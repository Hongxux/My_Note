
#### 阶段一：索引创建决策——是否要建？

- **核心问题**：这个表真的需要索引吗？
    
- **判断标准**：
    
    - **数据量**：表数据量是否足够大（通常数千行以上）？
        
    - **访问频率**：该表是否被频繁查询（SELECT）？
	    - 利用[[SQL操作执行频率]]得知
        
    
- **结论**：如果两者都满足，则进入下一阶段；否则，暂不创建索引，避免不必要的开销。
	    索引不是必须的。对于数据量小或很少被查询的表，**创建和维护索引的开销**可能大于其带来的性能收益。

#### 阶段二：索引字段选择——为谁建？

- **目标字段**：选择在查询中真正发挥作用的字段。
    
    - **查询条件**：常出现在 `WHERE`子句中的字段。
        
    - **排序操作**：常用于 `ORDER BY`的字段。
        
    - **分组操作**：常用于 `GROUP BY`的字段。
        
    
- **质量评估**：在候选字段中，优先选择**高区分度**的字段。
    
    - **计算方法**：`SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;`
        
    - **经验值**：比率越接近1，索引效果越好（如唯一标识符）；低于0.1则效果较差（如状态、类型字段）。
        
    

#### 阶段三：索引结构设计——如何建？

- **首选策略**：优先使用**联合索引**，而非多个单列索引。
    
    - **设计原则**：遵循**最左前缀法则**。将最常用作查询条件的列放在联合索引的最左边。
        
    - **高级目标**：争取实现**覆盖索引**，即索引本身包含查询所需的所有字段，避免回表操作，极大提升性能。
        
    
- **特殊处理**：对于超长字符串字段（如地址、备注），使用**前缀索引**以平衡空间和效率。
    
    - **确定前缀长度**：通过测试不同前缀长度的区分度来选择最优值。
        
    

#### 阶段四：索引成本控制——如何管？

- **数量控制**：索引并非越多越好。每个索引都会带来写操作（INSERT/UPDATE/DELETE）的维护成本。定期审查并删除未使用或重复的索引。
    
- **约束优化**：为索引列添加 `NOT NULL`约束，这能为查询优化器提供更明确的信息，有助于生成更优的执行计划。
    
- **持续监控**：使用数据库提供的性能分析工具（如 MySQL 的 EXPLAIN命令或 Slow Query Log）定期分析索引的有效性，并进行调整。
    


