---
aliases:
  - readview
---
- 需求背景：对于一个发起查询的事务（例如“事务A”），版本链上的哪个版本对它来说是“可见”的？
- 解决措施：ReadView决定快照读 读取undo log 中的哪一个版本
- 实现基础：
	- `creator_trx_id`： 创建本 ReadView 的事务ID（即“事务A”自己的ID）。
	- `min_trx_id`： 生成 ReadView 时，系统中**活跃的（未提交的）​**​ 最小事务ID。
	- `max_trx_id`： 生成 ReadView 时，系统**将要分配的下一个事务ID**​（即当前最大事务ID+1）。
	- `m_ids`： 生成 ReadView 时，系统中所有**活跃事务ID**的列表。
- 实现机制：当“事务A”读取某行数据时，会从最新的数据版本开始，沿版本链依次判断每个版本是否可见：
	- 快照的生效前提：
		- 仅普通 SELECT 语句触发 MVCC 快照机制，
		- SELECT ... FOR UPDATE、SELECT ... LOCK IN SHARE MODE 这类**锁定查询不生成快照**，直接触发行锁 / 临键锁；
	- 可见性规则：
		-  ​`trx_id == creator_trx_id`：​说明这个数据版本是“事务A”​**自己修改**的，​**可见**。
		- `trx_id < min_trx_id`：说明这个数据版本在“事务A”启动**之前就已经提交**了，​**可见**。
		- `trx_id >= max_trx_id`：说明这个数据版本是由在“事务A”启动**之后才开启的事务**修改的，​**不可见**
		- `min_trx_id <= trx_id <= max_trx_id`：检查 `trx_id`是否在 `m_ids`（活跃事务列表）中。
		    - ​**不在**​：说明该版本在“事务A”启动时**已经提交**了，​**可见**。
		    - ​**在**​：说明该版本在“事务A”启动时**还未提交**，​**不可见**。
	- 生成时机：
		- ​**读已提交（READ COMMITTED）​**​
			- 时机：**每次**执行快照读（`SELECT`）时都**生成一个新的 ReadView**。
			- 效果：每次读都能看到**最新已提交**的数据。这会导致**不可重复读**
		- **可重复读（REPEATABLE READ）**
			- 时机：**仅在第一次**执行快照读时生成一个 ReadView，后续**所有读操作都复用这个快照**。
			- 效果：在整个事务期间，每次读看到的都是**同一个一致性快照**。这避免了不可重复读

    

