### 需求背景

在有序数据集中高效定位元素是核心需求。二分查找通过分治策略将时间复杂度从线性搜索的 O(n) 降至 O(log n)，但需满足两个前提：

1. ​**数据集有序**​
    
2. ​**支持随机访问**​（否则退化为线性搜索）
    
    ​**与其他技术关系**​：
    
    - ​**依赖排序算法**​：需先通过 `Collections.sort()`或 `List.sort()`完成排序
        
    - ​**Comparator 扩展**​：支持自定义对象比较规则
        
    - ​**数据结构制约**​：链表等结构因无法随机访问导致性能劣化
        
    

---

### 一、核心机制

#### 1. 基础用法

```
// 1. 自然排序集合的查找（元素需实现 Comparable）
int index = Collections.binarySearch(sortedList, target);

// 2. 自定义排序集合的查找
int index = Collections.binarySearch(sortedList, target, customComparator);
```

#### 2. 返回值语义

|​**返回值**​|​**含义**​|​**后续操作**​|
|---|---|---|
|≥ 0|目标元素索引|`sortedList.get(index)`即目标|
|< 0|未找到元素|计算插入位：`insertionPoint = -index - 1`|

​**插入未存在元素的场景**​：

```
if (index < 0) {
    sortedList.add(-index - 1, target); // 保持集合有序性
}
```

---

### 二、进阶知识

#### 1. 性能对比（n=1024 元素）

|​**搜索方式**​|​**成功查找步数**​|​**失败确认步数**​|
|---|---|---|
|线性搜索|平均 512|1024|
|二分查找|10|10|

#### 2. 数据结构适配策略

|​**集合类型**​|​**二分查找效率**​|​**原因**​|
|---|---|---|
|ArrayList/Array|✅ O(log n)|支持随机访问（`get(i)`为 O(1)）|
|LinkedList|⚠️ 退化为 O(n)|访问中间元素需遍历（`get(i)`为 O(n)）|

> ​**实现机制**​：
> 
> 若检测到 `RandomAccess`接口未实现（如 LinkedList），自动切换为线性搜索

#### 3. 错误使用场景

```
// 陷阱 1：未排序集合使用二分查找
List<Integer> unsortedList = Arrays.asList(3, 1, 4);
Collections.binarySearch(unsortedList, 1); // 返回错误结果！

// 陷阱 2：链表期望高效二分查找
LinkedList<Integer> sortedLinkedList = ...; // 已排序链表
Collections.binarySearch(sortedLinkedList, 5); // 实际执行线性搜索
```

---

### 重点知识分层

|​**学习者层级**​|​**必须掌握的核心内容**​|
|---|---|
|​**初学者**​|1. `binarySearch()`前置条件（有序集合）  <br>2. 正负返回值的含义|
|​**进阶者**​|1. 插入位置计算 `-i-1`的数学原理  <br>2. 不同集合类型的性能差异  <br>3. 自定义比较器（Comparator）的集成|
|​**高级应用**​|1. 二分查找在 JDK 中的实现策略（随机访问检测）  <br>2. 与树结构（如 TreeSet）二分查找的对比|

---

### 应用示例

```
// 在有序员工列表中按薪资查找
List<Employee> employeesBySalary = ... ; // 已按薪资排序
Comparator<Employee> salaryComp = Comparator.comparingDouble(Employee::getSalary);

// 查找薪资为 50,000 的员工
int pos = Collections.binarySearch(employeesBySalary, 
                                   new Employee("", 50000), 
                                   salaryComp);

if (pos >= 0) {
    System.out.println("找到员工：" + employeesBySalary.get(pos).getName());
} else {
    System.out.println("需插入位置：" + (-pos - 1));
}
```