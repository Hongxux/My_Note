---
aliases:
  - 死锁
---
## 死锁（Deadlock）
#### 发生的必要条件：
1. **互斥**：资源只能被一个进程 / 线程独占，其他需等待；
2. **持有并等待**：进程 / 线程持有部分资源，同时等待其他资源；
3. **不可抢占**：已分配的资源不能被强制剥夺，只能主动释放；
4. **循环等待**：多个进程 / 线程形成环形等待链，互相等待对方的资源。
#### 预防方法：
- **预防互斥：​**​ 通过设计**无锁（Lock-Free）​**​ 或 ​**等待无关（Wait-Free）​**​ 的数据结构和算法来访问共享资源。
	- 优先设计无状态代码（如无状态 Servlet），避免线程竞争独占资源；
	- 对只读数据（如配置）不做同步，仅对写操作加锁；
	- 优先使用并发容器（如`ConcurrentHashMap`）替代手动加锁的独占容器。
- **预防持有并等待：​**​ 要求线程在开始执行前，​**原子性地（Atomically）​**​ 获取其所需的所有资源（锁）。如果无法一次性获得所有资源，则不能持有任何已获得的资源（需要释放）。这通常通过一个额外的‘门栓锁’（Glock）来保证原子性，但可能降低并发度并导致资源浪费（提前获取但不立即使用）。
- **预防不可抢占：​**​ 当线程在尝试获取一个锁（如第二个锁）失败时（例如使用 `pthread_mutex_trylock`），它必须主动**释放其当前持有的所有锁**，然后重新开始获取过程（通常需要重试）。这破坏了‘持有并等待’条件。为了避免多个线程同时回退和重试导致的**活锁（Livelock）​**，可以在重试之间加入**随机化的退避延迟（Randomized Backoff）​**
	-  **使用带超时的锁**：使用`ReentrantLock.tryLock(long timeout, TimeUnit unit)`方法，如果线程在超时时间内未能获得所有需要的锁，则释放已获得的锁并回退，然后重试或执行其他操作。
- **预防循环等待：​**​ 对所有锁定义一个**全局的、全序（Total Order）​**​ 的获取顺序。所有线程在需要获取多个锁时，必须严格按照这个预定义的顺序进行申请。这从根本上消除了循环等待链形成的可能性。

#### 避免方法：
- **死锁避免（Deadlock Avoidance）​**​：操作系统或运行时环境可以采用特定的策略来**动态评估**资源分配请求是否可能导致未来死锁。如果评估认为有风险，则拒绝该请求。最著名的算法是 **[[银行家算法（Banker's Algorithm）]]** ​。这种方法需要系统预先知道线程的最大资源需求，实现开销较大，实际应用受限。
	- 两个线程能否并发执行，关键在于它们**请求的锁集合是否存在冲突**。
		- 如果两个线程请求的锁**完全不相交**​（不涉及任何相同的锁），它们可以安全并发。
		- 如果它们请求的锁**存在交集**​（需要同一个锁），那么在该锁上它们是互斥的，不能同时持有。
		- 更复杂的情况涉及多个锁。如果线程A持有锁L1请求锁L2，线程B持有锁L2请求锁L1，就构成了循环等待，可能导致死锁（如果其他条件也满足）。你提到的“其中一个只要一个锁”可能是指一个线程只持有一个锁就去请求另一个线程持有的锁，这本身是“持有并等待”，是死锁的必要条件之一，但并不能直接保证“可以同时运行”。保证安全并发需要更精细的策略（如锁顺序、锁粒度控制、无锁编程）。
#### 检测和修复

- 死锁的检测：使用jstack

在某些应用场景中，如果经过评估认为**死锁发生的概率极低**，或者实现完美的死锁预防机制会带来过高的**性能开销**或**实现复杂度**，那么一种可接受的策略是**允许死锁发生**。

系统不进行积极的预防，而是通过一个独立的**死锁检测算法**​（例如，定期构建并分析资源分配图）来监控系统状态。一旦检测到死锁，则触发**恢复机制**。常见的恢复手段包括：

1. ​**终止进程/线程**​：强制终止一个或多个陷入死锁的参与者。
    
2. ​**资源抢占**​：强制剥夺某个线程持有的关键资源，但这可能带来回滚和状态一致性问题。
    
3. ​**系统重启**​：在极端或难以清理的情况下，重启整个服务或子系统。
    

这种方法是一种典型的**工程权衡**，用**故障发生后的恢复成本**，换取了**正常运行时更高的性能和更简单的架构**。它常见于对可用性要求不是极端苛刻、且重启代价可接受的系统中。
- **适用场景**​：这种策略通常适用于死锁发生需要极特殊的条件组合、业务逻辑简单易于重启、或预防死锁会严重损害系统性能（如高频交易核心路径）的情况。
    
- ​**局限性**​：对于要求高可用的核心系统（如数据库、支付系统、航空控制系统），这种“先崩溃再恢复”的模式通常是不可接受的，因此仍会优先采用死锁预防或避免策略。