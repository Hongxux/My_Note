# 哈希表核心原理与关键问题

## 基本理解

哈希表通过**以空间换时间**的策略实现高效操作。其核心机制是利用哈希函数，根据键（Key）的特定特征（如对整数取模）将数据分布到不同的桶（Bucket）中。插入时，首先计算键的哈希值以定位对应桶，然后在桶内寻找空位（通常采用链表结构，将新元素插入末端）。查找时，同样先对查询键进行哈希化定位到目标桶，再在桶内进行线性检索。在理想情况下，这种设计使得插入和查找操作的**平均时间复杂度接近 O(1)​**。

## 问题一：数据量过大与扩容机制

当数据量持续增长时，哈希表通过**动态扩容**以维持高效性能。

- ​**扩容过程**​：
    
    1. 创建一个新的、容量翻倍的桶数组。
    2. 遍历原有数组中的所有元素。
    3. 对每个键值对重新计算其在新数组中的哈希位置。
    4. 将数据迁移至新数组的对应桶中。
- ​**触发条件**​：扩容由**负载因子**决定。
    
    - 负载因子 = 元素总数 / 桶数组长度
    - 当负载因子超过预设阈值（例如 Java `HashMap` 中默认为 ​**0.75**），便会触发自动扩容。此阈值是**时间效率**​（避免频繁扩容）与**空间效率**​（避免过度浪费内存）之间的重要权衡。
- ​**桶内优化**​：  
    单个桶内数据过多会导致性能下降。在 Java 8 的 `HashMap` 中，当桶中的链表长度超过阈值（默认为 ​**8**）时，链表会自动转换为**红黑树**，从而将最坏情况下的查找性能从 `O(n)` 提升至 `O(log n)`，以此应对极端情况。
    

## 问题二：非整数类型键的处理

哈希表不仅限于整数键。对于其他数据类型（如字符串、对象等），可通过 ​**`hashCode()`方法**将其转换为一个固定长度的整数值，继而通过取模等操作映射到具体的桶索引。这使得哈希表能够处理各种类型的键，应用范围极其广泛。

## 问题三：优秀哈希函数的特性

一个高质量的哈希函数应满足以下三个关键特性：

1. ​**确定性**​：相同的输入必须始终产生相同的哈希值。
2. ​**均匀性**​：哈希值应尽可能均匀地分布在整个输出区间，以最小化哈希冲突。
3. ​**高效性**​：计算速度必须足够快，以保证操作的整体高效。

## 问题四：`equals` 与 `hashCode` 的契约

这是一个至关重要的概念，直接关系到哈希表的正确性。

- ​**为什么必须重写**​：若未重写 `hashCode()` 方法，即使两个对象内容完全相同（`equals()` 返回 `true`），默认的 `Object.hashCode()` 实现（通常基于对象内存地址）也会为它们生成不同的哈希值。这将导致：
    
    - ​**重复添加**​：内容相同的对象被存入不同的桶，造成数据冗余。
    - ​**查找失败**​：无法使用一个内容相同的键去找到之前存入的条目。
- ​**必须遵守的契约**​：
    
    - 如果两个对象根据 `equals()` 方法判断是相等的，那么它们的 `hashCode()`**必须**返回相同的值。
    - 因此，一旦重写了 `equals()` 方法，​**就必须同时重写 `hashCode()`**​ 方法，以确保这一契约成立，保证哈希表行为的正确性。
### 如果我只重写了 `equals()` 而没有重写 `hashCode()`，会发生什么具体问题？能举个例子吗？”​​


> “会彻底破坏哈希表的逻辑，导致无法正确查找对象。我举一个典型的例子：
> 
> 假设我有一个 `Student` 类，有 `id` 和 `name` 字段。我认为只要 `id` 相同，就是同一个学生，所以我重写了 `equals()` 方法。
> 
> java
> 
> 运行
> 
> 复制
> 
> ```java
> class Student {
>     int id;
>     String name;
>     // 构造器省略...
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
>         Student student = (Student) o;
>         return id == student.id; // 只比较id
>     }
>     // 忘记重写 hashCode() !
> }
> ```
> 
> 现在我做以下操作：
> 
> java
> 
> 运行
> 
> 复制
> 
> ```java
> Map<Student, String> map = new HashMap<>();
> Student s1 = new Student(1, "Alice");
> map.put(s1, "Math");
> 
> // 我想用另一个id相同的对象去取成绩
> Student s2 = new Student(1, "Alice"); // 内容相同，但另一个对象实例
> String course = map.get(s2);
> ```
> 
> ​**结果 `course` 会是 `null`！​**​
> 
> ​**原因**​：
> 
> 1. `s1` 和 `s2` 内容相同，`s1.equals(s2)` 为 `true`。
> 2. 但由于没重写 `hashCode()`，它们使用 `Object` 的默认实现，​**基于内存地址计算**。`s1` 和 `s2` 是两个不同的对象，它们的哈希值**极大可能不同**。
> 3. `map.get(s2)` 计算 `s2` 的哈希值，然后去一个**完全不同**的桶里查找，当然找不到 `s1` 存入的键值对。
> 
> 这就是为什么契约要求：​**如果 `equals` 相等，`hashCode` 必须相等**。”

## 延伸阅读：[[哈希冲突]]

哈希冲突是哈希表设计中的核心问题，主流解决方案包括链地址法（如 Java `HashMap`）和开放寻址法等。