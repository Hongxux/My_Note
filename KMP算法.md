[KMP算法的动画讲解](https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=d72d89f64e3acc7c73191e3aed96fb3a)

## 问题背景：
在一个较长的文本（**Text**， 简称 `T`）中，查找一个较短的模式串（**Pattern**， 简称 `P`）是否出现，以及出现的位置。
## 核心思想：

**暴力匹配O（n*m）=> KMP算法 O（n+m）**
1. ​**预处理（Preprocessing）​**​：KMP算法通过对模式串 ​**自身进行分析**，预先计算出一个 `next`数组（部分匹配表）。这个表记录了模式串各部分的自相似信息。
2. ​**利用信息（Utilization）​**​：在匹配失败时，算法不是像暴力法那样简单地后移一位并从头开始，而是**查询 `next`数组**。
3. ​**智能滑动（Smart Shift）​**​：根据 `next`数组的值，算法将模式串向后**滑动多位**，并**从模式串中一个特定的位置（而非开头）​**​ 开始下一轮的匹配，从而充分利用了之前已经匹配成功的信息，避免了不必要的重复比较。

### 部分匹配表 next数组
#### 1.实现的效果：
根据 `next`数组的值，算法将模式串向后**滑动多位**，并**从模式串中一个特定的位置（而非开头）​**​ 开始下一轮的匹配。（即有不回退主串，只回退模式串的核心特点）
$$
例如下图：在第[i]个字符即红色处字符不匹配，则根据next[i-1]的值，回退两个从匹配串[2]处开始匹配
$$
![[Pasted image 20250918191752.png]]
#### 2.next数组的含义
代表着最大的前缀字符串集合和后缀字符串集合中相同的元素中最长的字符串
例如

![[Pasted image 20250918193617.png]]
#### 3.获得next数组 利用dp

![[Drawing 2025-09-18 19.48.24.excalidraw]]

## KMP算法实现

![[Pasted image 20250918202813.png]]