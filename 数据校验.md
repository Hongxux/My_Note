---
aliases:
  - "@Validated"
---
### 常见的数据校验的注解
| 注解类别        | 注解示例                          | 核心作用与区别                                                    |
| ----------- | ----------------------------- | ---------------------------------------------------------- |
| **空值检查**​   | `@NotNull`                    | 对象必须不为 `null`，但可以是空字符串 (`""`) 或空集合<br><br>。                |
|             | `@NotBlank`                   | **仅用于字符串**。值不能为 `null`，并且修剪首尾空格后的长度必须大于零<br><br>。          |
|             | `@NotEmpty`                   | 对象不能为 `null`，且其大小/长度必须大于零（适用于字符串、集合、数组、Map）<br><br>。       |
| **布尔检查**​   | `@AssertTrue`/ `@AssertFalse` | 被注解的字段必须为 `true`/ `false`，通常用于逻辑标志<br><br>。                |
| **数值检查**​   | `@Min`/ `@Max`                | 验证数字值是否大于等于/小于等于指定值<br><br>。                               |
|             | `@DecimalMin`/ `@DecimalMax`  | 功能同 `@Min`/`@Max`，但以字符串形式表示边界值，可精确表示小数<br><br>。            |
|             | `@Digits`                     | 验证数字的整数部分和小数部分的位数是否符合要求<br><br>。                           |
|             | `@Positive`/ `@Negative`      | 验证数字必须是正数或负数（可包含零，如 `@PositiveOrZero`）<br><br>。            |
|             | `@Range`                      | 验证数值是否在指定的最小值和最大值之间（Hibernate Validator 提供）<br><br>。       |
| **字符串与集合**​ | `@Size`                       | 验证字符串、集合、数组、Map 的大小是否在指定范围内<br><br>。                       |
|             | `@Length`                     | 功能同 `@Size`，但通常**仅用于字符串**（Hibernate Validator 提供）<br><br>。 |
| **格式与模式**​  | `@Pattern`                    | 验证字符串是否匹配指定的正则表达式，适用于复杂格式要求（如手机号、特定编码）<br><br>。            |
|             | `@Email`                      | 验证字符串是否符合电子邮件地址格式<br><br>。                                 |
|             | `@Past`/ `@Future`            | 验证日期或时间是否在当前时间之前（过去）或之后（未来）<br><br>。                       |
### 为配置属性类启用数据校验
**目的：检验配置中的属性值的正确性**

整个过程可以总结为以下三个关键步骤：

#### 步骤一：导入校验依赖

这是基础，需要引入实现校验规范的依赖包。在 `pom.xml`中添加以下坐标：

```
<!-- JSR303 规范接口 -->
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
</dependency>
<!-- Hibernate 提供的校验实现 -->
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
</dependency>
```

**注意**：如果你使用的是较新版本的 Spring Boot，其 `spring-boot-starter-web`或 `spring-boot-starter-validation`中已经包含了这些依赖，可能无需手动添加。

#### 步骤二：在类上启用校验功能

在您的配置属性类上，除了 `@ConfigurationProperties`注解，还必须添加 `@Validated`注解。这个注解是告诉 Spring Boot 需要对此类的实例进行方法级别的校验。

```
@Component
@Data
@ConfigurationProperties(prefix = "servers")
@Validated // 关键注解：启用对该Bean的校验功能
public class ServerConfig {
    // ... 属性定义
}
```

#### 步骤三：在字段上设置具体校验规则

在类的属性字段上，使用具体的校验注解来定义规则。图片中以 `port`端口号属性为例，使用 `@Max`注解来限制其最大值。

```
public class ServerConfig {
    @Max(value = 400, message = "端口最大值不能超过400") // 具体校验规则
    private int port;
}
```

常用的校验注解还包括 `@NotNull`（非空）、`@NotEmpty`（非空字符串或集合）、`@Min`（最小值）、`@Pattern`（正则匹配）等。


### 工作流程与效果

当您的应用程序启动时，Spring Boot 会读取配置文件（如 `application.yml`）中的 `servers.port`值，并将其注入到 `ServerConfig`类的 `port`字段中。**在注入之后，校验框架会自动触发**，检查 `port`的值是否满足 `@Max(400)`的规则。

如果配置的值超过400（例如设为500），应用将**无法启动**，并会在控制台清晰地看到校验失败的异常信息，其中包含您设置的错误提示 `"端口最大值不能超过400"`。这能有效防止注入无效的配置值，保证应用的配置合法性。
## 数据校验和断言的区别

|对比维度|JSR-303 Bean Validation（注解校验）|Spring Assert（断言）|
|---|---|---|
|**核心目的**|**声明式**的数据格式与规则校验|**命令式**的业务逻辑或参数状态校验|
|**典型应用场景**|验证实体对象字段的格式、长度、范围、非空等，如邮箱格式、用户名长度。|校验业务逻辑的先决条件，如检查对象状态、验证参数与业务数据的关系（例如用户是否存在）。|
|**使用方式**|在实体类字段上使用注解（如 `@NotBlank`），并在Controller方法参数上使用 `@Valid`触发。|在代码中直接调用 `Assert`的方法（如 `Assert.notNull(user, "用户不存在")`）。|
|**代码风格**|声明式，规则与业务代码分离，更简洁。|命令式，嵌入在业务逻辑中。|
|**触发时机**|通常在数据绑定阶段，**进入业务方法前**自动执行。|在**代码执行到该行时**立即检查。|
|**校验失败异常**|通常抛出 `MethodArgumentNotValidException`或 `ConstraintViolationException`。|通常抛出 `IllegalArgumentException`或 `IllegalStateException`。|
|**处理方式**|通常通过 `BindingResult`或 `@ControllerAdvice`全局异常处理器统一处理。|需要通过 `try-catch`或全局异常处理器捕获相应的异常（如 `IllegalArgumentException`）进行处理。|
|**核心价值**|确保输入数据的**基本有效性**和格式正确性。|保障业务逻辑的**正确性**和一致性，是业务规则的守护者。|

如何选择与搭配使用

理解了它们的区别，关键在于如何在项目中正确地选择和组合使用它们。

1. **优先使用 JSR-303 Bean Validation**：对于所有通过API接收的实体对象（DTO/VO），应优先使用注解校验。这能确保无效数据在最早阶段被拦截，避免流入核心业务逻辑。
    
2. **善用 Spring Assert 进行业务校验**：在Service层或工具方法中，对于无法用注解表达的、需要查询数据库或涉及复杂业务规则的校验，使用 `Assert`。它能让校验代码更简洁直观，替代繁琐的 `if...throw...`语句。
    
3. **组合使用示例**：一个典型的流程是，在Controller中先用JSR-303校验数据格式，然后在Service方法中用Assert校验业务状态。
    
    ```
    @PostMapping("/users")
    public String createUser(@Valid @RequestBody UserDTO userDTO) {
        // 1. JSR-303 校验通过后，数据格式基本正确
        // 2. 调用服务层，进行业务逻辑校验
        userService.createUser(userDTO);
        return "success";
    }
    
    @Service
    public class UserService {
        public void createUser(UserDTO userDTO) {
            // 使用Assert校验业务逻辑，例如检查用户名是否已存在
            User existingUser = userRepository.findByUsername(userDTO.getUsername());
            Assert.isNull(existingUser, "用户名已存在"); // 业务规则：用户名必须唯一
    
            // ... 后续创建用户的逻辑
        }
    }
    ```
    