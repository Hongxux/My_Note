https://zhuanlan.zhihu.com/p/92654574

窗口函数是SQL中用于进行复杂数据分析的强大工具，它能在不折叠原始数据行的前提下，对数据的特定“窗口”进行计算，为每一行返回一个结果。这在需要同时查看详细数据和对应的汇总、排名或移动平均值时非常有用。


|特性维度|普通聚合函数 (如 SUM, AVG)|窗口函数 (如 SUM(...) OVER(...))|
|---|---|---|
|**返回结果**​|将多行数据**折叠**成一个汇总结果。|为查询的**每一行**都返回一个计算结果，保留所有原始数据。|
|**数据形态**​|结果集行数减少。|结果集行数不变。|
|**典型用法**​|与 `GROUP BY`子句搭配，用于生成汇总报表。|与 `OVER`子句搭配，用于在保留细节数据的基础上进行高级分析。|

### 🔍 窗口函数的核心构件

一个完整的窗口函数调用包含几个关键部分，它们都在 `OVER()`子句中定义：

1. **函数本身**：决定计算什么，比如是求和、排名还是取相邻行的值。
    
2. **分区（PARTITION BY）**：类似于 `GROUP BY`，它将数据集划分为更小的分组（窗口），函数会**独立地在每个分区内**进行计算。如果省略，整个结果集将作为一个分区。
    
3. **排序（ORDER BY）**：它定义了分区内数据的**排列顺序**。这对计算累计值、排名等操作至关重要。
    
4. **窗口框架（Window Frame）**：它精确指定了计算所针对的数据范围，通常相对于当前行。例如，`ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING`表示窗口包含当前行、前一行和后一行。这是实现移动平均等计算的关键。
    

### 📚 常见的窗口函数类型

窗口函数主要分为以下几类，可以应对不同的分析场景：

|类别|代表函数|主要用途与区别|
|---|---|---|
|**排名函数**​|`ROW_NUMBER()`|为每一行生成一个**唯一的连续序号**，即使值相同。|
||`RANK()`|排名相同的数据会**占用后续名次**（如1,1,3）。|
||`DENSE_RANK()`|排名相同的数据**不占用后续名次**（如1,1,2）。|
|**聚合函数**​|`SUM()`, `AVG()`|在窗口内进行聚合计算，如计算**累计求和**。|
|**偏移函数**​|`LAG()`|访问分区内**当前行之前**的某一行的值。|
||`LEAD()`|访问分区内**当前行之后**的某一行的值。|

### 💡 实际应用举例

假设有一张销售数据表 `sales_data`，包含销售员、销售日期和销售额等字段。

- **计算每个销售员的月度排名**
    
    ```
    SELECT salesperson, sale_date, sale_amount,
           ROW_NUMBER() OVER (PARTITION BY salesperson ORDER BY sale_amount DESC) as rank
    FROM sales_data;
    ```
    
    这里，`PARTITION BY salesperson`确保排名在每个销售员内部独立进行。
    
- **计算累计销售额**
    
    ```
    SELECT salesperson, sale_date, sale_amount,
           SUM(sale_amount) OVER (PARTITION BY salesperson ORDER BY sale_date) as cumulative_amount
    FROM sales_data;
    ```
    
    这可以展示每个销售员随时间推移的业绩总和。
    
- **计算移动平均**
    
    ```
    SELECT salesperson, sale_date, sale_amount,
           AVG(sale_amount) OVER (PARTITION BY salesperson ORDER BY sale_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
    FROM sales_data;
    ```
    
    这可以平滑数据，观察近期趋势，`ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`指定了计算最近3天（包括当天）的平均值。
    

### ⚠️ 使用技巧与注意事项

- **执行顺序**：窗口函数是在查询中几乎**最后**被执行的，紧接在 `WHERE`, `GROUP BY`, `HAVING`子句之后，仅在 `ORDER BY`之前。
    
- **在子查询中过滤**：由于执行顺序，你无法直接在 `WHERE`子句中引用窗口函数计算结果的别名。如果需要进行过滤，需要先将带有窗口函数的查询作为子查询。
    
    ```
    SELECT * FROM (
      SELECT *, RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rnk
      FROM employee
    ) AS t WHERE rnk = 1; -- 筛选出每个部门薪资最高的人
    ```
    
- **命名窗口**：当多个窗口函数使用相同的窗口定义时，可以使用 `WINDOW`子句为其命名，简化代码。
    
    ```
    SELECT 
      id,
      SUM(sale_amount) OVER w AS total,
      AVG(sale_amount) OVER w AS average
    FROM sales_data
    WINDOW w AS (PARTITION BY salesperson ORDER BY sale_date);
    ```
    

希望这些解释能帮助你理解窗口函数。这是一种非常强大的数据分析工具，多多练习就能熟练掌握。如果你有具体的业务场景想用窗口函数实现，我很乐意帮你看看。