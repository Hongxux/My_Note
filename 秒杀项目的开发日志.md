12.12
创建数据库表的思考
- 实现一个楼中楼和神评功能的评论表
- 设计blog表
  我根据[[考虑表需要哪些字段]]这篇笔记提供的角度，思考了需要哪些字段，然后需要建立哪几张表，再考虑字段类型和约束
- blog表：内容与元数据分离
	- tb_blog，博客对象
		- 博客id：
			- 类型：BIGINT
			- 约束：主键
		- 作者id：
			- 类型：bigint，和用户表user匹配
			- 约束：不为空，外键，关联tb_user表
		- 标题
			- 类型：VARCHAR(100)
			- 约束：不为空
		- 内容id
			- 类型：BIGINT
			- 约束：不为空，外键，和tb_blog_content相匹配
		- 封面图片的地址
			- 类型：VARCHAR(255)
			- 约束：不为空
		- 创建时间、修改时间
			- 类型：DATETIME
		- 点赞数、评论数
			- 类型：INT
	- tb_blog_content
		- 内容id
			- 类型：BIGINT
			- 约束：主键
		- 关联的blog id
			- 类型：BIGINT
			- 类型：外键
		- 具体内容
			- 类型：TEXT
	- tb_blog_comment
		- 关联的blogid：
			- 类型：BIGINT 和tb_blog匹配
		- 评论者id
			- 类型：bigint，和用户表user匹配
			- 约束：不为空，外键，关联tb_user表
		- 评论者用户名称
			- 类型：varchar(32)，和用户表user匹配
		- 评论者头像的url
			- 类型：varchar(255)，和用户表user匹配
		- 评论内容id
			- 类型：bigint
			- 约束：主键
		- 评论的点赞数
			- 类型：int
		- 评论的父评论
			-  类型：bigint
		- 评论的根评论
			-  类型：bigint
	- tb_blog_comment_content
		- 评论内容id
			-  类型：bigint
			- 约束：主键
		- 评论id
			-  类型：bigint，与tb_blog_comment匹配
			- 约束：外键
		- 具体内容
			- 类型：varchar(1000)，限制发言字数
- AI评价存在的问题：
	- **内容与博客是“一对一”关系**，分离意义不大，反而增加JOIN操作。建议合并回主表。
	- **数据冗余与一致性的权衡**
		- 你在评论表中直接存储了`评论者用户名称`和`评论者头像的url`，这属于**反范式设计**。其初衷是为了避免每次显示评论时都去关联用户表，用**空间换时间**提升查询性能
		- 问题：但这样做带来了严重的数据一致性问题：当用户修改名字或头像时，所有已发布的评论数据不会同步更新。
		- **优化建议**：除非有明确的、极高的性能要求，否则在初期应优先保证数据一致性，即**遵循第三范式**。评论表只保留 `user_id`，需要显示用户信息时通过 `JOIN`用户表查询。在高并发场景下，可以考虑使用缓存来优化用户信息的查询效率。
	- **内容关系**：`tb_blog_content`表与`tb_blog`表是“一对一”关系，这通常意味着它们可以合并。除非博客内容极其庞大且很少被访问，否则分开只会让查询变得更复杂。
	- 对于更新频率高的字段，比如点赞数、评论数
		- 问题：在并发场景下，直接使用`UPDATE ... SET count = count + 1`可能会产生锁竞争，影响性能。
		- 优化方案：将点赞行为记录到一张单独的`点赞流水表`中，然后通过异步任务或定时任务来统计计数，但这会增加系统复杂性。初期可以直接使用计数字段，但心里要清楚这个潜在问题。
	- **缺失的“状态”字段**：一个好的博客表应该有`status`（状态）字段，例如`draft`（草稿）、`published`（已发布）、`deleted`（已删除）等。这比物理删除数据要好得多，可以实现“逻辑删除”
	- **考虑软删除**：为核心表（如博客、评论）增加`is_deleted`TINYINT字段或`deleted_at`DATETIME字段，用于标记是否删除，这是企业级应用的常见实践。
	- **索引策略**：除了主键，应在常用的查询条件字段上创建索引，例如：
		- `tb_blog(author_id, create_time)`：用于查询某个作者的所有博客并按时间排序。
		- `tb_blog_comment(blog_id, create_time)`：用于查询某篇博客下的所有评论并按时间排序
- 最终方案：
```sql
-- 博客主表
CREATE TABLE tb_blog (
  blog_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  author_id BIGINT NOT NULL,
  title VARCHAR(255) NOT NULL, -- 增加长度
  content TEXT NOT NULL, -- 内容合并回来
  cover_image_url VARCHAR(500), -- 增加长度，允许为空
  `status` ENUM('draft', 'published', 'deleted') DEFAULT 'draft', -- 增加状态
  like_count INT UNSIGNED DEFAULT 0,
  comment_count INT UNSIGNED DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  is_deleted TINYINT(1) DEFAULT 0, -- 软删除
  FOREIGN KEY (author_id) REFERENCES tb_user(user_id)
  -- 在author_id, status, created_at等字段上建立索引
);

-- 评论表
CREATE TABLE tb_blog_comment (
  comment_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  blog_id BIGINT NOT NULL, -- 关键：关联博客ID
  user_id BIGINT NOT NULL,
  parent_id BIGINT DEFAULT 0, -- 父评论ID，0表示顶级评论
  root_id BIGINT DEFAULT 0, -- 根评论ID，方便查询整棵树
  content TEXT NOT NULL, -- 内容直接存储，除非有特殊需求
  like_count INT UNSIGNED DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (blog_id) REFERENCES tb_blog(blog_id),
  FOREIGN KEY (user_id) REFERENCES tb_user(user_id)
  -- 在blog_id, parent_id, created_at等字段上建立索引
);
-- 为评论表添加索引
CREATE INDEX idx_blog_id ON tb_blog_comment(blog_id);
CREATE INDEX idx_user_id ON tb_blog_comment(user_id);
CREATE INDEX idx_parent_id ON tb_blog_comment(parent_id);
CREATE INDEX idx_root_id ON tb_blog_comment(root_id); -- 建议也加上，便于查询评论树

-- 点赞流水表
CREATE TABLE tb_blog_like_record (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  blog_id BIGINT NOT NULL COMMENT '被点赞的博客ID',
  user_id BIGINT NOT NULL COMMENT '点赞的用户ID',
  action ENUM('liked', 'unliked') NOT NULL DEFAULT 'liked' COMMENT '操作类型: liked-点赞, unliked-取消点赞',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  UNIQUE KEY uk_blog_user (blog_id, user_id) COMMENT '防止用户对同一博客重复点赞'
  FOREIGN KEY (blog_id) REFERENCES tb_blog(blog_id),
  FOREIGN KEY (user_id) REFERENCES tb_user(user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='博客点赞流水表';
-- 用户点赞或取消点赞 
INSERT INTO tb_blog_like_record (blog_id, user_id, action) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE action = VALUES(action), updated_at = CURRENT_TIMESTAMP;
```


12.13
在开发发表评论功能的时候，我打算用RabbitMQ异步提交

于是我需要先在项目中配置可靠的消息队列机制