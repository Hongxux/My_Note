
1. **线程的创建与启动**
[[创建线程]]
- **`start()`**
    - 功能：
	    1. 启动一个新线程：调用 `start`方法仅仅意味着线程进入了“就绪”状态
		    -  就绪状态：代码并不会立刻得到运行，具体执行时机取决于CPU的调度。
	    2. 在新线程中执行 `run`方法体内的代码。
	- 每个线程对象的 `start`方法只能被调用一次
		- 多次调用会抛出 `IllegalStateException`异常。
- **`run()`**:
    - 功能：这是新线程启动后真正会执行的方法。
	    - 不直接被调用或者用于启动线程：应该调用 `start()`方法而非直接调用 `run()`方法
		    - `start()`会启动新线程并自动调用 `run()`
		    - 直接调用 `run()`则等同于普通方法调用
			    - 不会启动新线程 
			    - 还是在当前线程执行run的方法
	    - 只用于定义线程要执行的指令流
    - 定义run的具体行为：
	    - 默认不执行任何操作。
	    - 方式一：传递Runnable对象给Thread
		    - Runnable对象指的是实现Runnable接口的类 
			    - 常用匿名内部类实现run（）方法
		    - 线程启动后将调用该参数对象的 `run`方法；
	    - 方式二：继承 `Thread`类并重写此方法
		    - 也可以用匿名类内部类


2. **线程属性的获取与设置**
- **`currentThread()`**
    - **功能**：返回当前正在执行的线程对象的引用。这在任何方法中都可以用来获取当前线程的信息，例如打印日志时记录线程名。
- **`getId()`**：获取线程的唯一长整型ID。PID
    
- **`getName()`**​  与  **`setName(String)`**：分别用于获取和设置线程的名称。
	- 可以在创建Thread的时候构造参数传参，指定名字
    
- **`getPriority()`**​  与  **`setPriority(int)`**：分别用于获取和设置[[线程的优先级]]。
    
    - **关键说明**：在Java中，线程优先级被定义为1到10的整数。设置较高的优先级可以**提高**该线程被CPU调度的**几率**，但这并非绝对的保证，具体行为依赖于底层的操作系统调度器。
        
    
- **`getState()`**：获取线程当前的状态。Java中使用6个枚举值来表示线程状态，分别是：
	- NEW
	- RUNNABLE
	- BLOCKED
	- WAITING
	- TIMED_WAITING,
	- TERMINATED。
- **`setDaemon(boolean)`**：设置其是否为是守护线程
3. **线程状态判断方法**

- **`boolean isAlive()`**
    
    - 功能：判断当前线程是否仍然存活。
	    - 使用场景：等待一个线程完成后再进行后续操作
    - 存活的标准：满足两个条件：
	    1. 它已经启动（`start`方法已被调用）
	    2. 尚未终止（`run`方法尚未执行完毕）。

- **`boolean isInterrupted()`**
    
    - 功能：检查目标线程的中断标记
	    - 不会清除该标记。
        
    - 中断机制：是Java中一种协作式的线程终止或通知机制，并非强制停止。
        
4. **线程中断操作方法**
- 需求背景：
	- 需要让某个线程提前结束任务的情况
		- 用户取消了操作
		- 服务需要紧急关闭
		- 任务执行超时
	- 粗暴终止会导致被提前结束的线程中涉及的对象状态不一致，出现严重问题：
		- 数据损坏
		- 资源泄露：如文件句柄或数据库连接未关闭
- 解决方法：协作式中断机制
	- 核心思想：堆需要停止的线程发送终中断请求信号
		- 中断请求信号：收到这个信号的信号可以在一个合适且安全的时机结束运行，并完成必要的清理工作
	- 实现机制：在线程内部增加一个中断状态标志位，调用`interrupt`后，设置为true
		- 运行中的线程（Runnable）：
			- 通过自行检查这个标志位（`Thread.interrupted()`），线程决定是否中断，以及如何中断
				- `Thread.interrupted()`会清除当前线程的中断标记
		- 阻塞中的线程（在 `sleep()`, `wait()`, `join()`中）：
			- 线程被立即唤醒，并抛出 `InterruptedException`异常，线程从catch块开始执行指令
			- 中断标志位会被清除：因为以及响应到了这个请求
- **[[两阶段终止]]**设计模式
- **`void interrupt()`**
    - 功能：中断一个线程。
    - 实现机制：设置中断标志为true
- **`static boolean interrupted()`**
    - **功能**：这是一个静态方法，用于**检查当前正在执行的线程是否被中断**。
	    - 
    - **关键点**：与 `isInterrupted()`最大的不同在于，这个方法在返回值后，**会清除当前线程的中断标记**。


5. **静态工具方法**

- **`static void sleep(long millis)`**
    
    - **功能**：让**当前线程**暂停执行指定的毫秒数
	    - 状态转变：从 Running 进入 Timed waiting 状态
		    - Timed waiting 状态：
			    - CPU时间：线程主动让出CPU时间片，任务调度器认为该状态下的线程没有资格被CPU调度实习
			    - 锁的持有：但不会释放所持有的锁
	    - 睡眠结束后的线程未必会立刻得到执行
		    - 睡眠结束：
			    - 暂停了指定的毫秒数
			    - 睡眠期间，有其他线程调用了此线程的 `interrupt()`方法
		    - 原因：睡眠结束后的线程需要“重新排队”等待CPU资源，而不是立刻恢复执行。
			    - 睡眠结束后状态会从 `TIMED_WAITING`变为 `RUNNABLE`
				    - `RUNNABLE`状态表示线程处于“就绪”状态，有资格被CPU调度执行。
	- 该方法必须处理受检异常 `InterruptedException`：
		- `InterruptedException`产生的原因：其它线程使用 interrupt 方法打断正在睡眠的线程
	- 实践使用：
		- 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性![[Pasted image 20251130143716.png]]
		- 避免cpu百分百占用：
			- 需求背景：在服务器中
				- 服务器要24小时不断提供服务：使用while(true)表示永不停止。常驻。
				- while(true)的空转cpu会导致极高的、不必要的CPU占用率，甚至可能达到100%
					- 如果系统中没有其他更需要CPU的繁忙线程，调度器会频繁地将CPU分配给这个“饥饿”的循环线程
			- 解决方法：加入`sleep()`
				- 即使休眠1毫秒，cpu也能完成成千上万条其他指令
    
- **`static void yield() `**
    
    - **功能**：向线程调度器表示当前线程愿意让出当前使用的CPU。
	    - 状态转变： Rummiig进入 Rummabie 状态
		    - 有同优先级的线程：调度器执行其它同优先级的线程
		    - 没有同优先级的线程：不能保证让当前线程暂停 
    - **关键点**：这是一个启发式的调用，主要用于测试和调试，目的是帮助暴露由于线程执行顺序不当导致的并发问题。**在一般的业务代码中应谨慎使用**，因为它不能保证达到预期的效果。
    
6. **wait和notify**
- obj.wait()
	- 使用前提：在owner的线程才有资格调用
		- 只能在`synchronized`代码块中使用
	- 实现机制：让本线程进入waitSet队列，并且进入WAITING状态
- obj,notify/notifyAll
	- 使用前提：在owner的线程才有资格调用
		- 只能在`synchronized`代码块中使用
	- 实现机制：
		- 唤醒：从waitSet队列加入entryList队列，状态变为BLOCKED
		- notify:让waitSet队列中等待的线程中挑一个唤醒
		- notifyAll:把所有都唤醒
			- notifyAll+while 循环条件检查：解决[[虚假唤醒]]问题
- [[保护性暂停模式]]

6. **线程的同步**
- 需求背景：
	- 多个线程是[[并行]]和[[并发]]执行的：你无法确定子线程和主线程谁先结束
	- 一个线程的接下来任务需要某个线程完成才能进行：
		- 数据初始化：该线程需要使用的资源或者数据，由一个或多个子线程预先加载或计算完成
		- 结果汇总：大任务被分块给多个线程完成，最后的结果必须等待所有分块任务完成才能得到
		- 流程控制：多个有前后依赖关系的步骤由不同的线程执行
			- 前后依赖关系：复杂的业务操作包含多个步骤，后一步骤严格依赖于前一步骤的完成
- join的工作原理：![[Pasted image 20251130151908.png]]
	- 和保护性暂停模式相似，只是一个是等待结果出现就被唤醒，一个是等到线程的run方法执行完毕被唤醒
		 - 当线程B的 `run()`方法执行结束时，Java虚拟机会自动调用该线程对象的 `notifyAll()`方法。
- **`join()`**：阻塞线程
    
    - **功能**：等待目标线程运行结束。例如，在主线程中调用 `t.join()`，那么主线程会暂停并等待线程 `t`执行完毕后，才会继续执行。
        
    
- **`join(long n)`**
    
    - **功能**：等待目标线程运行结束，但最多只等待指定的毫秒数。这是一个带超时机制的等待，可以避免当前线程无限期地阻塞。