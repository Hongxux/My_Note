| 特性       | InnoDB                     | MyISAM                       |
| -------- | -------------------------- | ---------------------------- |
| **事务支持** | 支持 (ACID)                  | 不支持                          |
| **锁粒度**  | 行级锁 (Row-level Lock)，并发性能好 | 表级锁 (Table-level Lock)，并发性能差 |
| **外键**   | 支持                         | 不支持                          |
| **MVCC** | 支持                         | 不支持                          |
| **崩溃恢复** | 支持 (通过`redo log`)          | 不支持                          |
| **索引结构** | 聚簇索引                       | 非聚簇索引                        |
| **适用场景** | 适用于需要事务和高并发写的场景            | 适用于读密集、非事务性的场景               |
## 逻辑存储结构
![[Pasted image 20251102105301.png]]


#### 1. 行（Row）

- ​**是什么**​：存储数据的**最小单位**，即我们常说的“一行记录”。
    
- ​**内容**​：包含用户定义的表字段数据（如 id, name）、事务ID（DB_TRX_ID）、回滚指针（DB_ROLL_PTR）等系统隐藏列。
    
- ​**行格式**​：InnoDB 支持多种行格式（如 `COMPACT`, `DYNAMIC`），影响如何存储变长字段（如 VARCHAR, TEXT）和溢出页的使用。
    

#### 2. 页（Page）

- ​**是什么**​：InnoDB ​**磁盘管理的最小单元**，也是内存与磁盘交互的基本单位。所有读写操作最终都以页为单位进行。
    
- ​**大小**​：默认 ​**16KB**，可在初始化数据库时通过参数 `innodb_page_size`调整（但一旦初始化就不能更改）。
    
- ​**功能**​：一个页内包含多行数据。页是 B+Tree 索引的节点，数据页之间通过双向链表连接。
    

#### 3. 区/簇（Extent）

- ​**是什么**​：由**连续的页**构成的物理分配单位。
    
- ​**大小**​：​**1MB**​（因为 `1MB / 16KB = 64`，所以一个区包含 ​**64 个连续的页**）。
    
- ​**目的**​：为了**顺序I/O和性能**。当为表或索引分配空间时，InnoDB 每次至少分配一个区（1MB），而不是单个页（16KB）。这可以减少随机I/O，提升大量数据插入和范围查询的性能。
    

#### 4. 段（Segment）

- ​**是什么**​：由一个或多个区构成的逻辑概念，是**表空间的主要组成部分**。
    
- ​**分类**​：
    
    - ​**叶子节点段**​：B+Tree 中存储实际行数据的区的集合。
        
    - ​**非叶子节点段**​：B+Tree 中存储索引指针的区的集合。
        
    - ​**回滚段**​：用于存储事务回滚所需信息的区的集合。（undo log）
        
    
- ​**管理**​：一个索引会生成两个段：一个用于非叶子节点（索引），一个用于叶子节点（数据）。
    

#### 5. 表空间（Tablespace）

- ​**是什么**​：InnoDB 存储结构的**最高层级**，是段、区、页的物理容器，对应磁盘上的一个或多个文件。
    
- ​**分类**​：
    
    - ​**系统表空间**​：存储数据字典、回滚段、双写缓冲区等元数据。
        
    - ​**独立表空间（默认）​**​：每个表有自己独立的 `.ibd`文件，包含该表的数据和索引。这正是图中描述的 `users.ibd`文件。
        
    

### 核心设计思想与价值

1. ​**层次化与模块化**​：将大问题分解为小问题，便于管理、空间分配和回收。
    
2. ​**预分配与连续性**​：通过“区”的概念一次性分配连续的大块空间，极大提升了顺序I/O性能，减少了磁盘碎片。
    
3. ​**固定大小单元**​：“页”作为固定大小的操作单元，简化了内存管理和磁盘读写。
    
4. ​**链接性**​：页与页之间通过双向链表连接，便于范围扫描。
    
## 架构
### 内存缓冲区结构
内存缓冲区结构是数据库实现高性能读写的关键。
这些组件共同协作，极大地提升了数据库的并发处理能力和响应速度。它们之间的关系与分工可以通过下图直观展示：
![[Pasted image 20251102111627.png]]




![[Pasted image 20251102111745.png]]
#### 1. 缓冲池 - Buffer Pool：主内存缓存区

缓冲池是 InnoDB 引擎中最大、最重要的内存区域，是数据库的“工作台”。

- ​**功能**​：缓存磁盘上的表数据和索引数据。当执行查询时，InnoDB 首先在 Buffer Pool 中查找所需的数据页（Page）。如果找到（称为“缓存命中”），则直接返回；如果未找到，则从磁盘读取并加载到 Buffer Pool 中。
    
- ​**工作单元**​：以 ​**Page（页，通常16KB）​**​ 为单位进行管理。
    
- ​**页的状态**​：
    
    - ​**Free Page**​：空闲页，可供使用。
        
    - ​**Clean Page**​：干净页，内容与磁盘一致，未被修改。
        
    - ​**Dirty Page**​：脏页，内容已被内存中的事务修改，与磁盘数据不一致，需要被刷回磁盘。
        
    
- ​**价值**​：通过将“热数据”留在内存中，​**极大减少了昂贵的磁盘I/O操作**，是提升性能的基石。
    

#### 2. 更改缓冲区 - Change Buffer：非唯一索引的写优化器

更改缓冲区是针对**非唯一二级索引**的特殊优化结构，是提升写入性能的关键。

- ​**解决的问题**​：当对表进行 `INSERT`、`UPDATE`、`DELETE`操作时，如果受影响的**二级索引页不在 Buffer Pool**​ 中，传统做法需要先将索引页从磁盘读入内存再修改，这会产生大量的随机磁盘I/O，性能低下。
    
- ​**工作原理**​：如图中“变更路径”所示，如果目标索引页不在内存中，Change Buffer 会先将这些修改操作**缓存起来**，而不是立即从磁盘读取索引页。当未来该索引页被读取时，再将 Change Buffer 中缓存的修改**合并**到该页上。
    
- ​**价值**​：将多次随机的磁盘I/O**合并为更少的顺序I/O**，显著提升了涉及二级索引的DML操作性能。
    

#### 3. 自适应哈希索引 - Adaptive Hash Index：查询加速器

自适应哈希索引是 InnoDB 为优化查询性能而自动构建的**内存哈希表**。

- ​**功能**​：InnoDB 引擎会监控对表上索引的查找。如果发现某个索引值被频繁用等值查询（如 `WHERE id = 5`），且建立一个哈希索引可以提升速度，它就会在内存中**自动**为这些“热”索引页建立哈希索引。
    
- ​**关键特性**​：​**完全自适应，无需人工干预**。
    
- ​**价值**​：对于频繁的等值查询，可以将B+Tree的3-4次查找**优化为接近O(1)的哈希查找**，极大提升查询速度。可通过参数 `adaptive_hash_index`开启或关闭。
    

#### 4. 日志缓冲区 - Log Buffer：日志的中间站

日志缓冲区是用于缓存重做日志的小块内存区域。

- ​**功能**​：用来缓冲即将写入磁盘的重做日志和 undo 日志。所有事务的日志信息会先写入 Log Buffer，然后再根据一定策略批量刷新到磁盘上的日志文件。
    
- ​**关键参数**​：
    
    - `innodb_log_buffer_size`：缓冲区大小，默认16MB。对于大事务，可以适当调大。
        
    - `innodb_flush_log_at_trx_commit`：​**控制日志刷盘时机**，是数据安全与性能的关键权衡点：
        
        - ​**1（默认）​**​：事务提交时**立即写入并刷新**到磁盘。最安全，性能最低。
            
        - ​**0**​：日志每秒**写入并刷新**一次。性能高，但服务器崩溃可能丢失1秒内的事务。
            
        - ​**2**​：事务提交时**立即写入**操作系统缓存，但每秒才**刷新**到磁盘。性能与安全性的折中方案。
            
        
    
- ​**价值**​：通过缓冲和批量写入，减少了频繁的磁盘日志写入操作，提升了事务处理的吞吐量。
    

#### 总结

这四大缓冲区共同构成了 InnoDB 高性能的支柱：

1. ​**Buffer Pool**​ 是核心缓存，优化了**读操作**。
    
2. ​**Change Buffer**​ 是辅助缓存，专门优化了对**非唯一二级索引的写操作**。
    
3. ​**Adaptive Hash Index**​ 是智能索引，自动优化了**频繁的等值查询**。
    
4. ​**Log Buffer**​ 是日志中转站，通过批量I/O优化了**事务的持久化过程**。
    

### 磁盘结构
 ![[Pasted image 20251102161138.png]]
#### 1. 表空间

表空间是 InnoDB 存储结构的最高层级，是数据文件的逻辑容器。它分为几种类型：

​**a) 系统表空间**​

- ​**文件**​：默认名为 `ibdata1`。
    
- ​**存储内容**​：
    
    - ​**数据字典**​：存储表、列、索引等元数据的系统表。
        
    - ​**Change Buffer**​：更改缓冲区的磁盘存储部分。
        
    - ​**双写缓冲区**​：为提高数据页写入安全性而设计的结构。
        
    - ​**Undo Logs**​：在 MySQL 5.7 及更早版本中，默认将 Undo 日志放在系统表空间。8.0 已独立。
        
    
- ​**管理建议**​：在生产环境中，建议启用 `innodb_file_per_table`并将 Undo 日志独立出来，以避免系统表空间过大难以管理。
    

​**b) 独立表空间**​

- ​**文件**​：每个表对应一个独立的 `.ibd`文件（如 `users.ibd`）。
    
- ​**启用**​：通过参数 `innodb_file_per_table = ON`控制。
    
- ​**存储内容**​：该表的**数据**和**索引**​（B+Tree 结构）。
    
- ​**优势**​：
    
    - ​**易于管理**​：可以单独对表进行备份、恢复和迁移。
        
    - ​**空间回收**​：当表被删除或截断时，空间可以直接释放给操作系统。
        
    - ​**减少碎片**​：表之间相互独立，避免空间碎片交叉。
        
    

​**c) Undo 表空间**​

- ​**功能**​：专门存储 ​**Undo Logs**。
    
- ​**作用**​：用于事务回滚和实现多版本并发控制。它记录了数据被修改前的旧版本。
    
- ​**文件**​：默认名为 `undo_001`, `undo_002`。
    

​**d) 临时表空间**​

- ​**功能**​：存储用户创建的临时表和磁盘内部的临时表。
    
- ​**文件**​：默认名为 `ibtmp1`。
    

#### 2. 重做日志

这是 InnoDB 实现 ​**Crash-Safe**​ 能力的核心组件，即保证数据库在发生宕机等故障后数据不丢失。

- ​**文件**​：通常为 `ib_logfile0`和 `ib_logfile1`，循环写入。
    
- ​**工作方式**​：
    
    1. 当数据发生变更时，变更产生的**重做日志**会先被写入 ​**Log Buffer**。
        
    2. 根据策略（如事务提交时），日志被顺序、批量地刷入这些重做日志文件。
        
    3. ​**关键点**​：重做日志的写入是**顺序追加**的，比随机写入数据页要快得多。
        
    
- ​**崩溃恢复**​：当数据库重启时，InnoDB 会检查重做日志，将那些已提交但尚未刷盘的数据变更（脏页）重新应用（重做）到数据页上，从而保证持久性。
    
- ​**配置**​：通过 `innodb_log_file_size`和 `innodb_log_files_in_group`参数控制文件大小和数量。
    

#### 3. 双写缓冲区

这是一个提高数据页写入可靠性的安全网。

- ​**问题背景**​：操作系统和磁盘硬件以“块”为单位进行写入（如 4KB），而 InnoDB 数据页通常是 16KB。如果发生部分页写入（例如写入16KB时只写了8KB后断电），会导致页数据损坏，即使有重做日志也无法恢复，因为重做日志的恢复依赖于页本身的完整性。
    
- ​**解决方案**​：
    
    1. 在将脏页刷到表空间数据文件**之前**，InnoDB 会先将它们顺序地写入磁盘上一个名为双写缓冲区的连续区域。
        
    2. 然后再将脏页散落地写入其真正的数据文件位置。
        
    
- ​**崩溃恢复**​：如果发生部分页写入，InnoDB 可以从双写缓冲区中找到该页的一个完好副本，用它来恢复损坏的页。
    
- ​**性能权衡**​：双写机制会增加一次额外的磁盘写入，但通过顺序写入来降低性能开销。在支持原子写的现代存储设备上可以考虑关闭。
    

### 后台线程
后台线程组是连接内存（缓冲池）和磁盘（数据/日志文件）的桥梁。
#### 1. Master Thread：核心调度与总管

这是 InnoDB 的**大脑和总指挥**，负责全局性的调度和关键任务的执行。

- ​**核心职责**​：
    
    - ​**缓冲池刷新**​：定期将内存缓冲池中的**脏页**异步刷新到磁盘数据文件，确保内存和磁盘数据的一致性。
        
    - ​**合并插入缓冲**​：将 Change Buffer 中缓存的对二级索引的更改，合并到实际的索引页中。
        
    - ​**Undo 页回收**​：回收不再需要的 Undo 日志空间。
        
    - ​**协调调度**​：负责管理和协调其他后台线程的活动。
        
    
- ​**重要性**​：它的健康运行直接关系到数据库的整体性能和数据安全性。它通过异步操作将随机 I/O 转换为相对顺序的 I/O，平衡了性能和数据持久化。
    

#### 2. IO Thread：异步 I/O 处理引擎

为了应对高并发的 I/O 请求，InnoDB 使用了**异步 I/O**​ 模型，而 IO Thread 专门负责处理这些 I/O 请求的回调。

- ​**工作模式**​：使用 ​**AIO**，数据库发起一个 I/O 请求后无需等待其完成，可以立即处理下一个请求。当 I/O 操作完成后，由对应的 IO Thread 执行回调函数处理结果。
    
- ​**分类与职责**​：
    
|线程类型|默认个数|职责说明|
|---|---|---|
|​**Read thread**​|4|负责处理数据文件的**读请求**，如将数据页从磁盘加载到缓冲池。|
|​**Write thread**​|4|负责处理数据文件的**写请求**，如将缓冲池的脏页刷回磁盘。|
|​**Log thread**​|1|专门负责将**重做日志缓冲区**的内容刷新到磁盘的日志文件。|
|​**Insert buffer thread**​|1|负责将 ​**Change Buffer**​ 中的更改刷到磁盘。|
    
- ​**性能调优**​：对于 I/O 密集型的应用，可以通过参数（如 `innodb_read_io_threads`和 `innodb_write_io_threads`）适当增加读写线程的数量，以提升并发 I/O 处理能力。
    

#### 3. Purge Thread：事务垃圾回收器

专门用于回收**已经提交的事务**所不再需要的 ​**Undo Log**。

- ​**背景知识**​：为了实现事务的 MVCC（多版本并发控制），当数据被更新或删除时，旧版本数据会保存在 Undo Log 中，以便其他正在运行的事务可以读取到一致性的快照。
    
- ​**工作时机**​：当没有任何事务需要这些旧版本数据时，这些 Undo Log 就成为了可回收的“垃圾”。
    
- ​**作用**​：Purge Thread 会定时清理这些无用的 Undo Log，释放磁盘空间，防止 Undo 表空间无限增长。
    
- ​**演化**​：在 MySQL 5.6 之后，可以配置多个 Purge Thread（`innodb_purge_threads`）来提升回收效率。
    

#### 4. Page Cleaner Thread：脏页刷新专家

这是一个为了**减轻 Master Thread 负担**而引入的专用线程。

- ​**要解决的问题**​：在早期版本中，脏页刷新工作完全由 Master Thread 负责。在写入密集型场景下，这会给 Master Thread 带来巨大压力，可能成为性能瓶颈。
    
- ​**专用化职责**​：Page Cleaner Thread 从 Master Thread 中接过了**脏页刷新**这一重要且繁重的任务。它专门负责在后台将缓冲池中的脏页刷新到磁盘。
    
- ​**带来的好处**​：
    
    - ​**降低延迟**​：使 Master Thread 能更专注于调度，减少用户请求的阻塞。
        
    - ​**提升性能**​：专门的线程可以更高效地管理脏页刷新策略，提升整体吞吐量。
        
    


 ### 内存和磁盘协同工作

1. ​**写入流程**​：
    
    - 事务修改数据，在 ​**Buffer Pool**​ 中产生**脏页**。
        
    - 日志先被写入 ​**重做日志文件**​（WAL 机制）。
        
    - 脏页通过后台线程刷盘时，先经过**双写缓冲区**，再写入**用户表空间**的 `.ibd`文件。
        
    - 事务回滚或 MVCC 所需的信息保存在 ​**Undo 表空间**。
        
    
2. ​**读取流程**​：
    
    - 所需数据页从 ​**表空间文件**​（.ibd）被加载到 ​**Buffer Pool**。
        
    - 如果需要旧版本数据，则从 ​**Undo 表空间**​ 中构造。
        
    
3. ​**崩溃恢复**​：
    
    - 重启后，比较**重做日志**和**数据页**。
        
    - 利用**双写缓冲区**修复损坏的页。
        
    - 应用重做日志中已提交的事务，回滚未提交的事务（使用 Undo 日志）。
        
    

简单来说，InnoDB 通过这种精巧的磁盘结构设计，在保证数据**持久性（Durability）​**​ 和**一致性（Consistency）​**​ 的前提下，最大限度地提升了数据库的**性能和可靠性**。理解这些组件是进行高级数据库管理和性能调优的基础。
## 事务原理（[[MySQL事务ACID的实现]]）

