
- 设计目标：高吞吐量
- 设计原理：
	- 垃圾回收时间在运行期间占比越低，吞吐量越高 
	- 因此采用多线程，并行进行垃圾回收，降低GC时间
- 问题：
	- 垃圾回收发生时候，会出现极高的cpu占有率
		- 因为要利用可以利用的cpu资源进行垃圾回收
	- 单次STW停顿时间较长
- 场景选择
	- 对于计算密集型、无低延迟要求的服务端应用，并行GC能提供最高、最稳定的吞吐量**
	- 而CMS/G1等是为**低延迟**场景设计的
- 工作模式：基于分代垃圾回收，其中fullGC使用标记整理分发![[Pasted image 20251207170121.png]]
	- 垃圾回收线程数量：
		- 默认：在一个范围内，和cpu核数一样
		- 配置：`-XX:ParallelGCThreads=n`
	- 相关配置：
		- 动态调整各个区域大小和晋升的阈值：`-XX:+UseAdaptivesizePolicy`
		- 根据目标，进行动态调整
			- 调整垃圾回收时间占工作时间的百分比：`-XX:GCTimeRatio=ratio`
				- 默认99，推荐19
				- ratio值越大，GC时间占比越小，应用吞吐量目标越高
				- 计算公式：GC时间占比 = 1 / (1 + ratio)
			- 调整单次垃圾回收时间：`-XX:MaxGCPauseMillis=ms`
				- 默认200
			- 两个目标相互冲突
- 开启方式：JDK1.8默认开启 `XX:+UseParallelGC和XX:+UseParallelOldGC`
	- 开启一个，连带开启另一个