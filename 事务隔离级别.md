


| 隔离级别                          | 脏读  | 不可重复读 | 幻读  | 解释                                                                               |
| ----------------------------- | --- | ----- | --- | -------------------------------------------------------------------------------- |
| ​**Read Uncommitted（读未提交）​**​ | √   | √     | √   | ​**级别最低**。一个事务可以读取到另一个事务**未提交**的修改。存在所有并发问题，性能最好但数据一致性最差，很少使用。                   |
| ​**Read Committed（读已提交）​**​   | ×   | √     | √   | 一个事务只能读取到其他事务**已经提交**的修改。解决了**脏读**，但可能发生不可重复读和幻读。这是**Oracle等数据库的默认级别**。          |
| ​**Repeatable Read（可重复读）​**​  | ×   | ×     | √   | 确保在同一个事务中，多次读取同一数据的结果是一致的。解决了脏读和不可重复读，但可能发生**幻读**（使用当前读可以防止）。这是**MySQL的默认隔离级别**。 |
| ​**Serializable（可序列化）​**​     | ×   | ×     | ×   | ​**级别最高**。所有事务串行执行，完全隔离。解决了所有并发问题，但性能开销最大，因为并发性急剧下降。                             |
**可重复的风险**
1. **RR 的核心承诺**：同一事务内，对同一数据的多次读取结果一致（避免「不可重复读」），通过 InnoDB 的 MVCC（多版本并发控制）实现「读不加锁、写锁互斥」，支持读写并发。
	- 价值：实现**高并发**和**事务内部逻辑自洽**
2. **RR 不承诺的事**：不阻止「并发修改」（即其他事务仍可修改数据），也不直接保证「业务规则一致性」（如余额不为负）—— 这是业务逻辑与隔离级别的边界。
3. 启示：明确「数据库一致性」与「业务一致性」的边界
	- RR能保证一个事务中的视图一致，这是数据库的一致性，**保障的是事务内部的一致性**
	- 至于**业务一致性**，则是需要我们通过锁机制或者乐观校验解决

**在可重复读中，为什么会出现幻读现象**：
在 SQL 标准中，可重复读隔离级别本身并不要求解决幻读问题。幻读是更严格的串行化级别才解决的问题。
但 MySQL 的 InnoDB 引擎通过 MVCC 和 Next-Key Lock 增强了可重复读，使其能够避免大部分幻读。

普通 `SELECT`不会出现幻读，但在以下情况下需要注意：

1. ​**当前读的情况**​：如果你使用 `SELECT ... FOR UPDATE`或 `SELECT ... LOCK IN SHARE MODE`（当前读），情况会不同。当前读会读取最新提交的数据，可能会看到新插入的行。
    
2. ​**混合操作的影响**​：如果事务A先执行普通 `SELECT`，然后执行了 `UPDATE`或 `DELETE`操作，这些写操作会看到最新的数据。在某些数据库实现中，这可能会影响后续的读操作（但MySQL的可重复读级别通常能保持一致性）。
---
如何[[基于业务需求与底层原理 选择事务隔离级别]]
