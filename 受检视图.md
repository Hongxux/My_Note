---
aliases:
  - Checked Views
---


​**需求背景**​

泛型类型在编译时存在类型擦除，可能导致**运行时错误注入**​：

- 通过原始类型（Raw Type）可向泛型集合混入非法类型元素（如向 `ArrayList<String>`插入 `Date`对象）。
    ![[Pasted image 20251027091607.png]]
- 错误不会在注入时暴露，而是在后续读取并强制转型时抛出 `ClassCastException`，增加调试难度。
    

​**解决方案**​

使用 `Collections.checkedXxx`方法创建**受检视图**，在元素插入时立即进行类型校验：

```
// 创建受检视图  
List<String> safeStrings = Collections.checkedList(strings, String.class);
```
![[Pasted image 20251027091653.png]]
**与其他技术的关系**

- ​**泛型擦除的补充**​：受检视图是 Java 泛型类型擦除机制下的一种**运行时补救措施**，但无法完全替代编译时泛型安全。
    
- ​**调试工具**​：与断言（Assertions）和日志监控结合，可构建更健壮的类型安全防御层。
    
- ​**替代方案**​：在需要严格泛型校验的场景，可考虑使用第三方库（如 Checker Framework）或升级到支持更严格类型检查的语言（如 Kotlin）。
---

#### 核心特性

​**1. 即时类型检查**​

- 受检视图的 `add()`方法会**立即校验元素类型**，非法插入直接抛出 `ClassCastException`：
    
    ```
    ArrayList rawList = safeStrings;  
    rawList.add(new Date()); // 抛出 ClassCastException（错误定位到插入点）
    ```
    

​**2. 调试支持**​

- 将运行时错误从**不可预测的读取点**提前到**确定的写入点**，显著提升问题定位效率。
    

​**3. 局限性**​

- ​**无法检测泛型参数类型**​：虚拟机仅检查原始类型（Raw Type）。
    
    ```
    // 示例：无法阻止插入 Pair<Date> 到 ArrayList<Pair<String>>  
    List<Pair<String>> list = new ArrayList<>();  
    List<Pair<String>> checkedList = Collections.checkedList(list, Pair.class);  
    checkedList.add(new Pair<Date>()); // 通过检查！因虚拟机只校验 Pair 类
    ```
    

---

### 重点知识分层

|​**学习者层级**​|​**必须掌握的核心内容**​|
|---|---|
|​**初学者**​|理解受检视图的目的：在**插入时捕获类型错误**，避免延迟暴露的 `ClassCastException`。|
|​**进阶者**​|掌握 `Collections.checkedList/Set/Map()`的用法，明确其即时校验机制和调试价值。|
|​**高级应用**​|认识受检视图的局限性：​**无法校验泛型参数类型**​（受限于类型擦除）。|

---

