---
aliases:
  - 临键锁
  - 间隙锁
---
本篇主要内容：
1. InnoDB 如何通过**临键锁**​ 来防止幻读
2. 在特定条件下为了**提高并发性**而做出的锁优化。
	InnoDB 的锁机制在**绝对保证数据一致性（无幻读）​**​ 的前提下，会智能地在各种特定场景下进行**优化，尽可能缩小锁定范围，以提高并发性能**。

### 一、 基础：间隙锁、临键锁与幻读防护
- 什么是[[幻读]]
- 什么是[[临键锁]]和[[间隙锁]]
- ​[[防止幻读的加锁机制]]：通过锁定一个范围（记录+间隙），它阻止了其他事务在这个范围内**插入新的记录**，从而彻底解决了“幻读”问题。
    

### 二、 三种锁的优化场景（退化机制）
**锁退化**​ 是指 InnoDB 在保证数据一致性的前提下，​**智能地将较大范围的锁转换为更小范围的锁**，以提高并发性能。

核心思想：​**在能保证不出现幻读的情况下，尽量缩小锁的范围。​**

| 场景                     | 锁定机制                     | 核心目的             |
| ---------------------- | ------------------------ | ---------------- |
| ​**默认情况**​             | ​**临键锁**​                | ​**根本性防止幻读**​    |
| ​**唯一索引等值查询（记录不存在）​**​ | ​**退化为间隙锁**​             | 提高并发（不锁记录），但仍防插入 |
| ​**普通索引等值查询**​         | ​**部分退化为间隙锁**​           | 精准锁定范围，平衡并发与一致性  |
| ​**唯一索引范围查询**​         | ​**临键锁（扫到第一个不满足条件的值）​**​ | 确保范围查询的绝对一致性     |
#### 场景1：唯一索引等值查询，记录不存在 → 退化为间隙锁

​**查询示例**​：

```
SELECT * FROM users WHERE id = 7 FOR UPDATE;
```

假设表中存在 `id = 5, 10, 15`

​**退化过程**​：

1. ​**默认情况（无退化）​**​：加临键锁 `(5, 10]`（锁住间隙+记录）
    
2. ​**优化后（退化）​**​：只加间隙锁 `(5, 10)`
    
3. ​**退化原因**​：
    
    - 记录不存在，不需要锁定具体的行
        
    - 间隙锁足以防止在 `(5, 10)`之间插入 `id=7`，从而防止幻读
        
    - 释放了对 `id=10`的行锁，提高并发
- **效果对比**​：
	- ​**无退化**​：其他事务不能修改 `id=10`，不能插入 `id=7`
	- ​**退化后**​：其他事务可以修改 `id=10`，但不能插入 `id=7`✅ 并发性更好
#### 场景二：唯一索引下的等值查询，记录存在

> ​**针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。​**​

这是非常重要的**性能优化点**。在某些特定条件下，严苛的临键锁会“降级”为更宽松的行锁。

- ​**触发条件**​（必须同时满足）：
    
    1. 使用了**唯一索引**​（如主键、唯一约束索引）。
        
    2. 查询是**等值匹配**​（例如 `id = 5`，而非范围查询 `id > 5`）。
        
    3. 匹配的记录**必须存在**。
        
    
- ​**优化效果**​：InnoDB 可以确定只锁定这一条明确的记录，无需锁定一个范围，从而**减少了锁的冲突**，提升了并发性能。

#### 场景三：等值查询（普通索引），向右遍历至不满足条件时

- ​**查询语句**​：`SELECT * FROM users WHERE age = 20 FOR UPDATE;`
    
- ​**优化后（实际行为）​**​：两个锁，第二个临键锁退化成间隙锁
	- 向右遍历到第一个不满足条件的值（`age=30`）时，退化为间隙锁，只锁定间隙 `(20, 30)`。
    
- ​**默认情况（无优化）​**​：如果严格使用临键锁，InnoDB 会加两个临键锁：
    
    1. 对所有满足 `age=20`的记录加临键锁（例如锁定 `(10, 20]`、`(20, 20]`等）。
        
    2. 继续向右遍历，直到第一个不满足条件的值（`age=30`）。此时，不会退化，直接对 `age=30`加临键锁，即锁定区间 `(20, 30]`。
        
        - ​**锁范围**​：包括所有 `age=20`的记录及其周围的间隙，以及 `age=30`和之前的间隙 `(20, 30]`。
            
        - ​**影响**​：
            
        - 其他事务无法在 `age=20`相关的区间内插入新记录，也无法在 `20`和 `30`之间插入（如 `age=25`）。
            
        - 其他事务无法修改或删除 `age=30`的记录（因为行锁被锁定）。
            
        - 相比优化后的锁，默认情况的锁范围更大，尤其锁定了 `age=30`的行，这可能会不必要的阻塞其他事务。
​
        
    
​
### 三、 关键特性：间隙锁的共存性


> ​**间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。​**​

- ​**唯一目的**​：间隙锁**不直接锁定任何现有数据**，它只“守护”一个空的范围，唯一目的就是**防止插入**​（`INSERT`），从而解决幻读。
    
- ​**可共存**​：​**多个事务可以同时对同一个间隙加间隙锁**。它们不会相互阻塞，因为它们的目标一致——都只是不允许插入新数据。
    
- ​**冲突点**​：间隙锁与**插入操作**冲突。当一个事务持有某个间隙的锁时，另一个事务尝试在该间隙内插入数据会被阻塞。
    

### 四、防止幻读的加锁机制