---
aliases:
  - 跳表
---
- 需求背景：
	- 传统指针从头或者尾进行逐个遍历，有时候我们要求从中间进行随机查询，这时候性能就较低
- 解决方法：SkipList
	- 设计思想：**空间换时间**和**随机化**的策略
	- 特点：
		- 元素按照顺序排列存储
		- 节点包含多个指针，不止头尾指针，而且指针跨度不一样
			- 减少了查找的时候遍历效率![[Pasted image 20251126210602.png]]
- 好处：
	- 接近平衡二叉查找树的查询效率，但是实现上更为简单
	- 能高效地支持范围查询
- 问题：
	- 存储多级指针，有额外的空间开销
	- 节点在内存中的分布不连续，这种非连续存储会导致**缓存命中率较低**
	- 跳表性能依赖于随机化算法（如抛硬币）决定新节点层级，存在性能的随机性
-  Redis 跳表与 MySQL B+Tree 快速查询的相通之处及 Redis 选型原因
	- 相同之处
		- 核心思想一样：空间换时间，通过构建稀疏的上层索引，避免对全量数据的遍历，从而将查询时间复杂度从线性 O (n) 优化到对数级 O (log n)
		- 基础前提一样：数据有序性：两者均以「数据有序性」作为快速查询的基础，有序性是实现高效定位的前提。
		- 查询逻辑一样：快速缩小范围 + 最终精准匹配：均遵循「从上到下、从粗到细」的思路，先通过上层索引快速缩小查询范围，再到下层进行精准匹配。
	- 区别：为什么Redis要用跳表： **B+Tree 的优势在该场景下完全无法发挥，劣势却被无限放大**
		- B+Tree的劣势被放大：
			- 与单线程模型不适配适配：
				- 跳表：插入 / 删除仅需修改 “当前节点及其相邻层级的少量指针”，**无连锁反应**，因此耗时**固定**且短，不会阻塞单线程
				- B+Tree：为维持平衡，插入 / 删除时的 “节点分裂 / 合并” 是**连锁式批量操作**
					- 例如：插入数据导致叶子节点满 → 分裂叶子节点 → 父节点满 → 分裂父节点 → 直至根节点分裂，整个树的层级可能改变
					- 问题：耗时不确定且可能较长，若某条 Sorted Set 操作触发 B+Tree 连锁分裂，会 **阻塞整个 Redis 服务**
			- 不适配适配 Sorted Set 的灵活操作需求：如 “排名计算”“分数更新” 
			    - `zrank`（获取排名）：
				    - 跳表的节点可通过**层级指针**快速统计 “当前节点之前的节点数”（或在插入时维护排名信息），无需遍历全量数据；
				    - 而 B+Tree 需额外维护 “子树节点计数”（每个非叶子节点存储子树大小），更新时需同步修改所有祖先节点的计数，复杂度极高。
			    - `zincrby`（分数增量更新）：分数更新本质是 “删除旧节点 + 插入新节点”
				    - 跳表的删除 / 插入是 O (log n) 且无连锁开销；
				    - 而 B+Tree 若分数更新导致节点排序变化，**可能触发多次分裂 / 合并**，性能极差。
		-  B+Tree 的 “磁盘 IO 优化” 优势在内存场景中完全失效
			- B+Tree的核心优势是其节点紧凑、层级少，从而减少**减少磁盘寻道次数**
			- 但 Redis 是 **纯内存数据库**（内存随机访问速度是纳秒级），反而其复杂的平衡机制会带来额外的内存开销和操作延迟。
		    
---

- 数据结构：![[Pasted image 20251126211250.png]]
	- zskiplist![[Pasted image 20251126210705.png]]
		- 索引层级
			- 大小和链表长度相关
			- 查询方式由最高层的链表往下查（越高层指针跨度越大）
	- zskiplistNode![[Pasted image 20251126210928.png]]
		- level数组的大小在节点创建时通过随机算法指定（最大为32）



---
插入元素
1. 确定插入位置
	- 查找的顺序：从最高层头节点开始，向右/向下查找
	- 产出结果：
		- 记录了每层中最后一个小于新元素值的节点（前驱节点）
		- 确定了自己的插入位置
2. 随机生成层数
	- 决定的方式：通过随机算法（如抛硬币）决定新节点需要出现在哪些层（即节点高度）
	- 设计思想：新节点是否成为索引、成为多高级别的索引，完全由“运气”决定
	- 作用：使得索引**分布相对均匀**，不会因为输入数据的**顺序性**导致性能退化
3. 调整层高与
	- 触发时机：新节点层数超过当前跳表层数
	- 触发反应：
		1. 创建新的空索引层
		2. 更新头节点
4. 逐层插入节点
	- 开始位置：新节点实际所在层
	- 插入方式：自上而下依次更新各层的前驱节点和后继节点的指针