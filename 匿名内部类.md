---
aliases:
  - Anonymous Inner Classes
---


想象这个困境：你在写按钮点击事件，监听器只需使用一次。如果定义完整类，代码冗长；用局部内部类又需命名。匿名内部类只需`new ActionListener(){...}`就能搞定！这就是它的价值——极致简洁。

---


带着这些问题深入探索吧：

1. 匿名内部类为什么不需要类名？编译器如何标识它？
    
2. `new ActionListener(){...}`中，`ActionListener`是接口还是类？这行代码究竟在做什么？
    
3. 为什么匿名内部类不能有构造函数？如何实现初始化逻辑？
    
4. 什么时候该用Lambda替代匿名内部类？什么时候必须用匿名类？
    
5. `new Object(){}.getClass().getEnclosingClass()`这种技巧解决了什么问题？
    

---


​**一、本质特征**​

1. ​**定义形式**​：
    ![[Pasted image 20251021203933.png]]
    ```
    new SuperType(构造参数) { 
        // 方法实现或重写
    }
    ```
    
    - `SuperType`：接口（隐式实现）或类（隐式继承）
        
    - ​**无类名**​：编译后命名为`外部类$数字.class`（如`TalkingClock$1.class`）
        
    
2. ​**特殊语法规则**​
	- 若SuperType是**接口**，则创建了一个Object，这个Object的类是一个**实现**了SuperType接口的类，因此没有用于构造器的构造参数
	- 若SuperType**类**，则创建了一个Object，这个Object的类是一个**继承**了SuperType的类
		- 由于匿名类没有名字，因此没有自己的构造器，传递的构造参数**用于SuperType的构造器**。
		- 但是他仍然可以用初始化块完成自己的初始化
			![[Pasted image 20251021204848.png]]

| 场景   | 语法                          | 示例                          |
| ---- | --------------------------- | --------------------------- |
| 实现接口 | `new Interface() { ... }`   | `new ActionListener(){...}` |
| 继承类  | `new SuperClass(args){...}` | `new Thread("worker"){...}` |
|初始化|对象初始化块`{ ... }`|`new ArrayList<>(){{ add("a"); }}`|


​**二、与Lambda的辩证关系**​

|特性|匿名内部类|Lambda表达式|
|---|---|---|
|适用场景|任意接口/类|仅函数式接口（单抽象方法）|
|代码量|较多（需完整重写方法）|极少（`(params) -> expression`）|
|可读性|复杂逻辑更清晰|简单逻辑更简洁|
|典型应用|多方法接口（如WindowAdapter）|单方法接口（如Runnable）|

​**三、关键技巧**​

1. ​**双括号初始化**​（Double Brace Initialization）
    
    ```
    // 创建并初始化集合
    invite(new ArrayList<String>(){{ 
        add("Harry"); 
        add("Tony");
    }});
    ```
    
    - 外层`{}`：匿名子类
        
    - 内层`{}`：对象初始化块
        
    
2. ​**静态方法获取类名**​
    
    ```
    // 在静态方法中获取所在类名
    new Object(){}.getClass().getEnclosingClass();
    ```
    
四、风险和解决措施
- **内存泄漏风险**：匿名内部类对象会**隐式持有外部类对象的引用**。如果这个内部类实例的生命周期长于外部类实例（例如被放入一个静态集合或正在执行的异步任务），会导致外部类实例无法被垃圾回收，从而造成内存泄漏。
	- 解决措施：使用静态内部类 + 弱引用持有外部类引用
		- 静态内部类：不持有外部类的隐式引用
		- `WeakReference`包裹外部类：使得垃圾回收器在决定是否回收外部类实例时，可以忽略这个弱引用
		- 示例代码：
			```
			public class MainActivity extends AppCompatActivity {
				private MyButton myButton;
			
				@Override
				protected void onCreate(Bundle savedInstanceState) {
					super.onCreate(savedInstanceState);
					myButton = findViewById(R.id.my_button);
					// 传递外部类引用时使用弱引用
					myButton.setOnClickListener(new MyClickListener(this));
				}
			
				// 1. 使用静态内部类，避免持有外部类引用
				private static class MyClickListener implements View.OnClickListener {
					// 2. 使用弱引用来持有外部类实例
					private final WeakReference<MainActivity> activityWeakReference;
			
					MyClickListener(MainActivity activity) {
						this.activityWeakReference = new WeakReference<>(activity);
					}
			
					@Override
					public void onClick(View v) {
						// 3. 使用前先获取活动实例，并检查是否有效
						MainActivity activity = activityWeakReference.get();
						if (activity != null && !activity.isFinishing()) { // 检查Activity未被销毁
							// 安全地使用activity，例如更新UI
							activity.updateUI();
						}
					}
				}
			
				private void updateUI() {
					// 更新界面
				}
			}
			```
- **性能考量**：每次执行到定义匿名内部类的地方，都会生成一个新的类对象（虽然类本身只加载一次）。在敏感的场景下，可能会考虑其他方式。

---

### 第三部分：面试官关心的问题与答案

​**问题1：匿名内部类编译后如何命名？​**​

​**答案**​：

编译器按出现顺序生成数字编号：

```
class TalkingClock {
    void start() {
        var listener = new ActionListener() { // 编译为TalkingClock$1.class
            public void actionPerformed(...) {...}
        };
        var runner = new Runnable() { // 编译为TalkingClock$2.class
            public void run() {...}
        };
    }
}
```

​**问题2：为什么匿名内部类不能有构造函数？如何初始化？​**​

​**答案**​：

​**无名限制**​：构造函数名必须与类名相同，但匿名类无类名。

​**替代方案**​：

1. ​**继承类时**​：通过父类构造参数初始化
    
    ```
    new Thread("worker") { // 调用Thread(String)构造器
        public void run() {...}
    }
    ```
    
2. ​**通用方案**​：对象初始化块
    
    ```
    new Object() {
        { // 初始化块
            System.out.println("init");
        }
    }
    ```
    

​**问题3：何时必须使用匿名内部类而非Lambda？​**​

​**答案**​：

以下三种场景必须使用匿名内部类：

1. ​**需继承具体类**​（非接口）
    
    ```
    button.addMouseListener(new MouseAdapter() { // 适配器类
        public void mouseClicked(MouseEvent e) {...}
    });
    ```
    
2. ​**需实现多方法接口**​
    
    ```
    new WindowAdapter() {
        public void windowOpened(WindowEvent e) {...}
        public void windowClosing(WindowEvent e) {...}
    }
    ```
    
3. ​**需访问非final外部变量**​（旧版Java兼容）
    

​**问题4：双括号初始化有什么优缺点？​**​

​**答案**​：

​**优点**​：单表达式完成创建+初始化

​**缺点**​：

1. 创建**匿名子类**​（非原类型），影响类型判断
    
    ```
    new ArrayList<>(){{...}} // 实际是ArrayList的子类
    ```
    
2. 可能破坏`equals`方法（`getClass()`比较失败）
    
3. 内存开销（额外类加载）
    
    ​**替代方案**​：
    

```
// Java 9+ 工厂方法
List.of("Harry", "Tony");

// Java 8+ Stream
invite(Stream.of("Harry", "Tony").collect(toList()));
```

​**问题5：`new Object(){}.getClass().getEnclosingClass()`原理是什么？​**​

​**答案**​：

这是**获取静态方法所在类**的技巧：

1. `new Object(){}`：创建Object的匿名子类实例
    
2. `getClass()`：获取该匿名类Class对象
    
3. `getEnclosingClass()`：返回**定义该匿名类的外部类**​
    

```
class Util {
    static void printClass() {
        Class<?> clazz = new Object(){}.getClass().getEnclosingClass();
        System.out.println(clazz.getName()); // 输出"Util"
    }
}
```

​**价值**​：在静态方法中替代`this.getClass()`（因static方法无`this`）