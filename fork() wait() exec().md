好的，这三个系统调用 (`fork()`, `wait()`, `exec()`) 是 Unix/Linux 操作系统进程管理的核心基石，它们共同协作，使得创建、控制和执行新程序变得非常灵活和强大。下面详细介绍每个 API 的功能、工作原理以及它们如何协同工作：

### 1. `fork()`：创建新进程

[[fork()]]
### 2. `exec()`家族：执行新程序

[[exec()]]

### 3. `wait()`/ `waitpid()`：等待子进程状态改变
[[wait()]]

### 三者的经典协作模式：Shell 运行命令的简化模型

1. ​**Shell (父进程) 调用 `fork()`：​**​ 创建一个子进程（Shell 的副本）。
    
2. ​**子进程：​**​
    
    - （可选）在调用 `exec()`​**之前**进行环境设置（如重定向输入/输出、修改环境变量、改变工作目录等）。
        
    - 调用 `exec()`加载并执行用户指定的命令（如 `ls`, `grep`, 用户程序等）。子进程的代码被新程序替换。
        
    - 新程序执行完毕，子进程退出。
        
    
3. ​**Shell (父进程)：​**​
    
    - 调用 `wait()`（或 `waitpid()`）​**阻塞**等待子进程结束。
        
    - 获取子进程的退出状态。
        
    - 回收子进程资源（避免僵尸）。
        
    - 显示新的提示符，等待下一条命令。
        
    

### 总结

- ​**`fork()`：​**​ 克隆自己。用于创建新进程。父进程和子进程在 `fork()`后并发执行。
    
- ​**`exec()`：​**​ 变身。用于加载并执行一个全新的程序，替换当前进程的映像。不创建新进程。
    
- ​**`wait()`/`waitpid()`：​**​

这三个 API 的分离设计（特别是 `fork`和 `exec`分开）是 Unix 哲学“组合小工具完成复杂任务”的完美体现，赋予了 Shell 和程序员极大的灵活性，能够轻松实现进程控制、环境定制（重定向、管道等）、作业管理等多种强大功能。理解它们是深入理解 Unix/Linux 进程管理和 Shell 工作原理的关键。