
Memory leak: 
- 表现：
	- 观察对象：程序中己动态分配的堆内存
	- 原因：某种原因，经典场景包括
		- 静态集合类：如果不停地向其中添加对象而不移除，就会造成泄漏
			- 生命周期和程序一致
		- 未关闭的资源：如数据库连接、网络连接或文件流
			- 如果使用后没有显式关闭，它们可能不会被及时回收
		- 监听器与回调：在对象上注册了监听器或回调
			- 在对象不再需要时没有取消注册，导致该对象无法被回收
		- 不合理的对象作用域：在方法内将对象误设为静态变量
			- 静态对象生命周期和程序一致
	- 行为：程序未释放或无法释放这些堆内存
		- 即对象无法被GC回收
- 影响：
	- 造成系统内存的浪费
		- 内存泄露的堆积终将导致内存溢出。
	- 导致程序运行速度减慢甚至系统崩溃等严重后果。
- 解决措施：
	- 长生命周期对象持有短生命周期对象的引用：例如，一个全局的静态集合（如 `Map`、`List`）不断添加对象却从未清理。
	    - 修复方案：
		    - 使用弱引用（`WeakReference`）或软引用（`SoftReference`）来替代强引用，
		    - 或者在使用完毕后主动从集合中移除对象
	- 未关闭的资源：数据库连接、网络连接、文件流等未正确关闭。
	    - 修复方案：使用 `try-with-resources`语法（Java 7+）确保资源一定被关闭。
	- 监听器或回调未注销：向全局事件总线注册了监听器，但在对象销毁时没有反注册。
	    - 修复方案：在对象的生命周期结束时（如 `destroy()`方法中）确保注销监听器。
	- 内部类持有外部类引用：非静态内部类会隐式持有外部类的引用，如果内部类对象（如线程）的生命周期长于外部类对象，就会导致外部类无法被回收。
	    - 修复方案：如果内部类不需要访问外部类实例，将其改为 `static`静态内部类。