##### 各隔离级别详解

图中的表格对比了四种隔离级别对三种典型问题的控制能力（`√`表示会出现，`×`表示不会出现）。

| 隔离级别                          | 脏读  | 不可重复读 | 幻读  | 解释                                                                               |
| ----------------------------- | --- | ----- | --- | -------------------------------------------------------------------------------- |
| ​**Read Uncommitted（读未提交）​**​ | √   | √     | √   | ​**级别最低**。一个事务可以读取到另一个事务**未提交**的修改。存在所有并发问题，性能最好但数据一致性最差，很少使用。                   |
| ​**Read Committed（读已提交）​**​   | ×   | √     | √   | 一个事务只能读取到其他事务**已经提交**的修改。解决了**脏读**，但可能发生不可重复读和幻读。这是**Oracle等数据库的默认级别**。          |
| ​**Repeatable Read（可重复读）​**​  | ×   | ×     | √   | 确保在同一个事务中，多次读取同一数据的结果是一致的。解决了脏读和不可重复读，但可能发生**幻读**（使用当前读可以防止）。这是**MySQL的默认隔离级别**。 |
| ​**Serializable（可序列化）​**​     | ×   | ×     | ×   | ​**级别最高**。所有事务串行执行，完全隔离。解决了所有并发问题，但性能开销最大，因为并发性急剧下降。                             |

**在可重复读中，为什么会出现幻读现象**：
在 SQL 标准中，可重复读隔离级别本身并不要求解决幻读问题。幻读是更严格的串行化级别才解决的问题。
但 MySQL 的 InnoDB 引擎通过 MVCC 和 Next-Key Lock 增强了可重复读，使其能够避免大部分幻读。

普通 `SELECT`不会出现幻读，但在以下情况下需要注意：

1. ​**当前读的情况**​：如果你使用 `SELECT ... FOR UPDATE`或 `SELECT ... LOCK IN SHARE MODE`（当前读），情况会不同。当前读会读取最新提交的数据，可能会看到新插入的行。
    
2. ​**混合操作的影响**​：如果事务A先执行普通 `SELECT`，然后执行了 `UPDATE`或 `DELETE`操作，这些写操作会看到最新的数据。在某些数据库实现中，这可能会影响后续的读操作（但MySQL的可重复读级别通常能保持一致性）。
---

##### SQL 操作示例：查看和设置事务隔离级别的SQL语句


1. ​**查看当前事务隔离级别：​**​
    
    ```
    SELECT @@TRANSACTION_ISOLATION;
    ```
    
2. ​**设置事务隔离级别：​**​
    
    ```
    SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL
        [READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE];
    ```
    
    - `SESSION`： 只对当前会话（连接）后续的所有事务有效。
        
    - `GLOBAL`： 对设置之后所有新建立的会话有效（不影响当前已存在的会话）。
