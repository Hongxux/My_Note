### 索引概述

#### 1. 索引的定义

图片中的文字给出了最精炼的定义：

> ​**索引是帮助 MySQL 高效获取数据的有序数据结构。​**​

我们可以从两个关键点来理解：

- ​**本质是数据结构**​：索引不是数据本身，而是一种像“目录”一样独立存在的、专门为快速查找而设计的数据结构（例如图中提到的二叉树、B+Tree等）。
    
- ​**特点是有序**​：正是因为数据在其中是有序存放的，所以才能实现高效的区间查找和快速定位。
    
#### 2.索引的意义
这张图的核心是演示一条查询语句 `SELECT * FROM user WHERE age = 45`在执行时，有无索引的区别。
![[Pasted image 20251029190851.png]]
##### 1. 无索引的情况（低效，全表扫描）

- ​**场景**​：数据库想要找到所有年龄为45岁的用户。
    
- ​**过程**​：由于 `age`字段上没有建立索引，数据库不知道哪些记录的 `age=45`，它**没有快速通道可走**。
    
- ​**操作**​：数据库必须进行 ​**全表扫描**——即从第一条记录开始，一行一行地检查每一行的 `age`字段值，直到扫描完整个表。如图所示，它需要遍历 `id`从 2 到 32 的所有记录。
    
- ​**结果**​：图中用**红色禁止标识**醒目地提示了这种方式的低效性。当表中有数百万甚至上亿条数据时，这种查询速度会慢到无法接受。
    

##### 2. 有索引的情况（高效，索引查找）

- ​**场景**​：同样的查询，但在 `age`字段上建立了索引。
    - **树形结构**​：代表了索引本身（如B+Tree）。它通过对年龄值进行分层排序，实现了快速查找。
    
	- ​**数字（如 17, 33, 48...）​**​：是 `age`字段的值，在索引中是有序存储的。
	    
	- ​**十六进制值（如 0x07, 0x05）​**​：这些是**指针**，指向表中实际数据行所在的**物理位置**。
- ​**过程**​：数据库现在可以使用一个为 `age`字段专门建立的、**有序的数据结构**​（图中展示的是一个简化的B+树索引结构）。这个结构像一本书的目录一样。
    
- ​**操作**​：
    
    1. 数据库直接去查询这个“年龄目录”。
        
    2. 索引结构是有序的，因此可以**快速定位**到值为 `45`的位置。
        
    3. 索引中存储了对应数据行的位置（如物理地址 `0x07`）。
        
    4. 数据库根据这个地址，​**直接去磁盘上精确读取**对应的数据行，无需遍历任何不相关的数据。
        
    
- ​**结果**​：图中用**绿色“高效”圆圈**标注，表示查询速度极快。无论表有多大，通过索引都能在几乎恒定的时间内找到目标数据。
    
##### 总结
简单来说，​**索引用额外的存储空间和少量的维护开销，换来了查询性能的质的飞跃**，是数据库优化中最重要、最有效的手段之一。
- ​**核心价值**​：​**避免全表扫描**，将数据查找的时间复杂度从 O(n) 降为 O(log n)，从而极大提升查询性能。
    
- ​**工作方式**​：通过维护一个额外的、有序的“目录”（索引结构），该目录存储了字段值和数据行物理地址的映射关系，实现快速定位。
#### 3.索引的优缺点

##### 优势（优点）

1. ​**提高检索效率，降低 I/O 成本**​
    
    - ​**解释**​：索引就像一本书的目录，可以让你快速找到所需内容，而无需一页一页地翻看（即“全表扫描”）。对于数据库来说，这意味着可以大大减少磁盘 I/O 操作的次数，从而显著提升数据查询速度。
        
    
2. ​**降低排序成本，减少 CPU 消耗**​
    
    - ​**解释**​：如果数据检索的结果需要排序（如 `ORDER BY`语句），而索引本身就是一个有序的数据结构。如果排序的字段上恰好有索引，数据库可以直接按索引的顺序返回数据，避免了在内存中再次进行排序操作，从而降低了 CPU 的消耗。
        
    

##### 劣势（缺点）

1. ​**占用磁盘空间**​
    
    - ​**解释**​：索引需要单独的数据结构来存储，因此会占用额外的磁盘空间。表的数据量越大，建立的索引越多，消耗的存储空间也就越多。
        
    
2. ​**降低更新表的速度**​
    
    - ​**解释**​：索引在提升查询速度的同时，会降低数据写入（`INSERT`）、修改（`UPDATE`）和删除（`DELETE`）的速度。因为当表中的数据发生变化时，数据库不仅需要更新数据本身，还需要对相关的索引进行维护和更新，这带来了额外的开销。
        
    

##### 核心结论与使用建议

- ​**核心思想**​：索引是一种权衡，用**额外的存储空间**和**数据维护的开销**，来换取**数据检索的高性能**。
    
- ​**实践建议**​：
    
    - ​**对查询频繁、但修改较少的列建立索引**​（如作为查询条件的字段、经常需要排序或分组的字段）。
        
    - ​**避免对经常进行增、删、改操作的表建立过多索引**。
        
    - ​**避免为数据重复率很高的列（如“性别”）建立索引**，其效果甚微。
        
    

简而言之，​**索引不是越多越好，而是要根据实际的查询需求来精准创建**。



### 索引结构
|索引类型|InnoDB|MyISAM|Memory|
|---|---|---|---|
|​**B+Tree索引**​|支持|支持|支持|
|​**Hash索引**​|不支持|不支持|支持|
|​**R-tree索引**​|不支持|支持|不支持|
|​**Full-text索引**​|5.6版本之后支持|支持|不支持|

​**简要说明：​**​

- ​**B+Tree索引**​：是最常见的索引类型，所有显示引擎都支持。适用于范围查找和排序。
    
- ​**Hash索引**​：只有Memory引擎支持。查询效率极高，但只适用于精确匹配（=， IN），不支持范围查询。
    
- ​**R-tree索引**​：主要用于空间数据类型（如地理坐标），通常只有MyISAM引擎支持。
    
- ​**Full-text索引**​：即全文索引，用于全文搜索。MyISAM很早就支持，InnoDB在5.6版本后才开始支持。
    

​**结论：​**​

在选择存储引擎时，如果需要特定的索引类型（如哈希索引或空间索引），这是一个重要的考量因素。对于绝大多数常规应用，使用默认的InnoDB引擎及其B+Tree索引即可满足需求。
#### [[B+Tree]]索引

#### [[hash算法（散列算法）]]
### 索引分类
#### 四类索引

|分类|含义|特点|关键字|
|---|---|---|---|
|​**主键索引**​|针对表中的主键字段创建的索引。|- ​**默认自动创建**​  <br>- 一个表**只能有一个**​  <br>- 确保主键的**唯一性**和**非空**​|`PRIMARY`|
|​**唯一索引**​|避免同一个表中某个列的值出现重复。|- 一个表**可以有多个**​  <br>- 确保列值的**唯一性**​（允许为空）|`UNIQUE`|
|​**常规索引**​|用于快速定位特定数据，是最基本的索引类型。|- 一个表**可以有多个**​  <br>- 无唯一性约束|(无特定关键字)|
|​**全文索引**​|查找的是文本中的关键词，而不是直接比较索引值。|- 一个表**可以有多个**​  <br>- 主要用于大文本字段的模糊搜索|`FULLTEXT`|

1. ​**主键索引 (PRIMARY KEY)​**​
    
    - 这是最重要的索引，通常在创建表时通过 `PRIMARY KEY`指定。它不仅是索引，还强制了数据的唯一标识约束。
        
    
2. ​**唯一索引 (UNIQUE)​**​
    
    - 与主键索引类似，保证数据的唯一性，但一个表可以创建多个唯一索引（例如，为手机号、邮箱字段创建），且允许字段值为 NULL。
        
    
3. ​**常规索引 (KEY/INDEX)​**​
    
    - 这是最常用的索引类型，唯一目的就是提高查询速度。它没有任何唯一性的约束。使用 `KEY`或 `INDEX`关键字创建。
        
    
4. ​**全文索引 (FULLTEXT)​**​
    
    - 专门用于解决文本内容的模糊查询（`LIKE '%关键词%'`）效率低下的问题。它通过分析文本中的关键词来进行搜索，适用于 `CHAR`、`VARCHAR`、`TEXT`等类型的列。
      
#### InnoDB的索引分类
![[Pasted image 20251029194747.png]]
   InnoDB 中的索引根据存储形式分为以下两种：

|索引类型|含义|特点|
|---|---|---|
|​**聚集索引**​|将数据行和索引存储在同一个结构中。|​**必须有，而且只有一个**。索引结构的**叶子节点直接保存了完整的行数据**。|
|​**二级索引**​|将数据与索引分开存储。|​**一个表可以存在多个**。索引结构的**叶子节点关联的是对应数据行的主键值**。|
**聚集索引的性能比二级索引性能高，因为二级索引索引到主键值之后还要利用聚集索引获得行数据**
###### 1. 聚集索引

- ​**核心特点**​：​**数据即索引，索引即数据**。表中的数据行实际就存储在聚集索引的叶子节点上。因此，表数据的物理存储顺序与聚集索引的顺序是一致的。
    
- ​**为什么必须有且只有一个？​**​ 因为一份数据只能以一种物理顺序存储。
    

###### 2. 二级索引

- ​**核心特点**​：​**独立于数据存储的目录**。二级索引的叶子节点不存储行数据，只存储该索引列的值和对应的**主键值**。
    
- ​**查询过程**​：当通过二级索引查询时，需要先根据二级索引找到对应的主键值，然后再拿着这个主键值去**聚集索引**中查找完整的行数据。这个过程称为 ​**回表查询**。
    
##### 聚集索引的选取规则

InnoDB 会按照以下**优先级**为每张表选择一个聚集索引：

1. ​**主键优先**​：如果表定义了主键（PRIMARY KEY），则主键索引自动成为聚集索引。
    
2. ​**唯一索引备选**​：如果表没有主键，但存在一个唯一索引（UNIQUE），则第一个被定义的非空唯一索引（NOT NULL UNIQUE）会被选中作为聚集索引。
    
3. ​**自动生成**​：如果表既没有主键，也没有合适的唯一索引，InnoDB 会自动在内部生成一个名为 `rowid`的隐藏列作为主键，并以此构建聚集索引。
### [[索引基础语法]]


### [[SQL性能分析工具]]
### [[索引使用]]
### [[索引设计原则]]