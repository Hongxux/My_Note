### 错误日志

#### 一、 错误日志是什么？


> ​**错误日志是MySQL中最重要的日志之一，它记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。​**​

- ​**定位**​：它是 MySQL 的**诊断日志**，
    
- ​**内容**​：主要记录三类事件：
    
    1. ​**启动/停止信息**​：数据库实例的启动、关闭过程，包括配置加载、初始化步骤。如果启动失败，原因必在此日志中。
        
    2. ​**严重错误**​：运行时发生的致命性问题（如存储引擎崩溃、无法访问关键文件、内存耗尽等）。
        
    3. ​**关键警告**​：一些可能影响系统稳定性的重要警告信息。
        
    

#### 二、 为什么错误日志至关重要？

图中一句关键提示点明了其价值：

> ​**当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。​**​

- ​**首要排查依据**​：当数据库服务无法启动、连接失败、运行中突然崩溃或出现严重性能问题时，错误日志是**最直接、最快速的线索来源**。它通常会给出明确的错误代码和描述。
    
- ​**问题诊断**​：通过分析错误日志中的时间戳和错误信息，可以精确定位故障发生的**时间**和**根本原因**。
    

#### 三、 如何管理错误日志？

图中所列的是最基础的管理操作：

1. ​**默认设置**（linux）​
    
    - ​**状态**​：​**默认开启**。MySQL 安装后会自动启用错误日志。
        
    - ​**存放路径**​：默认在 `/var/log/`目录下。
        
    - ​**文件名**​：默认名为 `mysqld.log`。
        
    
2. ​**查看日志路径​**​
    
    由于安装方式或配置调整，错误日志的实际路径可能与默认值不同。图中给出了标准查询方法：
    
    ```
    SHOW VARIABLES LIKE '%log_error%';
    ```
    
    - ​**执行结果解读**​：这条命令会返回一个全局变量 `log_error`的值，该值就是当前 MySQL 实例使用的错误日志文件的**完整路径**。这是查找日志的**最可靠方法**。
        
    

#### 实战应用与扩展

掌握了图中的基础概念后，以下是更深入的实践指南：

#### 1. 如何查看错误日志内容？

- ​**命令行查看**​：使用 `tail`, `cat`, `grep`等 Linux 命令。
    
    ```
    # 实时查看最新日志（最常用）
    tail -f /var/log/mysqld.log
    
    # 查找包含 "ERROR" 关键词的日志行
    grep -i "error" /var/log/mysqld.log
    
    # 查看最近100行日志
    tail -n 100 /var/log/mysqld.log
    ```
    

#### 2. 如何配置错误日志？

日志配置通常在 MySQL 的配置文件 `my.cnf`或 `my.ini`中修改。

- ​**主要配置参数**​：
    
    ```
    [mysqld]
    # 指定错误日志文件路径
    log-error = /path/to/your/mysql_error.log
    # 设置日志错误级别 (1: ERROR, 2: WARNING, 3: INFORMATION)
    log-error-verbosity = 2
    ```
    

#### 3. 常见错误日志分析示例

- ​**启动失败**​：日志中可能出现 `[ERROR] Can't start server: Bind on TCP/IP port: Address already in use`，表示端口被占用。
    
- ​**权限问题**​：`[ERROR] Can't read from the '.err' file (Errcode: 13 - Permission denied)`，表示 MySQL 用户对数据目录没有读写权限。
    
- ​**表损坏**​：`[ERROR] Table 'db.table' is marked as crashed and should be repaired`，指示特定表已损坏，需要修复。
    

#### 总结

这张图的核心价值在于强调了错误日志的**基础性、关键性和优先级**。请您牢记：

1. ​**第一反应**​：数据库出问题，​**第一个**就应该去查错误日志。
    
2. ​**定位方法**​：使用 `SHOW VARIABLES LIKE '%log_error%';`找到它的准确位置。
    
3. ​**分析内容**​：重点关注 `[ERROR]`级别的信息，结合时间点进行诊断。
    

掌握错误日志的查看和分析，是每一位数据库开发和管理人员的必备技能。它是您解决 MySQL 疑难杂症的“第一把钥匙”。


### 二进制日志（只记录DML和DDL，不记录select）


二进制日志是 MySQL 服务器级别的一种逻辑日志，它记录了所有对数据库结构和数据内容进行修改的操作（DML和DDL）。​**它不记录查询操作**，是实现数据复制和数据恢复的基石。

#### 一、 核心作用与价值

1. ​**数据恢复**​：
    
    - ​**场景**​：当发生数据误删除（如误执行 `DROP TABLE`或 `DELETE`语句）时，可以基于**全量备份**​ + ​**二进制日志**，将数据恢复到误操作前的某个时间点。
        
    - ​**价值**​：这是实现**时间点恢复**​ 的关键。
        
    
2. ​**主从复制**​：
    
    - ​**场景**​：构建高可用、可扩展的数据库架构。主库上的数据变更通过二进制日志传递给从库，从库重放这些日志，从而保持数据同步。
        
    - ​**价值**​：实现**读写分离、负载均衡、数据备份**。
        
    

​**查看状态**​：使用 `SHOW VARIABLES LIKE '%log_bin%';`可查看二进制日志是否开启及相关参数。

#### 二、 日志记录的三种格式
这是二进制日志最核心的特性之一，不同格式在**数据一致性、日志大小和性能**之间有不同的权衡。

|格式|工作原理|优点|缺点|适用场景|
|---|---|---|---|---|
|​**STATEMENT**​|记录**原始的SQL语句**​|日志文件小，节省空间|可能引发主从数据不一致（如使用 `NOW()`, `RAND()`等非确定性函数）|已逐渐被淘汰|
|​**ROW**​|记录**每一行数据如何被修改**​（如修改前、修改后的值）|​**数据安全可靠**，主从一致性高（默认格式）|日志文件大（尤其是批量更新时）|​**强一致性要求的场景**，如金融业务|
|​**MIXED**​|​**混合模式**。多数情况用 STATEMENT，在不安全的场景下（如使用不确定函数）自动切换为 ROW|在安全性和日志大小间取得平衡|逻辑相对复杂|通用场景|

​**查看格式**​：使用 `SHOW VARIABLES LIKE 'binlog_format';`查看当前格式。
基于`binlog_format = 'row '`行的二进制内容
![[Pasted image 20251104091201.png]]
基于`binlog_format = 'statement '`sql的二进制内容，以一个事务为单元地记录
![[Pasted image 20251104091804.png]]

#### 三、 如何查看日志内容

二进制日志是二进制格式，无法直接阅读，需使用官方工具 `mysqlbinlog`。

​**基本命令**​：`mysqlbinlog [options] logfilename`

​**常用参数**​：

- `-d database_name`：只查看指定数据库的日志。
    
- `-o n`：忽略日志中的前 n 个条目。
    
- `-v`：将 ROW 格式的日志“重构”为可读的 SQL 语句。​**这是最常用的参数**。
    
- `-vv`：在 `-v`基础上，增加更详细的注释信息。
    
- `--start-datetime=/--stop-datetime`：按时间范围筛选。
    
- `--start-position=/--stop-position`：按日志位置点筛选，更精确。
    

​**示例**​：`mysqlbinlog -v -d mydb binlog.000001`会以可读形式显示 `mydb`数据库在 `binlog.000001`文件中记录的所有变更。

#### 四、 日志清理策略

二进制日志会不断增长，占用大量磁盘空间，必须定期清理。

|命令|作用|风险|
|---|---|---|
|`RESET MASTER;`|​**删除所有**二进制日志文件，并**重置索引**，从 `binlog.000001`重新开始。|​**极其危险**​！仅在从库不需要、且无备份恢复需求的测试环境使用。|
|`PURGE MASTER LOGS TO 'binlog.000010';`|删除指定编号**之前**的所有日志（即删除 `binlog.000001`到 `binlog.000009`）。|相对安全，确保要删除的日志已经不再需要。|
|`PURGE MASTER LOGS BEFORE '2023-10-01 12:00:00';`|删除指定时间点**之前**生成的所有日志。|相对安全，需确认时间点。|

​**生产环境建议**​：设置参数 `expire_logs_days`，让 MySQL 自动清理过期的日志文件，这是最安全稳妥的方式。
#### undo-log和二进制日志的关系
![[Pasted image 20251106092515.png]]
##### 一、 核心区别：本质与目标的不同

这是理解两者为何并存的根本。我们可以通过下表进行核心属性的对比：

|特性|​**重做日志**​|​**二进制日志**​|
|---|---|---|
|​**所属层级**​|​**InnoDB 存储引擎层**​|​**MySQL Server 层**​|
|​**日志类型**​|​**物理逻辑日志**​|​**逻辑日志**​|
|​**记录内容**​|记录每个**数据页**的**物理变化**​|记录造成数据改变的**原始SQL语句**或事件|
|​**主要目标**​|​**崩溃恢复**​|​**数据复制**、**数据恢复**​（按时间点）|
|​**生命周期**​|循环写入，空间用完则覆盖|追加写入，按文件大小或时间切换|
|​**持久化时机**​|在事务提交时写入（WAL机制）|在事务提交后写入|
##### 二、二者执行的顺序
![[Pasted image 20251106092742.png]]


###### 第一步：准备阶段 - 写入 Redo Log (Prepare)

这个过程对应于上图中的步骤 1-5。

1. **执行 UPDATE**：客户端发送 `UPDATE users SET name = 'Alice' WHERE id = 1;`并执行 `COMMIT`。
    
2. **修改内存数据**：InnoDB 引擎在内存的 **Buffer Pool**中找到 `id=1`的这行数据所在的数据页，将其修改为 `name='Alice'`。此时数据页变“脏”，但**尚未刷盘**。
    
3. **写入 Redo Log (Prepare)**：InnoDB 立即将本次修改的**物理逻辑**信息（比如“在表空间X的页Y的偏移Z处写入值‘Alice’”）写入到 **Redo Log Buffer**，并最终**刷盘**到物理的 Redo Log 文件（`ib_logfile0`）中。
    
    - **关键点1**：此时 Redo Log 的记录状态被标记为 **`PREPARE`**（准备中）。
        
    - **关键点2**：写入 Redo Log 是**顺序追加**，比随机修改数据页要快得多（WAL机制的优势）。
        
    

**到这一步，即使数据库崩溃，我们也有能力重放这个修改。**

###### 第二步：提交阶段 - 写入 Binlog (Commit)

这个过程对应于上图中的步骤 6-7。

1. **写入 Binlog**：MySQL Server 层生成对应的 **Binlog**。Binlog 记录的是逻辑SQL语句（如 `UPDATE users SET name = 'Alice' WHERE id = 1;`）或行变更逻辑。然后将 Binlog 写入到 Binlog Cache，并最终**刷盘**到物理的 Binlog 文件（`bin.000001`）中。
    

**到这一步，这个事务的变更已经记录在了逻辑日志中，可以被复制到从库。**

###### 第三步：最终提交 - 修改 Redo Log 状态 (Commit)

这个过程对应于上图中的步骤 8-11。

1. **Redo Log 状态更改**：在确保 Binlog 已经成功落盘后，InnoDB 引擎会**再次修改 Redo Log**中对应记录的状态，将其从 `PREPARE`改为 **`COMMIT`**（已提交）。
    
2. **返回成功**：完成以上步骤后，MySQL 才向客户端返回“提交成功”。
    

**此后，脏页由后台线程在适当时机（如 Checkpoint）异步刷回表空间数据文件（.ibd）。**

---

###### 为什么需要这么复杂的两阶段提交？

核心目的是为了解决 **Redo Log 和 Binlog 是两个独立日志**所带来的**数据一致性问题**。如果没有两阶段提交，在崩溃恢复时会出现问题。

**崩溃恢复场景分析：**

假设在提交过程中的某个时间点数据库崩溃了，重启后 MySQL 会检查 Redo Log 和 Binlog：

|崩溃时间点|Redo Log 状态|Binlog 状态|恢复操作|解释|
|---|---|---|---|---|
|**在写入Binlog之前**|`PREPARE`|无记录|**回滚事务**|Binlog中没有记录，说明事务不完整，从库会丢失这个事务。为保证主从一致，主库也回滚。|
|**在写入Binlog之后，但在Redo Log Commit之前**|`PREPARE`|**有完整记录**|**提交事务**|Binlog中已存在记录，从库将会重放这个事务。为保证主从一致，主库必须提交。|
|**在Redo Log Commit之后**|`COMMIT`|有完整记录|**提交事务**|事务已完整提交，直接重做即可。|

**这种检查机制保证了：**

- **只要 Binlog 中有记录，事务最终一定会被提交。**这是数据一致性的关键。
    
- 避免了主库有数据而从库没有，或者主库回滚了而从库却提交了的数据不一致问题。
    

###### 总结

**两阶段提交（2PC）**是 MySQL 协调 Redo Log（存储引擎层）和 Binlog（Server 层）的**一致性协议**。

1. **Prepare 阶段**：让 Redo Log 先落盘，确保物理修改不会丢失。
    
2. **Commit 阶段**：让 Binlog 落盘，确保逻辑修改可被复制。
    
3. **最终状态更新**：在两者都确认落盘后，才标记事务为最终提交。
    

这种机制用**短暂的同步等待**（等两个日志都落盘）的代价，换来了**崩溃后数据的强一致性**，是数据库可靠性的基石。简单来说，它就像一场婚礼的仪式：主婚人（MySQL）问 Redo Log “你愿意吗？”（Prepare），得到肯定答复后问 Binlog “你愿意吗？”（Commit），都得到肯定答复后，才宣布“礼成”（Commit Success）。






### 查询日志
开启查询日志会带来显著的 I/O 开销和性能损耗**，因为每次执行 SQL 都需要写磁盘。因此，​**不建议在生产环境中长期开启**，通常只在需要排查特定问题时临时开启。

如果只是为了分析和优化慢查询，更推荐使用 ​**慢查询日志**，它只记录执行时间超过指定阈值的 SQL，对性能影响更小，目标也更明确。
    
 ![[Pasted image 20251104093003.png]]
 ![[Pasted image 20251104093619.png]]
#### 一、 查询日志是什么？

图中给出了明确定义：

> ​**查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。​**​

- ​**功能**​：查询日志会记录下 MySQL 服务器接收到的**每一个客户端连接和执行的每一条 SQL 语句**​（包括 `SELECT`, `SHOW`, `INSERT`, `UPDATE`, `DELETE`, `DROP`等所有操作）。
    
- ​**与二进制日志的区别**​：这是关键点。二进制日志主要记录**更改数据的语句**​（如 DML 和 DDL），用于复制和恢复。而查询日志记录**所有语句**，包括不修改数据的纯查询（如 `SELECT`），更侧重于**审计和问题排查**。
    
- ​**默认状态**​：​**默认情况下，查询日志是未开启的。​**​ 因为记录所有操作会对性能产生一定影响，并产生大量日志，所以需要手动开启。
    

#### 二、 如何开启查询日志？

图中详细说明了开启查询日志的标准步骤，这是通过修改 MySQL 的配置文件来实现的。

​**1. 找到并编辑配置文件**​

- 文件路径通常是 `/etc/my.cnf`（Linux 系统下）。
    
- 使用文本编辑器（如 `vim`）打开此文件。
    

​**2. 添加配置参数**​

在 `[mysqld]`配置段下，添加或修改以下两行参数：

```
[mysqld]
# 该选项用来开启查询日志。可选值：0 或者 1；0 代表关闭，1 代表开启
general_log=1
# 设置日志的文件名，如果没有指定，默认的文件名为 host_name.log
general_log_file=mysql_query.log
```

- ​**`general_log`**​：这是总开关。设置为 `1`即表示开启查询日志。
    
- ​**`general_log_file`**​：指定日志文件的名称和路径。如果不设置绝对路径，则文件会创建在 MySQL 的数据目录（如 `/var/lib/mysql/`）下。图中示例设置为 `mysql_query.log`。
    

​**3. 重启 MySQL 服务**​

修改配置文件后，必须重启 MySQL 服务才能使配置生效。

```
# 根据系统不同，选择相应的命令重启
systemctl restart mysqld
# 或
service mysql restart
```

#### 三、 验证查询日志状态

在配置前后，你可以通过 SQL 命令查看查询日志的当前状态，以确认配置是否生效。

```
-- 查看查询日志是否开启（ON/OFF）及其日志文件路径
SHOW VARIABLES LIKE 'general_log%';
```

执行结果会显示两个变量：

- `general_log`：值为 `ON`或 `OFF`。
    
- `general_log_file`：日志文件的完整路径。
    

#### 总结与注意事项

1. ​**核心价值**​：查询日志是进行 ​**SQL 审计、慢查询分析、业务逻辑排查和操作追踪**​ 的强力工具。通过它，你可以看到数据库上发生的“每一件事”。
    
2. ​**日志管理**​：查询日志会快速增长，需要定期清理或归档，以避免占满磁盘空间。
    


### [[慢查询日志]]

