---
aliases:
  - AHI
---
- 服务对象：热点数据查询
	- 识别热点数据的方式：某个索引页上的某些索引值被**频繁地、以等值查询的方式**访问
- 设计目的：结合B+Tree和[[哈希索引]]的优点，对热点数据查询进行加速
- 特点： 由 InnoDB 引擎自动管理的，根据运行时的访问模式动态地创建和销毁
- 好处：
	- **显著提升等值查询性能：** 对于那些频繁被访问的“热点行”，查询可以接近O(1)的时间复杂度，效果立竿见影 。
	- **减少锁竞争：** 通过减少遍历B+Tree的路径，可以降低对B+Tree内部节点上闩锁（latch）的竞争，在高并发场景下尤其有益。
- 问题：
	- **内存消耗：** AHI本身会占用InnoDB Buffer Pool的一部分内存空间，这意味着能够缓存数据页的内存就相应减少了 。
	- **维护开销：** AHI的构建和维护需要消耗CPU资源。当表数据被修改时，如果修改了AHI中索引的键值，InnoDB还需要同步更新AHI。
	- **不适用的工作负载：** 在某些场景下，AHI可能反而会带来性能下降。例如，在大量范围查询、`LIKE`模糊查询为主的负载下，AHI的命中率很低，但维护开销依然存在。在极高并发的写负载下，维护AHI的内部锁也可能成为瓶颈。
- 控制方式： AHI是默认开启的 (`innodb_adaptive_hash_index=ON`)。在特定场景下，如果通过监控发现AHI成为性能瓶颈，DBA可以选择手动关闭它

  ---

- 工作模式：
	- 触发条件：识别到热点数据
	- 采取行动：InnoDB会在**内存的Buffer Pool中**，为热点数据额外建立一个哈希索引。
		- 键：B+Tree索引的键值
		- 值：该键值所在B+Tree叶子节点的内存地址。
	- 产出结果：当下一次同样的等值查询到来时，InnoDB可以先通过AHI（O(1)复杂度）直接定位到目标数据在内存中的页，从而**跳过**了在B+Tree上从根节点开始逐层向下查找的漫长过程，极大地提升了查询效率。