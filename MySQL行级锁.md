- 需求背景：高并发情况下，比起行级锁更能减少锁的竞争
- 工作模式：
	-  基于索引实现：InnoDB 的行级锁是加在**索引项**上的。
		- 锁退化：如果 SQL 查询条件**未能有效使用索引**，InnoDB 将无法精确定位到具体的行，从而可能退而使用**表级锁**。
		- 相同的索引键导致锁冲突：即使访问的是不同的行，但如果它们使用了**相同的索引键**（例如，一个非唯一索引），也可能会发生锁冲突
	- 行锁的加锁和释放遵循“两阶段锁协议”
		- 两阶段锁协议含义：锁的申请和释放分两个阶段进行
			- 需要时候才加锁
			- 释放锁：行级锁的行为受隔离级别影响
				- 读已提交：行级锁在语句执行后可能立即释放。
				- 可重复读：事务提交或者回滚的时候才释放锁
	    - 启发：在编程时应尽量将最可能造成锁冲突的 SQL 语句放在事务的后面执行，以缩短该锁的持有时间，提升并发度
- 分类
    - **记录锁 (Record Lock)**：锁定索引中的一条具体记录。
    - **间隙锁 (Gap Lock)**：锁定索引记录之间的一个区间，防止其他事务在这个区间内插入新数据，从而解决“幻读”问题
    - **临键锁 (Next-Key Lock)**：记录锁和间隙锁的组合，是 InnoDB 在默认可重复读（REPEATABLE READ）隔离级别下防止幻读的主要工具
	    - 锁优化：在可重复读隔离级别下，对唯一索引做等值查询且记录存在时，临键锁会退化为记录锁；若记录不存在，则会退化为间隙锁

- 查询方式：
	```sql
	select * from performance_schema.data_locks;
	```
- 使用方式：
	 - 自动加锁：以下语句会在涉及的数据行上**自动**添加**排他锁（X锁）​**​：
		- 触发条件：`INSERT`、`UPDATE`、`DELETE`​
	 - 手动加锁实现“当前读”或“悲观锁”
		 - 普通的 `SELECT`语句是**快照读**，不加任何锁（基于 MVCC 机制）
		 - 当前读:加共享锁 
			 - 加锁方式：`SELECT ... LOCK IN SHARE MODE`
			 - 共享锁的含义:
				 - 读取是共享的
				 - 修改是互斥的
		- 悲观读：加排他锁
			- ​加锁方式：`SELECT ... FOR UPDATE`​
			- 排他锁的含义：
				- 需要等待别人释放了共享锁，才能进行加锁
				- 其他事务的读取和修改都是被阻塞的
			- 使用场景：常用于实现“先查后改”的悲观锁逻辑，如库存扣减、防止重复提交等。
    
- 问题：死锁
	- 多个事务需要访问相同的资源，但请求锁的顺序不一致
	- 共享锁升级：两个锁住同一行的共享锁，尝试升级为排他锁：互相等待对方释放共享锁
	- 临键锁插入：当两个事务分别持有一个间隙的间隙锁，并尝试在对方持有的间隙中插入数据时，会因为等待对方的间隙锁释放而产生死锁。
	- 当两个事务并发插入同一条唯一键记录时，如果该记录已存在，后插入的事务会阻塞，尝试获取一个共享锁。如果两个事务同时插入一条不存在但唯一键冲突的记录，可能会因唯一性检查产生的锁等待而导致死锁
- 避免发生：
	- 解决措施：确保所有事务对多个表或表中多行数据的访问顺序是一致的（例如，都按主键ID升序处理）。
	- 不要在事务内先使用共享锁读取数据然后又在同一事务内修改该数据。
	- 考虑使用乐观锁机制
- 减小锁冲突的概率：
	- 保持事务小而块：保持事务简短，避免在事务内执行远程调用、文件IO等耗时操作。操作完成后立即提交或回滚
	- 精心设计索引和确保正确使用索引：
		- 为`WHERE`子句中的条件列创建合适的索引，特别是有效的联合索引，可以避免全表扫描，减少锁定的范围。
		- 同时，注意索引的有效性，确保查询能真正利用到索引。
	- 合理选择隔离级别：在业务允许的情况下，可以考虑使用读已提交（READ COMMITTED）​ 隔离级别。此级别下间隙锁较少使用，可以降低死锁概率
  - 事后补救
	1. 死锁检测与恢复：InnoDB 引擎内置了死锁检测机制（默认开启 `innodb_deadlock_detect=on`），当检测到死锁时，它会自动选择回滚其中一个代价较小的事务（通常是根据锁定数量判断），让其他事务得以继续执行
	2. 设置锁等待超时：通过 `innodb_lock_wait_timeout`参数设置一个锁等待的超时时间，避免事务无限期等待
	3. 应用程序重试：在应用程序中，对因死锁而失败的事务实现重试逻辑。捕获死锁异常（如 `DeadlockLoserDataAccessException`），等待一段随机时间后重试事务