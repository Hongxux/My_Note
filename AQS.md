- 定位：阻塞式的锁和同步器工具的框架
- 工作模式：子类通常只需根据需求实现其中一种模式的一组方法。
	- 独占模式：一次只有一个线程可获取资源，如 `ReentrantLock`
	- 共享模式：多个线程可同时获取资源，如 `Semaphore`
- 组成成分：
	- state：同步状态，`volatile int`变量
		-  设计目的：用于表示共享资源的状态
			- 子类需定义 `state`的具体语义，并基于此实现资源获取与释放的逻辑。
				- 在 `ReentrantLock`中，`state`表示锁被同一线程重入的次数（0 表示未锁定）
				- 在 `Semaphore`中，`state`表示当前可用的许可证数量
				- 在 `CountDownLatch`中，`state`表示倒计时计数器的初始值
		- 相关操作：
			- 获取当前状态值：`getState()`
			- 设置状态值：setState(int newState):
				- 用于不涉及竞争条件的初始化
			- 线程安全地设置状态值：compareAndSetState(int expect, int update)：

	- CLH队列的区别与协作
		- **同步队列**：
			- 唯一的：**整个AQS只有一个同步队列**。
			- 作用：所有尝试获取资源失败的线程都会进入此队列等待。
		- **条件队列**：与`ConditionObject`相关，每个`Condition`对象都维护一个独立的、**单向链表**的条件队列。
			- 当线程调用`Condition.await()`时，会释放锁并进入条件队列；
			- 当调用`Condition.signal()`时，会将条件队列中的头节点转移到**同步队列**中重新参与锁竞争。
	- 同步队列
		- 队列特点：
			- **双向链表**：在处理超时或中断而取消排队时，使得节点可以更方便地被移除
			- **线程的阻塞与唤醒**
				- LockSupport.[[LockSupport的park方法|park]]`()`：阻塞线程
				- `LockSupport.unpark()` ：唤醒线程
			- **状态控制**：为每个节点引入了丰富的`waitStatus`状态，使得线程间的协作通知机制更为精细
		- Node节点：
			- thread：指向请求资源的线程
			- `prev`& `next`：指向前驱和后继节点，构成双向链表。
			- nextWaiter：用于标识节点是共享模式还是独占模式，同时在条件队列中也用于链接节点
			- waitStatus：标示节点的状态
				- `SIGNAL (-1)`：表示当前节点的后继节点需要被唤醒。
					- 唤醒时机：当前节点释放锁或取消时，必须唤醒其后继节点。
					- ​**精准单点唤醒**：只唤醒头节点的直接后继线程
				- `PROPAGATE (-3)`：**共享模式**下使用，表示释放共享资源的操作应该**无条件传播**给后续节点。
					- **级联传播唤醒**：当前节点获取成功后会继续尝试唤醒后续共享节点
				- `CANCELLED`：当前节点因为超时或者中断已取消等待
				- `CONDITION (-2)`：表示该节点当前处于**条件队列**中，等待某个条件成立。
				- 0：节点的初始状态。
		- 设计目的：用于管理所有获取资源失败的线程
			- 子类无需关心队列细节，AQS 已封装所有底层操作。
		- 更新方式：AQS 负责队列的维护
			- 节点入队于获取资源：当线程尝试获取资源（如锁）失败时，会执行以下流程
				1. **线程封装成节点，考虑队列是否要初始化
					1. AQS会立即将该线程**封装成一个Node节点**
					2. 如果同步队列是**首次**有线程需要排队，AQS会先进行初始化，即创建一个**虚拟头节点（Dummy Node）**。
						- 目的：简化边界条件的处理逻辑
					3. 如果已经创建完成，新创建的Node节点会通过**尾插法**被添加到同步队列的尾部
						- 加入队尾方式：CAS
							- 保证线程安全
						- 加入失败：则不断自旋直至成功
				2. **在队列中自旋检查**：节点成功入队后，并非立即进入阻塞状态。它会在队列中**自旋（死循环）**，不断检查自己的前驱节点是否为头节点。
				    - 如果是，说明自己排在队伍最前面，有资格再次尝试获取锁，会再次尝试获取资源。
				    - 如果获取成功，则将当前节点**设置为新的头节点**（`setHead(node)`），原头节点出队。
				    - 如果获取失败，当前节点就需要考虑挂起自己，以避免消耗CPU资源
					    - 失败原因：可能由于非公平锁策略允许新来的线程插队，或锁已被占用
				3. **考虑挂起自己**：如果当前节点不该或无法获取资源，会调用`shouldParkAfterFailedAcquire`方法
					- 目的：在挂起前，确保前驱节点状态为`SIGNAL`，从而保证将来能被可靠唤醒，避免"睡死"。
					- 流程：
					    1. 该方法会检查前驱节点的`waitStatus`。
					    2. 如果前驱节点状态为`SIGNAL`，则当前线程可以安全地阻塞（`park`）。
					    3. 如果前驱节点已`CANCELLED`，则将其“跳过”，并链接到更早的未取消节点。
					    4. 否则（如前驱节点状态为0或`PROPAGATE`），会使用CAS将前驱节点状态设置为`SIGNAL`，为下一次检查做准备
			- 资源释放与节点出队：当持有资源的线程释放资源时
				- 前提：
					- 调用`tryRelease`方法释放后state为0
					- 判断是否头节点要唤醒后继结点
						- 要唤醒的依据：头节点`waitStatus`状态不为0
							- SIGNAL：精确唤醒
							- PROPAGATE：传播唤醒
				- 唤醒后继节点的方式：调用`unparkSuccessor`方法。
			- 独占模式下唤醒后继节点：`unparkSuccessor`方法。
				1. **清理唤醒信号**：将当前头节点（即刚释放锁的节点）的 `waitStatus`从 `SIGNAL (-1)`通过 CAS 操作重置为 0，
					- 表示它已经完成了唤醒后继的使命
				2. **寻找有效后继**：
					- 寻找的顺序：从后向前遍历
						- 解决在并发场景下，正向遍历可能因节点入队操作未完成而找不到有效后继的问题。
					- 寻找的目标：
						- 寻找距离头节点最近的
						-  `waitStatus`非取消状态的节点。
				3. **执行唤醒**：找到有效的后继节点后
					1. 调用 `LockSupport.unpark(s.thread)`来唤醒在该节点中阻塞的线程
					2. 调用acquireQueued方法自选循环
						- 在这次循环中，该线程会检查到自己的前驱是头节点，并且此时`tryAcquire`能够成功获取到资源，
						- 于是调用`setHead(node)`方法完成出队
			- 共享模式下唤醒后继结点
				1. 检查是否能释放：
					- 判断方式：调用子类实现的`tryReleaseShared(arg)`，
						- 返回true说明能释放
				2. 如果能释放：调用`doReleaseShared()`方法，循环检测 检查头节点的`waitStatus`。
				    1. 如果为`SIGNAL`，则尝试CAS将其置为0。如果CAS成功，则唤醒后继节点（`unparkSuccessor`）
				    2. 如果为0，则尝试CAS将其置为`PROPAGATE`，确保唤醒信号能继续传播
				- 被唤醒的线程成功获取共享资源后调用`setHeadAndPropagate`
				    1. **出队**：与独占模式一样，调用`setHead(node)`将自己设置为新的头节点，完成出队
				    2. **判断传播**：根据剩余资源量（`propagate`）或新头节点的状态等因素，判断是否满足传播条件。如果满足，则**再次调用`doReleaseShared()`**​  来唤醒下一个后继节点
				- 目的：形成了“**唤醒-获取-设置新头-继续唤醒**”的级联效应，一次释放操作可能让多个等待中的共享线程接连被唤醒并获取资源，极大提高了吞吐量

- 设计思想：
	- 重写 AQS 的特定“钩子”方法（Hook Methods）来定义同步状态（state）的获取与释放规则
	- 线程排队、阻塞、唤醒等复杂操作则由 AQS 的模板方法（如 `acquire`和 `release`）自动完成
	- 模板方法：定义了获取/释放资源的固定算法骨架（如尝试获取、入队、阻塞、唤醒）
		- 设计目的：定义了核心的工作流程
			- 【钩子方法】其中关键的资源获取与释放逻辑留给你来实现
		- 独占式：
			- acquire(int arg)
				- 获取资源，若失败则将线程加入同步队列等待，不响应中断
			- acquireInterruptibly(int arg)
				- 支持响应中断的独占式获取
			- tryAcquireNanos(int arg, long nanosTimeout)
				- 在可中断基础上，增加了**超时等待**功能
			- release(int arg)
				- 释放资源，并唤醒同步队列中的后继节点
		- 共享式：
			- acquireShared(int arg)
			- acquireSharedInterruptibly(int arg)
			- tryAcquireSharedNanos(int arg, long nanosTimeout)
			- releaseShared(int arg)
	- 钩子方法：你要实现的方法
		- 独占
			- `boolean tryAcquire(int arg)`：定义资源何时能被单个线程独占。
				- `true`表示获取成功；`false`表示失败。
			- `boolean tryRelease(int arg)`：定义如何释放独占资源。
				- `true`表示已完全释放；`false`表示否。
		- 共享：
			- `int tryAcquireShared(int arg)`：定义资源何时能被多个线程共享。
				- **负数**：获取失败；
				- **0**：成功，但无剩余资源；
				- **正数**：成功，且还有剩余资源。
			- `boolean tryReleaseShared(int arg)`：定义如何释放共享资源。
				- `true`表示释放后可能允许其他线程获取；`false`表示否。
		- `boolean isHeldExclusively()`：判断当前资源是否被当前线程**独占**。
			- 通常用于实现 Condition 条件变量
	- 工具方法：辅助你实现钩子方法的方法
		- 状态操作
			- `getState()`获取当前同步状态值。
			    - 在 `tryAcquire`或 `tryAcquireShared`中，首先调用此方法判断资源是否可用。
			- `setState(int newState)`直接设置状态值，此操作**不具备原子性**保证。
			    - 通常用于资源初始化，或在已持有锁、不存在竞争的单线程安全场景下更新状态。
			- compareAndSetState(int expect, int update)通过 CAS（比较并交换）操作原子性地更新状态，是实现线程安全的核心。`
			    - 在 `tryAcquire`中尝试获取锁或资源时（例如，在非重入锁中尝试将 state 从 0 改为 1）。
		- 线程管理
			- `setExclusiveOwnerThread(Thread thread)`记录当前独占模式下载的持有线程。
			    - 实现可重入锁时，在成功获取锁后，调用此方法记录锁的持有者。
			- `getExclusiveOwnerThread()`获取当前独占模式下载的持有线程。
			    - 在 `tryRelease`中验证执行释放操作的线程是否正确，以及实现可重入功能时判断当前线程是否为锁的持有者。
		- 队列状态查询
			- `hasQueuedThreads()`检查同步队列中是否有线程正在等待。
			    - 监控或诊断，了解是否存在资源竞争。
			- hasQueuedPredecessors() 检查同步队列中是否存在比当前线程**更早**开始排队等待的线程，这是实现公平性的核心。`
			    - 实现公平锁时，在 `tryAcquire`中先调用此方法，如果有排队者，则当前线程不应抢锁，而应乖乖排队，防止插队。
		- 内部类支持
			- `ConditionObject` AQS 提供的内部类，实现了 `Condition`接口，提供比 `Object.wait()/notify()`更强大、灵活的等待/通知机制。
			    - 实现 `Lock`接口的 `newCondition()`方法，返回此类的实例，以支持多个条件队列。