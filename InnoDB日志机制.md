---
aliases:
  - undo log
  - redo log
  - binlog
---
- 需求背景：实现事务的[[ACID]]![[Pasted image 20251102162346.png]]
- 组成结构：
	- [[redo log]]（重做日志)
	- [[回滚日志|Undo Log]]（回滚日志）
	- [[二进制日志|binlog]]（二进制日志）
- 执行事务的流程
	1. 事务开始：记录undo log
		- 保存数据修改前的状态
	 2. 数据修改：
	    - 更新内存中的数据
	    - 生成redo log，记录数据页的物理修改
	3. 二阶段提交，记录binlog和redolog的刷盘成功，实现redo log 和 binlog 这两种日志数据一致性，
		- [[两阶段提交的目的]]：实现在主从复制、数据恢复等关键场景下的数据一致性
			- 在崩溃恢复后，通过redo log的标志，判断binlog和redo log的写入状态，执行正确的崩溃恢复决策
			- 先redo log，再写bin log，避免主从不一致
		1. Prepare阶段：redo log刷盘。redo log 记录状态为prepare
			- prepare：标志redo log已经刷盘，不属于已提交事务
				- 事务的修改已经持久化，但事务本身并未最终提交，对其他事务仍不可见
		2. Commit阶段：bin log 刷盘，redo log 记录状态为commit
			- commit：标志bin log已经刷盘，属于已提交事务
	4. 事务回滚时：使用undo log将数据恢复到事务开始前的状态
- 数据恢复
	- 人为误操作后的时间点恢复
		- 恢复目标：误删除数据，误更新数据
		- 恢复方式：
			1. 还原最近的全量备份
			2. 找到备份对应的二进制日志位置或时间点。
			3. 使用 `mysqlbinlog`工具重放备份时间点到误操作前的二进制日志事件
				- 如果需要跳过误操作，则需重放误操作之后的日志
	- MySQL实例崩溃恢复：
		- 恢复流程：
			- 已经提交的事务：保证事务的持久性
				- 恢复的对象：在崩溃前已经提交但更改可能还留在内存缓冲区（Buffer Pool）未来得及写入数据文件的事务
				- 恢复方式：从检查点开始扫描重做日志文件，重新执行所有已提交事务对数据页的物理修改
			- 未提交的事务：保证事务的原子性
				- 恢复的对象：所有在崩溃时处于活动状态（未提交）的事务
				- 恢复方式：
					- 如果发现一个事务的 redo log 处于 `PREPARE`状态
						- 如果 binlog 中存在该事务的记录：标记成已经提交
							- 与提交只差标记这一步
						- 如果 binlog 中不存在该事务的记录：由后台线程执行回滚操作
					-