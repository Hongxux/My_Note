
### 一、 硬编码（Hard-Coded）

这是最直接的方式，将值直接写在注解中。

**示例：**

```
@Component("myBean") // value 为 "myBean"
@RequestMapping("/api/users") // value 为 "/api/users"
@ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true") // name 和 havingValue 都是硬编码
```

- **特点**：简单、直观。但**缺乏灵活性**，如果需要修改，必须改动源代码并重新编译。
    
- **适用场景**：固定不变的配置，如通用的 API 路径前缀、不随环境变化的常量。
    

---

### 二、 占位符（Placeholder） - 从配置文件读取

这是 Spring **最常用、最核心**的外部化配置方式。它允许你将注解的属性值与配置文件（如 `application.properties`或 `application.yml`）进行绑定。

**语法：**`${property.name:default_value}`

**示例：**

假设 `application.properties`中有：

```
app.name=MyApplication
server.port=8080
datasource.url=jdbc:mysql://localhost/test
```

在注解中使用：

```
// 1. 基本用法：直接引用属性名
@Component("${app.name}") // 最终 Bean 的名称为 "MyApplication"

// 2. 组合使用：在路径中使用
@RequestMapping("/${server.port}/api") // 最终路径为 "/8080/api"

// 3. 为 Bean 设置属性值（@Value 注解是使用占位符的经典场景）
public class MyService {
    @Value("${datasource.url}")
    private String dbUrl; // 字段值将被注入为 "jdbc:mysql://localhost/test"
}

// 4. 条件注解中的使用
@ConditionalOnProperty(name = "app.feature.advanced", havingValue = "true") // 根据配置决定是否启用
```

- **特点**：实现了**配置与代码的分离**。通过修改外部配置文件，即可改变程序行为，无需重新编译代码。这是 Spring Boot **“约定大于配置”**的基石。
    
- **默认值**：使用 `:`可以指定默认值，当配置文件中找不到对应属性时使用。例如：`@Value("${unknown.property:defaultValue}")`。
    

---

### 三、 SpEL 表达式（Spring Expression Language）

SpEL 是一种强大的表达式语言，允许在注解中进行**动态计算、方法调用、条件判断**等复杂操作。

**语法：**`#{expression}`

**示例：**

```
// 1. 数学运算和字符串拼接
@Value("#{100 + 200}") // 计算结果为 300
private int number;

@Value("#{'Hello, ' + 'World!'}") // 字符串拼接，结果为 "Hello, World!"
private String greeting;

// 2. 引用其他 Bean 及其属性/方法
@Value("#{myService.myProperty}") // 引用名为 `myService` 的 Bean 的 `myProperty` 属性值
private String valueFromOtherBean;

@Value("#{systemProperties['user.home']}") // 引用系统属性（如用户主目录）
private String userHome;

@Value("#{myBean.calculateValue()}") // 调用名为 `myBean` 的 Bean 的 `calculateValue()` 方法
private String calculatedValue;

// 3. 三元运算符（条件判断）
@Value("#{someBean.status == 'active' ? 'enabled' : 'disabled'}")
private String featureStatus;

// 4. 安全导航操作符（避免空指针）
@Value("#{someBean?.nestedProperty?.deepProperty ?: 'default'}")
private String safeValue;
```

- **特点**：**功能极其强大**，可以进行逻辑运算，访问容器中的其他 Bean。但过度使用会使配置变得复杂，可读性降低。
- **Bean的名字**：如果没有特别设置（在@Component的value中设置），默认为
- **适用场景**：需要简单逻辑判断、依赖其他 Bean 值的场景。
    

---

### 四、 编程式控制（Programmatic Control）

这是最灵活、最强大的方式。它通过**编程接口**在运行时动态地决定注解的行为。这通常不是通过直接修改注解的 `value`属性实现的，而是通过实现特定的**条件接口**。

**核心机制：** 使用 `@Conditional`注解，并配合实现 `Condition`接口。

**示例：实现一个根据系统环境决定是否创建 Bean 的条件**

```
// 1. 自定义条件类，实现 Condition 接口
public class MyCustomCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 在这里编写任意复杂的判断逻辑
        Environment env = context.getEnvironment();
        // 例如：只有当配置了 `env=prod`，并且类路径下存在 `SomeClass` 时才返回 true
        return "prod".equals(env.getProperty("env")) &&
               context.getClassLoader().loadClass("com.example.SomeClass") != null;
    }
}

// 2. 在配置类中使用自定义条件
@Configuration
public class AppConfig {
    @Bean
    @Conditional(MyCustomCondition.class) // 使用自定义条件
    public MyService myService() {
        return new MyService();
    }
}
```

**Spring Boot 提供的便捷条件注解：**

Spring Boot 在 `@Conditional`的基础上，提供了大量开箱即用的条件注解，它们本质上是编程控制的“语法糖”，内部实现了 `Condition`接口。

```
@Configuration
public class AppConfig {
    // 组合使用多个条件注解，实现复杂的编程逻辑
    @Bean
    @ConditionalOnClass(name = "com.example.SomeClass") // 编程逻辑：检查类路径
    @ConditionalOnProperty(prefix = "app", name = "feature.enabled", matchIfMissing = true) // 编程逻辑：检查配置
    @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 编程逻辑：检查应用类型
    @ConditionalOnMissingBean // 编程逻辑：检查容器中是否已存在该类型的Bean
    public SomeService someService() {
        return new SomeService();
    }
}
```

- **特点**：**控制力极强**，可以编写任何你能想到的 Java 代码逻辑来决定 Bean 的创建与否。这是 Spring Boot **自动装配**的基石。
    
- **适用场景**：框架开发、编写自定义 Starter、需要高度动态和复杂条件判断的业务场景。
    

---

### 总结与对比

|方式|语法|灵活性|复杂度|典型应用场景|
|---|---|---|---|---|
|**硬编码**|直接赋值|低|低|固定不变的常量|
|**占位符**|`${...}`|中|低|**应用配置外部化**（数据库连接、服务器端口等）|
|**SpEL**|`#{...}`|高|中|需要简单计算、依赖其他 Bean 值的场景|
|**编程控制**|实现 `Condition`接口或使用 `@ConditionalOn...`|**极高**|高|**条件化装配**、自动配置、框架集成|

**最佳实践建议：**

1. **首选占位符**：对于大多数需要外部化的配置，使用 `${...}`是最清晰、最标准的方式。
    
2. **慎用 SpEL**：虽然强大，但会降低配置的可读性。仅在确实需要其特性时使用。
    
3. **活用编程控制**：当简单的配置和表达式无法满足复杂的条件逻辑时，使用 `@Conditional`或其衍生注解是最终的解决方案。
    

理解这几种方式，尤其是后三种，能让你真正掌握 Spring 和 Spring Boot 灵活配置的精髓。