---
aliases:
  - 行级锁
  - 全局锁
  - 表锁
---
## 一、概述
## 二、全局锁
![[Pasted image 20251101215847.png]]

### 一、全局锁概述

#### 核心概念

- ​**全局锁**是一种数据库级别的锁，用于对整个数据库实例加锁。
    
- ​**加锁后效果**​：数据库实例处于**只读状态**，所有数据修改操作将被阻塞，包括：
    
    - DML 写操作（如 `INSERT`、`UPDATE`、`DELETE`）
        
    - DDL 操作（如 `CREATE`、`ALTER`、`DROP`）
        
    - 事务提交（如 `COMMIT`）
#### 典型使用场景

- ​**全库逻辑备份**​：确保备份期间数据一致性，获取一个逻辑时间点的一致性视图。
    
- ​**数据迁移或维护**​：防止在关键操作过程中数据被修改，保证数据完整性。
    

#### 示意图解读

- 数据库实例（圆柱形）包含多张表（如 `tb_stock`、`tb_order`等）
    
- 加锁后，所有表被锁定，形成“只读快照”
    

---

### 二、加锁操作

#### 命令详解

```
FLUSH TABLES WITH READ LOCK;
```

- ​**作用**​：立即关闭所有打开的表，并对整个数据库加全局读锁。
    
- ​**执行结果**​：
    
    - 所有现有会话只能执行读操作（`SELECT`）
        
    - 新会话的写操作会被阻塞，直到锁被释放
        
    
- ​**注意事项**​：
    
    - 需要 `RELOAD`权限
        
    - 锁会持续到显式解锁或会话结束
        
    

---

### 三、数据备份操作
#### 备份命令详解

```
mysqldump -uroot -p itcast > itcast.sql
```

- ​**`mysqldump`**​：MySQL 官方逻辑备份工具
    
- ​**参数说明**​：
    
    - `-uroot`：指定用户名（root）
        
    - `-p1234`：指定密码（1234），生产环境建议使用 `-p`交互输入
        
    - `itcast`：要备份的数据库名
        
    - `> itcast.sql`：输出重定向到文件
        
    
- ​**备份内容**​：生成包含 SQL 语句的文本文件，可用于完整恢复数据库结构和数据
    
![[Pasted image 20251101220722.png]]

---

### 四、解锁操作

#### 命令详解

```
UNLOCK TABLES;
```

- ​**作用**​：释放当前会话持有的所有锁，包括全局读锁。
    
- ​**执行后**​：数据库恢复正常读写状态，被阻塞的写操作可以继续执行。
    

---

### 五、完整备份流程与最佳实践

#### 标准操作步骤

1. ​**连接数据库**​
    
    ```
    mysql -uroot -p
    ```
    
2. ​**加全局锁**​（确保一致性）
    
    ```
    FLUSH TABLES WITH READ LOCK;
    ```
    
3. ​**检查锁状态**​（可选但推荐）
    
    ```
    SHOW PROCESSLIST;  -- 确认无写操作在进行
    ```
    
4. ​**执行备份**​（新开终端会话）
    
    ```
    mysqldump -uroot -p1234 itcast > itcast.sql
    ```
    
5. ​**释放锁**​（返回第一个会话）
    
    ```
    UNLOCK TABLES;
    ```
    

#### 流程示意图

```
加锁 (FLUSH TABLES WITH READ LOCK) 
    ↓
备份 (mysqldump) 
    ↓
解锁 (UNLOCK TABLES)
```

#### 注意事项

1. ​**业务影响**​：加锁期间所有写操作会被阻塞，应在业务低峰期进行
    
2. ​**锁超时**​：如果备份时间过长，可能导致连接超时，锁自动释放
3. 
    
3. ​**替代方案**​：对于 InnoDB 引擎，推荐使用 `--single-transaction`参数实现无锁备份
    
    ```
    mysqldump --single-transaction -uroot -p1234 itcast > itcast.sql
    ```
    例如：
![[Pasted image 20251101220737.png]]
---

## 三、表级锁

### 表锁
![[Pasted image 20251102085549.png]]
表级锁是 MySQL 中最基本的锁机制，它直接锁定整张表，以保证数据操作的完整性。
#### 一、 表锁的分类

表锁分为两类，这两种锁的特性与上图所示的“独占性”直接相关：

1. ​**表共享读锁（Read Lock）​**​
    
    - ​**特性**​：如上图所示，多个会话可以同时获得同一张表的**读锁**，即“共享”。获得读锁后，会话**只能读表，不能写表**，并且会阻塞其他会话申请写锁。
        
    - ​**适用场景**​：适用于需要确保在读取过程中数据不被更改，但允许其他会话并发读取的场景。
        
    
2. ​**表独占写锁（Write Lock）​**​
    
    - ​**特性**​：如上图所示，写锁是**独占和排他**的。一个会话获得某张表的写锁后，​**既可以去写，也可以去读**，但**其他会话不能再对该表加任何锁（无论是读锁还是写锁）​**，直到该锁被释放。其他会话的读写操作都会被阻塞。
        
    - ​**适用场景**​：适用于需要对表进行数据更新（INSERT、UPDATE、DELETE）或表结构变更（ALTER）等操作，需要严格排他的场景。
#### 二、 加锁与释放锁的语法

1. ​**加锁语法**​
    
    ```
    LOCK TABLES 表名 [AS 别名] READ;   -- 加读锁
    LOCK TABLES 表名 [AS 别名] WRITE;  -- 加减锁
    ```
    
    - ​**关键点**​：如图中流程所示，锁是**会话级别**的。加锁成功后，该会话后续的所有操作都受此锁约束。
        
    
2. ​**释放锁语法**​
    
    - ​**显式释放**​：
        
        ```
        UNLOCK TABLES;
        ```
        
    - ​**隐式释放**​：当客户端会话断开连接时，也会**自动释放**该会话持有的所有锁。
        
    

#### 三、 一个简单的示例

```
-- 会话1 操作
-- 1. 对表`users`加写锁
LOCK TABLES users WRITE;

-- 2. 执行一些需要排他性的操作，例如批量更新
UPDATE users SET status = 'inactive' WHERE last_login < '2020-01-01';

-- 3. 操作完成后，显式释放锁
UNLOCK TABLES;


-- 会话2 操作（在会话1未UNLOCK TABLES之前）
-- 尝试查询，会被阻塞，直到会话1释放写锁
SELECT * FROM users; -- 此查询需要等待
```

#### 总结与注意事项

1. ​**粒度较粗**​：表锁一次性锁住整张表，并发性能较低。对于并发量高的应用，InnoDB 存储引擎的**行级锁**是更优的选择。
    
2. ​**会话绑定**​：锁是由会话持有和释放的，如流程图所示，这是理解其行为的关键。
    
3. ​**隐式提交**​：对表加锁（`LOCK TABLES ...`）操作会隐式提交当前会话中所有未提交的事务。
    
4. ​**存储引擎差异**​：表锁在 MyISAM、MEMORY 等存储引擎中是主要锁机制，而 InnoDB 虽然也支持表锁，但优先使用行锁。
### 元数据锁

元数据锁是 MySQL 5.5 版本引入的一种**系统级锁**，其主要作用是**维护表结构（元数据）的一致性**，确保在数据操作过程中，表结构不会被意外修改。

#### 一、MDL 的核心作用与特性

1. ​**自动加锁**​：
    ![[Pasted image 20251102090920.png]]
    MDL 的加锁和释放过程完全由数据库系统自动控制，开发者无需（也无法）手动干预。只要执行访问表的 SQL 语句，系统就会自动加上相应的 MDL。
    
2. ​**解决 DML 与 DDL 的冲突**​：
    
    这是 MDL 最重要的职责。它防止了以下情况的发生：
    
    - ​**场景**​：一个事务正在执行查询（如 `SELECT * FROM users`），同时另一个会话试图修改表结构（如 `ALTER TABLE users ADD COLUMN ...`）。
        
    - ​**没有 MDL 的后果**​：如果允许 DDL 执行，正在进行的查询可能会因为列的改变而报错或得到错误的结果。
        
    - ​**MDL 的解决方案**​：通过 MDL 的互斥性，`ALTER TABLE`操作会等待 `SELECT`完成后再执行，从而保证了数据操作期间表结构的稳定性。
        
    

#### 二、MDL 的锁类型与兼容性

图中的表格是核心，它详细说明了不同 SQL 语句会自动获取哪种 MDL，以及各种锁之间的兼容关系。

| 对应 SQL                                                   | 锁类型                                             | 兼容性说明                                                  |
| -------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------ |
| `LOCK TABLES ... READ/WRITE`                             | `SHARED_READ_ONLY`/ `SHARED_NO_READ_WRITE`      | 显式表锁相关的 MDL                                            |
| ​**`SELECT`、`SELECT ... LOCK IN SHARE MODE`**​           | ​**`SHARED_READ`**和行锁的共享锁​（table的IS和record的S）   | ​**与 `SHARED_READ`、`SHARED_WRITE`兼容，与 `EXCLUSIVE`互斥**​ |
| ​**`INSERT`、`UPDATE`、`DELETE`、`SELECT ... FOR UPDATE`**​ | ​**`SHARED_WRITE`**和行锁的排他锁​​（table的IX和record的X） | ​**与 `SHARED_READ`、`SHARED_WRITE`兼容，与 `EXCLUSIVE`互斥**​ |
| ​**`ALTER TABLE ...`**​                                  | ​**`EXCLUSIVE`**​                               | ​**与其他的所有 MDL 都互斥**​                                   |
![[Pasted image 20251102095939.png]]
![[Pasted image 20251102095955.png]]
​**兼容性解读（最关键的部分）：​**​

- ​**共享锁之间兼容**​：
    
    - `SHARED_READ`（读操作）和 `SHARED_WRITE`（写操作）之间是**兼容**的。
        
    - 这意味着：​**多个会话可以同时对一张表进行读和写操作**，这是 MySQL 高并发的基础。例如，一个会话在查询（`SELECT`）的同时，另一个会话可以插入数据（`INSERT`），它们不会相互阻塞。
        
    
- ​**排他锁与所有锁互斥**​：
    
    - `EXCLUSIVE`锁（主要用于 DDL 操作，如 `ALTER TABLE`）与**所有其他类型的 MDL 都互斥**。
        
    - 这意味着：​**当要对表结构做变更时，必须等待该表上所有正在进行的读写操作（包括显式事务）提交或回滚后才能开始。反之，一旦 DDL 开始，后续的所有读写操作都必须等待 DDL 完成。​**​
        
    

#### 一个生动的例子说明互斥性

假设有两个会话（Session A 和 Session B）操作同一张表 `t`：

1. ​**时刻 T1**​：
    
    - ​**Session A**​ 开启一个事务并执行：`SELECT * FROM t;`（自动获取 `SHARED_READ`锁）
        
    - ​**Session B**​ 可以正常执行：`INSERT INTO t ...;`（自动获取 `SHARED_WRITE`锁），因为 `SHARED_READ`和 `SHARED_WRITE`兼容。
        
    
2. ​**时刻 T2**​：
    
    - ​**Session C**​ 尝试执行：`ALTER TABLE t ADD COLUMN ...;`（需要获取 `EXCLUSIVE`锁）
        
    - ​**结果**​：​**Session C 的 `ALTER`语句会被阻塞，进入等待状态**。因为它需要的 `EXCLUSIVE`锁与 Session A 持有的 `SHARED_READ`锁和 Session B 持有的 `SHARED_WRITE`锁都互斥。
        
    
3. ​**时刻 T3**​：
    
    - ​**Session D**​ 此时发起一个新的查询：`SELECT * FROM t;`
        
    - ​**结果**​：​**Session D 的查询也会被阻塞**​！因为 `ALTER TABLE`在排队等待获取 `EXCLUSIVE`锁，这个锁的请求会阻塞后续所有新的 `SHARED_READ`锁请求。
        
    
4. ​**时刻 T4**​：
    
    - ​**Session A**​ 提交事务（或结束会话），释放了 `SHARED_READ`锁。
        
    - ​**结果**​：但 `ALTER`操作仍然被 Session B 的 `INSERT`操作（`SHARED_WRITE`锁）阻塞，所以 Session C 和 Session D 依然在等待。
        
    
5. ​**时刻 T5**​：
    
    - ​**Session B**​ 提交事务，释放了 `SHARED_WRITE`锁。
        
    - ​**结果**​：此时表上没有任何活动的 MDL 锁，Session C 成功获取 `EXCLUSIVE`锁，开始执行 `ALTER TABLE`。执行完毕后，释放锁，之后 Session D 的查询才能继续执行。
        
    

​**这个例子展示了 MDL 如何导致 DDL 操作被长时间阻塞，以及一个未提交的长事务是如何影响整个系统的。​**​

#### 总结

这张图的核心价值在于说明了：

1. ​**MDL 是自动的**​：用于保护表结构，避免 DML 和 DDL 冲突。
    
2. ​**锁的兼容性决定了并发度**​：DML 语句（增删改查）之间可以并发，但它们都与 DDL 语句（改表结构）互斥。
    
3. ​**`ALTER TABLE`是一个重操作**​：因为它需要获取排他的 `EXCLUSIVE`锁，会阻塞后续所有操作，所以必须在业务低峰期谨慎进行。
    

理解 MDL 对于分析数据库性能瓶颈、解决“表锁等待”问题以及规划在线表结构变更（如使用 `pt-online-schema-change`工具）至关重要。
### 意向锁
意向锁的**设计初衷**​：解决**行级锁**与**表级锁**之间的冲突检测效率问题。

- ​**没有意向锁时**​：如果事务 A 持有表中某一行的锁，此时事务 B 想对整个表加锁（如 `LOCK TABLES ... WRITE`），数据库需要**逐行检查**表中是否有数据已被上锁，效率极低。
    
- ​**有意向锁后**​：意向锁作为一种**表级锁**，充当了“预告”或“标识”的角色。事务在获取行锁之前，会先获取对应的意向锁。这样，其他事务通过检查表上的意向锁，就能快速判断是否能安全地加上表锁，​**避免了低效的逐行扫描**。
    

​**简单比喻**​：意向锁就像图书馆的“房间占用牌”。你想给整个房间（表）加锁前，只需看门口牌子（意向锁）就知道里面是否有人（行锁），而不用逐个座位（行）去检查。

#### 一、 意向锁的类型

两种意向锁及其产生方式：

|锁类型|英文与缩写|产生语句（示例）|说明|
|---|---|---|---|
|​**意向共享锁**​|Intention Shared Lock (IS)|`SELECT ... LOCK IN SHARE MODE;`|表示事务**准备**在表中的某些行上设置**共享锁**​（读锁）。|
|​**意向排他锁**​|Intention Exclusive Lock (IX)|`INSERT`, `UPDATE`, `DELETE`, `SELECT ... FOR UPDATE`|表示事务**准备**在表中的某些行上设置**排他锁**​（写锁）。|

​**关键点**​：

- ​**​“意向”的含义**​：它表示一种“意向”或“预告”，意味着事务**即将**要对表中的某些行进行操作，但尚未真正给行加锁。
    
- ​**兼容性基础**​：意向锁之间不会互斥（如 IS 和 IX 可以共存），因为它们只是“预告”，不冲突的实际操作可能发生在不同的行上。
    

#### 二、 意向锁的兼容性规则

第三张图是核心，它揭示了意向锁如何与表锁互动，这也是其价值的体现。下表总结了其兼容性：

|请求的锁类型|当前表上已有的锁类型|是否兼容|解释|
|---|---|---|---|
|​**意向共享锁 (IS)​**​|​**表级共享读锁**​ (READ)|​**兼容**​ ✅|大家都只是读意向，不冲突。|
|​**意向共享锁 (IS)​**​|​**表级排他写锁**​ (WRITE)|​**互斥**​ ❌|写锁要独占，拒绝任何意向。|
|​**意向排他锁 (IX)​**​|​**表级共享读锁**​ (READ)|​**互斥**​ ❌|读锁不允许有写的意向。|
|​**意向排他锁 (IX)​**​|​**表级排他写锁**​ (WRITE)|​**互斥**​ ❌|写锁要独占，拒绝任何意向。|
|​**意向共享锁 (IS)​**​|​**意向排他锁 (IX)​**​|​**兼容**​ ✅|意向锁之间本身不互斥。|

​**规则解读**​：

- ​**共享读锁 (READ)​**​ 比较宽松，允许其他事务有读的意向 (IS)，但不允许有写的意向 (IX)。
    
- ​**排他写锁 (WRITE)​**​ 非常严格，它要求独占整个表，因此拒绝任何其他意向锁（无论是 IS 还是 IX）。
    
#### 总结

意向锁是 InnoDB 实现高效多粒度锁管理的精髓。它的价值在于：

1. ​**提升性能**​：通过表级的意向标记，避免了加表锁时的全表行锁扫描，极大提升了并发效率。
    
2. ​**实现多粒度锁**​：使得行级锁和表级锁能够共存，数据库系统可以根据需要灵活地在不同粒度上加锁。
    
3. ​**保证一致性**​：通过清晰的兼容性规则，确保了并发事务下数据读取和修改的正确性。
    


## 四、行级锁
```sql
select * from performance_schema.data_locks;
```
提交事务就释放了行锁

- 行级锁与MVCC协作：MVCC处理读写冲突（通过快照读），行级锁处理写写冲突。**
- MySQL锁防止幻读

### 三种行锁

- **记录锁 (Record Lock)** ：锁定单条索引记录。
- **间隙锁 (Gap Lock)** ：锁定索引记录之间的间隙，以防止其他事务在范围内插入新数据，从而解决幻读问题。**仅在可重复读(RR)隔离级别下有效**。
- **临键锁 (Next-Key Lock)** ：**这是InnoDB的默认行锁策略**，它是记录锁和间隙锁的组合，即锁住记录本身以及该记录之前的间隙。
### 行锁的依赖条件
- **核心原理**：InnoDB的行锁是加在索引项上的，而不是加在物理行记录上的。
- **重要推论**：如果SQL查询条件**没有使用索引**，InnoDB将无法定位到具体的行，因此会**退化为表锁**（锁升级），这会严重降低并发性能。
- **潜在陷阱**：即使访问的是不同的行，但如果它们使用了**相同的索引键**（例如，一个非唯一索引），也可能会发生锁冲突
### 行锁触发机制
[[SQL语句触发行锁]]
### 影响行锁行为的因素
#### 行级锁的行为受隔离级别影响
- ​**读已提交**​：行级锁在语句执行后可能立即释放。
    
- ​**可重复读**​：行级锁可能持续到事务结束，并可能使用间隙锁防止幻读。
	- ​**默认锁算法**​：​**临键锁**。它是**行锁 + 间隙锁**的组合，不仅锁住记录本身，还会锁住记录之前的间隙。这有效防止了其他事务在间隙中插入新数据，从而杜绝了幻读。
	- [[锁优化与锁升级]]
### [[MySQL锁性能优化]]
#### 总结与最佳实践

1. ​**核心关系**​：图1的兼容性规则是图2中所有加锁行为的基础。理解了 S 锁和 X 锁的冲突关系，就能预判不同 SQL 语句并发执行时可能发生的锁等待现象。
    
2. ​**应用场景**​：
    
    - ​**写操作（INSERT/UPDATE/DELETE）​**​：自动加 X 锁，是数据安全的基石。
        
    - ​**高并发读**​：使用普通 `SELECT`，利用 MVCC 实现无锁快照读，性能最佳。
        
    - ​**保证读取一致性**​：使用 `SELECT ... LOCK IN SHARE MODE`加 S 锁，防止读取的数据被修改。
        
    - ​**实现悲观锁**​：使用 `SELECT ... FOR UPDATE`加 X 锁，锁定资源进行“先查后改”的原子操作。
        
    
3. ​**性能与[[死锁问题]]**​：不当的手动加锁（尤其是 `FOR UPDATE`）会增加锁冲突概率，可能导致性能下降甚至死锁，应在明确需要的场景下谨慎使用。


