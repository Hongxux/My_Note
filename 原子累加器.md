---
aliases:
  - LongAdder
  - LongAccumulator
  - DoubleAdder
  - DoubleAccumulator
---
- 需求背景：专门用于做累加的类，性能远高于AtomicInteger和AtomicLong
	- 解决高并发下热点变量的激烈竞争，提升吞吐量
	- 实现最终一致性，对实时性的精确性要求不高，比如网站点击量
- 实现方式（为什么高效的原因）：
	- AtomicLong为例：竞争中不断自旋重试
	- LongAdder为例：不同线程累加不同单元，从而分散竞争，最后将累加的记入汇总![[Pasted image 20251202134339.png]]
		- 实现基础：都用volatile保证可见性和有序性
			- `Cell[] cells`:用于有竞争的情况
				- 懒惰创建，有竞争的时候创建
				- 根据线程数量进行动态扩容
					- 数组的个数不超过cpu核心数
				- Cell类使用Contended注解防止[[伪共享]]
					- 使得cells的每个cell处于不同缓存行
					- 避免出现修改`cells[i]`，却导致`cells[j]`失效了，要进行缓存刷新，降低性能的问题
			- `long base`:基础值，在没有竞争的时候不使用cell，直接使用base进行累加
			- `int cellsBusy`:
				- 设计目的：避免重复创建和重复扩容
				- 使用时机：
					-  cells 创建时进行加锁
					-  cells 扩容时进行加锁：新增加累加单元cell
				- 使用方式：
					- 先判断有没有被上锁（是否为1）
					- 没有上锁，则使用cas置为 1，表示加锁
		- 实现`increment()`方法：![[Pasted image 20251202141415.png]]
			-  核心思想：首先尝试在代价最小的路径（直接更新 base）上完成，如果失败，则逐步升级到更复杂但并发能力更强的路径（操作 Cell 数组），甚至进行扩容。
			- 获取当前线程的cell：`cellIndex = 线程哈希 & (cells.length - 1);`
				- 线程哈希 = `ThreadLocalRandom.getProbe();`
			- `longAccumulate`：分层、乐观的重试机制，状态机处理方式
				- 状态判断使用二次判断模式DCL
					- 首次判断为快速判断：`cellsBusy == 0 && cells == as && casCellsBusy()`
						- 先判断是否能锁：`cellsBusy == 0 `
						- 再判断是否满足条件：例如`cells == as`
						- 最后判断加锁是否成功：`casCellsBusy()`
					- 再次判断为加锁后判断条件是否满足：例如`cells == as`
						- 保证正确性
							- 第一次检查到成功获取锁这段时间内，共享变量可能被其他线程修改
				- cell累加单元创建![[Pasted image 20251202142705.png]]
				- cells数组创建--Balking模式：这是从无竞争（使用 `base`）到有竞争（使用 `cells`）的转折点。![[Pasted image 20251202142133.png]]
					- 加锁失败，存在一个线程正在进行创建cells数组创建、
				- 对线程对应的cell进行cas累加--作为最后的回退方案，确保了即使在最坏的情况下，线程也不会被无限期阻塞![[Pasted image 20251202144612.png]]
					- 改变线程对应的cell：对线程进行再哈希
					- 扩容：
						- 扩容后大小：当前大小的两倍
						- 新旧数组替换：直接拷贝旧的cell到新的cell，下标都不变
				

- 实现类：
	- LongAdder
	- LongAccumulator：它是`LongAdder`的功能增强版，可以进行更复杂的归约操作
		- 增强：允许你传入一个自定义的二元运算符（如`Long::max`用于求最大值），不再局限于累加
	- DoubleAdder
	- DoubleAccumulator