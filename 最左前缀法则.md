
联合索引生效的前提
- 联合索引的创建过程：为列`(A, B, C)`创建联合索引
	1. 全局有序性：首先，所有数据行按照索引定义中的第一列（A列）的值进行严格排序。这是最顶层的顺序。
	2. 局部有序性：当A列的值相同时，这些行再按照第二列（B列）的值进行排序。如果B列的值也相同，则继续按第三列（C列）排序

​**最左前缀法则**指的是：在使用复合索引时，查询条件必须从索引的**最左列开始**，并且**不跳过索引中的中间列**。（顺序可以乱，因为Mysql会自动调节顺序）

- ​**领头列不可少**​：查询必须包含复合索引的最左列。
    
- ​**中间列不能断**​：不要跳过索引中的列，否则后续列无法使用。
    
- ​**范围之后全失效**​：范围查询会使它右边的索引列失效。
    

在设计复合索引时，应将**最常被作为查询条件**且**区分度高**的列放在最左边。
#### 法则详解与示例

假设我们有一张 `user`表，并为其 `(profession, age, status)`三个字段创建了一个复合索引，名为 `idx_pro_age_sta`。

​**1. 完全遵循法则（索引有效）​**​

查询条件中包含了索引的最左列 `profession`。

- `WHERE profession = '软件工程师' AND age = 30 AND status = '1'`（**索引生效**，三个字段都用了）
    
- `WHERE profession = '软件工程师' AND age = 30`（**索引生效**，使用了 `profession`和 `age`）
    
- `WHERE profession = '软件工程师'`（**索引生效**，只使用了 `profession`）
    

> ​**只要查询条件中包含最左列 `profession`，索引就会生效。使用的索引列越多，过滤效果越好。​**​

​**2. 违反法则（索引失效）​**​

查询条件**不包含**最左列 `profession`。

- `WHERE age = 30`（**索引失效**）
    
- `WHERE status = '1'`（**索引失效**）
    

- `WHERE age = 30 AND status = '1'`（**索引失效**）
    

> ​**跳过最左列，直接使用后面的列，复合索引将完全失效，会导致全表扫描。​**​

​**3. 特殊情况（部分生效）​**​

查询条件包含最左列，但跳过了中间的列。

- `WHERE profession = '软件工程师' AND status = '1'`（**索引部分生效**）
    

> 在这种情况下，索引**不会完全失效**。MySQL 仍然会使用复合索引，但它只能使用到 `profession`这一列（这被称为“索引前缀”）。`status`列无法被用于索引过滤，因为中间的 `age`列缺失了，破坏了索引的有序性。

#### 注意事项与特殊情况

1. ​**条件的顺序不重要**​：SQL 是声明式语言，查询优化器会帮你优化条件的顺序。以下两条 SQL 对于索引的使用是等价的：
    
    - `WHERE profession = '软件工程师' AND age > 30`（索引生效）
        
    - `WHERE age > 30 AND profession = '软件工程师'`（索引同样生效，优化器会调整顺序以匹配索引）
        
    
2. ​**范围查询右边的列索引失效**​：如果对索引中的某一列使用了范围查询（如 `>`， `<`， `like '%abc'`， `BETWEEN`），则它**右边的所有列**将无法再使用索引进行过滤。
    
    - 例如：`WHERE profession = '软件工程师' AND age > 30 AND status = '1'`
        
    - 在这个查询中，`profession`和 `age`会使用索引，但 `status`不会。因为 `age > 30`是一个范围查询，它右边的 `status`列在索引中变得无序，无法被高效利用。
        