---
aliases:
  - 重做日志
---
- 需求背景：实现持久性
	- 事务提交直接写入磁盘：随机I/O性能低
		- 数据库以页（16KB）为单位进行磁盘交互
			- 而事务可能只修改页中几个字节
		- 数据页分散问题
			- 事务修改的多个数据页在物理磁盘上位置分散
	- 事务提交仅依赖内存缓冲：**断电会导致数据丢失**，违背持久性原则
- 解决方法：redo log
- 日志记录内容： 数据页的物理变化（如"页号X偏移量Y修改为Z"），而非逻辑SQL语句
	- 恢复时无需解析SQL，直接应用物理修改，速度更快
- 写入顺序：
	- WAL（Write-Ahead Logging）机制：先写日志，再写数据
		- 事务提交时先将修改记录写入redo log，随后再将数据页刷盘
			- 可以配置redo log在事务提交后写入磁盘
			- InnoDB的线程在合适的时候再将脏页从内存写入磁盘
		- 实现崩溃恢复：
			- 恢复的目标：未刷盘的已提交事务
			- 恢复时机：数据库重启后
	- 内存缓冲与批量刷盘：先将日志写入内存缓冲区，再以页为单位批量刷盘
		- 写入的内存缓冲区：redo log buffer
		- 配置刷盘机制：
			- `innodb_flush_log_at_trx_commit=1`：**最高安全性**（每次提交刷盘）。
			- `innodb_flush_log_at_trx_commit=2`：**平衡策略**（写入page cache，每秒刷盘）。
			- `innodb_flush_log_at_trx_commit=0`：**最高性能**（仅内存，每秒刷盘）。

- 写入机制：
	- 顺序IO写入磁盘
		- 磁盘顺序写入性能比随机写入高几个数量级
	- 循环写入机制
		- redo log文件固定大小，写满后从头覆盖旧日志



