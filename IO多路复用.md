- 需求背景：
	- 无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据
	- recvfrom只能监听一个[[FD]]，判断这个FD有没有带就绪
- 解决思路：IO多路复用![[Pasted image 20251127134455.png]]
	- 一次监听多个FD，只要有FD准备就绪（处于可读或者可写状态）了，就对这个FD进行recvfrom读取数据到用户态
- 监听FD、通知的实现方式
	- select和poll：
		- select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认
			- select使用BitMap的结构存储监听FD
			- poll是用链表的结构存储监听FD
		- 需要在内核态和用户态内存相互拷贝储存监听的FD数据结构
	- [[epoll]]：epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间
		- 无需在内核态和用户态内存相互拷贝储存监听的FD数据结构
			- 使用红黑树存储监听的FD（内核态）
			- 使用链表存储就绪的FD（内核态）
				- 只需要拷贝就绪的FD到用户态，需要拷贝的数量少
	