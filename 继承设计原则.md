这是一个关于**继承设计原则**的优秀总结。让我为你梳理和解释这些关键点：

## 1. 将公共操作和字段放在超类中 ✅

​**核心思想：​**​ 通过继承实现代码复用

```
// 好的做法
class Person {
    protected String name;  // 公共字段放在超类
    public String getName() { return name; }
}

class Employee extends Person {
    // 自动继承name字段和getName方法
}

class Student extends Person {
    // 自动继承name字段和getName方法
}
```

## 2. 不要使用[[protected修饰符|protected]]字段 ⚠️

​**原因：​**​ 破坏封装性

- ​**问题1：​**​ 任何子类都能直接访问protected字段
    
- ​**问题2：​**​ 同包中的所有类都能访问，不限于子类
    
- ​**建议：​**​ 使用private字段 + 公共getter/setter方法
    

## 3. 用继承建模"is-a"关系 🔍

​**关键测试：​**​ 子类必须是超类的特殊类型

```
// 错误示例 - Contractor不是Employee的特殊类型
class Contractor extends Employee {  // 不合适！
    private double hourlyWage;
}
```

​**问题：​**​ Contractor有hourlyWage，但继承了salary字段，造成数据冗余和逻辑混乱。

## 4. 确保所有继承方法都有意义 ❌

​**反例：​**​ Holiday继承GregorianCalendar

```
class Holiday extends GregorianCalendar {
    // 问题：add()方法会让假日变成非假日
    // christmas.add(Calendar.DAY_OF_MONTH, 12); // 这还算是假日吗？
}
```

​**解决方案：​**​ 使用组合而非继承

```
class Holiday {
    private LocalDate date;  // 组合，不是继承
    private String name;
}
```

## 5. 重写方法时不要改变预期行为 ⚖️

​**里氏替换原则：​**​ 子类应该可以替换父类而不影响程序正确性

```
class BankAccount {
    public void withdraw(double amount) {
        balance -= amount;  // 预期行为：减少余额
    }
}

class SavingsAccount extends BankAccount {
    @Override
    public void withdraw(double amount) {
        // 错误：完全改变行为，比如什么都不做
        // 正确：可以在父类行为基础上添加额外逻辑
        super.withdraw(amount);
        applyWithdrawalFee();
    }
}
```

## 6. 使用多态，而不是类型检查 🔄

​**不好的做法：​**​

```
if (animal instanceof Dog) {
    ((Dog) animal).bark();
} else if (animal instanceof Cat) {
    ((Cat) animal).meow();
}
```

​**好的做法：​**​

```
abstract class Animal {
    public abstract void makeSound();
}

class Dog extends Animal {
    public void makeSound() { bark(); }
}
// 使用时：animal.makeSound(); // 自动调用正确的方法
```

## 7. 不要过度使用反射 🪞

​**反射的问题：​**​

- 编译时无法检查错误
    
- 性能较差
    
- 代码难以理解和维护
    
- ​**适用场景：​**​ 框架开发、系统编程，而不是普通应用
    

## 总结：继承的最佳实践

|原则|要做什么|不要做什么|
|---|---|---|
|​**代码组织**​|公共功能放超类|在每个子类重复代码|
|​**封装性**​|使用private字段+getter/setter|使用protected字段|
|​**关系建模**​|确保"is-a"关系|强行继承不相关类|
|​**方法设计**​|所有继承方法都有意义|继承不适合的方法|
|​**行为一致性**​|遵守里氏替换原则|改变重写方法的预期行为|
|​**代码结构**​|使用多态|使用大量的instanceof检查|
|​**高级特性**​|谨慎使用反射|过度依赖反射|

这些原则的核心是：​**继承应该简化代码，而不是增加复杂性**。当继承变得复杂时，考虑使用**组合**或**接口**可能是更好的选择。

接下来的接口章节会展示如何用接口实现更灵活的设计！