- 需求背景：在 RDB 持久化之外，提供一种**数据安全性更高、实时性更强**的数据持久化方案，解决特定场景下**对数据丢失的零容忍需求**
	- RDB在两次快照期间存在数据丢失的可能性
- 解决措施：AOF（Append Only File）
	- 数据备份频率高，数据丢失可能性低：记录每一个写操作，它能够将故障时的数据丢失量降至最低
		- 提供了 `appendfsync`配置选项，让你可以根据业务需求在性能和数据安全性之间进行精细权衡
			- always：每个写命令都同步刷盘。数据最安全，但性能开销最大。
			- everysec（默认）：每秒同步一次。在性能和数据安全间取得了很好的平衡，是生产环境的常用选择。
			- no：由操作系统决定同步时机。性能最好，但数据丢失风险最高。
	- 有序的追加写入模式
		- 含义：所有的写操作都是顺序的
		- 好处：没有昂贵的磁盘寻址开销，因此写入性能通常很高
	- 良好的可读性与可修复性
		- 可读性是可修复性的前提
		- 可读性的实现：AOF 文件以 Redis 协议格式存储命令
		- 灾难修复的方式：
			- 背景：如果不幸有人误执行了 `FLUSHALL`这样的危险命令
			- 前提：AOF 重写尚未触发
			- 恢复方式：编辑 AOF 文件，删除错误的命令，然后重启 Redis 来恢复数据
- 问题：
	- 文件体积较大：即使有重写机制，AOF文件在两次重写之间的体积通常仍会大于同等数据量的RDB文件
	- 恢复速度相对较慢：数据恢复需要逐条重放AOF文件中的所有命令。当AOF文件很大时，这个过程会比直接加载RDB文件慢得多
	- 写入性能开销：AOF需要持续地将命令写入文件。根据`appendfsync`策略的不同，会对主进程的性能造成一定影响

---
实现细节


- `appendfsync`是AOF机制的**心脏**，它直接决定了AOF的性能和数据安全性。它有三个可选策略 ：
	- `always`（总是同步）‍：
	    - 行为：每执行一条写命令，主进程都会**阻塞**住
		    - 写入成功的判断依据（阻塞停止的时机）：操作系统将该命令从内核缓冲区强制**刷入到磁盘物理介质**
	    - 优点：数据安全性最高。理论上，只要磁盘和操作系统不出现问题，最多只会丢失一个事件循环中的数据（几乎等同于不丢失）。
	    - 缺点：性能极差。每次写操作都要等待磁盘I/O完成，这使得Redis的QPS会急剧下降到几百甚至更低，完全无法发挥其高性能特性。它只适用于对数据完整性有极端要求的场景，如金融交易。
	- `everysec`（每秒同步）‍：
	    - 行为：
		    1. 每执行一条写命令，只是先将其写入内核缓冲区就立即返回，这个过程非常快。
		    2. Redis会有一个专门的后台线程，每隔一秒钟执行一次`fsync`操作，将过去一秒内积累在内核缓冲区的命令批量刷入磁盘。
	    - 优点：这是一个完美的折衷方案。它既保证了高性能（写命令几乎无延迟），又提供了很好的数据安全性。即使服务器宕机，最多也只会丢失**最近一秒钟**的数据。
	    - 缺点：在最坏情况下，会有一秒的数据丢失。
	- `no`（从不主动同步）**‍：
	    - 行为：Redis只负责将命令写入内核缓冲区，完全不调用`fsync`。何时将数据刷入磁盘，完全由操作系统自己决定（通常是几十秒一次，或者当缓冲区满时）。
	    - 优点：性能最好，与不开启AOF时几乎无异。
	    - 缺点：数据安全性最差。一旦服务器宕机，会丢失上一次操作系统自动同步之后的所有数据，丢失的数据量不可控，可能长达数十秒

- 文件重写（Rewrite）机制
	- 产出结果：最终会生成一个**体积小**得多、**内容等效**的新AOF文件
		- 它会为每一个键值对生成一条或多条足以恢复该键值对的、最简洁的命令。
		- 示例：对一个计数器执行了100次`INCR`，旧AOF文件里有100条`INCR`命令，而重写后的新AOF文件里可能只有一条`SET counter_key 100`
	- 触发方式：
		- 手动触发：执行`BGREWRITEAOF`命令。
		- 自动触发：
			- 触发条件：
			    - `auto-aof-rewrite-percentage 100`：当AOF文件的当前大小，比上次重写后的大小，增长超过了这个百分比（默认100%，即翻倍）时，触发重写。
			    - `auto-aof-rewrite-min-size 64mb`：为了避免文件很小时频繁重写，设置了一个触发重写的最小文件体积门槛（默认64MB）。
		    - 触发判断逻辑链：
			    1. `当前AOF文件大小 > auto-aof-rewrite-min-size` 
			    2.  `(当前大小 - 上次重写后大小) / 上次重写后大小 > auto-aof-rewrite-percentage`。
	- 实现模式：**非阻塞**
		1. **`fork`子进程**：与`BGSAVE`类似，主进程`fork`一个子进程。子进程拥有`fork`时刻的内存数据副本。
		2. **子进程**：
			- 职责：遍历和重写内存数据
			- 产生结果：为每一个键值对生成一条或多条足以恢复该键值对的、最简洁的命令
			- 内容暂存位置：一个新的、临时的AOF文件中。
		3. **主进程**：
			- 职责：
				- 在子进程重写期间，主进程继续处理客户端的写命令。
				- 保证数据一致性
			- 数据一致性的实现基础：
			    - AOF缓冲区（`aof_buf`）‍：
				    - 职责：作为重写期间故障发生时的安全备份。
					    - 确保即使在重写过程中发生故障，旧的AOF文件也能记录下尽可能完整的数据
				    - 实现方式：在重写期间，它依然正常工作，接收所有写命令，并根据配置的`appendfsync`策略（如always、everysec、no）将命令同步到旧的AOF文件
			    - AOF重写缓冲区（`aof_rewrite_buf`）‍：
				    - 创建时机：在重写开始时才创建
				    - 职责：解决子进程快照与实时数据之间的“时间差”问题
				    - 实现方式：为新的AOF文件收集自重写开始后产生的增量数据。
					    - 主进程会将之后接收到的每一个写命令同时追加到AOF缓冲区和AOF重写缓冲区
			- 数据一致性的实现方式：主进程会将之后接收到的每一个写命令同时追加到AOF缓冲区和AOF重写缓冲区
		4. **数据合并与替换**：
		    - 触发条件：子进程完成对内存快照的重写
		    - 操作流程：阻塞（短暂暂停处理新命令）
				1. 数据追加：**AOF重写缓冲区**中累积的所有写命令追加到子进程刚刚生成的新AOF文件的末尾
					- 作用：确保了新AOF文件包含了从重写开始到结束这一时间段内的所有数据变更，与当前数据库的状态完全一致。
				2. 文件替换：主进程会**原子性**地用新的AOF文件**替换**旧的AOF文件
				3. 清理与恢复：主进程会清理并释放AOF重写缓冲区，然后恢复正常服务，继续处理客户端命令