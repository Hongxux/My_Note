
## NoSQL和SQL对比
### 一、 核心特性对比

|特性维度|SQL (关系型数据库)|NoSQL (非关系型数据库)|
|---|---|---|
|**1. 数据结构**|**结构化 (Structured)**|**非结构化 (Unstructured)**|
|**2. 数据关联**|**关联的 (Relational)**|**无关联的 (Non-relational)**|
|**3. 查询方式**|**SQL 查询**(声明式)|**非SQL**(API驱动，命令式)|
|**4. 事务特性**|**ACID**|**BASE**|
|**5. 存储方式**|**磁盘**(优先保证持久性)|**内存**(优先保证性能)|
|**6. 扩展性**|**垂直扩展 (Scale-up)**|**水平扩展 (Scale-out)**|
|**7. 使用场景**|数据结构固定；业务对**一致性、安全性**要求高|数据结构灵活；对**高性能、高可用**要求高|

---

### 二、 核心概念详解

#### 1. 数据结构：结构化 vs. 非结构化

- **SQL**：需要**预定义模式（Schema）**。就像一张严格的Excel表格，必须先定义好列名（字段）、数据类型（如整数、字符串）、有时候包括约束，才能插入数据。**结构固定，不易修改**。
    ![[Pasted image 20251115202353.png]]
- **NoSQL**：**无模式或动态模式**。可以随时添加新的字段，每条记录的结构可以完全不同。非常灵活，适合处理多变的数据。它包含多种模型：
    
    - **键值型 (Key-Value)**：如 Redis。最简单的模型，通过唯一的 Key 访问 Value。
        
    - **文档型 (Document)**：如 MongoDB。数据以类似 JSON 的文档形式存储。
        
    - **列族型 (Column-Family)**：如 HBase。按列族存储数据，适合大规模数据分析。
        
    - **图型 (Graph)**：如 Neo4j。专门用于存储实体间复杂的关系网络。
        
    ![[Pasted image 20251115202635.png]]

#### 2. 数据关联：关联 vs. 无关联

- **SQL**：通过**外键**等机制建立表与表之间的关联，支持复杂的**连接查询**。
    ![[Pasted image 20251115202813.png]]
- **NoSQL**：**没有连接查询**。数据通常以聚合的形式存储，鼓励去规范化，通过应用程序来处理数据关系。
    

#### 3. 查询语言：SQL vs. 非SQL

- **SQL**：使用标准化的 **SQL**语言进行查询，语法强大且声明式（你只需告诉数据库“想要什么”，而不是“如何获取”）。
    
- **NoSQL**：**没有统一的标准查询语言**。每种数据库都有自己的 API 或查询语法，通常是命令式的。
    
![[Pasted image 20251115203141.png]]
#### 4. 事务特性：ACID vs. BASE

这是两者在数据一致性理念上的根本区别。

- **SQL - ACID**：
    
    - **原子性**：事务内的操作要么全部成功，要么全部失败。
        
    - **一致性**：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
        
    - **隔离性**：并发事务之间互不干扰。
        
    - **持久性**：事务一旦提交，对数据的改变是永久性的。
        
    - **目标**：**强一致性**，保证数据的绝对准确，适合金融交易等场景。
        
    
- **NoSQL - BASE**：
    
    - **基本可用**：系统保证基本可用，即使在故障时。
        
    - **软状态**：允许系统中的数据存在中间状态，但不影响整体可用性。
        
    - **最终一致性**：经过一段时间后，数据副本最终会达到一致。
        
    - **目标**：**高可用性和高性能**，允许数据在短时间内不一致，适合社交网络、实时推荐等场景。
        
    

#### 5. 扩展性：垂直扩展 vs. 水平扩展

- **SQL**：主要通过**垂直扩展**，即增加单个服务器的性能（如更强的CPU、更大的内存）来提升处理能力。成本高，有上限。
    
- **NoSQL**：天生支持**水平扩展**，即通过增加更多的普通服务器节点来组成集群，共同处理数据。成本低，扩展性几乎无限。
    

---

### 三、 如何选择？—— 使用场景

**选择 SQL 当：**

- **数据结构稳定**：业务模型成熟，数据结构不会频繁变动。
    
- **需要复杂查询**：业务需要大量的关联查询和复杂报表。
    
- **要求数据一致性**：业务对数据的准确性和完整性要求极高，如银行、会计系统。
    

**选择 NoSQL 当：**

- **数据结构多变**：业务处于快速迭代中，数据模型需要频繁调整。
    
- **高并发读写**：应用需要处理巨大的流量，如电商秒杀、社交媒体的点赞评论。
    
- **海量数据存储**：需要存储和处理TB/PB级别的数据，如日志、物联网传感器数据。
    
- **对一致性要求不高**：可以接受数据的短暂不一致，以换取极高的性能和可用性。
    

### 总结

这四张图连起来，清晰地揭示了 SQL 和 NoSQL 的根本差异：

- **SQL**像一本**结构严谨的百科全书**，强调**规矩、精确和一致性**，是处理严谨、关联性强的结构化数据的首选。
    
- **NoSQL**像一本**随时可涂鸦的速写本**，强调**速度、灵活和可扩展性**，是应对海量、多变、高并发数据需求的利器。
    

**现代应用开发中，两者不是取代关系，而是互补关系**。很多大型系统都采用**混合架构**，使用 SQL 处理核心交易数据，使用 NoSQL 处理缓存、日志、用户画像等场景，充分发挥各自优势。



## Redis 
### Redis的常见作用
- **作为缓存（Cache）**：在`sendCode`方法中，将验证码以 `String`类型存入Redis，并设置键名 `LOGIN_CODE_KEY + phone`。这是一种标准的K-V缓存模式，读写速度快，适合存储临时数据。[[Redis作为缓存使用]]
    
- **作为会话存储（Session Store）**：在`login`方法中，将登录用户信息以 `Hash`类型存入Redis，并设置过期时间（TTL）。键名为 `LOGIN_USER_KEY + token`。这实现了**分布式会话**，用户状态不再依赖于服务器的本地内存，而是集中存储在Redis中，非常适合集群部署。
	- 如果存在Session中,后期会为了提高负载能力而使用多台tomcat服务器,所以不能保证每次请求都在相同服务器,因此也不能确保Session都存在。如果考虑多台服务器之间复制，则又太浪费内存。因此使用redis实现分布式会话。
	- ![[f88f8abec92d87b6bdb72d1488814205.jpeg]]
- Redis实现分布式锁 ---Redisson
- Redis实现消息队列--[[Redis Stream]]
### [[Redis的数据清理机制]]
### [[ Redis的通用命令]]
### 常见数据类型
#### [[redisObject]]
#### [[String]]
#### [[Hash]]
#### [[List]]
#### [[Set]]
#### [[SortedSet]]
#### [[Redis Stream]]
#### [[Redis GEO]]
#### [[Redis BitMap]]
#### [[Redis HyperLogLog]]

### Redis高级功能
#### [[Redis 分布式缓存]]
#### 多级缓存

### SpringBoot中使用Redis
##### [[SpringDataRedis]]
### Redis的最佳实践
#### [[Redis键值设计]]
#### [[Redis批处理]]
#### 服务端优化
#### 集群的最佳实践