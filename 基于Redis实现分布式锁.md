## 基本要求
### 分析获取锁的需求和解决方法
1. 要求：加锁要保证互斥性
	- 实现指标：只有一个客户端能成功
	- 实现方式：使用setnx，获取成功则返回1，获取失败（已存在）则返回0
2. 避免死锁
	- 实现指标：即使客户端崩溃，锁也能自动释放
	- 实现方式：设置TTL（避免持有并等待的现象出现）

![[Pasted image 20251119135957.png]]

 ![[Pasted image 20251119140903.png]]
![[Pasted image 20251119141250.png]]

### 分析释放锁的需求和解决方法
1. 要求：不能释放不是自己的锁
	- 现象出现的原因：![[Pasted image 20251119141844.png]]
		- 为什么会出现不是自己的锁：业务执行阻塞，锁由于过期而被释放（TTL），之后新的线程由重新获取了锁
		- 为什么会释放了不是自己的锁：当业务执行完成后，要执行释放锁的命令，因为锁的key是一样的，所以释放了不是自己的锁
	- 解决方法：在释放锁的时候要看看锁的标识，是否与自己的一致，这样就能避免误删别人的锁![[Pasted image 20251119142210.png]]
		- 数据结构：这个锁的值（key-value的value）会存放一个标识
			- 标识的生成：uuid（随机数）+“-”+线程id拼接而成（只使用线程id可能会出现相同的，要实现不同线程标识肯定不一样）![[Pasted image 20251119142700.png]]![[Pasted image 20251119142801.png]]
2. 要求：释放锁的过程要原子性
	- 背景：我们采用先判断这个锁是不是自己的，再释放锁，即“先判断后执行”的模式，再这个窗口期可能会使得锁超时过期而被别人获取，从而又导致自己误删别人的锁![[Pasted image 20251119143411.png]]
	- 解决方案：使用[[lua脚本]]，原子性地执行先判断后执行![[Pasted image 20251119145747.png]]
		- Redis执行Lua脚本是原子的
## 拓展需求--使用[[Redisson]]
![[Pasted image 20251119151423.png]]
### 实现可重入
### 实现[[重试获取锁]]
### 实现[[看门狗默认时间]]避免超时释放
### 实现[[联锁]]保证主从一致


