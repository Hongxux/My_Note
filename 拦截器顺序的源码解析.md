好的，我们来深入分析 Spring MVC 拦截器的源码，这能从根本上理解其精确的执行顺序和设计哲学。整个流程的核心在 `DispatcherServlet`的 `doDispatch()`方法中。

为了直观把握整个流程，下图描绘了拦截器核心方法在**正常情况**与**异常情况**下的完整执行序列与逻辑分支：

```
sequenceDiagram
    participant D as DispatcherServlet
    participant HI as HandlerInterceptor
    participant HM as HandlerMethod
    participant HV as View (渲染)

    Note over D: doDispatch() 流程开始

    D->>HI: 1. 按序调用 applyPreHandle()
    Note right of HI: 遍历调用所有Interceptor的<br>preHandle()方法

    HI-->>D: 若某个preHandle返回false
    Note left of D: 2. 流程中断触发<br>（任一preHandle返回false）
    D->>HI: triggerAfterCompletion()<br>（逆序回调已成功的Interceptor的afterCompletion）
    D-->>D: 返回，结束处理

    HI-->>D: 所有preHandle返回true
    D->>HM: 3. 调用目标HandlerMethod
    Note right of HM: 执行Controller中的方法

    HM-->>D: 正常返回ModelAndView
    D->>HI: 4. 逆序调用 applyPostHandle()
    Note right of HI: 遍历调用所有Interceptor的<br>postHandle()方法

    D->>HV: 5. 渲染视图（processDispatchResult）
    HV-->>D: 渲染完成（成功或异常）

    D->>HI: 6. 最终逆序调用 triggerAfterCompletion()
    Note right of HI: 无论成功或异常，都会触发<br>（但仅会触发preHandle成功的Interceptor）

    Note over D: doDispatch() 流程结束
```

下面，我们结合源码中的关键代码段，来深入理解这个流程。

### 二、 源码分析：`doDispatch`方法中的拦截器链

在 `DispatcherServlet`类中，处理请求的核心方法是 `doDispatch`。以下是其中与拦截器相关的关键代码片段（基于 Spring Framework 5.x，为清晰起见进行了简化和注释）：

```
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    // ... 前置代码（初始化等）...
    try {
        // 1. 根据请求获取处理执行链（包含目标Controller和所有拦截器）
        HandlerExecutionChain mappedHandler = getHandler(processedRequest);
        
        // ... 其他处理 ...

        // 2. 【关键点1】按顺序调用所有拦截器的 preHandle 方法
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            // 如果任何一个 preHandle 返回 false，则直接返回，中断流程
            return;
        }

        // 3. 如果所有 preHandle 都返回 true，才真正调用目标Controller的方法
        ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

        // 4. 【关键点2】逆序调用所有拦截器的 postHandle 方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);

    } catch (Exception ex) {
        // ... 异常处理 ...
    } finally {
        // 5. 【关键点3】无论成功与否，最终都会逆序触发 afterCompletion
        if (mappedHandler != null) {
            // 注意：这里传入的是当前执行的结果（可能包含异常）
            mappedHandler.triggerAfterCompletion(processedRequest, response, null);
        }
    }
}
```

### 三、 深入 `HandlerExecutionChain`的三个核心方法

上面的 `mappedHandler`是 `HandlerExecutionChain`类型，它是持有**目标处理器**（你的Controller方法）和**所有拦截器列表**的包装类。它的三个方法实现了拦截器的核心逻辑。

#### 1. `applyPreHandle()`方法 - 顺序执行 `preHandle`

```
boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
    // 获取配置的所有拦截器
    HandlerInterceptor[] interceptors = getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        // 按配置顺序（i从0开始）遍历所有拦截器
        for (int i = 0; i < interceptors.length; i++) {
            HandlerInterceptor interceptor = interceptors[i];
            // 调用当前拦截器的 preHandle 方法
            if (!interceptor.preHandle(request, response, this.handler)) {
                // 如果返回 false，立即触发逆序的 afterCompletion
                triggerAfterCompletion(request, response, null);
                return false; // 中断执行
            }
            // 记录当前拦截器的索引，用于后续的逆序回调
            this.interceptorIndex = i;
        }
    }
    return true; // 全部成功，放行
}
```

**逻辑**：顺序遍历，一旦某个 `preHandle`返回 `false`，就立即逆序回调之前已经成功执行的拦截器的 `afterCompletion`，然后中断整个流程。

#### 2. `applyPostHandle()`方法 - 逆序执行 `postHandle`

```
void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception {
    HandlerInterceptor[] interceptors = getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        // 注意：这里是逆序遍历（i从最后开始）
        for (int i = interceptors.length - 1; i >= 0; i--) {
            HandlerInterceptor interceptor = interceptors[i];
            // 调用当前拦截器的 postHandle 方法
            interceptor.postHandle(request, response, this.handler, mv);
        }
    }
}
```

**逻辑**：只有所有 `preHandle`都成功且目标控制器方法也成功执行后，才会执行此方法。它按**配置顺序的逆序**调用所有拦截器的 `postHandle`方法。

#### 3. `triggerAfterCompletion()`方法 - 逆序执行 `afterCompletion`

```
void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) throws Exception {
    HandlerInterceptor[] interceptors = getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        // 注意：同样是逆序遍历，但只遍历到最后一个成功执行的拦截器（interceptorIndex）
        for (int i = this.interceptorIndex; i >= 0; i--) {
            HandlerInterceptor interceptor = interceptors[i];
            try {
                // 调用当前拦截器的 afterCompletion 方法
                interceptor.afterCompletion(request, response, this.handler, ex);
            } catch (Throwable ex2) {
                logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
            }
        }
    }
}
```

**逻辑**：

- 在 `finally`块中调用，**无论请求处理成功还是出现异常，都会执行**。
    
- 它只逆序回调那些 `preHandle`返回了 `true`的拦截器（从 `interceptorIndex`开始逆序）。
    
- 如果控制器方法执行抛出异常，该异常会通过 `ex`参数传递给每个 `afterCompletion`方法。
    

### 四、 总结：设计哲学与启示

通过源码分析，我们可以总结出 Spring 拦截器执行顺序的设计哲学：

1. **`preHandle`- “安检”流程**：顺序执行，任何一个环节不通过，立即终止并启动“善后”流程（逆序执行已通过环节的 `afterCompletion`）。这保证了资源的正确释放。
    
2. **`postHandle`- “后处理”流程**：只在完全成功时执行，且顺序是“后配置的先执行”，这是一种栈式的后进先出（LIFO）逻辑，确保资源清理顺序与申请顺序相反。
    
3. **`afterCompletion`- “善后”流程**：在 `finally`块中执行，保证了**绝对会被调用**，类似于 `try-catch-finally`中的 `finally`，用于进行最终的资源清理、日志记录等操作，是系统健壮性的重要保障。
    

**简单来说，拦截器的执行顺序设计体现了“安全第一”和“资源管理”的原则**：前置检查严格且可中断，后处理有序，最终清理绝对可靠。理解这一点，就能真正掌握拦截器的精髓。