
|层面|关键技术|解决的核心问题|
|---|---|---|
|​**前端/网关**​|CDN、限流、防刷、Token 机制|​**流量消峰**，拦截无效请求，保护后端集群。|
|​**核心服务**​|​**Redis（原子操作）​**、**消息队列**​|​**异步化、排队**，将瞬时高并发转为平稳处理，解决超卖。|
|​**数据持久化**​|数据库行锁、最终一致性、分库分表|​**数据准确性**，保证库存和订单的最终正确。|

​**简单来说，处理抢购高并发的哲学是：​**​

​**​“不要硬抗，而要疏导和分层过滤”​**。通过层层削减，将一场“洪水”变为“溪流”，让系统核心数据库能够平稳处理。这套架构方案是经过无数大厂实战验证的、支撑“双十一”、“618”等顶级流量场景的成熟方案。

### 核心设计思想：化“同步突击”为“异步排队”

​**核心目标**​：​**尽量减少直接打到数据库上的瞬时并发请求**。数据库是系统中最脆弱、最难扩展的部分。

​**实现思路**​：将一个复杂的“秒杀”过程拆解成多个步骤，并通过各种技术手段，将流量层层削减，最终让数据库以它能承受的平稳速率处理请求。

---

### 一、 前端层面：第一道防线，流量消峰

目标：在请求到达服务器之前，拦截掉无效和部分流量。

1. ​**静态资源 CDN 化**​
    
    - ​**措施**​：将商品图片、详情页静态 HTML、CSS/JS 等资源放到 CDN 上。用户请求这些资源时，直接从最近的 CDN 节点获取，​**不占用后端服务器的带宽和计算资源**。
        
    
2. ​**按钮防重复提交与灰度计数**​
    
    - ​**措施**​：在用户点击“抢购”后，立即通过 JavaScript 将按钮置为灰色禁用，防止用户疯狂点击。同时，在页面上显示“排队中”或近似剩余数量（非精确），缓解用户焦虑。
        
    
3. ​**恶意请求拦截**​
    
    - ​**措施**​：在页面展示时，对商品ID进行加密或生成一个一次性的 `token`。用户发起抢购请求时必须带上这个 `token`，服务器端校验其有效性。这可以防止用户直接写脚本模拟请求。
        
    

---

### 二、 网关/接入层：第二道防线，限流与过滤

目标：对入口流量进行统一管控。

1. ​**限流**​
    
    - ​**措施**​：在网关层（如 Nginx、API Gateway）对秒杀接口实施**限流**。例如，使用**令牌桶**或**漏桶算法**，将每秒的请求数限制在系统能承受的范围内（如 1 万/秒），超出部分的请求直接返回“服务器繁忙”等友好提示。
        
    - ​**技术**​：Nginx 的 `limit_req`模块、Spring Cloud Gateway 的 RequestRateLimiter 过滤器。
        
    
2. ​**防刷**​：
    
    - ​**措施**​：基于 IP、用户ID等维度，设置短时访问频率阈值，拦截恶意刷接口的行为。
        
    

---

### 三、 核心业务层：第三道防线，异步化与排队

这是最关键的一层，核心是：​**快速校验，异步下单**。

1. ​**库存校验与扣减 - 使用 Redis**​
    
    - ​**问题**​：如果直接查询数据库校验库存，大量请求会瞬间打垮数据库。
        
    - ​**方案**​：将商品库存提前加载到 ​**Redis**​ 中。因为 Redis 是内存操作，性能极高（可达 10W+/秒 QPS）。
        
    - ​**关键**​：库存扣减必须在 Redis 中**原子性**地完成。
        
        - ​**使用 Lua 脚本**​：将“判断库存是否大于0”和“扣减库存”这两个操作写在一个 Lua 脚本中，确保原子性执行，避免超卖。
            
        
        ```
        -- 伪代码示例
        if (redis.call('get', stock_key) > 0) then
            return redis.call('decr', stock_key) -- 原子性减1
        else
            return 0
        end
        ```
        
    
2. ​**请求异步化 - 使用消息队列**​
    
    - ​**流程**​：
        
        - ​**步骤1**​：网关和 Redis 过滤后，少量的“抢购资格”请求到来。
            
        - ​**步骤2**​：服务端完成 Redis 库存原子扣减。​**扣减成功后，并不代表下单成功，只代表用户获得了下单资格**。
            
        - ​**步骤3**​：立即返回用户“抢购排队中，结果稍后通知”，同时将生成订单的请求信息发送到**消息队列**​（如 RabbitMQ、RocketMQ、Kafka）中。至此，用户的等待结束。
            
        - ​**步骤4**​：后端的订单处理服务，以平稳的速度从消息队列中消费消息，逐个完成创建订单、支付等后续复杂的业务逻辑。
            
        
    - ​**价值**​：​**消息队列起到了“削峰填谷”的作用**，将瞬时的高并发请求转换成平稳的异步处理，保护了数据库。
        
    

---

### 四、 数据库层：最后保障，最终一致性

目标：保证数据最终的正确性。

1. ​**数据库优化**​
    
    - ​**库存扣减**​：即使使用了 Redis，数据库仍是库存的“唯一可信数据源”。订单服务在处理消息时，还需要在数据库中完成最终的库存扣减。此时，数据库的并发压力已经很小。
        
    - ​**优化手段**​：使用 `UPDATE product SET stock = stock - 1 WHERE product_id = ? AND stock > 0`这样的 SQL，利用数据库的**行锁**来保证最终库存不会超卖。
        
    
2. ​**分库分表**​
    
    - ​**场景**​：对于海量订单，可以对订单表进行分库分表，分散数据库的读写压力。
        
    

