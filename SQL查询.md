查询的执行数据
- **流水线**：先**锁定数据源（FROM）并连接（JOIN）**，然后**筛选行（WHERE）**，接着**分组（GROUP BY）并筛选组（HAVING）**，再**选择并计算要展示的列（SELECT）**，最后**排序（ORDER BY）和限制返回数量（LIMIT）**。

|执行顺序|关键字|核心任务与说明|
|---|---|---|
|1|**FROM**​|确定数据来源，如果有多张表，会先进行**笛卡尔积**，生成一个庞大的虚拟表。|
|2|**ON**​|应用 **JOIN**​ 的连接条件，过滤掉不符合条件的数据行。|
|3|**JOIN**​|根据指定的连接类型（如 LEFT JOIN），将未匹配到的行（外部行）添加到当前虚拟表中。|
|4|**WHERE**​|对来自 **FROM**​ 和 **JOIN**​ 后的虚拟表进行**行级过滤**。此阶段不能使用聚合函数（如 SUM, COUNT）。|
|5|**GROUP BY**​|按照指定的列对过滤后的数据进行**分组**。|
|6|**HAVING**​|对 **GROUP BY**​ 分组后的结果进行**组级过滤**。**只有在这里才能使用聚合函数作为条件**。|
|7|**SELECT**​|**选择**​ 需要返回的列或表达式，并可以定义字段的**别名**。注意，别名在此步骤之后才生效。|
|8|**DISTINCT**​|对 **SELECT**​ 的结果集进行**去重**。|
|9|**ORDER BY**​|对最终的結果集进行**排序**。|
|10|**LIMIT/OFFSET**​|**限制**​ 返回的行数，常用于分页。|
- **WHERE 与 HAVING 的根本区别**
	- **WHERE**​ 
		- 时机：在分组前（**GROUP BY**​ 之前）
			- 它不能包含聚合函数。
		- 数据粒度：过滤**单条一条的记录**。
	- **HAVING**​ 
		- 时机：在分组后（**GROUP BY**​ 之后）
			- 通常与聚合函数一起使用
		- 数据粒度：过滤**由多条记录组成的组**
- 别名的作用域
	- 由于 **SELECT**​ 子句在执行顺序中相对靠后，在它之前执行的子句（如 **WHERE**, **GROUP BY**, **HAVING**）**不能使用**在 **SELECT**​ 中定义的别名。但之后执行的子句（如 **ORDER BY**）可以

---
编写SQL的思考路径

1. 分析数据结构
	- **确认表名和字段**
	- **理解表间关系**：如果要查多个表，必须搞清楚它们是怎么关联的，这是写对 `JOIN` 的关键
2.  拆解查询逻辑，从“源头”开始写，按照SQL的执行顺序来构建查询
	1. FROM & JOIN（确定数据来源）‍ ：
		- 先写要从哪个或哪些表取数据。
		- 如果需要连接，就把 `JOIN` 和 `ON` 条件一起写好。
	2. WHERE（过滤行）‍：写过滤条件
	3. GROUP BY & HAVING
		- 前提：需要汇总数据（使用聚合函数）
		- `HAVING` 是对分组后的结果进行过滤。
	4. SELECT：确定最终要返回哪些字段
		- 可以计算聚合函数或使用别名
	5. ORDER BY（排序）‍：指定结果的排序方式
	6.  LIMIT/OFFSET（限制条数）‍：如果只需要前几条，最后加上。
3. 处理复杂需求，善用高级功能
	- **子查询**：当一步查询无法完成时，可以分步思考，比如“先找出某个条件下的集合，再从这个集合里查”。
		- 如果子查询语法复杂，考虑使用WITH语法，引入[[公共表表达式|公共表]]
	- **[[窗口函数]]**：遇到“排名”、“累计求和”、“移动平均”这类问题
	-  **[[CASE WHEN语法]]**：用于条件判断和分类，非常灵活。
	- **常见[[函数|函数]]**：字符串处理、日期计算等，根据需要使用。
	   