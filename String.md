Sring（字符串）是 Redis 中最基本、最常用的数据类型。你可以将其理解为一个键值对（key-value），其中 key 永远是字符串类型，而 value 在 String 类型中，可以是**字符串、整数或浮点数**。最重要的是，Redis 的 String 是**二进制安全**的，这意味着它可以存储任何形式的字节数据，包括文本、JSON、图片或序列化后的对象，其最大容量为 **512MB**。

|特性维度|说明|
|---|---|
|**存储内容**|文本、数字（整数/浮点数）、二进制数据（如图片、序列化对象）|
|**最大容量**|512 MB|
|**关键特性**|二进制安全（可存储任意格式数据）、所有操作均为原子性|
|**经典场景**|缓存、计数器、分布式锁、Session存储|

### 🔍 底层设计与高效原理
String 类型的底层实现是 **SDS (Simple Dynamic String，简单动态字符串)**

| SDS结构组成部分   | 数据类型          | 说明                                                                                  |
| ----------- | ------------- | ----------------------------------------------------------------------------------- |
| **`len`**   | `int`(或适配的整型) | 记录 `buf`数组中**已使用的字节数量**，即字符串的实际长度。这使得获取字符串长度的时间复杂度为 **O(1)**<br><br>。               |
| **`free`**  | `int`(或适配的整型) | 记录 `buf`数组中**未使用的字节数量**。此属性是实现空间预分配和惰性空间释放优化的关键<br><br>。                            |
| **`buf[]`** | `char[]`      | **柔性数组**，真正用于存储字符串数据的字节数组。其末尾会自动追加空字符 `'\0'`，以兼容部分 C 标准库函数，但这个空字符不计入 `len`<br><br>。 |

SDS 的结构设计使其相比 C 语言原生字符串更具优势，这也是 Redis 高效的重要原因之一：
- **常数时间复杂度获取长度**：SDS 结构内部维护了 `len`属性，直接记录字符串长度，使 `STRLEN`命令时间复杂度为 O(1)。
- **杜绝缓冲区溢出**：进行修改操作时，SDS 会先检查空间是否充足，并自动扩容。
- **减少内存重分配**：通过**空间预分配**（扩容时会多分配一些空间）和**惰性空间释放**（缩短字符串时不立即释放多余空间）策略，减少昂贵的内存重分配次数。
- **二进制安全**：依靠 `len`属性而非空字符 `\0`来判断字符串结束，因此可以安全存储任意二进制数据。

为了进一步优化内存，Redis会根据存储的值自动选择三种编码方式：

| 编码方式（encoding） | 触发条件                             | 特点与优势                                             |
| -------------- | -------------------------------- | ------------------------------------------------- |
| **`int`**      | 存储的值是**8字节长整型范围内的整数**            | 直接将数值存储在指针位置，无需SDS，效率最高                           |
| **`embstr`**   | 存储的字符串长度**小于等于44字节**（Redis 5.0+） | `redisObject`和SDS结构分配在**一块连续内存**，只需一次内存分配，缓存局部性更好 |
| **`raw`**      | 存储的字符串长度**大于44字节**               | `redisObject`和SDS结构存放在**两块独立内存**，适用于大字符串          |

> 注意：`embstr`编码是只读的。一旦对其进行修改，无论结果是否超过44字节，都会被转换为`raw`编码。

44字节
![[Pasted image 20251125162047.png]]
####  embstr的优势详解

`embstr`编码的优势完全源于其“嵌入式”的连续内存布局：

1. **内存分配效率翻倍**
    
    创建和销毁一个 `embstr`编码的字符串对象，内存分配器只需要进行一次分配和一次释放。而 `raw`编码则需要分别为 `redisObject`和 `SDS`进行两次分配和两次释放。对于需要频繁创建和销毁的大量短字符串（例如缓存键、临时计数器），**减少一半的内存管理操作能显著降低系统开销**。
1. **极致利用CPU缓存**
    
    由于 `redisObject`和字符串数据在内存中是紧密相邻的，当程序访问这个对象时，CPU有很大概率能通过一次缓存行（Cache Line）加载就将所有相关数据读取到高速缓存中。这大大减少了CPU等待数据从主内存传输的时间，**提升了数据访问速度。这种优化对于Redis这种对速度要求极高的内存数据库来说至关重要。
#### ⚖️ 为何不全部使用embstr？

既然 `embstr`效率更高，为什么不对所有字符串都使用它呢？这主要是基于对**修改开销**和**内存重分配风险**的考量。

`embstr`被设计为**只读**的。当你尝试修改一个 `embstr`编码的字符串时（即使是追加一个字符），Redis 会先将其编码转换为 `raw`，然后再执行修改。修改后的对象即使长度又变回了44字节以内，也**不会再转回 `embstr。
	这样设计的原因是，如果修改一个 `embstr`字符串导致其长度增加，原本预分配的连续内存块可能无法容纳新的数据。为了保证数据的完整性，最稳妥的方式就是**重新分配一块足够大的内存**。这个过程本质上和创建一个新的 `raw`编码字符串没有区别。因此，Redis 直接选择在修改时转换为 `raw`，一劳永逸地避免了对复杂边界条件的处理。

对于长字符串，其修改的可能性相对更大，如果使用 `embstr`，一旦发生修改，其连续内存结构的优势会立即丧失，而之前分配连续大块内存的成本却更高。因此，Redis 选择直接使用更灵活、更适合修改的 `raw`编码来存储长字符串。
### ⚙️ 核心命令与使用示例

String类型的命令非常丰富，可以分为几个功能类别。

#### 1. 基本值的设置与获取

- **`SET key value`**/ **`GET key`**: 最基础的设置和获取值。
    
- **`MSET key1 value1 key2 value2...`**/ **`MGET key1 key2...`**: 批量设置或获取多个键值对，能有效减少网络往返时间，提升效率。
    
- **`SETNX key value`**: **当且仅当key不存在时**才设置值。这是实现**分布式锁**的基石命令。
    
- **`SETEX key seconds value`**: 设置值的同时，指定其过期时间（秒级）。
    

**示例：基础操作与分布式锁**

```
> SET name "Alice"
OK
> GET name
"Alice"
> MSET age 30 city "Beijing"
OK
> MGET name age city
1) "Alice"
2) "30"
3) "Beijing"
> SETNX my_lock "unique_identifier"  # 尝试获取锁
(integer) 1  # 获取成功
> SETNX my_lock "another_identifier"
(integer) 0  # 获取失败，因为锁已存在
> SETEX user_session:123 3600 "session_data"  # 设置会话，1小时后过期
OK
```

#### 2. 数字操作

String类型可以直接对数字进行原子性的增减操作，非常适合计数场景。

- **`INCR key`**/ **`DECR key`**: 将key中存储的数字值增加1/减少1。
    
- **`INCRBY key increment`**/ **`DECRBY key decrement`**: 按指定步长增减。
    
- **`INCRBYFLOAT key increment`**: 增加一个浮点数。
    

**示例：文章点赞计数**

```
> SET article:1001:likes 0
OK
> INCR article:1001:likes  # 用户点赞
(integer) 1
> INCRBY article:1001:likes 5  # 批量点赞（例如分享带来的增长）
(integer) 6
> DECR article:1001:likes  # 用户取消点赞
(integer) 5
```

#### 3. 字符串操作

- **`APPEND key value`**: 向指定key的值后追加字符串。
    
- **`GETRANGE key start end`**: 获取字符串的子串，支持负数索引（-1表示最后一个字符）。
    
- **`SETRANGE key offset value`**: 从指定偏移量开始，覆盖原字符串的一部分。
    
- **`STRLEN key`**: 获取字符串值的长度。
    

**示例：字符串操作**

```
> SET msg "Hello"
OK
> APPEND msg ", World!"
(integer) 13
> GET msg
"Hello, World!"
> GETRANGE msg 0 4
"Hello"
> STRLEN msg
(integer) 13
```

### 💡 主要应用场景

1. **缓存（Cache）**
    
    这是String最典型的用途。将数据库查询结果、复杂计算结果等序列化（如JSON格式）后存入Redis，后续请求可直接读取，极大提升响应速度，降低后端压力。通常会给缓存设置过期时间（使用`SETEX`或`SET key value EX seconds`）。
    
2. **计数器（Counter）**
    
    利用`INCR`、`DECR`等命令的**原子性**，可以安全地实现文章阅读量、视频播放次数、用户点赞数、网站访问量等统计，无需担心多线程或多进程环境下的并发问题。
    
3. **分布式锁（Distributed Lock）**
    
    利用`SETNX`的互斥特性（只有key不存在时才能设置成功），可以实现简单的分布式锁。通常配合过期时间（`PX`参数）使用，防止锁无法释放。
    
    ```
    SET lock:resource001 "unique_identifier" NX PX 10000  # 获取锁，并设置10秒过期
    ```
    
4. **共享Session（Session Store）**
    
    在分布式或集群环境中，将用户登录状态（Session）集中存储在Redis中，可以解决Session一致性问题，实现单点登录。
    

### ⚠️ 使用注意事项

- **值的大小**：虽然最大支持512MB，但作为缓存时，建议存储较小的热点数据。过大的value会占用大量内存和网络带宽，可能阻塞服务，影响其他请求的响应速度。
    
- **键名设计**：建议使用清晰的命名规范，如`业务名:对象名:唯一标识[:属性]`（例如`shop:user:1001:name`），这有助于管理和防止键冲突。
    
- **编码转换**：注意，对`embstr`编码的字符串进行任何修改操作，都会使其转换为`raw`编码，且不可逆。
    

希望这份详细的介绍能帮助你全面掌握Redis的String数据类型。如果你对特定命令或场景有更深入的疑问，我们可以继续探讨。