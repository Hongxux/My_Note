---
aliases:
  - Semaphores
  - Semaphore
---
- 需求背景：
	- ReentrantLock互斥锁是保证只有一个线程能访问资源
	- 但是有的场景是有多个线程同时访问一个资源池（有多个资源）
		- 此时需要实现的不是资源的互斥访问
		- 而是资源访问的并发量控制
		- 示例：一个只有**3个连接**的数据库连接池，却可能面临**10个线程**同时需要数据库连接的情况。如果放任所有线程同时竞争，会导致连接超时、响应缓慢甚至系统崩溃
- 解决措施：信号量
	- 控制并发线程数（共享模式），通过 “许可数” 限制同时访问资源的线程数。
- 实现原理：基于 AQS 的实现逻辑
	- 同步状态（state）定义 ：**可用许可数**（int 类型）
		- state>0：有可用许可，线程可获取；
		- state=0：无许可，线程入队阻塞。
	- 核心钩子方法实现（共享模式）：
	  
	  - **tryAcquireShared（共享获取）**：
	    CAS 将 state 减 N（N = 获取的许可数），若 state≥0 则成功（返回剩余许可数）；否则失败（返回 - 1），入队阻塞；
	- **tryReleaseShared（共享释放）**：
	    CAS 将 state 加 N，返回 true 触发 AQS 的`doReleaseShared`（唤醒传播），链式唤醒等待的线程。
	- 关键设计：
		- 公平 / 非公平：和 ReentrantLock 类似，公平模式先检查队列，非公平直接抢许可；
		- 共享唤醒：释放许可后，AQS 的`doReleaseShared`链式唤醒多个等待线程（直到许可耗尽）