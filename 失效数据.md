

### 导读和引入

嗨，欢迎继续阅读！这一节我们聚焦于“失效数据”，这是并发编程中一个常见但容易忽略的问题。从前面章节（如第2章可能介绍了线程基础和可见性问题）来看，你已经知道多线程环境下数据共享的风险；这一节深入探讨**缺乏同步时数据“过期”的具体表现**，为后面章节（如第3.2节可能介绍同步机制）打下基础。作者在这里的目的是通过生动示例（如NoVisibility和MutableInteger）**揭示失效数据的危害**，**强调同步的必要性**——它本质上是**性能优化（如编译器重排序）带来的副作用**，但通过同步（如synchronized）可以解决。作者的组织逻辑是：先定义概念，再展示问题示例，最后给出解决方案。注意，失效数据不是新技术的替代，而是对单线程编程的“增强”中暴露的弱点，容易与“内存可见性”混淆（后者更广义，失效数据是具体表现）。

新名词解释：

- ​**失效数据**​：当线程读取共享变量时，可能得到过期的值（由于缺乏同步，如缓存或重排序导致）。示例：在NoVisibility中，读线程可能看到ready变量的旧值，导致程序行为错误。
    
- ​**同步**​：通过机制（如synchronized）确保线程间操作顺序一致，避免数据不一致。示例：SynchronizedInteger使用synchronized方法保证get/set的原子性。
    

现在，我们按照作者的文章逻辑来生成问题。文章先介绍失效数据的概念和危害，然后通过NoVisibility示例说明，接着讨论MutableInteger的非线程安全问题，最后展示SynchronizedInteger的解决方案。请带着这些问题阅读正文，它们直指核心，顺序与文章一致，能帮你保持专注。

​**先说明失效数据的概念、产生原因和潜在危害；**​

1. 什么是失效数据？为什么在缺乏同步的程序中容易出现失效数据？
    **失效数据**是线程在缺乏同步时读取到的过期变量值
    **原因：** 由于J**VM允许编译器**或**CPU**对操作**重排序和缓存值**（如第16章细节），导致数据不一致。出现原因包括多核处理器下的优化行为。
2. 失效数据可能导致哪些具体的危险后果（如安全問題或活跃性问题）？
    

​**然后通过NoVisibility示例展示失效数据的实际表现；接着讨论MutableInteger的非线程安全设计；**​

1. NoVisibility示例中，失效数据是如何体现的？它为什么会导致程序输出错误或无法结束？
    危害包括：输出错误值、程序无法结束、意外异常、数据结构破坏、不精确计算或无限循环，在Web应用可能不严重，但其他场景会引发安全问题。
2. MutableInteger为什么是非线程安全的？仅对set方法进行同步是否足够，为什么？
	NoVisibility示例中，读线程查看ready变量可能得到失效值，导致输出错误或循环无法终止，因为值更新不可见。

​**最后介绍通过同步解决失效数据的SynchronizedInteger示例，并强调关键点。​**​

1. 如何通过同步使MutableInteger变为线程安全？SynchronizedInteger的设计关键是什么？
    通过对get和set都添加**synchronized关键字**，使SynchronizedInteger线程安全，**确保每次访问都同步**，避免失效值。

