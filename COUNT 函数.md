原理
count是用来统计有效行数的函数
- 有效行数：**选定的字段是非空**

| 用法                | 含义                                     | 是否统计 NULL | 性能说明                                           |
| ----------------- | -------------------------------------- | --------- | ---------------------------------------------- |
| ​**`COUNT(*)`**​  | 统计所有行数（包括 NULL 行）。                     | 是         | InnoDB 中需扫描表，但优化器会优先选择最小的索引。                   |
| ​**`COUNT(主键)`**​ | 统计主键字段非 NULL 的行数（主键必非 NULL，故等价于总行数）。   | 否         | 与 `COUNT(*)`效果相同，但可能略慢，因为需检查主键值。               |
| ​**`COUNT(字段)`**​ | 统计指定字段非 NULL 的行数。                      | 否         | 如果字段有索引，可能使用索引扫描；否则全表扫描。                       |
| ​**`COUNT(1)`**​  | 统计常量表达式非 NULL 的行数（1 永远非 NULL，故等价于总行数）。 | 否         | 性能与 `COUNT(*)`类似，但推荐使用 `COUNT(*)`（更符合 SQL 标准）。 |

- `COUNT(字段)`需要**传值 + 判空**，开销最大。
- `COUNT(主键)`需要**传值**，开销次之。
- `COUNT(1)`和 `COUNT(*)`​**不传值**，只计数，开销最小。

---
1. 优先使用 `COUNT(*)`：
    - 它是 SQL 标准写法，清晰表达“统计行数”的意图，且现代优化器会高效处理。
    - 避免使用 `COUNT(字段)`除非需排除 NULL 值。
        
2. ​InnoDB 表的优化方法​：
    - ​索引优化​：为经常用于 `WHERE`条件的字段创建索引，使 `COUNT`能利用索引扫描（如 `WHERE status = 'active'`时，索引 on `status`可加速）。
    - ​避免全表扫描​：如果表很大，`COUNT(*)`可能较慢，考虑使用近似值（如从信息模式表 `information_schema.tables`获取估算值）或业务层缓存。
    - MySQL 8.0+：通过调整参数 `innodb_parallel_read_threads`来增加扫描线程数。但需注意，社区版目前主要支持主键的并行扫描
3. 考虑换一个数据库
	- **MyISAM 引擎**​：
	    - 将表的总行数直接存储在磁盘上（在元数据中）。
	    - 执行 `COUNT(*)`时，直接返回这个预存的值，​**效率极高**，时间复杂度为 O(1)。
	    - 但注意：如果查询包含 `WHERE`条件，MyISAM 仍需逐行扫描。

	- ​**InnoDB 引擎**​：
	    - ​**不会预存总行数**，因为支持事务和并发控制，不同事务可能看到不同的行数（如 MVCC 机制）。
	    - 执行 `COUNT(*)`时，需要逐行读取数据（可能使用索引）并累积计数，​**效率较低**，时间复杂度为 O(n)。
	    - 优化：如果存在可用的二级索引，InnoDB 会优先扫描较小的二级索引来计数（因为二级索引叶子节点包含更少数据）。
​
