### 事务简介
事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

以银行转账为例，张三向李四转账1000元，这个操作包含三个步骤：

1. 查询张三账户余额
    
2. 将张三账户金额减少1000元
    
3. 将李四账户金额增加1000元
    

如果所有步骤都成功执行，则提交事务，数据永久生效。如果在任何步骤出现异常（如余额不足、系统故障等），则回滚事务，撤销所有已执行的操作，账户余额恢复到事务开始前的状态。

在MySQL中，默认情况下每条DML语句（如INSERT、UPDATE、DELETE）都会自动提交事务。可以通过设置autocommit参数为0来关闭自动提交，改为手动控制事务。

事务的典型操作包括：

- START TRANSACTION：开始事务
    
- COMMIT：提交事务
    
- ROLLBACK：回滚事务
    

通过事务机制，可以确保数据库操作的一致性，避免出现部分操作成功、部分操作失败导致的数据不一致情况。
![[Pasted image 20251029151044.png]]

### [[事务操作]]

### 事务四大特性
- 原子性（Atomicity）指事务是不可分割的最小操作单元，所有操作要么全部成功执行，要么全部失败回滚，不存在中间状态。

- 一致性（Consistency）要求事务完成后，数据库必须从一个一致状态转换到另一个一致状态，所有数据都符合预定义的规则和约束。

- 隔离性（Isolation）确保多个并发事务之间相互隔离，每个事务在独立环境下运行，不受其他事务的干扰，防止数据不一致。

- 持久性（Durability）表示事务一旦提交或回滚，其对数据库数据的修改就是永久性的，即使系统发生故障也不会丢失。
### 并发事务
#### 问题：
| 问题        | 描述                                                                                                  |
| :-------- | :-------------------------------------------------------------------------------------------------- |
| **脏读**    | 一个事务读到另外一个事务**还没有提交的**数据。                                                                           |
| **不可重复读** | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。（在一次事务A中可以查到另外一个事务B在事务A执行过程中提交的数据，导致同一事务内两次查询结果不一样）               |
| **幻读**    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了"幻影"。（查询的时候查不到，插入的时候又提示有：因为在这个事务A的过程中事务B插入了该数据并提交） |
|           |                                                                                                     |


##### 1. 脏读

- ​**定义**​：事务A读到了事务B**尚未提交**的数据。
    
- ​**经典示例**​：银行转账过程中的意外读取。
    

|时间序列|事务A（转账事务）|事务B（查询事务）|数据库中的金额（元）|
|---|---|---|---|
|T1|开始事务。||账户A: 1000， 账户B: 1000|
|T2|从账户A扣除100元 (`update A set money=900 where id=A`)。||账户A: ​**900**， 账户B: 1000|
|T3||开始事务。||
|T4||​**读取账户A的金额（读到了900元）​**。||
|T5|​**由于某种原因（如扣款失败），执行了回滚（rollback）​**。||账户A: 1000， 账户B: 1000|
|T6||提交事务。||
|T7||||

​**问题**​：事务B基于一个“脏数据”（900元）进行了业务逻辑判断，但这个数据从未真正生效过。如果事务B据此向用户展示了余额，就会造成误导。

##### 2. 不可重复读

- ​**定义**​：在同一个事务中，两次读取**同一条**记录，得到的结果不同。这是因为在两次读取之间，该记录被另一个**已提交**的事务修改了。
    
- ​**经典示例**​：银行系统在同一个事务内两次校验余额。
    

|时间序列|事务A（校验事务）|事务B（扣款事务）|账户A的余额（元）|
|---|---|---|---|
|T1|开始事务。||1000|
|T2|​**第一次读取账户A的余额**，结果是1000元。|||
|T3||开始事务。||
|T4||从账户A成功扣款100元 (`update A set money=900 where id=A`)。|​**900**​|
|T5||​**提交事务**。|900（已提交）|
|T6|​**第二次读取账户A的余额**，结果是**900元**。|||
|T7|提交事务。|||

​**问题**​：事务A在同一个事务内两次读取同一账户的余额，结果却不一致。这会导致事务A的逻辑产生混乱，无法进行可靠的重复校验。

##### 3. 幻读

- ​**定义**​：事务A根据相同条件两次查询，第二次查询看到了第一次查询中未出现的**新数据行**​（“幻影行”）。这是因为在两次查询之间，另一个**已提交**的事务插入了满足条件的新数据。
    
- ​**经典示例**​：统计公司总人数并为其新增部门。
    

|时间序列|事务A（统计与新增事务）|事务B（入职事务）|员工表|
|---|---|---|---|
|T1|开始事务。||已有5名员工|
|T2|​**查询员工总数**，`count(*)`结果为 5。|||
|T3||开始事务。||
|T4||插入一名新员工的记录 (`insert into employee ...`)。|6名员工|
|T5||​**提交事务**。|6名员工（已提交）|
|T6|准备将总人数（5）除以2，为公司创建2个新部门。|||
|T7|​**再次查询员工总数以确认**，`count(*)`结果变为 ​**6**​！|||
|T8|提交事务。|||

​**问题**​：事务A像出现了幻觉一样，发现数据行变多了。这会导致基于第一次查询结果所做的业务决策（如“创建2个新部门”）可能不再准确。幻读的重点在于**新增或删除**了数据行，而不可重复读的重点在于**修改**了已有的数据行。

##### 总结对比

| 问题          | 关注重点          | 操作类型                     |
| ----------- | ------------- | ------------------------ |
| ​**脏读**​    | 数据的**提交状态**​  | 读到了未提交的数据                |
| ​**不可重复读**​ | 同一数据行的**内容**​ | UPDATE（更新）操作             |
| ​**幻读**​    | 数据集的**行数**​   | INSERT（插入）或 DELETE（删除）操作 |


数据库的隔离级别（如读已提交、可重复读、序列化）就是为了解决这些不同层面的并发问题而设计的。
#### 解决方案：事务隔离级别 
权衡数据安全性和并发性：
	事务隔离级别是为了解决多个事务并发执行时可能引发的数据不一致问题。级别从低到高，数据一致性越强，但并发性能通常会降低。

---

##### 各隔离级别详解

图中的表格对比了四种隔离级别对三种典型问题的控制能力（`√`表示会出现，`×`表示不会出现）。

| 隔离级别                          | 脏读  | 不可重复读 | 幻读  | 解释                                                                      |
| ----------------------------- | --- | ----- | --- | ----------------------------------------------------------------------- |
| ​**Read Uncommitted（读未提交）​**​ | √   | √     | √   | ​**级别最低**。一个事务可以读取到另一个事务**未提交**的修改。存在所有并发问题，性能最好但数据一致性最差，很少使用。          |
| ​**Read Committed（读已提交）​**​   | ×   | √     | √   | 一个事务只能读取到其他事务**已经提交**的修改。解决了**脏读**，但可能发生不可重复读和幻读。这是**Oracle等数据库的默认级别**。 |
| ​**Repeatable Read（可重复读）​**​  | ×   | ×     | √   | 确保在同一个事务中，多次读取同一数据的结果是一致的。解决了脏读和不可重复读，但可能发生**幻读**。这是**MySQL的默认隔离级别**。   |
| ​**Serializable（可序列化）​**​     | ×   | ×     | ×   | ​**级别最高**。所有事务串行执行，完全隔离。解决了所有并发问题，但性能开销最大，因为并发性急剧下降。                    |

---

##### SQL 操作示例

图的下半部分提供了查看和设置事务隔离级别的SQL语句：

1. ​**查看当前事务隔离级别：​**​
    
    ```
    SELECT @@TRANSACTION_ISOLATION;
    ```
    
2. ​**设置事务隔离级别：​**​
    
    ```
    SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL
        [READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE];
    ```
    
    - `SESSION`： 只对当前会话（连接）后续的所有事务有效。
        
    - `GLOBAL`： 对设置之后所有新建立的会话有效（不影响当前已存在的会话）。
