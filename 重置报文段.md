**重置报文段（RST Segment）​**​ 是 TCP 协议中一种用于**立即强制终止连接**的控制报文。它不经过正常的四次挥手过程，而是直接宣告连接异常中断，类似于网络通信中的“紧急刹车”。

---

### ​**一、核心特征**​

1. ​**标志位**​：TCP 头部中 `RST=1`（Reset Flag）。
    
2. ​**不携带数据**​：纯控制报文，无应用层数据。
    
3. ​**无需确认**​：接收方无需回复 ACK（但实际实现可能验证序列号）。
    

---

### ​**二、触发场景（何时发送 RST？）​**​

#### ​**1. 连接请求无效**​

- ​**目标端口未监听**​：客户端向未开启服务的端口发起连接（如服务器无进程监听 80 端口）。
    
    ```
    # 示例：尝试连接未开启的端口
    telnet 192.168.1.100 9999
    # 服务器返回 RST
    ```
    
- ​**防火墙拦截**​：防火墙主动拒绝连接请求。
    

#### ​**2. 连接状态异常**​

- ​**收到不属于当前连接的包**​：如收到序列号不在接收窗口内的数据包。
    
- ​**半开连接（Half-Open Connection）​**​：一方崩溃后重启，收到另一方的数据包（无法识别连接）。
    
    ```
    sequenceDiagram
        客户端->>服务器: 发送数据（序列号 X）
        服务器-->>客户端: RST（序列号 Y） 
        Note left of 服务器: 服务器重启后<br>无此连接状态
    ```
    

#### ​**3. 主动终止连接**​

- ​**应用层强制关闭**​：程序调用 `close()`或 `shutdown()`时设置 `SO_LINGER`选项（超时时间为 0）。
    
    ```
    // C 代码示例：立即发送 RST
    struct linger opt = {1, 0}; // 启用 SO_LINGER，超时=0
    setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &opt, sizeof(opt));
    close(sockfd);
    ```
    

#### ​**4. 安全策略**​

- ​**防御 SYN 洪水攻击**​：某些系统对半连接（SYN_RECV 状态）设置超时，超时后向客户端发 RST。
    

---

### ​**三、RST 的工作流程**​

```
flowchart TD
    A[异常事件] --> B{是否需立即终止连接？}
    B -->|是| C[构造RST报文]
    C --> D[设置RST=1, 计算正确序列号]
    D --> E[发送RST]
    E --> F[本地释放连接资源]
    B -->|否| G[正常处理]
```

---

### ​**四、RST 与 FIN 的区别**​

|​**特性**​|​**RST (重置)​**​|​**FIN (正常终止)​**​|
|---|---|---|
|​**目的**​|强制立即终止连接|优雅关闭连接|
|​**流程**​|无需四次挥手|需完整四次挥手|
|​**数据可靠性**​|不保证数据完整性|保证数据完整传输|
|​**适用场景**​|错误处理、攻击防御|程序主动关闭连接|
|​**接收方行为**​|直接释放连接，无确认|回复 ACK，进入关闭流程|

---

### ​**五、抓包分析示例（Wireshark）​**​

```
# 客户端尝试连接关闭的端口
1  0.000000   Client → Server  SYN     Seq=0
2  0.000100   Server → Client  RST, ACK  Seq=0, Ack=1  [强制终止]

# 半开连接场景
1  0.000000   Client → Server  SYN     Seq=100
2  0.000050   Server → Client  SYN-ACK Seq=300, Ack=101
3  0.000100   Client → Server  ACK     Seq=101, Ack=301
4  5.000000   Server重启 → Client 数据 Seq=301 → RST
```

---

### ​**六、注意事项**​

1. ​**序列号有效性**​：
    
    **合法的 RST 必须包含正确的序列号（在接收方滑动窗口内），否则会被忽略（防御 RST 攻击）。**
    
2. ​**资源释放**​：
    
    收到 RST 的一方会立即释放连接资源（Socket、缓冲区等）。
    
3. ​**应用层通知**​：
    
    程序通过 `read()`/`recv()`返回错误（如 Linux 的 `ECONNRESET`）。
    

---

### ​**总结**​

- ​**RST 是 TCP 的“紧急终止”机制**，用于处理非法连接、状态异常或安全防御。
    
- 与 FIN 相比，RST ​**不保证数据完整性**，但能快速释放资源。
    
- 开发中可通过 `SO_LINGER`选项主动触发 RST，但需谨慎使用。