1. 确保锁操作的安全性与原子性
	- 原子性加锁：
		- 问题：分步执行 `SETNX`（设置键）和 `EXPIRE`（设置过期时间）命令，因为如果在这两步之间服务宕机，会导致锁无法自动释放，从而引发死锁
		- 解决措施：**原子性SET命令**：
			- `SET lock_key unique_value NX PX 30000`。这个命令将设置键值和过期时间合并为一个原子操作
	- 加锁要保证互斥性
		- 实现指标：只有一个客户端能成功
		- 实现方式：使用setnx，获取成功则返回1，获取失败（已存在）则返回0-
	- 避免死锁
		- 实现指标：即使客户端崩溃，锁也能自动释放
		- 实现方式：设置TTL（避免持有并等待的现象出现）
	
	- 不能释放不是自己的锁
		- 现象出现的原因：![[Pasted image 20251119141844.png]]
			- 为什么会出现不是自己的锁：业务执行阻塞，锁由于过期而被释放（TTL），之后新的线程由重新获取了锁
			- 为什么会释放了不是自己的锁：当业务执行完成后，要执行释放锁的命令，因为锁的key是一样的，所以释放了不是自己的锁
		- 解决方法：在释放锁的时候要看看锁的标识，是否与自己的一致，这样就能避免误删别人的锁![[Pasted image 20251119142210.png]]
			- 数据结构：这个锁的值（key-value的value）会存放一个标识
				- 标识的生成：uuid（随机数）+“-”+线程id拼接而成（只使用线程id可能会出现相同的，要实现不同线程标识肯定不一样）![[Pasted image 20251119142700.png]]![[Pasted image 20251119142801.png]]
	- 释放锁的过程要原子性
		- 背景：我们采用先判断这个锁是不是自己的，再释放锁，即“先判断后执行”的模式，再这个窗口期可能会使得锁超时过期而被别人获取，从而又导致自己误删别人的锁![[Pasted image 20251119143411.png]]
		- Redis执行Lua脚本是原子的
2. 管理锁的持有时间与续期
	- 问题：
		- 如果锁的过期时间设置过短，业务还没执行完锁就释放了，会导致数据不一致。
		- 设置过长，又可能在客户端真正崩溃时，资源被长时间锁定，影响系统可用性
	- 解决措施：锁续期机制（看门狗自动续期）
		- 使用场景：对于执行时间不确定的长任务
3. 锁服务的高可用性
	- Redis主从架构有数据丢失风险
		- 问题：主从同步是异步的，如果在客户端A刚在主节点上写完锁、该锁还未同步到从节点时，主节点宕机了，从节点晋升为新主，这个锁就“丢失”了
			- 锁丢失导致互斥性被破坏
		- 解决措施：使用联锁
	- RedLock算法
		- 工作模式：要求客户端向一个由多个（通常为5个）独立的Redis主节点组成的集群申请锁，并且只有在超过半数的节点（N/2 + 1）上都成功获得锁，且总耗时小于锁的有效期时，才算加锁成功
		- 好处：降低了对单个节点的依赖
		- 问题：在性能、复杂性和故障场景下的安全性方面存在一定争议
4. 扩展
	1. 实现可重入
	2. 实现[[重试获取锁]]
