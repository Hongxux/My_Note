- 需求背景：
	- 与c/c++相比
		- 跨平台需求：
			- 不同操作系统（Windows, Linux, macOS）的硬件指令和 API 不同
			- 传统语言（如 C/C++）需为每个平台编译特定版本
		- 自动内存管理：
			- C/C++ 等语言需开发者手动管理内存（分配/释放）
			- 易导致内存泄漏、指针错误等严重问题，降低开发效率与程序稳定性。
		- 数组下标越界问题不会自动检查
			- 数组下标越界会导致覆盖其他的内存
		- 多态的扩展性需求
	- 安全性与隔离性：
		- 程序可能携带恶意代码，或一个程序的崩溃不应影响同机器上的其他程序。
	- 语言生态统一：
		- 希望其他语言（如 Scala, Groovy, Kotlin）也能利用 JVM 成熟的生态系统和高性能。
- 解决措施：JVM，java虚拟机![[Pasted image 20251205130854.png]]
	- 一次编写，到处运行：引入字节码作为中间层，JVM 负责将字节码翻译成特定平台的本地指令
	- 内置垃圾回收机制：自动回收不再使用的内存对象，避免内存泄漏，提升开发效率和程序健壮性
	- 提供安全的沙箱（Sandbox）环境，限制程序的权限和行为。
		- 每个 Java 程序都运行在独立的 JVM 实例中，实现进程隔离。
	- JVM 成为多语言平台。只要其他语言能编译成符合规范的字节码，就能在 JVM 上运行，共享庞大的 Java 库和工具。
- JVM分类：JVM本质上是一个规范
	- HotSpot
	- ObenJ9
	- 等等 
- JVM组成部分![[Pasted image 20251205131514.png]]
	- [[JVM的内存结构]]
	- 执行引擎
		- GC[[垃圾回收]]
		- 解释器
		-  类运行期的优化：JIT即时编译器
	- 类的字节码结构和编译前优化
	- 类加载器ClassLoader
	
- 实现方式：
	1. **编译阶段**：你写好的 `.java`源代码文件，通过 JDK 中的 `javac`编译器编译成 `.class`字节码文件。
	2. **加载与执行阶段**：当运行程序时（使用 `java`命令），JVM 被启动。
		1. 将字节码加载到方法区：它首先通过类加载器（ClassLoader）​ 将所需的 `.class`文件加载到内存的方法区（Metaspace）。
		2. 执行字节码：现代 JVM 多采用混合模式
			- 启动main线程，分配栈帧内存：根据方法信息中的栈深度和局部变量个数划分内存
			- 执行的含义：将其翻译成本地 CPU 能够直接执行的机器指令。
			- 执行方式：
				- 混合模式先解释执行，识别出热点代码后再进行即时编译优化
				- 解释执行：
				- 即时编译：主要执行热点代码，优化字节码指令