

**新建（NEW）**：此时线程还没有开始执行，也没有任何系统资源。
- 发生时机：使用`new Thread()`创建一个线程对象后，但尚未调用`start()`方法时

**可运行（RUNNABLE）**
- 发生时机：调用了线程的`start()`方法
- 状态含义：
	- 包含了操作系统线程调度中的“就绪”（READY）和“运行”（RUNNING）两种 子状态
		- 就绪状态：等待CPU时间片，
		- 运行状态：获得了时间片，执行`run()`方法中的代码。
	- 即使线程因为I/O操作（如读写文件、网络请求）而在操作系统层面被阻塞，在JVM层面其状态仍然显示为RUNNABLE。

**阻塞（BLOCKED）**
- 发生时机：锁竞争失败
	- 线程试图进入一个被`synchronized`关键字保护的同步代码块或方法，但所需的监视器锁（monitor lock）正被其他线程持有
- 结束时机：一旦持有锁的线程释放了锁，该线程重新变为可运行以参与锁的竞争。

**等待（WAITING）** 处于此状态的线程会释放它持有的锁
- 发生时机：主动调用了某个无超时参数的方法
	- 需要无限期地等待其他线程执行特定操作来唤醒。
	- 进入此状态的方法：
		- 不带超时参数的`Object.wait()`、`Thread.join()`
		- `LockSupport.park()`。
- 结束（唤醒）方法：
	- 唤醒：从WAITING状态到RUNNABLE状态
	- 其他线程调用对应对象的`notify()`或`notifyAll()`方法
		- 唤醒的是所有在entryList的对象
	- 调用`LockSupport.unpark(thread)`
		- 唤醒的是thread这个对象
	- 调用`thread.interrupt`
		- 唤醒的是thread这个对象

**超时等待（TIMED_WAITING）**
- 发生时机：主动调用了某个有超时参数的方法
	- 如`Thread.sleep(long millis)`、`Object.wait(long timeout)`、`Thread.join(long millis)`等。
-  结束（唤醒）方法：
	- 其他线程调用对应对象的`notify()`或`notifyAll()`方法，
	- 调用`LockSupport.unpark()`
	- 调用`interrupt`
	- 超过了设定的等待时间

**终止（TERMINATED）**
- 发生时机：
	- 线程的`run()`方法正常执行完毕
	- 因抛出一个未捕获的异常而意外退出
- 状态含义：线程的生命周期已经结束
	- 不能再通过调用`start()`方法来重新启动。

