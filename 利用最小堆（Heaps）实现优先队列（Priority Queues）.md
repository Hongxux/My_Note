# 问题引入：
在一堆数据中，我想要获得其中的最小值，甚至需要频繁地插入和删除数组。
### 1. ​**时间复杂度优势**​：

- ​**最小堆**​：在最小堆中，最小值始终位于根节点，因此获取最小值的时间复杂度是 ​**O(1)​**。这是最直接和高效的方式。
- ​**二叉搜索树（BST）​**​：在BST中，最小值需要遍历到左子树的最左节点，平均时间复杂度为 ​**O(log n)​**​（如果树是平衡的），但在最坏情况下（如树退化为链表）可能达到 ​**O(n)​**。
- ​**排序算法**​：如果先对数据排序，然后取第一个元素，最小值获取是O(1)，但排序本身需要 ​**O(n log n)​**​ 时间，这比构建堆的O(n)时间更耗时（构建堆的时间复杂度是O(n)）。

### 2. ​**维护和操作效率**​：

- 最小堆不仅适合一次性获取最小值，还适合需要频繁插入、删除和获取最小值的场景（例如，优先队列）。插入和删除操作在堆中只需 ​**O(log n)​**​ 时间，而保持BST平衡需要额外的操作（如AVL树或红黑树的旋转），实现更复杂。
- 排序算法则不适合动态数据：如果数据经常变化，每次排序都需要重新排序，效率低下。

### 3. ​**空间复杂度**​：

- 最小堆通常可以用数组实现，空间开销小（不需要存储指针），而BST需要额外的指针空间用于节点连接。

### 4. ​**实际应用**​：

- 最小堆常用于需要高效获取最小值的场景，如Dijkstra算法、Huffman编码、任务调度等。这些场景中，最小值被频繁访问，最小堆提供了最优的性能。

总之，如果你只需要一次性获取最小值，任何方法都可以，但如果你需要多次获取最小值或数据动态变化，最小堆是更高效和简单的选择。

# 最小堆的性质
1. **结构性质**​：最小堆是一个完全二叉树。这意味着树的所有层都完全填充，除了最后一层，最后一层的节点都靠左排列。这个性质允许我们使用数组来表示堆，而不需要显式的指针或节点结构，从而节省空间。
2. ​**堆序性质**​：对于堆中的任何节点，其值都小于或等于其子节点的值（如果有子节点）。因此，根节点总是整个堆中的最小值。这个性质确保了我们可以快速访问最小值。


# 最小堆性质的应用
![[Pasted image 20250909202615.png]]

## 获得父亲节点，或者两个孩子在数组中的下标
在数组表示中，堆的元素从索引0开始存储（有时从索引1开始，但这里以索引0为例）。根据完全二叉树的结构性质，我们可以通过简单的算术计算获取任何节点的父节点或子节点的下标：

- 对于当前节点在索引 `i`：
    - ​**父节点**的索引： `parent(i) = (i - 1) // 2` （使用整数除法）。
    - ​**左孩子**的索引： `left_child(i) = 2 * i + 1`。
    - ​**右孩子**的索引： `right_child(i) = 2 * i + 2`。

这些计算公式直接源于完全二叉树的结构性质。例如，在索引0的根节点，其左孩子是索引1，右孩子是索引2；索引1的父节点是索引0。

## 插入（上浮）和删除（下沉）的实现

当向最小堆中插入一个新元素时，我们首先将新元素添加到数组的末尾（即最后一个位置），以维护结构性质。但新元素可能违反堆序性质（它可能比父节点小），因此需要“上浮”操作来调整：

1. 将新元素放在数组末尾，索引为 `n`（其中 `n` 是当前堆的大小）。
2. 比较新元素与其父节点（索引 `parent(n)`）的值。
3. 如果新元素小于父节点，交换它们的位置。
4. 重复步骤2和3，直到新元素不再小于其父节点或到达根节点（索引0）。

上浮操作利用了堆序性质，通过不断与父节点比较和交换，确保最小值向上移动，从而恢复堆序。

当从最小堆中删除最小值（即根节点）时，我们通常执行以下步骤：

1. 将根节点（索引0）的值替换为数组最后一个元素的值，然后减少堆大小。这维护了结构性质。
2. 但新根可能违反堆序性质（它可能比子节点大），因此需要“下沉”操作来调整：
    - 从根节点开始（索引0），比较当前节点与其左孩子和右孩子的值。
    - 如果当前节点大于其子节点中的最小值，则与那个最小的子节点交换。
    - 重复这个过程，直到当前节点不大于任何子节点或成为叶子节点。