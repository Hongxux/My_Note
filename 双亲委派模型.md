- 设计目的：
	- **安全性**：可以防止核心API被随意篡改。例如，用户自定义的`java.lang.Object`类永远不会被加载，因为启动类加载器已经加载了JDK中的Object类
	- **唯一性**：避免了类的重复加载，确保一个类在JVM中只有一个Class对象
- 工作流程：类加载器的loadClass方法
	1. 通过类的缓存，先检查自己这个加载器是否加载过，如果没加载则执行接下来流程
	2. **向上委托**：当一个类加载器收到加载请求时，它首先不会自己去尝试加载，而是将这个请求**委托给父类加载器**去完成。
		- 如果取上级加载器，发现为null，则使用启动类加载器
			- 说明自己是扩展加载器
	3. **逐级向上**：这个委托过程会一直递归到最顶层的启动类加载器。
	4. **向下尝试**：只有当所有父类加载器都**反馈无法完成加载请求**（在自己的加载路径下找不到指定的类）时，子加载器才会**尝试自己调用`findClass()`方法**去加载。
		- `findClass()`方法：读取字节码文件 -> 转为字节数组 -> 调用 `defineClass()`
- 打破双亲委派：
	- 例如，SPI（Service Provider Interface）机制（如JDBC）中，核心接口在`rt.jar`中由启动类加载器加载，但具体的实现类（如MySQL驱动）需要由应用类加载器加载。此时会使用**线程上下文类加载器**来加载实现类