---
aliases:
  - finally
---
### 现代替代方案：[[try-with-resources]]
1. ​**代码又臭又长**​ - 每个资源都要写一堆模板代码，业务逻辑都被埋没了
    
2. ​**错误信息会“丢失”​**​ - 关闭时的异常经常覆盖真正的业务错误，查bug查到崩溃
    
3. ​**资源泄漏防不住**​ - 复杂逻辑中很容易漏掉清理，或者关闭顺序搞反
是时候告别这种“手动挡”的资源管理了！接下来我要介绍的**try-with-resources**——**等效展开**
### ​**一、资源泄漏风险与`finally`的必要性**​

#### ​**1. 异常导致资源泄漏的机制**​

- ​**根本原因**​：异常中断正常执行流，跳过后续清理代码
    
- ​**高危资源类型**​：
    
    - 文件句柄（`FileInputStream`）
        
    - 网络连接（`Socket`）
        
    - 数据库连接（`Connection`）
        
    - 内存映射（`MappedByteBuffer`）
        
    
- ​**泄漏后果**​：
    
    - 文件句柄耗尽 → `Too many open files`
        
    - 数据库连接池枯竭 → 服务不可用
        
    - 内存泄漏 → `OutOfMemoryError`
        
    

#### ​**2. 传统清理方案的缺陷**​

```
// 典型重复清理模式
Resource res = null;
try {
    res = acquireResource();
    process(res); // 可能抛出异常
    res.close();  // 正常分支清理
} catch (Exception e) {
    if (res != null) res.close(); // 异常分支清理
    throw e;
}
```

​**缺陷**​：主要是在try中要写清理资源的代码，在catch中也要写

1. ​**代码冗余**​：关闭逻辑重复出现（违反DRY原则）
    
2. ​**维护风险**​：修改关闭逻辑需同步多处
    
3. ​**异常掩盖**​：关闭操作本身抛异常可能覆盖原始错误


---

### ​**二、`finally`执行机制深度解析**​

#### ​**执行路径矩阵**​

|​**场景**​|try块执行|catch块执行|finally块执行|后续流程|
|---|---|---|---|---|
|​**无异常**​|完整执行|跳过|执行|继续后续代码|
|​**捕获匹配异常**​|执行至异常点|执行匹配catch块|执行|继续后续代码|
|​**未捕获异常**​|执行至异常点|跳过|执行|异常传播至调用栈|
|​**finally中抛异常**​|按原场景执行|按原场景执行|抛出新异常|新异常覆盖原始异常|

#### ​**1. 控制流屏蔽陷阱**​
在finnally中不要使用如return, throw, break, continue等控制流语句，会覆盖正常语句catch或者try块中的的return, throw, break, continue。
​**案例1：返回值覆盖**​

```
int dangerous() {
    try {
        return 1; 
    } finally {
        return 2;  // 实际返回2，原始返回值1被丢弃
    }
}
```

​**案例2：异常吞噬**​

```
void risky() throws Exception {
    try {
        throw new IOException("原始错误");
    } finally {
        throw new SQLException("关闭错误"); // 掩盖原始异常
    }
}
```

#### ​**2. 安全关闭资源模板**​

```java
Closeable resource = null;
try {
    resource = acquire();
    operate(resource);
} finally {
    if (resource != null) {
        try {
            resource.close();
        } catch (RuntimeException e) { 
            // 非受检异常记录后忽略
            log.error("关闭异常", e); 
        } catch (Exception e) {
            // 受检异常记录后忽略
            log.error("关闭异常", e);
        }
    }
}
```

​**关键原则**​：
- 判空防止NPE
- 嵌套try-catch处理关闭异常
- 关闭操作自身异常**不得**中断主流程
- 仅记录日志不抛出新异常
	- 日志需包含资源标识（如文件名、连接URL）


#### ​**3. `finally`不执行的极端场景**​

|​**场景类别**​|​**具体案例**​|​**根本原因**​|
|---|---|---|
|JVM强制终止|`System.exit(0)`|进程级中断|
|线程强制终结|`thread.stop()`（已废弃）|线程状态不可控|
|死循环/死锁|`while (true) {}`或同步锁死|执行流永久阻塞|
|硬件故障|断电、内核崩溃|JVM运行环境失效|
|JVM内部错误|`InternalError`（如堆损坏）|虚拟机不可恢复状态|



---

### ​**三、`finally`高级应用模式**​

#### ​**1. 无catch的纯finally模式**​

```
// 专注资源释放，不处理业务异常
Connection conn = null;
try {
    conn = dataSource.getConnection();
    executeTransaction(conn); // 可能抛SQLException
} finally {
    if (conn != null) {
        try { conn.close(); } 
        catch (SQLException e) { /* 仅记录不传播 */ }
    }
}
```

​**适用场景**​：资源清理与业务错误处理解耦

#### ​**2. 嵌套try责任分离模式**​

```
try {
    // 外层：异常处理
    try {
        // 内层：资源保障
        try (InputStream in = new FileInputStream("file")) {
            process(in); // 业务逻辑
        } // 自动关闭
    } catch (IOException e) {
        throw new ProcessingException("处理失败", e);
    }
} catch (ProcessingException e) {
    alertUser(e.getMessage());
}
```

​**分层职责**​：

| ​**代码块**​ | ​**首要责任**​ | ​**次要责任**​ |
| --------- | ---------- | ---------- |
| 最内层try    | 资源生命周期管理   | -          |
| 中间层catch  | 异常转换与包装    | 保留原始异常链    |
| 最外层catch  | 用户友好错误处理   | 业务上下文补充    |


---

