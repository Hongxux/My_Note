为了应对成千上万种不同规格、不同协议的硬件设备，操作系统必须采用一种模块化、可扩展的方式来管理它们。这就是**设备驱动程序**​ 的作用。

- ​**定义与功能**​：设备驱动程序是操作系统内核中专门为特定设备或一类设备编写的软件模块。它封装了所有与硬件直接交互的低级细节，如如何初始化设备、如何理解设备状态、如何发送命令、如何处理该设备产生的中断等。
    
- ​**抽象与统一接口**​：驱动程序向上层操作系统内核（特别是I/O子系统）提供一个标准、统一、与设备无关的**软件接口**。例如，对于块设备（如硬盘），所有驱动程序都会提供`read`, `write`等标准操作接口。当文件系统需要读写磁盘时，它只需调用这个通用接口，而无需关心底层是SATA硬盘还是NVMe SSD。
    
- ​**价值**​：这种设计实现了两个关键目标：
    
    1. ​**设备中立性**​：操作系统核心部分和上层应用程序的构建不再依赖于具体硬件，实现了操作系统的可移植性。
        
    2. ​**封装性**​：将设备相关的所有复杂、易错的代码隔离在驱动模块中。新增一个设备，只需安装其对应的驱动程序即可，无需修改操作系统内核本身。
        
- **问题**：
	- **统一接口的代价**：标准化接口在简化设计的同时，也可能掩盖硬件的高级特性。硬件独有的高级功能无法通过标准化接口暴露给上层系统。
	- **设备驱动程序**：
		1. ​**驱动是操作系统的“暗物质”​**——占比巨大却常被忽视，任何接入系统的设备（键盘、显卡、USB设备等）都需要专属驱动，Linux 内核中 ​**70%+ 代码是驱动程序**​。
		2. **资源浪费：** 系统安装包需预装海量驱动以兼容潜在硬件，单台机器通常仅激活少量驱动（如仅连接1-2块网卡），其余成“死代码”
		3. **质量隐患：业余开发之殇**，大量驱动由硬件厂商程序员（非专业内核开发者）编写，内核开发需精通并发、内存管理等复杂机制，硬件工程师可能缺乏系统级开发经验，导致驱动成为系统崩溃主因。
