- 含义：关注的是修改的及时传播能力
	- 一个线程修改了某个**共享变量**后，这个修改能够被其他线程**立即感知**
	- 不能被及时感知，则出现可见性问题
- 修改及时传播的需求背景：多个线程需要访问和修改同一块数据（共享状态）以实现协作
	- 需要保证最新的、一致的数据视图：共享变量是传递信号的工具
		- 某些线程执行指令，需要标志位来指示，如果标志位的修改不能被及时传播，它可能用于无法开始工作
	- 需要确保程序的可预见性和稳定性：
		- 如果缺乏可见性保证，程序会表现出极其不稳定和难以预测的行为
- 修改不能及时传播原因（出现可见性问题的原因）：多个线程读写的不是一块区域
	- CPU是多核的，多级缓存架构
		- 单核cpu中，每个线程执行的时候操作的都是同一个CPU的缓存![[Pasted image 20251201194100.png]]
		- 多核cpu中，每个CPU的内核都有自己的缓存![[Pasted image 20251201194051.png]]
			- 多个不同的线程运行在不同的CPU内核上，这些线程操作的是不同的CPU缓存
	- JMM将内存抽象成主内存和工作内存![[Pasted image 20251201194352.png]]
		- 每个线程都有自己的工作内存
			- 线程使用变量时，会把主内存中的数据复制到线程自己私有的工作内存
			- 后续这个线程进行读写数据时，都是操作自己的工作内存中的数据
		- **例子**​：线程A修改了变量，但修改还停留在CPU缓存中，线程B从主内存读取到的还是旧值。
- 解决目标：防止由于CPU缓存导致的**内存一致性错误**，出现失效数据。
- 解决方法：遵循[[happens-before]]规则
	- 使用[[volatile]]关键字：表示你每次都要从主内存中读取最新值，不能从工作内存中读取
	- 使用synchronized
    
    ​
    
```
public class VisibilityProblem {
    private boolean flag = false; // 没有volatile，可能出现可见性问题
    
    public void writer() {
        flag = true; // 线程A执行
    }
    
    public void reader() {
        while (!flag) { // 线程B可能永远看不到flag变为true
            // 循环
        }
    }
}

// 使用volatile解决可见性
public class VisibilitySolution {
    private volatile boolean flag = false; // 保证可见性
}
```
---
