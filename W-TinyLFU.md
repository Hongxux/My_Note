- 数据结构:
	![[Pasted image 20251124204547.png]]
	- **准入窗口**（Admission Window）：一个小的LRU队列，用于存放**最新到达**的数据。
		- 这为新数据提供了一个“保护期”（给他们一定的成长时间来积累自己的使用频率），避免它们因为初始频率低而被立即淘汰。
	- **频次过滤器**（TinyLFU）：是Caffeine数据淘汰策略的核心所在。
		- 他依赖[[CountMin Sketch]]非精确的记录数据的历史访问次数，从而决定主缓存区数据的淘汰策略，这个数据结构用很小的成本完成了缓存数据访问频次的记录和查找。
	- **主缓存区**（Main region）:用于存放大部分的缓存数据，数据结构为一个分段LRU队列（SLRU），包括ProtectedDeque和ProbationDeque两部分。
		- ProtectedDeque：大小占总容量的80%，如果Probation为空，则选择Protected为淘汰队列。
			- 该部分使用TinyLFU的Adminsion策略进行数据的淘汰，一些访问频次很低的数据可以被快速淘汰掉，避免了主缓存区被新缓存污染。
			- 移出：Protecte队列如果达到其容量限制会触发Node Demotion过程，队列首部的元素会被peek出并下放到Probation队列。
		- ProbationDeque：当需要淘汰的时候，该队列的数据优先被淘汰。更新策略
			- 加入：
				- 当准入窗口的长度达到限制后，会把最久的数据加入到ProbationDeque
				- Protecte队列如果达到其容量限制会触发Node Demotion过程，队列首部的元素会被peek出并下放到Probation队列
			- 移出：进入Probation队列的数据如果在没有被主缓存区淘汰之前获得了一次access，该节点会被add进Protected队列，这个过程称之为Node Promotion。
- 淘汰过程:![[Pasted image 20251124205505.png]]

	
	1. 淘汰的时机：主缓存区的大小(Probation的大小 + Protected的大小)达到了其容量限制会触发主缓存区的数据淘汰
	2. 淘汰队列的选择：Probation会被优先选择为淘汰队列，如果Probation为空，则选择Protected为淘汰队列。
	3. 淘汰者的选择：分别选取淘汰队列的首部元素作为受害者(victim)，尾部元素作为竞争者(candidate)，通过对比两者的访问频次选择最终的淘汰者，其中访问频次通过CountMin Sketch获得。这里Caffeine对于竞争者的淘汰并不只是简单的判断其访问频次小于或等于受害者，而是加入了以下逻辑：
		 - 如果竞争者的访问频次大于5且小于或等于受害者频次，随机淘汰
			 - 这么做的原因主要是为了一定程度的避免哈希碰撞引起的受害者访问频次非自然增长，从而导致新数据无法被写入主缓存区。
		- 如果竞争者的访问频次小于等于5则直接淘汰竞争者，这是因为TinyLFU中记录数据的访问频次最大值为15，当超过这个最大值触发全局的reset后只有7，因此如果不加一个数据预热的过程，可能会导致一个频率较低的攻击者因为随机淘汰策略挤掉了热点数据。