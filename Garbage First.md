---
aliases:
  - G1
---
- 需求背景：
	1. **大堆场景下的延迟失控**：对于 GB 级以上大堆，CMS 的 STW 时间可能达到数百毫秒，无法满足电商秒杀、金融交易等低延迟场景需求。
	2. **内存碎片与吞吐量矛盾**：
		- CMS为了实现低延迟，采用的标记清除算法，因此必然产生内存碎片。而大量的内存碎片可能导致晋升失败、大对象无法存储从而在并发标记和并发清理阶段可能导致Serial Old的Full GC，进行不可控的长时间STW
		- 而 Serial GC、Parallel GC 虽无碎片，但整堆回收的 STW 时间随堆大小线性增长，吞吐量与延迟无法兼顾。
	3. **堆内存利用率低**：CMS 需要预留一定内存空间供并发回收时应用线程继续分配，堆利用率通常低于 70%，大堆场景下内存浪费严重。
- 设计目标：在处理大堆（通常≥4GB）场景下，**以可控的低延迟（默认最大暂停时间目标 200ms）为核心，兼顾高吞吐量**，同时避免产生严重内存碎片，支持动态堆内存管理
	- 针对的场景：堆内存大的服务器
	- 核心目标：**可控的**低延迟
		- 实现方式：
			1. **分区回收**：将堆划分为小 Region，每次只回收部分 Region
			2. **动态 CSet**：根据 MaxGCPauseMillis 参数，计算本次能安全回收的 Region 数量
			3. **优先级排序**：优先回收垃圾比例高的 Region，确保单位时间内回收效率最大化
	- 兼顾目标：
		- 高吞吐量
		- 避免产生严重的内存碎片
		- 支持动态内存管理
- 由涉及目标衍生的实现铁律
	- 为了实现可控的低延迟，需要将堆内存分成多个 “小区块”，每次只清理部分 “小区块”，避免长时间的清理占用
	- 为了兼顾高吞吐量
		- 大部分标记工作（如可达性分析）必须在应用线程并发执行，仅在关键节点触发短时间 STW，减少对吞吐量的影响
		- 使用复制算法，避免内存碎片产生，杜绝因碎片导致的频繁 Full GC
	- 为了避免产生严重的内存碎片，回收时必须对选定的 Region 进行压缩（复制算法）
- 问题：
	- 出现Full GC
		- 主要原因和对策：
			 - **并发模式失败**：
				 - 原因：在并发标记完成前，老年代就被填满。
				 - 对策：调低IHOP或增加堆大小。
			 - **晋升失败**：从年轻代分区拷贝存活对象时，无法找到可用的空闲分区
				 - 原因：Mixed GC速度跟不上对象从年轻代晋升到老年代的速度。
				 - 对策：优化应用减少对象创建，或调整参数让Mixed GC更积极。
			 - **大对象分配失败**：
				 - 原因： 分配巨型对象`Humongous Object` 时在老年代无法找到足够的连续分区
				 - 对策：避免分配过多大对象，或增大Region大小。
		- 后果：Full GC是**串行**的（Serial Old），停顿极长
	- [[秒杀系统 G1 GC Humongous 对象与低延迟平衡问题]]
- G1调优
	- 核心目标：**在满足业务延迟阈值（如秒杀 80ms）的前提下，尽可能降低回收频率、避免 Full GC**
	- Region的大小
		- 官方推荐设置：让 **Region 数量维持在 2048~4096 个**，这个区间能平衡 RSet 维护开销和回收效率 
			- 数量太少跨 Region 引用暴增、RSet 维护开销飙升，Humongous 对象数量增加
			- 数量太多
				- RSet 总数多，维护开销激增
				- 单次回收的复制 / 清理耗时增加
		- 计算规则：
			- 第一步：计算 “初始候选值”= 堆内存总大小（-Xms/-Xmx 的最小值，若两者相等则直接用该值） / 2048；
			- 第二步：将候选值调整为 “1MB~32MB” 范围内最近的 2 的幂次方（比如候选值是 5MB，会调整为 4MB；候选值是 7MB，会调整为 8MB）；
			- 第三步：若调整后超出 1MB~32MB 范围，则取边界值（堆太小则取 1MB，堆太大则取 32MB）
		- 手动设置方式：通过 `-XX:G1HeapRegionSize=N` 指定（N 必须是 1MB、2MB、4MB...32MB 中的一个，且是 2 的幂次方）
			- 官方建议 “非必要不手动指定”—— 除非生产环境出现明确的性能问题
	- 避免低收益回收
		- 监控维度：启用详细 GC 日志：`-Xlog:gc*:file=gc.log:time,uptime,level,tags`；
			- 延迟达标验证
				- Mixed GC 单次 STW 时长：日志中 “Pause G1 Mixed (G1 Evacuation Pause) [ms]” 后的数值；
				- Young GC 单次 STW 时长
			- 回收效率验证
				- Mixed GC 频率
				- 老年代内存增长率
			- 兜底风险验证
				- Full GC 次数
				- 并发标记完成率："Concurrent Mark Aborted"说明并发标记未完成
		- -XX:G1MixedGCLiveThresholdPercent=n ：
			- 作用：仅回收存活对象占比<n%的老年代Region，控制这个值可以控制回收的CSet集合数量，筛选低存活老年代 Region 纳入 CSet
				- 调低了可以减少CSet集合数量，降低STW延迟
				- 但是过低，也有风险，官方建议不低于70％
					- **直接风险**：可回收的老年代 Region 数量骤减→**单次** Mixed GC 释放的内存变少
					- **连锁风险**：内存释放不足→老年代内存增长速度加快→Mixed GC 触发**频率**升高（比如从每小时 5 次涨到 12 次）
					- **终极风险**：若 Mixed GC 频率过高，并发标记跟不上内存增长速度→堆内存逐步占满→触发 **Full GC**
			- 目的：避免高存活区域浪费STW时间（JDK 11默认值，官方推荐）
			- 默认值：85％
		- `-XX:G1HeapWastePercent = n`：
			- 作用：在 Mixed GC（回收新生代 + 部分老年代）过程中，G1 会先计算本次要回收的 Region 集合（CSet）里 “可回收垃圾空间的占比”；如果这个占比**低于 n%**，**G1 会直接终止本次 Mixed GC**，不再继续回收。
			- 默认值：10％
			- 目的：避免进行低收益的回收
				- 延迟和空间的权衡：花费的 STW 时间（比如 60ms）远大于回收的内存收益（比如几十 MB），完全得不偿失
	- 优化新生代垃圾回收：核心围绕 “缩小回收范围、提升复制效率、减少对象晋升”
		- 精准控制新生代大小：平衡 Young GC 的 “**回收频率**” 和 “**单次 STW 时长**”—— 新生代越大，单次 STW 越长、频率越低；新生代越小，单次 STW 越短、频率越高。
			- - `-XX:G1NewSizePercent=N`：新生代最小占堆内存比例（默认 5%）；
				- 降低值，能缩小新生代单次回收范围，直接降低 Young GC 的 STW 时间
			- `-XX:G1MaxNewSizePercent=N`：新生代最大占堆内存比例（默认 60%）。
				- 提高值，能避免新生代过小导致 Young GC 频率飙升
		- 提升并行回收线程数，加快复制速度
			- `-XX:ParallelGCThreads=N`：Young GC 并行回收线程数（默认 = CPU 核心数）。
				- 官方上限是 “CPU 核心数 ×1.5”：超过后线程上下文切换开销会抵消并行收益。
		- 启用新生代预回收：让 G1 根据内存使用趋势提前触发 Young GC，避免峰值时堆空间耗尽导致 “紧急 GC”（紧急 GC 的 STW 时间是正常的 2 倍）。
			- `-XX:G1PredictiveCollectionInterval=N`：预回收间隔（默认 0，关闭；秒杀场景设为 1000ms）。
			- 仅 JDK 11 + 支持，且预回收间隔不宜小于 500ms（否则 Young GC 频率过高）
		- 优化 Survivor 区，减少对象过早晋升：通过调整 Survivor 区比例和对象晋升年龄，让临时对象在新生代多存活几轮，减少老年代晋升压力。**（老年代压力小，反哺新生代回收效率）**
			- `-XX:SurvivorRatio=N`：Eden 区 / 单个 Survivor 区的比例（默认 8，即 Eden:Survivor0:Survivor1=8:1:1）；
				- 调低值能增大 Survivor 区空间，容纳更多临时订单对象；
			- `-XX:MaxTenuringThreshold=N`：对象晋升老年代的年龄阈值（默认 15）。
				- 调低值能避免长生命周期临时对象占用新生代空间。
		-  减少大对象直接进入老年代 **（源头优化）**：避免新生代大对象直接晋升老年代（大对象占老年代空间快，导致 Mixed GC 频繁，间接拖慢新生代回收）
			- 调整`-XX:G1HeapRegionSize`（如 8MB→16MB），让 4~5MB 订单对象不触发 Humongous 判定，留在新生代；
			- 代码层面拆分大对象（如把 8MB 订单数组拆为 2 个 4MB 数组）；
	-  `-XX:G1ReservePercent=n`：G1 会从总堆内存（比如你配置的 16GB）中，提前预留出n 的空间（即 3.2GB），这个空间专门用于**并发标记阶段**的新对象分配。
		- 目的：预防 “并发标记失败导致的 Full GC”：
		- 调高`G1ReservePercent`，预留更多堆空间供并发标记阶段分配新对象，避免并发标记失败（日志关键词`Concurrent Mark Aborted`）触发 Full GC
----
- 回收算法

| 回收阶段           | 采用算法                    | 适用场景                      | 核心目标             |
| -------------- | ----------------------- | ------------------------- | ---------------- |
| 年轻代回收（YGC）     | 复制算法（Copying）           | Eden/Survivor Region 回收   | 快速回收短生命周期对象，低停顿  |
| 混合回收（Mixed GC） | 标记 - 复制算法（Mark-Copy）    | 部分老年代 Region + 年轻代 Region | 增量回收老年代，控制单次停顿时间 |
| Full GC（退化场景）  | 标记 - 整理算法（Mark-Compact） | 全堆回收（极少触发）                | 解决内存碎片化，保证堆可用性   |
  
- 实现基础
	-  Region
		- 定位：G1 的最小内存管理单元，是实现 “垃圾优先” 和 “可控停顿” 的核心抽象
		- 需求背景：连续物理分代，无法实现部分回收，大堆下全代回收 STW 过长，物理边界固定导致资源浪费
		- 作用：将大堆拆分为多个独立小空间，回收时可按需选择部分 Region，控制单次回收工作量；
		- **逻辑分代**：G1 保留新生代、老年代概念，但仅为逻辑划分（Region 可动态切换分代属性），无物理分代边界。
			- 作用：
				- 兼容传统分代回收的优势（新生代对象存活率低，优先回收）
				- 同时避免物理分代的固定边界限制；
			- 逻辑分类：
				- Eden
				- Survivor
				- Old
				- Humongous（大对象）
					- Humongous对象的判断方式：当一个对象的大小 **≥ Region 大小的 50%** 时，会被标记为 Humongous 对象；
					- 存储Humongous对象的方式：
						- 一个Humongous对象会分配一个Region
						- 若对象大小超过单个 Region 的最大尺寸（32MB），则会占用**连续的多个 Humongous Region**（比如 40MB 的对象，32MB Region 下会占 2 个）。
					- 单独分配 Humongous Region的原因：
						- 主要原因：避免大对象拆分到多个普通 Region，暴增跨 Region 引用，RSet 维护开销飙升（内存），写屏障触发频率飙升（cpu）。
							- 大对象内部出现跨 Region 引用
							- 外部对象引用一个大对象时候需要记录多个跨 Region 引用
						- 次要原因：简化回收逻辑，Humongous 对象默认被归为老年代，回收时不参与 Young GC 的复制过程（避免大对象复制导致 STW 时间超标），仅在 Mixed GC 或 Full GC 时回收
		- 数据结构：采用固定大小的独立内存块吗，支持动态切换分代属性
			- 内存大小：通过 - XX:G1HeapRegionSize 手动指定（默认 1MB-32MB）
		- 关键操作：
			- Region 创建：JVM 启动时按堆大小拆分 Region，默认大小为 2 的幂（1MB、2MB...32MB）
			- 分代切换：
				- 新生代 Region 满后，存活对象晋升为老年代 Region；
				- 大对象（超过 Region 大小 50%）直接分配至大对象 Region；
					- 目的：避免新生代回收时的复制开销
					- 回收方式：触发 Full GC（JDK 11 及之前），JDK 12 + 优化为可在 Mixed GC 中回收
			- 回收后处理：被选入 CSet 的 Region，其存活对象会被复制到 “空闲 Region”，原 Region 标记为 “空闲”，后续可重新分配对象。
	- Remembered Set（RSet，记忆集）
		- 需求背景：回收一个 Region 时，需扫描所有其他 Region 是否有指向该 Region 的引用，相当于整堆扫描，STW 时间失控，失去分区回收的意义。
		- 定位：每个 Region 关联的 “引用追踪清单”，是实现 “跨 Region 引用精准追踪” 的核心抽象。
		- 作用：通过记录跨 Region 引用，使分区回收时无需扫描整堆，仅遍历 RSet 即可确定外部引用，保障 “低延迟”
		- 数据结构：每个 Region 对应一个 Hash 表，先按 “引用来源 Region” 分组（粗粒度），再在每个分组下记录 “该 Region 中哪些小范围包含引用”（细粒度）。
			  ![[Pasted image 20251226161206.png]]
			  ![[Pasted image 20251226161327.png]]
			  ![[Pasted image 20251226161529.png]]
			- Key 为引用来源 Region 的起始地址 **(其他 Region 中的对象)（粗粒度）**
			- Value 为该引用来源 Region 内引用当前 Region 对象的 “卡页” 集合。 **(其他 Region 中的对象的哪些卡页)（细粒度）**
			- 设计权衡：为什么精确引用记录（存储每个跨 Region 引用的具体地址）
				- 查询效率高，但空间开销大（大堆场景下 RSet 占用内存可能达堆大小的 10%）；
				- 通过 Card Table 的细粒度标记平衡空间与效率，符合 “高吞吐量” 铁律。
		- 工作流程：写屏障触发→脏卡标记→异步更新 RSet→回收时遍历 RSet→精准标记存活对象；
			- 步骤 1：记录引用（写屏障触发 RSet 更新）
				- 当执行`objA.ref = objB`（跨 Region 引用a->b）时，**写屏障（Write Barrier）** 会被触发（写屏障是 JVM 在对象赋值时插入的一段逻辑，无感知）。
				- 写屏障：找到 objA 所在的 Card（比如 Region 1 的 Card 0x12），将该 Card 标记为 “脏卡”（更新 Card Table）；
				- RSet 更新：后台线程（Dirty Card Queue Processor）异步处理 “脏卡”，解析出具体的跨 Region 引用，更新目标对象所在 Region 的 RSet。
					- 后台更新的原因：避免阻塞应用线程
			- 步骤 2：GC 时使用 RSet（回收 Region 0）
				1. 回收某 Region 时，直接遍历其 RSet，获取所有指向该 Region 的外部引用；
				2. 结合 SATB 标记结果，判断这些外部引用是否指向存活对象，无需扫描其他 Region。
			- 步骤3：RSet清理
				- 时机：并发标记阶段
				- 清理对象：引用对象已被回收的RSet
				- 兜底处理： RSet 占用内存过大（超过阈值），G1 会触发 “RSet 压缩”，合并重复的引用记录。
	- **SATB（Snapshot-At-The-Beginning，初始快照）**：并发标记的核心算法，确保标记过程的准确性
		- 需求背景：
			- 并发标记阶段，应用线程持续修改对象引用，如何确保标记结果的准确性（避免漏标或误标），同时不影响应用线程运行
			- 若采用 “增量更新”（CMS 的标记算法），需在标记后重新扫描修改过的引用，可能导致标记周期过长，影响吞吐量；
		- 核心价值：在并发标记阶段确保存活对象标记的准确性，同时将 STW 时间控制在毫秒级（符合 “并发标记” 和 “延迟优先” 铁律）；
		- 工作流程：初始标记（根对象）→ 并发标记（遍历 + 补标）→ 最终标记（确认）→ 生成存活快照
			- **初始化阶段（初始标记 STW）**：
			    1. 触发短时间 STW（通常 <10ms），标记 “根对象”（如线程栈、静态变量）直接引用的对象；
			    2. 对根对象引用的对象创建 “快照”，记录其初始引用状态（SATB 的核心：以标记开始时的对象引用关系为基准）。
			- **并发标记阶段（与应用线程并发）**：
			    1. 后台标记线程遍历初始标记的对象，递归标记所有可达对象；
			    2. 应用线程修改对象引用时（如`a.obj = null`），写屏障触发 “引用日志”（SATB Log），记录被删除的引用（避免漏标）；
			    3. 标记线程同时处理 SATB Log，对被删除引用指向的对象进行补标。
			- **最终标记阶段（重新标记 STW）**：
			    1. 触发短时间 STW（通常 < 20ms），处理剩余的 SATB Log 和未标记的对象；
			    2. 对标记结果进行最终确认，生成 “存活对象快照”，为 CSet 选择提供依据。
		- 核心权衡：
			- 为什么选择 “仅记录删除引用” 的 SATB 算法，不选择同时记录新增引用的增量更新
				- 若仅记录删除引用（SATB）：可避免漏标，但可能标记已死亡的对象（假阳性），导致回收不彻底；
				- 若同时记录新增引用（增量更新）：标记更精准，但日志处理开销大，影响吞吐量；
				- 权衡：假阳性对象可在下次 GC 中回收，以轻微的空间开销换取低延迟和高吞吐量（符合核心目标）
	- **Card Table（卡表）**：辅助 RSet 实现的细粒度引用标记结构，减少 RSet 的维护开销。
		- 通过 "写屏障" 标记 "脏卡"（内存页），后台线程异步处理，避免直接更新 RSet 带来的开销
		- - 二者配合解决了分区回收中的 "跨区域引用" 问题，是 G1 实现高效并发标记的关键
	- **Collection Set（CSet，回收集合）**：每次 GC 选定的待回收 Region 集合，其大小由 “延迟优先” 铁律决定
- **关联逻辑**
	- G1 将堆划分为等大 Region（默认 1MB~32MB，由堆大小自动计算），Region 分为年轻代（Eden/Survivor）和老年代，无需物理隔离（仅逻辑标记）；
	- 每个 Region 绑定一个 RSet，RSet 记录 “其他 Region 中指向本 Region 存活对象的引用”，由 Card Table 触发更新；
	- 并发标记阶段通过 SATB 算法生成堆中存活对象的快照，筛选出回收价值最高的 Region 组成 CSet；
	- 回收时对 CSet 中的 Region 执行复制压缩，将存活对象复制到空 Region，原 Region 清空后重新加入堆内存循环利用。
- 回收阶段：
	- 新生代垃圾回收（STW）：回收Eden和Survivor区
		- 触发时机：G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 `-XX:MaxGCPauseMills` 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做YoungGC，直到下一次Eden区放满，G1计算回收时间接近参数 `-XX:MaxGCPauseMills` 设定的值，那么就会触发YoungGC。
		  - 工作流程：
			  - 标记：解决RSet加速标记
				  1. 根扫描：得到GC Root
				  2. 更新RSet：处理 dirty card 队列中的 card，更新 RSet
					  - 作用：使得RSet 可以准确的反映老年代对所在的region 分区中对象的引用
				  3. 处理RSet
					  - 识别被老年代对象指向的 Eden 中的对象，这些被指向的Eden中的对象被认为是存活的对象
			  - 复制：
				  - 将 Eden 区存活的对象将被拷贝到 to survivor 区
				  - from survivor 区存活的对象则根据存活次数阈值分别晋升到 PLAB、to survivor 区和老年代中
					  - 如果 survivor 空间不够，Eden区的部分数据会直接晋升到年老代空间。
			  - 处理引用：处理软引用、弱引用、虚引用
	- 全局并发标记：初始标记和根区域扫描，为并发标记提供根对象，最终标记处理在并发过程中的引用关系新更改
		1. 初始标记（STW）：与一次Young GC的STW时间一并完成的，将新生代垃圾回收后的新生代Survivor分区作为根
			- 带来的额外开销非常小。
		2. 根区域扫描（并发）：
			- 工作内容：扫描在初始标记阶段结束时Survivor区中所有的对象（这些对象是根），并标记它们引用的老年代对象。
			- 时间要求：在**下一次Young GC发生之前**完成
				- 新的YoungGC后,Survivor区对象会发生改变
		3. 并发标记（并发）：标记的快照（SATB）
			- 触发时机：老年代的内存占用率达到一个特定的阈值，G1才会在下次Young GC后启动并发标记周期
				- 阈值的目的：G1希望在老年代还没有被完全填满之前，就提前开始分析哪些老年代Region中的垃圾最多，为后续的混合回收​ 做好准备，从而**避免陷入必须进行Full GC**的窘境
			- 标记的起点：
				- 初始标记中确定的Survivor分区
				- 根区域扫描中确定的老年代对象
		4. 最终标记（STW）：
			1. 处理剩余的[[漏标]]缓冲区：它通过捕捉引用删除，保证了在并发环境下标记的准确性，解决了“对象消失”这一核心难题
			2. 引用对象处理
				- 针对对象：**软引用、弱引用、虚引用和最终引用**。
				- 处理方式：G1会判断这些引用指向的对象是否已经被标记为不可达（垃圾），如果是，则会将它们加入到相应的引用队列中，等待Java应用程序自己处理
			3. 类卸载
				- 实现基础：在最终标记阶段确认了所有存活对象后，G1可以识别出**不再被任何存活对象引用的类**（即类的元数据），从而进行类卸载
				- 目的：有助于释放元空间的内存
		5. 回收价值计算
			- 需求背景：传统类卸载（非并发），通常在Full GC的STW阶段进行
				- 增加Full GC的停顿时间
				- 频率低且耗时
			- 实现基础：最终标记阶段结束后，G1对每个Region中存活对象的数据就有了准确的了解
			- 计算：
				- 每个Region的**回收价值**：即回收该Region能释放多少空间
				- 每个Region的**回收成本**：复制其存活对象需要的开销
			- 作用：**筛选回收阶段**决定优先回收哪些Region的直接依据
	- 混合收集：对三类区域进行垃圾回收
		- 工作流程：
			1. **筛选回收集CSet**：
				- 包括所有的年轻代Region，
				- 还会**选择性地加入一部分老年代Region**。
					- 选择的标准是“垃圾优先”，即优先选择垃圾比例高（回收价值大）的老年代Region。
			2. **复制存活对象，清空CSet的Region**：此阶段需要 **STW**。
				- 回收算法：**复制算法**
				- 复制的具体流程：这个过程与Young GC类似，但回收范围扩展到了老年代
					1. 将CSet中所有存活的对象**疏散**（Evacuate）​ 到新的空闲Region中
					2. 然后**清空**整个CSet的Region。
		- 回收特点：**分多次回收**
			- 设计目的：将总停顿时间控制在预期目标
			- 实现方式：分多次回收，在停顿间隔中让应用程序运行，从而避免单次STW时间过长，
			- 次数：G1默认会将混合回收分成**最多8次**进行
				- 可通过 `-XX:G1MixedGCCountTarget`调整。

- 优化：
	- 字符串去重
		- 需求背景：字符串冗余
			- 大量动态创建字符串
		- 解决措施：
			- 字符串入池
				- 使用[[字符串常量池|StringTable]]去重，共享 `String`对象本身在字符串常量池中的引用
				- 可以使用 `==`来快速比较内容是否相同
					- 比 `equals()`方法更快，因为 `==`只比较引用地址
			- G1字符串去重
				- 仍然是不同的字符串对象，共享字符串对象底层的 `char[]`字符数组
		- 开启方式：`-XX:+UsestringDeduplication`
		- 工作流程：
			- 将所有新分配的字符串放入一个队列
			- 当新生代回收时，G1并发检查是否有字符串重复
				- 如果它们值一样，让它们引用同一个 char数组![[Pasted image 20251208103514.png]]

	- 回收巨型对象![[Pasted image 20251208110003.png]]
		- 巨型对象定义：占据region的一半及其以上
		- 回收巨型对象的时候：G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉
			- 回收的时候优先考虑，越早回收越好
			- G1不会对巨型对象进行拷贝
	- 并发标记开始时间调整
		- 需求背景：减少Full GC
		- 核心思想：提早开始并发标记，提早开始混合回收，减少FullGC的发生机率
		- 配置：JDK9之后，能动态调整触发阈值（老年代占用堆空间比例达到阈值）
			- 设置初始值`-XX:InitiatingHeap0ccupancyPercent `用来设置初始值
			- 垃圾回收的时候进行数据采样并动态调整，总会添加一个安全的空间