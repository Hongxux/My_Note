**视图就是给一条常用的、可能很复杂的 `SELECT`查询语句起了一个别名（视图名），之后就可以通过这个别名方便地获取数据**。

1. **简单：简化操作，提升效率
- ​**核心价值**​：视图将复杂的查询逻辑（如多表连接、过滤条件）封装起来，对用户而言，视图就像一个真实的表。
- ​**具体表现**​：
    - ​**简化理解**​：用户无需关心数据来自哪些表以及表之间复杂的关联关系，只需面对一个结构清晰的视图。
    - ​**简化操作**​：对于频繁使用的复杂查询（例如，需要连接5张表才能获取的结果），可以将其创建为视图。之后，用户只需简单的 `SELECT * FROM 视图名`即可，避免了每次重复编写冗长且易错的SQL语句。
- ​**示例**​：将 `订单、客户、商品`三张表的复杂连接查询定义为 `v_order_summary`视图，业务人员直接查询该视图即可获得完整的订单摘要信息。
    

 2. **安全：数据安全与权限控制**
- ​**核心价值**​：视图是实现**列级**和**行级**数据权限控制的强大工具。
- ​**具体表现**​：
    - ​**限制数据访问**​：可以授权用户只能访问视图，而不能直接访问底层基表。
    - ​**隐藏敏感列**​：创建一个只包含非敏感字段的视图（如只显示`姓名、部门`，隐藏`薪资、电话号码`），使用户无法查看到他们不应看到的数据。
    - ​**过滤数据行**​：可以创建一个带 `WHERE`条件的视图（如 `WHERE department = '财务部'`），使用户只能看到与本部门相关的数据。
        
- ​**示例**​：创建 `v_public_employee`视图，仅包含员工的公开信息，从而保护员工的薪资、身份证号等隐私字段。


 3. **数据独立：逻辑独立性，屏蔽变化
- ​**核心价值**​：视图可以帮助应用程序在一定程度上**抵御底层数据库表结构变化所带来的冲击**，降低维护成本。
- ​**具体表现**​：
	- ​**屏蔽表结构变更**​：当底层基表的结构发生改变时（如增加列、拆分表），只要视图的查询语句能够被调整以适应变化，那么访问该视图的应用程序就**无需修改**。
    - ​**逻辑数据独立性**​：为应用程序提供了一种相对稳定的逻辑数据模型，即使物理模型（表结构）优化调整，只要视图接口不变，上层的业务逻辑就能保持稳定。  
- ​**示例**​：原本数据存在一张`用户信息`大表中，后来为了优化性能将其拆分为`用户基础表`和`用户详情表`。此时，可以修改原有视图的定义为两表的连接查询，而所有基于该视图的查询语句都无需改动。
### 一、什么是视图？
视图可以被理解为一个**虚拟表**。

- ​**核心特征1：虚拟存在**​
    
    视图中的数据**并不真实地存储在数据库中**。它的行和列的数据来自于定义视图时引用的基表（真实存在的表），并在用户查询视图时**动态生成**。
    
- ​**核心特征2：保存的是逻辑，而非结果**​
    
    视图本质上保存的是一条**预定义的 `SELECT`查询语句**，而不是保存查询的结果集。因此，当你查询视图时，数据库引擎会实时执行这条预存的 `SELECT`语句，并将结果作为虚拟表返回给你。
    
- ​**创建视图的核心工作**​
    
    正因为视图保存的是逻辑，所以创建视图的主要工作就是精心编写这条 `SELECT`查询语句。
    

### 二、视图相关操作

#### ​1.创建视图
**基本语法结构：​**​

```
CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS
SELECT 语句
[WITH [CASCADED | LOCAL] CHECK OPTION];
```

​**语法组件解析：​**​

1. ​**`CREATE VIEW ... AS ...`**​
    
    - 这是最基础的命令，意思是“创建一个视图，其内容由后面的 `SELECT`语句定义”。
        
    
2. ​**`[OR REPLACE]`（可选）​**​
    
    - 如果指定此关键字，当要创建的视图已经存在时，会**替换**掉已有的视图。这是一个非常方便的功能，无需先手动删除旧视图。
        
    
3. ​**`视图名称 [(列名列表)]`**​
    
    - `视图名称`：为你创建的视图取一个名字。
        
    - `(列名列表)`（可选）：可以自定义视图中列的别名。如果省略，视图的列名将直接使用 `SELECT`语句中查询出的列名。
        
    
4. ​**`SELECT 语句`**​
    
    - 这是视图的**灵魂**。它定义了视图要展示的数据来源、过滤条件、连接关系等。这可以是任意复杂的合法 `SELECT`查询。
        
    
5. ​**`[WITH CHECK OPTION]`（可选）​**​
    
    - 这是一个重要的**约束选项**，主要用于**可更新视图**​（即可以通过视图对基表进行插入、更新操作）。
        
    - 它的作用是保证通过视图对数据进行修改时，该数据必须仍然符合视图定义中的 `WHERE`条件。
        
    - `CASCADED`（默认）与 `LOCAL`选项控制了检查的粒度，涉及视图嵌套时的约束检查范围。
        
##### 视图的检查选项（WITH CHECK OPTION）
这是视图的高级特性，用于保证数据完整性。

当通过视图**插入、更新或删除**数据时（前提是视图可更新），
- `WITH CHECK OPTION`子句会强制要求这些操作的结果**必须符合视图本身的定义条件**​（即 `WHERE`子句），
- 而local与cascaded（默认）则决定是否会检查所依赖的视图是否定义了WITH CHECK OPTION
	- local是询问直接依赖视图，是否有检查条件（with check option）
	- cascaded相当于将其底层的检查条件结合到自己身上
	- 因此如果当先视图是with local check option，但是直接依赖视图是with cascaded check option（他这个的条件继承了所有依赖的视图的条件），是否代表会检查所有底层视图

如果操作会导致数据不符合视图条件，则会被拒绝。

**检查范围选项：CASCADED vs. LOCAL**

这两个选项决定了检查的严格程度，当视图基于其他视图（视图嵌套）时尤为重要。

1. ​**`CASCADED`（级联检查，默认值）​**​：
    
    - ​**行为**​：进行写操作时，数据库不仅检查当前视图的条件，还会**递归检查所有底层基视图**的条件。
        
    - ​**示例**​（基于第3张图）：
        
        ```
        -- 假设 v1 定义: WHERE id <= 15
        CREATE VIEW v2 AS 
        SELECT * FROM v1 WHERE id >= 10 
        WITH CASCADED CHECK OPTION;
        ```  
    - ​**关键**​：`CASCADED`会检查整个视图链的所有条件。
        
    
2. ​**`LOCAL`（本地检查）​**​：
    
    - ​**行为**​：进行写操作时，数据库只检查**当前视图的条件**。如果当前视图是基于其他视图的，它只会检查那些底层视图是否也定义了 `WITH CHECK OPTION`；如果有，则也检查它们，否则不检查。
        
    - ​**示例**​（基于第4张图）：
        
        ```
        CREATE VIEW v1 AS SELECT id, name FROM student WHERE id <= 15;
        CREATE VIEW v2 AS SELECT id, name FROM v1 WHERE id >= 10 WITH LOCAL CHECK OPTION;
        CREATE VIEW v3 AS SELECT id, name FROM v2 WHERE id < 20;
        ```
        
        - 通过 `v3`插入 `id=25`的记录：
            
            - `v3`没有定义 `CHECK OPTION`，所以不检查。
                
            - `v2`定义了 `WITH LOCAL CHECK OPTION`，会检查 `id >= 10`（25满足）。
                
            - `v1`没有定义 `CHECK OPTION`，所以即使 `id=25`不满足 `v1`的 `id <= 15`，操作也**可能被允许**​（取决于数据库实现，通常只要直接依赖的视图条件满足即可）。
                
            
        
    - ​**关键**​：`LOCAL`只检查当前视图及其直接依赖视图中定义了 `CHECK OPTION`的条件，检查范围更宽松。
        
    

 **核心区别总结**

|选项|检查范围|严格程度|适用场景|
|---|---|---|---|
|​**`CASCADED`**​|当前视图 + ​**所有底层视图**的条件|更严格|需要强数据完整性，确保操作不违反任何视图定义|
|​**`LOCAL`**​|当前视图 + ​**仅直接依赖视图中定义了 `CHECK OPTION`**​ 的条件|更宽松|只需保证直接依赖的约束，允许更灵活的写入|

​**建议**​：在需要严格数据完整性约束时使用 `CASCADED`；如果视图嵌套复杂且希望减少限制，可考虑 `LOCAL`。

##### 通过视图更新、插入数据
并非所有视图都可以通过 `INSERT`、`UPDATE`、`DELETE`语句进行修改。​**​ 视图能否被更新，取决于其定义是否满足特定条件。

###### 一、 可更新的核心条件（必要条件）

视图可更新的最根本条件是：

> ​**视图中的行与基础表中的行之间必须存在一对一的关系。​**​

这意味着：

- 视图的每一行必须**明确地对应**于底层基表中的**唯一一行**。
    
- 数据库必须能够**毫无歧义地**将你对视图数据的修改，反向映射并应用到具体的基表行上。
    

##### 二、 导致视图不可更新的具体情形（充分条件）

当视图的定义包含以下任何一项时，它将破坏“一对一”的映射关系，从而导致视图**不可更新**​：

1. ​**聚合函数或窗口函数**​（如 `SUM()`, `MIN()`, `MAX()`, `COUNT()`等）
    
    - ​**原因**​：这些函数将多行数据汇总成一行结果。数据库无法确定如何将对这个“汇总行”的修改（例如，修改一个平均值）反向应用到原始的多行数据上。
        
    - ​**示例**​：`CREATE VIEW sales_summary AS SELECT product_id, SUM(amount) AS total_sales FROM orders GROUP BY product_id;`此视图不可更新。
        
    
2. ​**`DISTINCT`关键字**​
    
    - ​**原因**​：`DISTINCT`用于去除重复行，这可能由多行基表数据合并而成。修改去重后的视图行，数据库无法确定具体要修改哪一条原始的重复记录。
        
    
3. ​**`GROUP BY`子句**​
    
    - ​**原因**​：与聚合函数类似，`GROUP BY`将多行数据分组，创建出代表整个组的新行。无法将对该组代表的修改反向应用到组内的所有具体行。
        
    
4. ​**`HAVING`子句**​
    
    - ​**原因**​：`HAVING`通常与 `GROUP BY`一起使用，对分组后的结果进行过滤。它依赖于分组聚合，因此同样不具备到基表的一对一映射。
        
    
5. ​**`UNION`或 `UNION ALL`**​
    
    - ​**原因**​：这些操作符将多个 `SELECT`语句的结果集合并。视图中的一行可能来自多个不同的基表或查询，数据库无法确定一条修改语句应该作用于哪个源结果集。
        
    

#### 2.视图的查询操作

视图创建后，需要掌握如何查看其定义和数据。第1张图列出了两个基本命令：

1. ​**查看视图的创建语句**​：
    
    ```
    SHOW CREATE VIEW 视图名称;
    ```
    
    - ​**作用**​：显示创建该视图的完整 SQL 语句，包括基表、筛选条件等定义细节。这对于审计或重建视图非常有用。
        
    - ​**示例输出**​：会返回包含 `CREATE VIEW`语法的结果，您可以从中看到视图的原始定义。
        
    
2. ​**查看视图的数据**​：
    
    ```
    SELECT * FROM 视图名称;
    ```
    
    - ​**作用**​：像查询普通表一样检索视图中的数据。视图是虚拟表，此操作会**动态执行**视图定义中的 `SELECT`查询并返回结果。
        
    - ​**注意**​：如果视图基于复杂的多表连接或聚合，此查询可能较慢，因为它每次都会执行底层查询。
        
    

​**关键点**​：视图不存储数据，只存储逻辑。`SELECT * FROM 视图`实际上是实时执行其定义好的 `SELECT`语句。

#### 3.视图的修改与删除操作

当业务逻辑变化时，需要修改或移除视图。第2张图给出了两种修改方式和删除命令。

#### 修改视图的两种方式：

1. ​**使用 `CREATE OR REPLACE VIEW`（推荐）​**​：
    
    ```
    CREATE OR REPLACE VIEW 视图名称 [(列名列表)] AS
    SELECT 语句
    [WITH [CASCADED | LOCAL] CHECK OPTION];
    ```
    
    - ​**优点**​：如果视图已存在，则**替换**它；如果不存在，则创建它。无需先执行 `DROP VIEW`，更安全便捷。
        
    
2. ​**使用 `ALTER VIEW`**​：
    
    ```
    ALTER VIEW 视图名称 [(列名列表)] AS
    SELECT 语句
    [WITH [CASCADED | LOCAL] CHECK OPTION];
    ```
    
    - ​**功能**​：直接修改现有视图的定义。与 `REPLACE`类似，但语法更显式地表明是修改操作。
        
    

#### 删除视图：

```
DROP VIEW [IF EXISTS] 视图名称 [, 视图名称] ...;
```

- ​**作用**​：永久删除一个或多个视图。视图删除后，其定义从数据库中移除，但**不影响基表数据**。
    
- ​**`IF EXISTS`**​：可选关键字，避免因尝试删除不存在的视图而报错，提高脚本健壮性。
    

​**最佳实践**​：修改视图时，优先使用 `CREATE OR REPLACE VIEW`，因为它兼具创建和修改功能，且能避免误操作。

#### 三、一个简单的创建示例

假设有一张员工表 `employees`，包含 `id`, `name`, `department`, `salary`等字段。我们想创建一个只显示“技术部”员工基本信息的视图。

```
-- 创建视图
CREATE OR REPLACE VIEW view_tech_employees (emp_id, emp_name, dept) AS
SELECT id, name, department
FROM employees
WHERE department = '技术部'
WITH CHECK OPTION;
```

​**使用视图：​**​

创建成功后，你可以像查询普通表一样查询这个视图：

```
SELECT * FROM view_tech_employees;
```

数据库在执行这条语句时，会动态地去执行 `SELECT id, name, department FROM employees WHERE department = '技术部'`并将结果返回。

### 总结

视图是一个强大的数据库功能，其主要优点包括：

- ​**简化复杂查询**​：将复杂的多表连接和过滤条件封装在视图中，用户只需查询简单的视图即可。
    
- ​**增强数据安全性**​：可以只暴露基表的部分行（通过 `WHERE`）或列（通过选择特定列），保护敏感数据。
    
- ​**逻辑数据独立性**​：即使底层基表的结构发生变化（如增加列），只要视图的查询结果不变，依赖于视图的应用程序就可能无需修改。


