---
aliases:
  - 事件通知模式
  - ET
  - LT
---
事件通知模式（callback）：![[Pasted image 20251127143304.png]]![[Pasted image 20251127143319.png]]
- 影响：事件通知模式决定被拷贝到events数组的的fd在list_head的去留
	- 在调用epoll_wait的时候会接受通知
	- 当收到通知后就绪fd从list_head拷贝events数组，
- LevelTriggered（LT）:只要文件描述符处于就绪状态（如内核读缓冲区不为空），每次调用 `epoll_wait`都会通知应用程序
	- 模式含义：当FD有数据可读时，会重复通知多次，直至数据处理完成。
		- 数据处理每次只能读取一定大小，
		- 数据多可能一次读不完（存在数据残留），需要读多次
		- LT能提醒将其数据全部读完
	- 是Epoll的默认模式。
	- 问题：
		- 重复通知的性能损耗：如果应用程序未能及时处理，这种重复通知会导致 cpu空转
		- 惊群效应：一个FD就绪，全部监听的线程都被唤醒
			- 只有一个能成功 `accept`到这个连接，其他进程/线程会 `accept`失败
			- 只需要几个线程就能处理完这个fd的数据
	- 解决方法：
		- 避免重复通知的性能损耗：
			- 在每次 `epoll_wait`返回后，务必循环处理所有就绪的事件，直到它们被处理完毕
		- 避免惊群效应：
			- 让每个工作进程创建自己独立的 epoll 实例（epfd）来管理连接，而不是共享同一个
- EdgeTriggered（ET）:仅在文件描述符的就绪状态**发生变化时**（如从无数据到有数据）通知一次
	- 模式含义：当FD有数据可读时，只会被通知 一次，不管数据是否处理完成。
		- 残留数据的丢失：可能会导致数据只读取了部分，而没有读完
	- 解决数据残留的方式：
		- 使用非阻塞IO循环读数据
			- 阻塞IO：读完后还会阻塞着等待有数据
			- 非阻塞IO：读完后能立刻返回告知没数据了