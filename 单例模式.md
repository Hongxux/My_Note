- 需求背景：
	- 避免资源冲突：
		- 设想一个日志记录器（Logger），如果每个需要打日志的模块都 `new`一个自己的 `Logger`实例，并且都写入同一个日志文件，在多线程环境下就可能发生多个线程同时写入的情况，导致日志内容相互覆盖、交错或丢失
		- 单例模式确保只有一个 `Logger`实例在操作文件，从而有序地管理这个临界资源
	- 保证全局状态唯一：单例模式确保所有模块读取到的都是同一份、唯一的配置状态
	- 优化性能与资源使用：
		- 有些对象的创建成本很高，例如数据库连接池。每次需要数据库连接时都新建一个池子再销毁，是极大的资源浪费
		- 单例模式确保这类重量级对象只创建一次，反复使用，显著提升性能
- 实现目标：
	- 受控的实例创建
		- 含义：杜绝外部代码通过 `new`关键字随意创建实例的可能
		- 实现方式：将类的构造函数设为私有
	- 简化的访问方式
		- 含义：提供一个**静态的公共方法**（常命名为 `getInstance()`）作为全局访问点
	- 线程安全：防止多个线程同时首次调用 `getInstance()`时创建出多个实例
- 实现方式
	- 饿汉式
	- 懒汉式：[[double-cheched locking]]
	- 静态内部类：利用 JVM 的类加载机制
		```
			public class InnerClassSingleton {
		    // 1. 私有构造器
		    private InnerClassSingleton() {
		    }
		
		    // 2. 静态内部类持有单例实例
		    private static class SingletonHolder {
		        // JVM 在加载类时是线程安全的，保证 INSTANCE 被安全地初始化
		        private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();
		    }
		
		    // 3. 全局访问点
		    public static InnerClassSingleton getInstance() {
		        // 首次调用 getInstance 时，才会加载并初始化 SingletonHolder，从而创建 INSTANCE
		        return SingletonHolder.INSTANCE;
		    }
		}
		```
		- 实现原理：
			- SingletonHolder.INSTANCE访问了类的静态变量
				- 触发SingletonHolder类加载的初始化
				- 在类加载的初始化阶段，才调用cinit构造方法，对静态成员变量进行赋值操作，创建InnerClassSingleton对象
			- JVM保证SingletonHolder类的初始化线程安全
		- 优点：线程安全、懒加载、实现简洁、无同步性能损耗
		- 问题：无法防御复杂的反射或序列化攻击
	- 枚举：
		```
		public enum EnumSingleton {
		    // 1. 枚举元素，本身就是单例
		    INSTANCE;
		
		    // 2. 可以添加任意需要的实例方法
		    public void doSomething() {
		        System.out.println("枚举单例方法执行。");
		    }
		
		    // 3. 示例：一个带状态的单例
		    private String state = "初始状态";
		
		    public String getState() {
		        return state;
		    }
		
		    public void setState(String state) {
		        this.state = state;
		    }
		}
		
		// 使用方式：
		// EnumSingleton instance = EnumSingleton.INSTANCE;
		// instance.doSomething();
		```
		- **绝对的单例**：JVM 从根本上保证枚举实例的唯一性，能有效防止通过反射和反序列化创建新实例。
		- **代码极简**：枚举本身是全局访问点。
		- **线程安全**：枚举实例的创建是线程安全的。
		    **适用场景**：需要防御反射、反序列化攻击，或者单例本身天然适合用枚举概念表达（如状态、策略等）。