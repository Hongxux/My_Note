---
aliases:
  - 栈帧
---


- 栈内存的使用
	- 服务对象：线程
		- 每个线程有自己的栈内存
		- 栈内存之间互相独立
	- 分配时机：每个线程启动的时候，JVM就会为其分配一个栈空间
	- 分配的大小：大小固定
		- 设置每个线程的栈内存大小：`-Xss`
			- 影响在总内存有限的情况下，增加此值意味着可创建的线程总数会减
	- 组成成分：栈帧
		- 分配时机：每次方法调用时
			- 方法被调用时候，对应的栈帧压入栈顶，成为活动栈帧
				- 活动栈帧：每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法
			- 方法执行完毕，对应的栈帧被弹出，返回方法返回地址所指向的位置继续执行
		- 栈帧存储的内容：![[Pasted image 20251208151434.png]]
			-  局部变量表：
				- 本质：一个个变量槽
					- 槽的大小确定：通过方法区中记录的局部变量数量确定
					- 存储变量属性和占的槽数：
						- 每个 Slot 都能存放一个 boolean、byte、char、short、int、float、reference（对象引用）或 returnAddress 类型的数据。
						- 64位的 long 和 double 类型变量会占用两个连续的 Slot
					- 局部变量表第 0 位索引的 Slot 默认用于存储方法所属对象的 **`this`引用**
				- 存放的范围：
					- 方法参数中带有的
					- 方法内部定义的
				- 存放的内容：
					- 基本类型变量
					- 对象引用。
			- 操作数栈：
				- 最大深度确定时机：在编译期就已确定，存储在方法Code属性的`max_stack`数据项
				- 作用：方法间数据传递
					- 调用者的操作数栈用于**准备参数**，将这些参数按顺序压栈。
					- 当被调用方法带有返回值时，其返回值会被压入**当前栈帧**（即调用者的栈帧）的操作数栈中
			- 动态链接：指向运行时常量池中该栈帧所属方法的引用。
				- 动态的含义：在程序运行期间，将类文件中的方法调用的符号引用转换为调用方法的直接引用
					- 符号引用：是编译时用**字面量**描述的抽象目标标识
					- 直接引用：是运行时转换后的**具体内存地址或偏移量**，可直接定位目标
				- 动态的目的：实现多态
					- 一个方法调用在编译时往往无法确定最终执行的是哪个类的方法。
					- 只有在运行时根据对象的实际类型，才能唯一确定应该调用的方法版本。
			- 方法返回地址：它记录了方法退出后，应该返回到哪里继续执行。
				- 内容：存放方法返回后需要继续执行的字节码指令地址。
					- 正常退出：当方法遇到返回指令（如 `return`）
						- 调用者的程序计数器（PC）的值就可以作为返回地址
					- 异常退出：方法执行过程中抛出的异常在方法体内没有被捕获，导致方法异常退出
						- 返回地址需要通过异常处理器表来确定
				- 退出操作：
					1. 当前栈帧出栈
					2. 恢复上层方法的局部变量表和操作数栈
					3. 将返回值（如果有）压入调用者栈帧的操作数栈
					4. 调整 PC 计数器的值
- 栈相关异常：
	1. `StackOverflowError`（栈内存溢出）：
		- 原因：
			- 栈帧过多
				- 线程的方法调用链过深（例如没有出口的递归），每次调用一个方法都增加栈帧
				- JSON转化器中待转化的类出现循环引用问题
			- 栈帧过大
	2. `OutOfMemoryError`：内存溢出
		原因：JVM没有足够的内存空间为一个新创建的线程分配其私有的栈内存时。
- [[线程运行诊断]]
	
