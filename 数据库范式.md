需求背景：早期数据库设计中因结构不合理而引发的各种问题
- 根源：数据冗余：
	- 含义：相同信息在多个地方重复存储
- 直接问题：浪费空间，增加数据扫描负担
- 衍生问题：数据不一致性
	- 具体体现：操作异常（举例，用户表和订单表混杂）
		- 插入异常：无法**独立**插入某类信息
			- 示例：一个设计不佳的“订单和客户信息表”，其中每条订单记录都重复保存了客户的详细资料（如电话、地址）。如果你想新增一个客户，但该客户还没有下过任何订单，你就无法将这位客户的信息存入数据库
		- 删除异常：删除一条信息时意外丢失不应删除的数据（如删除订单导致客户信息丢失）
		- 更新异常：修改一处信息需更新多条记录，易遗漏且导致不一致

- 解决措施：**引入数据库范式**：通过规范化设计（如范式理论）消除冗余和依赖异常
	- 核心思路：
		- **单一职责原则**：每个表只描述一个实体或其与其他实体的关系
			- 作用：避免数据混合
		- **依赖最小化**：数据直接依赖于主键
			- 实现方式：通过范式层层递进，消除部分依赖、传递依赖
	- 问题：范式等级越高，数据库表会被拆分得越细。当进行查询时，往往需要将多个表连接（JOIN）​ 起来。这可能会增加查询的复杂性，并降低查询性能
		- 解决措施：核心结构遵循第三范式，但针对某些频繁且性能要求高的查询，会有意地引入冗余（反范式化）


----

- 重要概念：
	- 函数依赖：属性集X的值能唯一确定Y的值（如学号→姓名），称为 Y 函数依赖于 X
	- 部分函数依赖：非主属性依赖于**主键的一部分**（如（学号,课程号）→姓名，但学号→姓名也成立）
	- 完全函数依赖：非主属性必须依赖于**整个主键**
		- 示例：（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
	- 传递函数依赖：非主属性通过其他非主属性间接依赖于主键
		- 示例：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

**数据库范式**：
- 第一范式 (1NF)：
	- 核心要求：确保每列具有原子性，即列不可再分
	- 实现方式：将复合字段拆分为独立列或通过多行存储多值
		- 示例：如果有一个“联系方式”字段同时存储了电话和地址，这就不符合1NF。应拆分为“电话”和“地址”两个独立的字段。
	- 产出结果：消除重复组，确保每列存储单一值
- 第二范式 (2NF)：
	- 核心要求：在1NF基础上，消除非主属性对主键的部分函数依赖
	- 针对对象：非主键和部分主键存在依赖关系
	- 实现方式：
		1. 确定主键：哪个或哪几个字段能唯一确定一条行记录（由表主体对象是什么决定）
		2. 识别部分依赖：
		3. 表拆分：将部分依赖的字段移至新表，并通过外键关联
	- 示例：
		- 在一个(学号, 课程号, 学生姓名, 成绩)的表中，“学生姓名”只依赖于“学号”，与“课程号”无关，这就是部分依赖。应拆分为学生表和选课表。
- 第三范式 (3NF)： 
	- 核心要求：在2NF基础上，消除非主属性间的传递依赖
	- 针对对象：非主键和非主键存在依赖关系
	- 实现机制：
		- 将传递依赖的字段拆分到新表。
		- 确保非主属性只直接依赖于主键，不依赖于其他非主属性
	- 示例：在一个(员工号, 部门, 部门电话)的表中，“部门电话”依赖于“部门”，而“部门”又依赖于“员工号”，这就是传递依赖。应拆分为员工表和部门表。