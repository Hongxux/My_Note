
​**需求背景**​

在多线程环境下访问集合时，存在**并发修改风险**​：

- 多个线程同时操作集合可能导致数据损坏（如一个线程添加元素时，另一个线程正在重组哈希表）。
    
- 直接使用常规集合类（如 `HashMap`）在多线程场景下会导致未定义行为或数据损坏。
    

​**解决方案**​

Java 集合框架通过**视图机制**提供线程安全包装：

```
// 将普通 Map 转换为线程安全版本  
Map<String, Employee> map = Collections.synchronizedMap(new HashMap<>());
```

类似方法也适用于其他集合类型：`synchronizedList()`, `synchronizedSet()`等。

---

#### 核心特性

​**1. 方法级同步**​

- 包装后的集合所有公共方法（如 `get()`, `put()`, `remove()`）均添加 `synchronized`修饰符。
    
- 任一方法执行时，其他线程**无法同时调用该集合的任何方法**​（互斥访问）。
    

​**2. 线程安全保证**​

- 通过同步锁确保**原子性操作**，防止并发修改导致的数据不一致。
    
- 示例：
    
    ```
    // 线程1执行  
    map.put("Alice", new Employee());  
    // 线程2必须等待put()完成后才能执行get()
    Employee e = map.get("Alice");
    ```
    

​**3. 使用限制**​

- ​**复合操作非原子**​：多步骤操作（如"检查再更新"）仍需额外同步：
    
    ```
    synchronized(map) {
        if (!map.containsKey("Alice")) 
            map.put("Alice", new Employee());
    }
    ```
    
- ​**迭代器需手动同步**​：遍历时需显式加锁防止 `ConcurrentModificationException`。
    

---

### 重点知识分层

|​**学习者层级**​|​**必须掌握的核心内容**​|
|---|---|
|​**初学者**​|理解同步视图的目的：解决多线程并发访问集合的安全问题；掌握 `Collections.synchronizedXxx()`的基本用法。|
|​**进阶者**​|认识同步视图的局限性：复合操作需额外同步；迭代遍历需手动加锁；了解其与并发集合（如 `ConcurrentHashMap`）的性能差异。|

---

### 与其他技术的关系

- ​**并发包基础**​：同步视图是 Java 早期线程安全解决方案，为 `java.util.concurrent`包中的高性能并发集合（如 `ConcurrentHashMap`）奠定设计理念。
    
- ​**锁机制应用**​：底层使用对象监视器锁（`synchronized`），与 `ReentrantLock`等显式锁形成互补。
    
- ​**现代替代方案**​：在高并发场景中，优先考虑 `ConcurrentHashMap`或 `CopyOnWriteArrayList`等更高效的并发集合。