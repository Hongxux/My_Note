## 定义：什么是生成树
## 割性质（cut property）
最小生成树（MST）中的**割性质（Cut Property）​**​ 是其核心理论基础之一，它确保了贪心算法（如 Prim 和 Kruskal 算法）能够逐步构造出全局最优的最小生成树。下面我们来详细解读它的作用。

### ✂️ 1. 理解割与割性质

一个**割（Cut）​**​ 指的是将连通图的所有顶点划分成两个互不相交的非空集合 S和 V−S。​**跨越边（Crossing Edge）​**​ 则是那些一个端点在 S中，另一个端点在 V−S中的边。

​**割性质**指出：对于给定的任意一个割，​**跨越该割的权值最小的边（称为轻量级边，Light Edge）​**，必定属于图的最小生成树。
![[Screenshot_20250910_112343_tv_danmaku_bilibilihd_HDUnitedBizDetailsActivity.jpg]]

**证明正确性：反证法**
[[割性质的证明]]

![[Pasted image 20250910113004.png]]
### 💡 2. 割性质的核心作用

割性质最主要的作用是为贪心算法选择“安全边”提供了理论依据和保障。

- ​**为贪心算法提供正确性保证**​：Prim和Kruskal算法每一步都在做出当前看似最优的局部选择（选择最小权重的边）。割性质确保了这种局部最优的选择不会破坏得到全局最优解的可能性，每一步选择的边都必然存在于某个最小生成树中，因此是“安全”的。
    
- ​**是算法设计的基石**​：
    
    - 在 ​**Prim算法**​ 中，每次迭代时，当前已选顶点集 S和未选顶点集 V−S就定义了一个割。算法选择连接这两个集合的最小权重边，这正是直接应用了割性质。
        
    - 在 ​**Kruskal算法**​ 中，虽然它看似按边权排序全局选择，但其“不形成环”的规则等价于确保每次选择的边都是连接两个当前尚未连通的连通分量（这本身也定义了一个割）的最小边。这同样是割性质的应用。
        


### 🔍 3. 一个简单的例子

想象一个简单的三角形图，三个顶点为A、B、C，边权分别为 AB=2, AC=3, BC=1。

1. 假设初始割为 S={A}, V−S={B,C}。跨越此割的边是AB(2)和AC(3)，最小边是AB(2)。根据割性质，AB边应在MST中。
    
2. 将B加入S，此时割变为 S={A,B}, V−S={C}。跨越此割的边是AC(3)和BC(1)，最小边是BC(1)。根据割性质，BC边应在MST中。
    
    最终得到的最小生成树包含边AB和BC，总权重为3。这个过程模拟了Prim算法的思想。
    

### ⚖️ 4. 与环性质的关系

割性质常与**环性质（Cycle Property）​**​ 一同讨论，后者指出：​**在一个环中，权值最大的边一定不在最小生成树中**。这两个性质共同构成了MST理论的基石：

- ​**割性质告诉我们哪些边必须被包含（安全边）​**。
    
- ​**环性质告诉我们哪些边可以被排除（无效边）​**。
    
    贪心算法利用割性质“纳入”安全边，并隐含地利用环性质（通过避免成环）来排除无效边。
    

### 📝 5. 在算法证明中的重要性

在理论计算机科学中，割性质为证明贪心算法（如Prim和Kruskal）的正确性提供了关键工具。通过数学归纳法和反证法，可以证明基于割性质每一步选择的边都必然存在于某个最小生成树中，从而最终构造出的树就是最小生成树。

### 🌐 6. 实际应用中的价值

理解割性质有助于我们在解决实际问题时，更好地理解和设计网络优化方案。例如，在设计通信网络、交通网络或电路布线时，我们需要以最低成本连接所有节点。割性质从理论上保证了通过局部最优决策（选择当前连接两个部分的最便宜链路）来构建全局最优网络的可行性。

## Prim算法
[Prim算法的动画](https://visualgo.net/en/mst?create=%7B%22vl%22%3A%7B%220%22%3A%7B%22x%22%3A300%2C%22y%22%3A25%2C%22extratext%22%3A%22%22%7D%2C%221%22%3A%7B%22x%22%3A400%2C%22y%22%3A25%2C%22extratext%22%3A%22%22%7D%2C%222%22%3A%7B%22x%22%3A500%2C%22y%22%3A25%2C%22extratext%22%3A%22%22%7D%2C%223%22%3A%7B%22x%22%3A600%2C%22y%22%3A25%2C%22extratext%22%3A%22%22%7D%2C%224%22%3A%7B%22x%22%3A700%2C%22y%22%3A25%2C%22extratext%22%3A%22%22%7D%2C%225%22%3A%7B%22x%22%3A300%2C%22y%22%3A125%2C%22extratext%22%3A%22source%22%7D%2C%226%22%3A%7B%22x%22%3A400%2C%22y%22%3A125%2C%22extratext%22%3A%22%22%7D%2C%227%22%3A%7B%22x%22%3A500%2C%22y%22%3A125%2C%22extratext%22%3A%22%22%7D%2C%228%22%3A%7B%22x%22%3A600%2C%22y%22%3A125%2C%22extratext%22%3A%22%22%7D%2C%229%22%3A%7B%22x%22%3A700%2C%22y%22%3A125%2C%22extratext%22%3A%22%22%7D%7D%2C%22el%22%3A%7B%220%22%3A%7B%22u%22%3A1%2C%22v%22%3A6%2C%22w%22%3A8%7D%2C%221%22%3A%7B%22u%22%3A2%2C%22v%22%3A7%2C%22w%22%3A8%7D%2C%222%22%3A%7B%22u%22%3A3%2C%22v%22%3A8%2C%22w%22%3A8%7D%2C%223%22%3A%7B%22u%22%3A0%2C%22v%22%3A1%2C%22w%22%3A10%7D%2C%224%22%3A%7B%22u%22%3A1%2C%22v%22%3A2%2C%22w%22%3A10%7D%2C%225%22%3A%7B%22u%22%3A2%2C%22v%22%3A3%2C%22w%22%3A10%7D%2C%226%22%3A%7B%22u%22%3A3%2C%22v%22%3A4%2C%22w%22%3A10%7D%2C%227%22%3A%7B%22u%22%3A5%2C%22v%22%3A6%2C%22w%22%3A10%7D%2C%228%22%3A%7B%22u%22%3A6%2C%22v%22%3A7%2C%22w%22%3A10%7D%2C%229%22%3A%7B%22u%22%3A7%2C%22v%22%3A8%2C%22w%22%3A10%7D%2C%2210%22%3A%7B%22u%22%3A8%2C%22v%22%3A9%2C%22w%22%3A10%7D%2C%2211%22%3A%7B%22u%22%3A1%2C%22v%22%3A7%2C%22w%22%3A13%7D%2C%2212%22%3A%7B%22u%22%3A2%2C%22v%22%3A8%2C%22w%22%3A13%7D%7D%7D&action=prim+5)
### Prim算法和[[Dijkstra算法(求SSSP问题)]]的区别

尽管两种算法的**代码实现和流程（贪心策略、使用优先队列）非常相似**，但其根本目标和核心逻辑有本质区别。

|对比维度|​**Dijkstra算法**​|​**Prim算法**​|
|---|---|---|
|​**算法目的**​|寻找从**单一源点**到所有其他顶点的**最短路径**​|寻找连接图中所有顶点的**最小生成树（MST）​**​|
|​**核心概念**​|​**​"到源点的距离"​**​|​**​"到树的距离"​**​|
|​**顶点访问顺序**​|按**当前计算的到源点的总距离**从小到大访问|按**到当前已构建的MST集合的最小边权（距离）​**​ 从小到大访问|
|​**松弛操作**​|判断一条边能否提供一条**到源点更短的路径**​|判断一条边是否是**连接当前MST和外部顶点的最小权重边**​|

#### 通俗理解：

- ​**Dijkstra**在解决 ​**​“怎么走最短”​**​ 的问题。它关心的是从起点到终点的总路程最短，即使需要绕远路。
    
- ​**Prim**在解决 ​**​“怎么连最省”​**​ 的问题。它关心的是用最小的总成本（权重和）把所有点连接起来，形成一个整体网络，不关心任意两点间的具体路径是否最短。
    

简单来说，两者最根本的区别就在于**比较的对象**不同：Dijkstra算法始终围绕**源点（Source）​**​ 的距离，而Prim算法则围绕**树（Tree）​**​ 的距离。

## Kruskal算法
>Kruskal算法是解决**最小生成树**​（Minimum Spanning Tree, MST）问题的一种经典**贪心算法**。它的核心思想是：​**每次选择权值最小的边，并确保加入这条边后不会形成环**，直到所有顶点都被连接且边数达到顶点数减一

**正确性：割性质**

#### Kruskal算法的过程

Kruskal算法通过并查集（Union-Find）数据结构来高效判断边的两个顶点是否属于同一连通分量（即是否成环）。

​1. **初始化并查集**​：让每个顶点自成一个集合[[并查集--用集合中的一个元素代表集合]]
​2. **边按权值排序**​：将所有边按权值从小到大排序[[利用最小堆（Heaps）实现优先队列（Priority Queues）]]
​3. **遍历排序后的边**​：依次检查每条边，如果边的两个顶点**不在同一集合**​（即不连通），则选中该边，并**合并这两个顶点所在的集合**；如果两点已在同一集合中（连通），则跳过该边以避免形成环
​4. **终止条件**​：当选中的边数等于**顶点数减一**时，算法终止

>**优化的关键**：一是利用**并查集**判断是否成环，二是利用**PQ**来找权值最小的边



## [[Kruskal算法和Prim算法比较]]
