
循环依赖是指两个或多个 Bean 相互依赖，形成一个闭环。例如，Bean A 依赖 Bean B，而 Bean B 又依赖 Bean A。Spring 通过巧妙的设计解决了特定场景下的这个问题。

 Spring 解决循环依赖的核心机制——**[[三级缓存]]**

---


1. **规则一**：在 **singleton（单例） + setter注入**模式下，Spring 可以**正常解决**循环依赖。
    
2. **规则二**：在 **prototype（原型） + setter注入**模式下，Spring **无法解决**循环依赖，会抛出 `BeanCurrentlyInCreationException`异常。
    

### 一、 成功 scenario：Singleton + Setter 模式

#### 1. 工作机制

这种模式成功的关键在于 Spring 容器的 **“三级缓存”** 机制和 **“提前曝光”** 策略。其工作流程完全遵循上图所示的步骤。

**核心原理**：Spring 将 Bean 的创建分为两个核心阶段：

1. **实例化**：调用构造方法创建一个“不完整”的 Bean（此时属性均为 null）。
    
2. **属性赋值**：为这个“不完整”的 Bean 注入它所需的依赖。
    

关键在于，在第一阶段完成后、第二阶段开始前，Spring 会**提前将这个“不完整”的 Bean 的引用（早期引用）暴露出来**，供其他 Bean 依赖。这样就打破了循环等待。

#### 2. 配置示例

图3的配置是此模式的典型示例：

```
<bean id="husbandBean" class="com.powernode.spring6.bean.Husband" scope="singleton">
    <property name="wife" ref="wifeBean"/> <!-- Husband 依赖 Wife -->
</bean>
<bean id="wifeBean" class="com.powernode.spring6.bean.Wife" scope="singleton">
    <property name="husband" ref="husbandBean"/> <!-- Wife 又依赖 Husband -->
</bean>
```

**流程吻合**：

- Spring 开始创建 `husbandBean`。
    
- 实例化 `husbandBean`后，**立即将其早期引用曝光**。
    
- 准备为 `husbandBean`注入 `wife`属性时，发现需要 `wifeBean`，于是开始创建 `wifeBean`。
    
- 实例化 `wifeBean`后，**立即将其早期引用曝光**。
    
- 准备为 `wifeBean`注入 `husband`属性时，Spring 能从**三级缓存**中成功找到 `husbandBean`的早期引用并完成注入。
    
- `wifeBean`创建完成后，`husbandBean`的 `wife`属性也随之完成注入。循环依赖被解决。
    

### 二、 失败 scenario：Prototype + Setter 模式

#### 1. 原因分析

当 Bean 的作用域被定义为 `prototype`时，Spring 容器的行为发生了根本变化：

- **无缓存**：Spring 容器**不会缓存**原型 Bean 的实例。每次请求都会创建一个全新的对象。
    
- **无法曝光**：由于没有缓存，Spring 无法像处理单例 Bean 那样“提前曝光”一个正在创建中的原型 Bean 的引用。
    
- **死循环**：当尝试创建原型 Bean A 时，发现它需要 B；去创建原型 Bean B 时，又发现它需要 A。由于没有提前暴露的引用，创建过程会陷入“A 等 B，B 等 A”的死循环。
    

#### 2. 异常结果

此时，Spring 会检测到这种无法解决的循环依赖，并抛出 `BeanCurrentlyInCreationException`异常，提示“当前的 Bean 正在创建中”。

#### 3. 特例说明

图2中特别指出：**“当两个 bean 的 scope 都是 prototype 的时候，才会出现异常。如果其中任意一个是 singleton，就不会出现异常。”**

**原因**：只要循环依赖链中有一个 Bean 是 `singleton`，这个单例 Bean 就可以被“提前曝光”。创建流程会在这个单例 Bean 这里“锚定”，从而打破循环。例如：

- `prototypeBeanA`(依赖) -> `singletonBeanB`(依赖) -> `prototypeBeanA`
    
- 创建 `prototypeBeanA`时，会触发创建 `singletonBeanB`。
    
- `singletonBeanB`在实例化后会被曝光。
    
- 当 `singletonBeanB`需要注入 `prototypeBeanA`时，虽然会再次请求一个新的 `prototypeBeanA`实例，但由于 `singletonBeanB`本身的引用是确定的，循环链被打破，不会导致死循环。
    

### 总结与对比

| 场景     | 依赖模式               | 结果                                    | 根本原因                             |
| ------ | ------------------ | ------------------------------------- | -------------------------------- |
| **成功** | Singleton + Setter | 正常                                    | 利用**三级缓存**和**提前曝光**机制，打破循环等待。    |
| **失败** | Prototype + Setter | 抛出 `BeanCurrentlyInCreationException` | 原型模式**无缓存**，无法提前曝光引用，导致死循环。      |
| **特例** | 混合作用域（含Singleton）  | 正常                                    | 循环链中存在单例Bean作为“锚点”，可通过曝光其引用解决问题。 |


### 三、失败 构造器注入
构造器注入引发的循环依赖是 Spring 开发中一个经典的陷阱。简单来说，当两个或更多的 Bean **都通过构造函数**相互依赖对方时，Spring 容器就会陷入一个“鸡生蛋还是蛋生鸡”的死循环，导致启动失败并抛出 `BeanCurrentlyInCreationException`异常。



####  为什么构造器注入无法解决循环依赖？

这与 Spring Bean 的创建流程和三级缓存机制有关：

1. **构造器注入的时机不可协调**：构造器注入发生在 Bean **实例化**的阶段。要调用 `new A(B b)`，就必须先有一个完整的 `B`的实例。反之，要创建 `B`，又需要先有完整的 `A`。双方都卡在第一步，无法继续 。
    
2. **三级缓存失效**：Spring 解决 Setter 注入循环依赖的秘诀在于**三级缓存**。它允许在 Bean 实例化后、属性填充前，提前将一个“半成品”Bean（早期引用）暴露出来。然而，构造器注入连“实例化”这一步都无法完成，根本来不及将工厂对象放入三级缓存，因此这个机制完全失效 。
    

####  解决构造器注入循环依赖的方案

##### 方案一：使用 `@Lazy`注解（推荐）

这是解决构造器注入循环依赖最优雅和常见的方式。`@Lazy`注解的作用是**延迟初始化**。通过在其中一个依赖项上添加 `@Lazy`，你告诉 Spring：“不要立即初始化这个 Bean，先给我一个代理对象，等到第一次真正使用它时再初始化。”

**代码示例**：

```
@Service
public class ServiceA {
    private final ServiceB serviceB;
    // 在构造参数上使用 @Lazy
    public ServiceA(@Lazy ServiceB serviceB) {
        this.serviceB = serviceB; // 此时注入的其实是ServiceB的代理对象
    }
}

@Service
public class ServiceB {
    private final ServiceA serviceA; // ServiceB 依然正常依赖 ServiceA
    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }
}
```

**优点**：保持了使用构造器注入带来的**不可变性和强依赖**优势（字段可用 `final`修饰）。

**缺点**：引入了代理，使得调试略微复杂。

##### 方案二：改用 Setter/字段注入

将相互依赖的 Bean 中**至少一个**的注入方式从构造器注入改为 Setter 注入或字段注入。这样，Spring 就可以利用三级缓存机制来解决循环依赖 。

**代码示例（改为 Setter 注入）**：

```
@Service
public class ServiceA {
    private ServiceB serviceB; // 移除了 final
    // 使用 Setter 方法注入
    @Autowired
    public void setServiceB(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}

@Service
public class ServiceB {
    private final ServiceA serviceA;
    // ServiceB 保持构造器注入不变
    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }
}
```

**优点**：简单直接。

**缺点**：放弃了构造器注入的**不可变性**（字段不能是 `final`），可能会掩盖设计上的缺陷。

##### 方案三：使用 `ObjectProvider`（推荐）

`ObjectProvider`是 Spring 提供的一个接口，它允许你**延迟**且**安全**地获取 Bean。它本质上也提供了延迟加载的能力，但比 `@Lazy`更为显式和可控 。

**代码示例**：

```
@Service
public class ServiceA {
    private final ServiceB serviceB;
    // 注入的是 ServiceB 的 ObjectProvider
    public ServiceA(ObjectProvider<ServiceB> serviceBProvider) {
        // 在需要时（如初始化方法中）再获取 ServiceB 实例
        this.serviceB = serviceBProvider.getIfUnique();
    }
}
```

**优点**：非常灵活，可以精确控制 Bean 的获取时机和条件（例如 `getIfAvailable`）。是 Spring 官方推荐的方式之一。

**缺点**：代码稍显繁琐。

##### 方案四：重新设计代码（根治方法）

以上都是技术解决方案，但**最根本、最推荐的方法是重新审视你的代码设计**。循环依赖往往是**设计不良**的信号，说明类的职责可能过重或耦合度过高 。

- **提取公共逻辑**：将 A 和 B 都依赖的功能抽取到一个新的 `ServiceC`中。
    
- **使用事件驱动**：让 A 完成工作后发布一个事件，由 B 来监听并处理后续逻辑，从而解耦。
    
- **审视分层**：确保严格遵守 Controller -> Service -> Repository 的调用方向，避免同层之间的相互依赖。
    

##### 总结与最佳实践

|方案|核心思想|适用场景|优先级|
|---|---|---|---|
|**`@Lazy`注解**|延迟加载，注入代理对象打破死锁|希望保持构造器注入的不可变性|高|
|**`ObjectProvider`**|显式地延迟获取依赖|需要精确控制依赖获取时机|高|
|**改用 Setter 注入**|改变注入时机，利用三级缓存|快速修复，对不可变性要求不高的场景|中|
|**重新设计代码**|消除循环依赖，优化架构|从根本提升代码质量，是长期最佳选择|最高|

**最佳实践建议**：在遇到构造器注入的循环依赖时，优先考虑使用 **`@Lazy`**或 **`ObjectProvider`**作为临时解决方案，但同时要将其视为一个**重构的警示信号**，在后续迭代中规划代码重构，从根本上消除循环依赖，从而实现更健壮、更易于维护的系统架构 。