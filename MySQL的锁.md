## 一、概述
## 二、全局锁
![[Pasted image 20251101215847.png]]

### 一、全局锁概述

#### 核心概念

- ​**全局锁**是一种数据库级别的锁，用于对整个数据库实例加锁。
    
- ​**加锁后效果**​：数据库实例处于**只读状态**，所有数据修改操作将被阻塞，包括：
    
    - DML 写操作（如 `INSERT`、`UPDATE`、`DELETE`）
        
    - DDL 操作（如 `CREATE`、`ALTER`、`DROP`）
        
    - 事务提交（如 `COMMIT`）
#### 典型使用场景

- ​**全库逻辑备份**​：确保备份期间数据一致性，获取一个逻辑时间点的一致性视图。
    
- ​**数据迁移或维护**​：防止在关键操作过程中数据被修改，保证数据完整性。
    

#### 示意图解读

- 数据库实例（圆柱形）包含多张表（如 `tb_stock`、`tb_order`等）
    
- 加锁后，所有表被锁定，形成“只读快照”
    

---

### 二、加锁操作

#### 命令详解

```
FLUSH TABLES WITH READ LOCK;
```

- ​**作用**​：立即关闭所有打开的表，并对整个数据库加全局读锁。
    
- ​**执行结果**​：
    
    - 所有现有会话只能执行读操作（`SELECT`）
        
    - 新会话的写操作会被阻塞，直到锁被释放
        
    
- ​**注意事项**​：
    
    - 需要 `RELOAD`权限
        
    - 锁会持续到显式解锁或会话结束
        
    

---

### 三、数据备份操作
#### 备份命令详解

```
mysqldump -uroot -p itcast > itcast.sql
```

- ​**`mysqldump`**​：MySQL 官方逻辑备份工具
    
- ​**参数说明**​：
    
    - `-uroot`：指定用户名（root）
        
    - `-p1234`：指定密码（1234），生产环境建议使用 `-p`交互输入
        
    - `itcast`：要备份的数据库名
        
    - `> itcast.sql`：输出重定向到文件
        
    
- ​**备份内容**​：生成包含 SQL 语句的文本文件，可用于完整恢复数据库结构和数据
    
![[Pasted image 20251101220722.png]]

---

### 四、解锁操作

#### 命令详解

```
UNLOCK TABLES;
```

- ​**作用**​：释放当前会话持有的所有锁，包括全局读锁。
    
- ​**执行后**​：数据库恢复正常读写状态，被阻塞的写操作可以继续执行。
    

---

### 五、完整备份流程与最佳实践

#### 标准操作步骤

1. ​**连接数据库**​
    
    ```
    mysql -uroot -p
    ```
    
2. ​**加全局锁**​（确保一致性）
    
    ```
    FLUSH TABLES WITH READ LOCK;
    ```
    
3. ​**检查锁状态**​（可选但推荐）
    
    ```
    SHOW PROCESSLIST;  -- 确认无写操作在进行
    ```
    
4. ​**执行备份**​（新开终端会话）
    
    ```
    mysqldump -uroot -p1234 itcast > itcast.sql
    ```
    
5. ​**释放锁**​（返回第一个会话）
    
    ```
    UNLOCK TABLES;
    ```
    

#### 流程示意图

```
加锁 (FLUSH TABLES WITH READ LOCK) 
    ↓
备份 (mysqldump) 
    ↓
解锁 (UNLOCK TABLES)
```

#### 注意事项

1. ​**业务影响**​：加锁期间所有写操作会被阻塞，应在业务低峰期进行
    
2. ​**锁超时**​：如果备份时间过长，可能导致连接超时，锁自动释放
3. 
    
3. ​**替代方案**​：对于 InnoDB 引擎，推荐使用 `--single-transaction`参数实现无锁备份
    
    ```
    mysqldump --single-transaction -uroot -p1234 itcast > itcast.sql
    ```
    例如：
![[Pasted image 20251101220737.png]]
---

## 三、表级锁

### 表锁
![[Pasted image 20251102085549.png]]
表级锁是 MySQL 中最基本的锁机制，它直接锁定整张表，以保证数据操作的完整性。
#### 一、 表锁的分类

表锁分为两类，这两种锁的特性与上图所示的“独占性”直接相关：

1. ​**表共享读锁（Read Lock）​**​
    
    - ​**特性**​：如上图所示，多个会话可以同时获得同一张表的**读锁**，即“共享”。获得读锁后，会话**只能读表，不能写表**，并且会阻塞其他会话申请写锁。
        
    - ​**适用场景**​：适用于需要确保在读取过程中数据不被更改，但允许其他会话并发读取的场景。
        
    
2. ​**表独占写锁（Write Lock）​**​
    
    - ​**特性**​：如上图所示，写锁是**独占和排他**的。一个会话获得某张表的写锁后，​**既可以去写，也可以去读**，但**其他会话不能再对该表加任何锁（无论是读锁还是写锁）​**，直到该锁被释放。其他会话的读写操作都会被阻塞。
        
    - ​**适用场景**​：适用于需要对表进行数据更新（INSERT、UPDATE、DELETE）或表结构变更（ALTER）等操作，需要严格排他的场景。
#### 二、 加锁与释放锁的语法

1. ​**加锁语法**​
    
    ```
    LOCK TABLES 表名 [AS 别名] READ;   -- 加读锁
    LOCK TABLES 表名 [AS 别名] WRITE;  -- 加减锁
    ```
    
    - ​**关键点**​：如图中流程所示，锁是**会话级别**的。加锁成功后，该会话后续的所有操作都受此锁约束。
        
    
2. ​**释放锁语法**​
    
    - ​**显式释放**​：
        
        ```
        UNLOCK TABLES;
        ```
        
    - ​**隐式释放**​：当客户端会话断开连接时，也会**自动释放**该会话持有的所有锁。
        
    

#### 三、 一个简单的示例

```
-- 会话1 操作
-- 1. 对表`users`加写锁
LOCK TABLES users WRITE;

-- 2. 执行一些需要排他性的操作，例如批量更新
UPDATE users SET status = 'inactive' WHERE last_login < '2020-01-01';

-- 3. 操作完成后，显式释放锁
UNLOCK TABLES;


-- 会话2 操作（在会话1未UNLOCK TABLES之前）
-- 尝试查询，会被阻塞，直到会话1释放写锁
SELECT * FROM users; -- 此查询需要等待
```

#### 总结与注意事项

1. ​**粒度较粗**​：表锁一次性锁住整张表，并发性能较低。对于并发量高的应用，InnoDB 存储引擎的**行级锁**是更优的选择。
    
2. ​**会话绑定**​：锁是由会话持有和释放的，如流程图所示，这是理解其行为的关键。
    
3. ​**隐式提交**​：对表加锁（`LOCK TABLES ...`）操作会隐式提交当前会话中所有未提交的事务。
    
4. ​**存储引擎差异**​：表锁在 MyISAM、MEMORY 等存储引擎中是主要锁机制，而 InnoDB 虽然也支持表锁，但优先使用行锁。
### 元数据锁

元数据锁是 MySQL 5.5 版本引入的一种**系统级锁**，其主要作用是**维护表结构（元数据）的一致性**，确保在数据操作过程中，表结构不会被意外修改。

#### 一、MDL 的核心作用与特性

1. ​**自动加锁**​：
    ![[Pasted image 20251102090920.png]]
    MDL 的加锁和释放过程完全由数据库系统自动控制，开发者无需（也无法）手动干预。只要执行访问表的 SQL 语句，系统就会自动加上相应的 MDL。
    
2. ​**解决 DML 与 DDL 的冲突**​：
    
    这是 MDL 最重要的职责。它防止了以下情况的发生：
    
    - ​**场景**​：一个事务正在执行查询（如 `SELECT * FROM users`），同时另一个会话试图修改表结构（如 `ALTER TABLE users ADD COLUMN ...`）。
        
    - ​**没有 MDL 的后果**​：如果允许 DDL 执行，正在进行的查询可能会因为列的改变而报错或得到错误的结果。
        
    - ​**MDL 的解决方案**​：通过 MDL 的互斥性，`ALTER TABLE`操作会等待 `SELECT`完成后再执行，从而保证了数据操作期间表结构的稳定性。
        
    

#### 二、MDL 的锁类型与兼容性

图中的表格是核心，它详细说明了不同 SQL 语句会自动获取哪种 MDL，以及各种锁之间的兼容关系。

| 对应 SQL                                                   | 锁类型                                             | 兼容性说明                                                  |
| -------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------ |
| `LOCK TABLES ... READ/WRITE`                             | `SHARED_READ_ONLY`/ `SHARED_NO_READ_WRITE`      | 显式表锁相关的 MDL                                            |
| ​**`SELECT`、`SELECT ... LOCK IN SHARE MODE`**​           | ​**`SHARED_READ`**和行锁的共享锁​（table的IS和record的S）   | ​**与 `SHARED_READ`、`SHARED_WRITE`兼容，与 `EXCLUSIVE`互斥**​ |
| ​**`INSERT`、`UPDATE`、`DELETE`、`SELECT ... FOR UPDATE`**​ | ​**`SHARED_WRITE`**和行锁的排他锁​​（table的IX和record的X） | ​**与 `SHARED_READ`、`SHARED_WRITE`兼容，与 `EXCLUSIVE`互斥**​ |
| ​**`ALTER TABLE ...`**​                                  | ​**`EXCLUSIVE`**​                               | ​**与其他的所有 MDL 都互斥**​                                   |
![[Pasted image 20251102095939.png]]
![[Pasted image 20251102095955.png]]
​**兼容性解读（最关键的部分）：​**​

- ​**共享锁之间兼容**​：
    
    - `SHARED_READ`（读操作）和 `SHARED_WRITE`（写操作）之间是**兼容**的。
        
    - 这意味着：​**多个会话可以同时对一张表进行读和写操作**，这是 MySQL 高并发的基础。例如，一个会话在查询（`SELECT`）的同时，另一个会话可以插入数据（`INSERT`），它们不会相互阻塞。
        
    
- ​**排他锁与所有锁互斥**​：
    
    - `EXCLUSIVE`锁（主要用于 DDL 操作，如 `ALTER TABLE`）与**所有其他类型的 MDL 都互斥**。
        
    - 这意味着：​**当要对表结构做变更时，必须等待该表上所有正在进行的读写操作（包括显式事务）提交或回滚后才能开始。反之，一旦 DDL 开始，后续的所有读写操作都必须等待 DDL 完成。​**​
        
    

#### 一个生动的例子说明互斥性

假设有两个会话（Session A 和 Session B）操作同一张表 `t`：

1. ​**时刻 T1**​：
    
    - ​**Session A**​ 开启一个事务并执行：`SELECT * FROM t;`（自动获取 `SHARED_READ`锁）
        
    - ​**Session B**​ 可以正常执行：`INSERT INTO t ...;`（自动获取 `SHARED_WRITE`锁），因为 `SHARED_READ`和 `SHARED_WRITE`兼容。
        
    
2. ​**时刻 T2**​：
    
    - ​**Session C**​ 尝试执行：`ALTER TABLE t ADD COLUMN ...;`（需要获取 `EXCLUSIVE`锁）
        
    - ​**结果**​：​**Session C 的 `ALTER`语句会被阻塞，进入等待状态**。因为它需要的 `EXCLUSIVE`锁与 Session A 持有的 `SHARED_READ`锁和 Session B 持有的 `SHARED_WRITE`锁都互斥。
        
    
3. ​**时刻 T3**​：
    
    - ​**Session D**​ 此时发起一个新的查询：`SELECT * FROM t;`
        
    - ​**结果**​：​**Session D 的查询也会被阻塞**​！因为 `ALTER TABLE`在排队等待获取 `EXCLUSIVE`锁，这个锁的请求会阻塞后续所有新的 `SHARED_READ`锁请求。
        
    
4. ​**时刻 T4**​：
    
    - ​**Session A**​ 提交事务（或结束会话），释放了 `SHARED_READ`锁。
        
    - ​**结果**​：但 `ALTER`操作仍然被 Session B 的 `INSERT`操作（`SHARED_WRITE`锁）阻塞，所以 Session C 和 Session D 依然在等待。
        
    
5. ​**时刻 T5**​：
    
    - ​**Session B**​ 提交事务，释放了 `SHARED_WRITE`锁。
        
    - ​**结果**​：此时表上没有任何活动的 MDL 锁，Session C 成功获取 `EXCLUSIVE`锁，开始执行 `ALTER TABLE`。执行完毕后，释放锁，之后 Session D 的查询才能继续执行。
        
    

​**这个例子展示了 MDL 如何导致 DDL 操作被长时间阻塞，以及一个未提交的长事务是如何影响整个系统的。​**​

#### 总结

这张图的核心价值在于说明了：

1. ​**MDL 是自动的**​：用于保护表结构，避免 DML 和 DDL 冲突。
    
2. ​**锁的兼容性决定了并发度**​：DML 语句（增删改查）之间可以并发，但它们都与 DDL 语句（改表结构）互斥。
    
3. ​**`ALTER TABLE`是一个重操作**​：因为它需要获取排他的 `EXCLUSIVE`锁，会阻塞后续所有操作，所以必须在业务低峰期谨慎进行。
    

理解 MDL 对于分析数据库性能瓶颈、解决“表锁等待”问题以及规划在线表结构变更（如使用 `pt-online-schema-change`工具）至关重要。
### 意向锁
意向锁的**设计初衷**​：解决**行级锁**与**表级锁**之间的冲突检测效率问题。

- ​**没有意向锁时**​：如果事务 A 持有表中某一行的锁，此时事务 B 想对整个表加锁（如 `LOCK TABLES ... WRITE`），数据库需要**逐行检查**表中是否有数据已被上锁，效率极低。
    
- ​**有意向锁后**​：意向锁作为一种**表级锁**，充当了“预告”或“标识”的角色。事务在获取行锁之前，会先获取对应的意向锁。这样，其他事务通过检查表上的意向锁，就能快速判断是否能安全地加上表锁，​**避免了低效的逐行扫描**。
    

​**简单比喻**​：意向锁就像图书馆的“房间占用牌”。你想给整个房间（表）加锁前，只需看门口牌子（意向锁）就知道里面是否有人（行锁），而不用逐个座位（行）去检查。

#### 一、 意向锁的类型

两种意向锁及其产生方式：

|锁类型|英文与缩写|产生语句（示例）|说明|
|---|---|---|---|
|​**意向共享锁**​|Intention Shared Lock (IS)|`SELECT ... LOCK IN SHARE MODE;`|表示事务**准备**在表中的某些行上设置**共享锁**​（读锁）。|
|​**意向排他锁**​|Intention Exclusive Lock (IX)|`INSERT`, `UPDATE`, `DELETE`, `SELECT ... FOR UPDATE`|表示事务**准备**在表中的某些行上设置**排他锁**​（写锁）。|

​**关键点**​：

- ​**​“意向”的含义**​：它表示一种“意向”或“预告”，意味着事务**即将**要对表中的某些行进行操作，但尚未真正给行加锁。
    
- ​**兼容性基础**​：意向锁之间不会互斥（如 IS 和 IX 可以共存），因为它们只是“预告”，不冲突的实际操作可能发生在不同的行上。
    

#### 二、 意向锁的兼容性规则

第三张图是核心，它揭示了意向锁如何与表锁互动，这也是其价值的体现。下表总结了其兼容性：

|请求的锁类型|当前表上已有的锁类型|是否兼容|解释|
|---|---|---|---|
|​**意向共享锁 (IS)​**​|​**表级共享读锁**​ (READ)|​**兼容**​ ✅|大家都只是读意向，不冲突。|
|​**意向共享锁 (IS)​**​|​**表级排他写锁**​ (WRITE)|​**互斥**​ ❌|写锁要独占，拒绝任何意向。|
|​**意向排他锁 (IX)​**​|​**表级共享读锁**​ (READ)|​**互斥**​ ❌|读锁不允许有写的意向。|
|​**意向排他锁 (IX)​**​|​**表级排他写锁**​ (WRITE)|​**互斥**​ ❌|写锁要独占，拒绝任何意向。|
|​**意向共享锁 (IS)​**​|​**意向排他锁 (IX)​**​|​**兼容**​ ✅|意向锁之间本身不互斥。|

​**规则解读**​：

- ​**共享读锁 (READ)​**​ 比较宽松，允许其他事务有读的意向 (IS)，但不允许有写的意向 (IX)。
    
- ​**排他写锁 (WRITE)​**​ 非常严格，它要求独占整个表，因此拒绝任何其他意向锁（无论是 IS 还是 IX）。
    
#### 总结

意向锁是 InnoDB 实现高效多粒度锁管理的精髓。它的价值在于：

1. ​**提升性能**​：通过表级的意向标记，避免了加表锁时的全表行锁扫描，极大提升了并发效率。
    
2. ​**实现多粒度锁**​：使得行级锁和表级锁能够共存，数据库系统可以根据需要灵活地在不同粒度上加锁。
    
3. ​**保证一致性**​：通过清晰的兼容性规则，确保了并发事务下数据读取和修改的正确性。
    


## 四、行级锁
```sql
select * from performance_schema.data_locks;
```
提交事务就释放了行锁

### 行锁

#### 第一部分：行锁的类型与兼容性

图1明确了 InnoDB 实现的两种标准行级锁：

##### 1. 共享锁（S锁）

- ​**特性**​：允许一个事务**读取**一行数据。
    
- ​**作用**​：阻止其他事务获取**相同数据行**的**排他锁（X锁）​**，但允许其他事务获取共享锁。
    
- ​**类比**​：就像多人同时打开同一份文档进行**只读**查看，互不干扰。
    

##### 2. 排他锁（X锁）

- ​**特性**​：允许一个事务**更新或删除**一行数据。
    
- ​**作用**​：阻止其他事务获取相同数据行的**共享锁（S锁）​**​ 和**排他锁（X锁）​**。
    
- ​**类比**​：就像一个人打开了文档并选择**编辑**，此时系统会锁定文件，阻止其他人同时查看或编辑。
    

##### 3. 兼容性矩阵：核心规则

图1的表格是理解并发控制的关键：

|当前已持有的锁|请求 ​**共享锁 (S)​**​|请求 ​**排他锁 (X)​**​|
|---|---|---|
|​**共享锁 (S)​**​|​**兼容**​ ✅|​**冲突**​ ❌|
|​**排他锁 (X)​**​|​**冲突**​ ❌|​**冲突**​ ❌|

​**规则解读**​：

- ​**S锁与S锁兼容**​：允许多个事务**同时读取**同一行数据，这是高并发读的基础。
    
- ​**S锁与X锁冲突**​：一个事务正在读时，不允许其他事务修改该行数据，防止读到未提交的更改（脏读）。
    
- ​**X锁与任何锁都冲突**​：一个事务正在修改某行时，其他事务**既不能读也不能写**该行，保证数据更新的安全性。
    

#### 第二部分：SQL语句如何触发行锁

图2清晰地列出了不同 SQL 语句触发行锁的规则，这是理论到实践的桥梁。

##### 1. 自动加锁（写操作）

以下语句会在涉及的数据行上**自动**添加**排他锁（X锁）​**​：

- ​**`INSERT`**、**`UPDATE`**、**`DELETE`**​
    
- ​**机制**​：这些写操作在执行时，InnoDB 会自动为要修改的行加上 X 锁，直到事务结束（提交或回滚）才释放。这是为了保证数据修改的原子性和一致性。
    

##### 2. 手动加锁（读操作）

普通的 `SELECT`语句是**快照读**，不加任何锁（基于 MVCC 机制）。但可以通过特定语法**手动**加锁，实现“当前读”或“悲观锁”：

- ​**`SELECT ... LOCK IN SHARE MODE`**​
    
    - ​**加的锁**​：​**共享锁（S锁）​**​
        
    - ​**场景**​：用于确保在事务执行过程中，读取的数据行**不被其他事务修改**，但允许其他事务并发读取。常用于需要确保数据在后续逻辑中保持不变的场景。
        
    
- ​**`SELECT ... FOR UPDATE`**​
    
    - ​**加的锁**​：​**排他锁（X锁）​**​
        
    - ​**场景**​：用于锁定读取的数据行，​**阻止其他事务读取（加S锁）或修改（加X锁）​**这些行。常用于实现“先查后改”的悲观锁逻辑，如库存扣减、防止重复提交等。
        
    

##### 3. 不加锁

- ​**普通的 `SELECT`语句**​：在 ​**读已提交（Read Committed）​**​ 和 ​**可重复读（Repeatable Read）​**​ 隔离级别下，使用**多版本并发控制（MVCC）​**​ 机制读取数据快照，​**不施加任何行锁**，因此可以实现最高的读取并发性能。
##### 锁升级

###### **一、 默认行为：使用临键锁防止幻读**

> ​**默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。​**​

- ​**隔离级别**​：MySQL 的默认隔离级别是 ​**REPEATABLE READ**。在这个级别下，核心要解决的是**幻读**问题（即一个事务内多次读取，结果集行数发生变化）。
    
- ​**默认锁算法**​：​**临键锁**。它是**行锁 + 间隙锁**的组合，不仅锁住记录本身，还会锁住记录之前的间隙。这有效防止了其他事务在间隙中插入新数据，从而杜绝了幻读。
    

###### **二、 优化情况：针对唯一索引的等值匹配**

> ​**针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。​**​

这是非常重要的**性能优化点**。在某些特定条件下，严苛的临键锁会“降级”为更宽松的行锁。

- ​**触发条件**​（必须同时满足）：
    
    1. 使用了**唯一索引**​（如主键、唯一约束索引）。
        
    2. 查询是**等值匹配**​（例如 `id = 5`，而非范围查询 `id > 5`）。
        
    3. 匹配的记录**必须存在**。
        
    
- ​**优化效果**​：InnoDB 可以确定只锁定这一条明确的记录，无需锁定一个范围，从而**减少了锁的冲突**，提升了并发性能。
    

​**示例对比**​：

```
-- 情况A：优化为行锁（使用主键等值查询存在记录）
SELECT * FROM users WHERE id = 10 FOR UPDATE; -- 只对id=10这行加行锁（Record Lock）

-- 情况B：仍使用临键锁（范围查询）
SELECT * FROM users WHERE id > 10 FOR UPDATE; -- 对id>10的范围加临键锁（Next-Key Lock），防止插入id=11,12...的新记录
```

###### **三、 风险情况：无索引导致锁升级**

> ​**InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。​**​

这是最需要警惕的**性能陷阱**。

- ​**根本原因**​：InnoDB 的行锁是**通过索引实现的**。如果 `WHERE`条件中的列没有索引，数据库**无法快速定位到目标行**。
    
- ​**后果**​：为了确保数据一致性，InnoDB 会退而求其次，​**锁住整张表**​（实际上是锁住所有行和间隙，效果等同于表锁）。
    
- ​**危害**​：​**并发性能急剧下降**。任何需要修改此表的操作都会被阻塞，极大影响系统吞吐量。
    

​**示例**​：

```
-- 假设 name 字段上没有索引
UPDATE users SET status = 'inactive' WHERE name = '张三';
-- 此操作会导致全表扫描，并对整个 users 表加锁，阻塞其他所有写操作
```

###### 四、 监控命令：查看锁信息

> ​**可以通过以下SQL，查看意向锁及行锁的加锁情况：​**​
> 
> `SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM performance_schema.data_locks;`

这是一个极其重要的**诊断工具**。当发生锁等待或怀疑锁行为不当时，可以用此命令来“破案”。

- ​**关键字段解读**​：
    
    - `LOCK_TYPE`：锁的粒度，`TABLE`为表级锁，`RECORD`为行级锁。
        
    - `LOCK_MODE`：锁的模式，如 `X`（排他行锁）、`IX`（意向排他锁）、`X,REC_NOT_GAP`（行锁）、`GAP`（间隙锁）、`X`（临键锁，即 Next-Key Lock）。
        
    - `LOCK_DATA`：被锁定的具体数据（对于行锁，显示主键值或索引值）。
        

#### 总结与最佳实践

1. ​**核心关系**​：图1的兼容性规则是图2中所有加锁行为的基础。理解了 S 锁和 X 锁的冲突关系，就能预判不同 SQL 语句并发执行时可能发生的锁等待现象。
    
2. ​**应用场景**​：
    
    - ​**写操作（INSERT/UPDATE/DELETE）​**​：自动加 X 锁，是数据安全的基石。
        
    - ​**高并发读**​：使用普通 `SELECT`，利用 MVCC 实现无锁快照读，性能最佳。
        
    - ​**保证读取一致性**​：使用 `SELECT ... LOCK IN SHARE MODE`加 S 锁，防止读取的数据被修改。
        
    - ​**实现悲观锁**​：使用 `SELECT ... FOR UPDATE`加 X 锁，锁定资源进行“先查后改”的原子操作。
        
    
3. ​**性能与死锁**​：不当的手动加锁（尤其是 `FOR UPDATE`）会增加锁冲突概率，可能导致性能下降甚至死锁，应在明确需要的场景下谨慎使用。

### 临键锁\间隙锁
InnoDB 如何通过**临键锁**​ 来防止幻读，以及在特定条件下为了**提高并发性**而做出的锁优化。
	InnoDB 的锁机制在**绝对保证数据一致性（无幻读）​**​ 的前提下，会智能地在各种特定场景下进行**优化，尽可能缩小锁定范围，以提高并发性能**。理解这些细微的差异，对于设计高性能、高并发的数据库应用至关重要。

**幻读**：在一个事务内，多次执行相同的查询，返回的结果集行数不一致（有新的“幻影行”出现或消失）。
	比如这样一种情况，你想要插入一条数据（核心目的），但是不确定有没有存在，于是你先查询这个数据，发现不存在，于是插入，但是插入的时候又被提示为已经存在该数据。
#### 一、 基础：临键锁与幻读防护

- ​**默认机制**​：在默认的 ​**REPEATABLE READ**​ 隔离级别下，InnoDB 使用 ​**`next-key lock`**​（临键锁）进行搜索和索引扫描。
    
- ​**临键锁是什么**​：它是 ​**行锁**​ 和 ​**间隙锁**​ 的结合。它不仅锁住记录本身，还会锁住该记录之前的间隙（`Gap`）。
    
- ​**如何防止幻读**​：通过锁定一个范围（记录+间隙），它阻止了其他事务在这个范围内**插入新的记录**，从而彻底解决了“幻读”问题。
    

#### 二、 三种锁的优化/退化场景

图中的三点详细描述了临键锁在特定查询条件下如何“降级”为更小粒度的锁，以提升并发效率。

​**1. 等值查询（唯一索引），记录不存在 -> 退化为间隙锁**​

- ​**场景**​：使用唯一索引（如主键）进行等值查询，但目标记录**不存在**。
    
- ​**优化**​：`next-key lock`退化为 ​**`gap lock`**​（间隙锁）。
    
- ​**示例与原理**​：
    
    ```
    -- 假设表中存在 id 为 1, 5, 10 的记录
    SELECT * FROM users WHERE id = 7 FOR UPDATE;
    ```
    
    - 由于 `id=7`的记录不存在，数据库会找到 `7`所在的下一个区间，即 `(5, 10)`。
        
    - 此时，InnoDB 只会对**间隙 `(5, 10)`**​ 加锁（间隙锁）。
        
    - ​**效果**​：允许其他事务修改 `id=5`或 `id=10`的现有记录，但**禁止**在 `5`和 `10`之间插入任何新记录（如 `id=7`）。这既防止了幻读（无法插入id=7），又提高了并发度（不锁已存在的行5和10）。
        
    

​**2. 等值查询（普通索引），向右遍历至不满足条件时 -> 退化为间隙锁**​

- ​**场景**​：使用普通索引（非唯一）进行等值查询。
    
- ​**优化**​：在找到所有满足条件的记录后，当继续向右遍历到第一个不满足条件的值时，`next-key lock`退化为 ​**`gap lock`**。
    
- ​**示例与原理**​：
    
    ```
    -- 假设在 age 字段上有普通索引，数据为 age=10, 10, 20, 20, 30
    SELECT * FROM users WHERE age = 20 FOR UPDATE;
    ```
    
    - InnoDB 会锁定所有 `age=20`的记录及其前后的间隙。当它向右遍历到第一个 `age=30`的记录时，发现不满足 `age=20`的条件。
        
    - 此时，对 `age=30`这个索引项加的 `next-key lock`会**退化为间隙锁**，锁住 `(20, 30)`这个区间。
        
    - ​**效果**​：防止其他事务插入 `age=20`到 `age=30`之间的新记录（如 `age=25`），但允许插入 `age=30`及以上的记录。
        
    

​**3. 范围查询（唯一索引）-> 访问到第一个不满足条件的值为止**​

- ​**场景**​：使用唯一索引进行范围查询（如 `BETWEEN`, `>`， `<`）。
    
- ​**机制**​：InnoDB 会为所有在查询范围内的记录加锁，并且会**一直遍历并加锁到第一个不满足查询条件的记录为止**。
    
- ​**示例与原理**​：
    
    ```
    -- 假设主键 id 为 1, 5, 10, 15
    SELECT * FROM users WHERE id < 10 FOR UPDATE;
    ```
    
    - InnoDB 不仅会锁住 `id=1`和 `id=5`的记录，还会继续找到 `id=10`。
        
    - 因为 `id=10`不满足 `id < 10`的条件，所以会对 `id=10`这个记录加上 ​**`next-key lock`**。
        
    - ​**效果**​：这锁定了 `(-∞, 10]`这个区间，防止了在 `10`以下插入任何新记录，确保了范围查询在事务内的可重复读。
        
    

#### 三、 关键特性：间隙锁的共存性

图中红色字体的“注意”部分是理解 InnoDB 高并发的关键：

> ​**间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。​**​

- ​**唯一目的**​：间隙锁**不直接锁定任何现有数据**，它只“守护”一个空的范围，唯一目的就是**防止插入**​（`INSERT`），从而解决幻读。
    
- ​**可共存**​：​**多个事务可以同时对同一个间隙加间隙锁**。它们不会相互阻塞，因为它们的目标一致——都只是不允许插入新数据。
    
- ​**冲突点**​：间隙锁与**插入操作**冲突。当一个事务持有某个间隙的锁时，另一个事务尝试在该间隙内插入数据会被阻塞。
    

### 总结与实践意义

|场景|锁类型|目的|
|---|---|---|
|​**默认情况**​|​**临键锁**​|​**根本性防止幻读**​|
|​**唯一索引等值查询（记录不存在）​**​|​**退化为间隙锁**​|提高并发（不锁记录），但仍防插入|
|​**普通索引等值查询**​|​**部分退化为间隙锁**​|精准锁定范围，提高并发|
|​**唯一索引范围查询**​|​**临键锁（扫到第一个不满足条件的值）​**​|确保范围查询的绝对一致性|

​**核心思想**​：InnoDB 的锁机制在**绝对保证数据一致性（无幻读）​**​ 的前提下，会智能地在各种特定场景下进行**优化，尽可能缩小锁定范围，以提高并发性能**。理解这些细微的差异，对于设计高性能、高并发的数据库应用至关重要。