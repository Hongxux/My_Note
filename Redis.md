
## NoSQL和SQL对比
### 一、 核心特性对比

|特性维度|SQL (关系型数据库)|NoSQL (非关系型数据库)|
|---|---|---|
|**1. 数据结构**|**结构化 (Structured)**|**非结构化 (Unstructured)**|
|**2. 数据关联**|**关联的 (Relational)**|**无关联的 (Non-relational)**|
|**3. 查询方式**|**SQL 查询**(声明式)|**非SQL**(API驱动，命令式)|
|**4. 事务特性**|**ACID**|**BASE**|
|**5. 存储方式**|**磁盘**(优先保证持久性)|**内存**(优先保证性能)|
|**6. 扩展性**|**垂直扩展 (Scale-up)**|**水平扩展 (Scale-out)**|
|**7. 使用场景**|数据结构固定；业务对**一致性、安全性**要求高|数据结构灵活；对**高性能、高可用**要求高|

---

### 二、 核心概念详解

#### 1. 数据结构：结构化 vs. 非结构化

- **SQL**：需要**预定义模式（Schema）**。就像一张严格的Excel表格，必须先定义好列名（字段）、数据类型（如整数、字符串）、有时候包括约束，才能插入数据。**结构固定，不易修改**。
    ![[Pasted image 20251115202353.png]]
- **NoSQL**：**无模式或动态模式**。可以随时添加新的字段，每条记录的结构可以完全不同。非常灵活，适合处理多变的数据。它包含多种模型：
    
    - **键值型 (Key-Value)**：如 Redis。最简单的模型，通过唯一的 Key 访问 Value。
        
    - **文档型 (Document)**：如 MongoDB。数据以类似 JSON 的文档形式存储。
        
    - **列族型 (Column-Family)**：如 HBase。按列族存储数据，适合大规模数据分析。
        
    - **图型 (Graph)**：如 Neo4j。专门用于存储实体间复杂的关系网络。
        
    ![[Pasted image 20251115202635.png]]

#### 2. 数据关联：关联 vs. 无关联

- **SQL**：通过**外键**等机制建立表与表之间的关联，支持复杂的**连接查询**。
    ![[Pasted image 20251115202813.png]]
- **NoSQL**：**没有连接查询**。数据通常以聚合的形式存储，鼓励去规范化，通过应用程序来处理数据关系。
    

#### 3. 查询语言：SQL vs. 非SQL

- **SQL**：使用标准化的 **SQL**语言进行查询，语法强大且声明式（你只需告诉数据库“想要什么”，而不是“如何获取”）。
    
- **NoSQL**：**没有统一的标准查询语言**。每种数据库都有自己的 API 或查询语法，通常是命令式的。
    
![[Pasted image 20251115203141.png]]
#### 4. 事务特性：ACID vs. BASE

这是两者在数据一致性理念上的根本区别。

- **SQL - ACID**：
    
    - **原子性**：事务内的操作要么全部成功，要么全部失败。
        
    - **一致性**：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
        
    - **隔离性**：并发事务之间互不干扰。
        
    - **持久性**：事务一旦提交，对数据的改变是永久性的。
        
    - **目标**：**强一致性**，保证数据的绝对准确，适合金融交易等场景。
        
    
- **NoSQL - BASE**：
    
    - **基本可用**：系统保证基本可用，即使在故障时。
        
    - **软状态**：允许系统中的数据存在中间状态，但不影响整体可用性。
        
    - **最终一致性**：经过一段时间后，数据副本最终会达到一致。
        
    - **目标**：**高可用性和高性能**，允许数据在短时间内不一致，适合社交网络、实时推荐等场景。
        
    

#### 5. 扩展性：垂直扩展 vs. 水平扩展

- **SQL**：主要通过**垂直扩展**，即增加单个服务器的性能（如更强的CPU、更大的内存）来提升处理能力。成本高，有上限。
    
- **NoSQL**：天生支持**水平扩展**，即通过增加更多的普通服务器节点来组成集群，共同处理数据。成本低，扩展性几乎无限。
    

---

### 三、 如何选择？—— 使用场景

**选择 SQL 当：**

- **数据结构稳定**：业务模型成熟，数据结构不会频繁变动。
    
- **需要复杂查询**：业务需要大量的关联查询和复杂报表。
    
- **要求数据一致性**：业务对数据的准确性和完整性要求极高，如银行、会计系统。
    

**选择 NoSQL 当：**

- **数据结构多变**：业务处于快速迭代中，数据模型需要频繁调整。
    
- **高并发读写**：应用需要处理巨大的流量，如电商秒杀、社交媒体的点赞评论。
    
- **海量数据存储**：需要存储和处理TB/PB级别的数据，如日志、物联网传感器数据。
    
- **对一致性要求不高**：可以接受数据的短暂不一致，以换取极高的性能和可用性。
    

### 总结

这四张图连起来，清晰地揭示了 SQL 和 NoSQL 的根本差异：

- **SQL**像一本**结构严谨的百科全书**，强调**规矩、精确和一致性**，是处理严谨、关联性强的结构化数据的首选。
    
- **NoSQL**像一本**随时可涂鸦的速写本**，强调**速度、灵活和可扩展性**，是应对海量、多变、高并发数据需求的利器。
    

**现代应用开发中，两者不是取代关系，而是互补关系**。很多大型系统都采用**混合架构**，使用 SQL 处理核心交易数据，使用 NoSQL 处理缓存、日志、用户画像等场景，充分发挥各自优势。



## Redis 
### Redis速度块的原因
- 内存操作：数据主要存储在内存中，直接操作内存，避免缓慢的磁盘I/O
- 单线程：避免多线程的上下文切换和锁竞争
- I/O多路复用：高效处理海量网络连接，在高并发场景下实现高吞吐量，解决了单线程可能阻塞的问题
- 高效数据结构：为每种值类型（如String, Hash, List）设计了精炼且多变的内部编码。
	- 根据数据特征（如元素数量、大小）自动选择最节省内存或最快查询速度的编码方式
### Redis的常见作用
- **作为缓存（Cache）**：在`sendCode`方法中，将验证码以 `String`类型存入Redis，并设置键名 `LOGIN_CODE_KEY + phone`。这是一种标准的K-V缓存模式，读写速度快，适合存储临时数据。[[Redis作为缓存使用]]
    
- **作为会话存储（Session Store）**：在`login`方法中，将登录用户信息以 `Hash`类型存入Redis，并设置过期时间（TTL）。键名为 `LOGIN_USER_KEY + token`。这实现了**分布式会话**，用户状态不再依赖于服务器的本地内存，而是集中存储在Redis中，非常适合集群部署。
	- 如果存在Session中,后期会为了提高负载能力而使用多台tomcat服务器,所以不能保证每次请求都在相同服务器,因此也不能确保Session都存在。如果考虑多台服务器之间复制，则又太浪费内存。因此使用redis实现分布式会话。
	- ![[f88f8abec92d87b6bdb72d1488814205.jpeg]]
- Redis实现分布式锁 ---Redisson
- Redis实现消息队列--[[Redis Stream]]
### Redis的底层原理
#### [[Redis的数据清理机制]]
#### [[Redis的网络模型]]
#### [[Redis通信协议]]

### [[ Redis的通用命令]]
### 常见数据类型
#### [[redisObject]]
#### [[String]]
#### [[Hash]]
#### [[List]]
#### [[Set]]
#### [[SortedSet]]
#### [[Redis Stream]]
#### [[Redis GEO]]
#### [[Redis BitMap]]
#### [[Redis HyperLogLog]]


### SpringBoot中使用Redis
##### [[SpringDataRedis]]
### Redis的最佳实践
#### [[Redis键值设计]]
#### [[Redis批处理]]
#### [[服务端优化]]
##### [[Redis慢查询日志]]

##### 命令及安全配置
![[Pasted image 20251126135252.png]]
##### [[Redis内存配置]]
#### 集群的最佳实践

### Redis开发中需要解决的问题
#### 可靠性
##### [[Redis持久化]]
##### [[Redis主从]]+[[Redis哨兵]]

##### [[Redis集群]]多主多从

#### 数据量过大(大key和热key)
- 问题：
	- 性能急剧下降：读写延迟飙升，慢查询增多，网络带宽被占满，整体响应变慢
		- 内存压力导致进行缓存淘汰策略，增加IO负担，而且可能导致缓存穿透
		- 持久化进行fork子进程的时间过长，导致主线程阻塞
		- Big Key导致的读取和增加阻塞
	- 可用性风险：主从同步故障，容灾切换时间过长，服务中断风险增加
		- 当主库宕机进行容灾切换（“切主”）后，新的从库需要从主库**全量同步**数据。数据量越大，传输和加载RDB文件的时间就越长。
		- 存在大Key或热Key，会导致某个数据分片的内存使用率或请求压力远高于其他节点，出现集群倾斜
- 解决措施：Redis缓存点赞收藏数据遇到数据量过大为例子
	1. **转变缓存维度（治本之策）**
	    - **问题所在**：传统的做法是为每个内容（如文章、视频）缓存一个集合（Set），里面存储所有点赞用户的ID（`content_id -> [user_id1, user_id2, ...]`）。当内容火爆时，这个集合会变得非常大，成为“大Key”。
	    - **优化方案**：改为以**用户**为维度进行缓存。为每个用户存储一个集合，里面是他最近点赞过的内容ID。例如，使用Hash结构：`user_id: { "ttl": 过期时间, "min_content_id": 最小内容ID, "content_id_1": 1, ... }`。
	    - **优势**：在常见的Feed流场景下，用户一次请求需要判断他是否点赞过展示的10条内容。旧方案需要查询10个Key，新方案只需要查询1个用户的Key，然后一次性判断所有内容ID是否存在其中，**性能提升显著**。
	2. **实施数据分片（应对大Key）**
	    如果业务上必须保留以内容为维度的设计，那么**分片**是必须的。
	    - **如何操作**：将一个内容下的点赞用户列表，按用户ID哈希取模，分散存储到多个Key中。例如：`content_id_shard1 -> [部分用户ID]`, `content_id_shard2 -> [另一部分用户ID]`。
	    - **注意事项**：分片增加了代码复杂度和Key总数，但能有效避免单个Key过大带来的性能问题。
	3. **区分冷热数据（精准缓存）**
	    这是减少数据量的关键思想。用户的点赞行为具有明显的时间局部性，即最近点赞的数据最容易被再次访问。
	    - **如何操作**：为每个用户只缓存他**最近点赞的5000条内容ID**（数量可调整）。在缓存中记录一个最小的内容ID（`min_content_id`）。当需要判断用户是否点赞过某内容时：
	        - 如果该内容ID大于 `min_content_id`，说明它在热数据范围内，可以直接在缓存中查询。
	        - 
	        - 如果该内容ID小于 `min_content_id`，说明它是较老的冷数据，则直接查询数据库。
	    - **优势**：用极小的缓存空间覆盖了绝大部分的查询请求，性价比极高。
	4. 当数据量持续增长，单一Redis实例无法承载时，就需要考虑架构层面的扩展。
		- **读写分离**：如果读压力巨大，可以配置主从复制，将读请求分流到从节点上。
		- **使用Redis Cluster**：这是官方的分布式解决方案。它将数据自动分片到多个节点上，每个节点负责一部分数据（槽位slot），可以轻松实现水平扩展，突破单机内存和性能瓶颈。
		- **服务拆分**：将简单的点赞计数（`count`）和复杂的点赞人列表（`detail`）拆分成两个服务。计数服务可以使用更高效的KV存储，而详情服务则采用上述的优化策略。
#### 缓存异常
1.  缓存雪崩
2. 缓存击穿
3. 缓存穿透
#### 数据一致性
