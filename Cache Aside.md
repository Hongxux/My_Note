---
aliases:
  - 应用层驱动
  - 主动更新
  - 缓存旁路模式
---
# **缓存旁路模式**的介绍
**缓存旁路模式**是最常用的缓存读写策略。
- 读请求先查缓存，未命中则读数据库并回填；
	- **缓存的存在是为了加速读取，而不是作为数据的权威来源。数据库才是“真相之源”。**
- 写请求直接更新数据库，然后**使缓存失效 (删除缓存)**。
	- 通过对缓存的**失效**操作来保证数据的一致性

----
# 主要考虑的三个方面问题
![[Pasted image 20251118124127.png]]

---

## 问题总结：

- **选择删除缓存使得缓存失效来**
	- 保证数据的一致性。
- **先更新数据库，再删除缓存。**
	- 这是基于发生概率的权衡下的最优解
	- 而且具有兜底和保障策略


----
## 问题论证
### 删除缓存还是更新缓存
**1. [[删除缓存 ]](Invalidate)**

**2. 更新缓存 (Update)**

- **适合场景：读多写少**
    
- **原因**：在数据不常变更但被频繁读取（读多）的场景下，确保缓存中始终是最新的数据价值很高。采用“更新缓存”策略，可以在每次数据变更后立即让缓存保持最新，从而保证后续大量的读请求都能直接命中新鲜数据，获得最佳性能。
    
- **劣势**：如果写操作也很频繁，就会如上面所述，产生大量无效的缓存更新开销。
---

### 如何保证操作数据库和操作缓存的原子性

- **单体系统**：用事务包裹“数据库操作”和“缓存操作（删除/更新）”，简单有效。
    
- **分布式系统**：这是难点。分布式事务（如TCC）太重，业界更常用的可靠模式是：
    
    1. **先更新数据库**
        
    2. **再删除缓存**
        
    3. **若删除缓存失败，通过消息队列重试或订阅数据库binlog补偿**，确保最终一致。

### **先操作数据库还是先操作缓存**
实践和业界共识，**“先操作数据库，再删除缓存”是更优的选择**。

- **原因**：如果顺序反过来（先删缓存，再更新数据库），在并发环境下，可能会出现一个旧数据在数据库更新前被重新加载到缓存，导致脏数据。虽然“先更新数据库，再删缓存”也有极小的不一致风险，但概率更低，影响窗口更小。[[先更新数据库的风险]]
