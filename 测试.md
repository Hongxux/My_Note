---
aliases:
  - "@SpringBootTest"
---
### 加载测试专用属性


在 Spring Boot 测试中，为测试方法**临时设置专用配置属性**的两种核心方式。它们都通过 `@SpringBootTest`注解来实现，但使用的参数和适用场景有所不同。

#### `properties`参数 vs `args`参数

下面的表格清晰地对比了这两种方法的关键差异：

|对比维度|使用 `properties`参数（图二）|使用 `args`参数（图一）|
|---|---|---|
|**语法示例**|`@SpringBootTest(properties = **"test.prop=testValue1"**)`|`@SpringBootTest(args = **"--test.arg=testValue2"**)`|
|**配置形式**|直接设置**属性键值对**。|模拟**命令行参数**的格式（通常以 `--`开头）。|
|**主要用途**|直接覆盖 `application.properties/yml`中的**已有属性**，或设置**新的测试专用属性**。|模拟应用启动时通过命令行传入参数的行为，其值会按Spring Boot的优先级规则被解析为属性。|
|**属性优先级**|优先级**高于**主配置文件。|优先级**极高**，通常**高于**`properties`参数和大部分外部配置（仅次于测试配置文件如 `application-test.yml`）。|
|**代码示例**|`@Value("${test.prop}") private String msg;`|`@Value("${test.arg}") private String msg;`|
|**适用场景**|更适合为测试**临时注入**一个明确的、简单的属性值。|更适合测试那些**需要通过命令行参数**来动态配置的特性，或需要验证高优先级配置的加载逻辑。|

#### 总结与选择建议

- **共同目标**：两者都是为了实现**测试隔离**，确保测试用例拥有自己独立的配置环境，而不会干扰或依赖全局的主配置文件。
    
- **如何选择**：
    
    - 如果你的测试只是需要一个临时的配置值，**推荐使用 `properties`参数**，因为它写法更简洁直接。
        
    - 如果你需要模拟生产环境中通过命令行（例如 `java -jar app.jar --server.port=8081`）启动应用的场景，或者需要测试配置属性的加载优先级，那么应该使用 `args`参数。
        
### 加载测试专用配置Bean

这张图片展示了在 Spring Boot 测试中，使用 **`@Import`注解为特定测试类导入专用配置**的实践方法。这是一种实现测试环境与主应用环境**配置隔离**的有效策略。

#### 核心内容解析

图片中的代码演示了如何通过 `@Import`注解，在测试类中精确地引入其运行所需的配置。

**代码示例与说明：**

```
// 关键注解：标记这是一个Spring Boot测试，并导入专用的配置类MsgConfig
@SpringBootTest
@Import(MsgConfig.class) // 核心操作：导入当前测试类专用的配置
public class ConfigurationTest {

    // 将会从导入的MsgConfig配置中注入名为msg的Bean
    @Autowired
    private String msg;

    @Test
    public void testConfiguration() {
        // 打印注入的msg值，以验证配置是否生效
        System.out.println(msg);
    }
}
```

#### 关键要点解读

1. **`@Import(MsgConfig.class)`的作用**
    
    这是本示例的核心。它的作用是**显式地**告诉Spring容器：在加载这个测试的上下文时，**除了主应用的所有默认配置外，请将 `MsgConfig`这个配置类中定义的Bean也注册进来**。这使得测试类 `ConfigurationTest`可以获取到 `MsgConfig`中定义的Bean（例如，一个名为 `msg`的字符串）。
    
2. **实现“专用配置”与“配置隔离”**
    
    - **专用性**：通过 `@Import`导入的配置（如 `MsgConfig`）是专门为这个测试类服务的。其他测试类不会受到它的影响。
        
    - **隔离性**：这种方法允许你为某个特定的测试场景创建一套最小化、精确的配置，从而与主应用的复杂配置隔离开。这在测试某些特定组件时非常有用，可以避免加载不必要的Bean或覆盖全局配置。
        
    
3. **与其它测试配置方法的对比**
    
    你之前了解过的 `@SpringBootTest(properties=...)`或 `@TestPropertySource`主要用于设置**属性值**（如 `application.properties`中的键值对）。而 `@Import`注解主要用于**导入一个或多个包含 `@Bean`定义的配置类**，从而向测试的Spring容器中**注册新的Bean**。它们解决的问题不同，可以结合使用。
    

#### 总结

这张图片的核心教学点是：**利用 `@Import`注解，可以在Spring Boot测试中灵活地导入专用的配置类，从而实现测试环境的精确控制和隔离。** 这是一种比修改全局配置文件更优雅、更安全的测试配置管理方式。

当你的测试需要一些特殊的、在主线配置中不存在的Bean时，`@Import`是非常理想的选择。

### 测试表现层（模拟浏览器）


#### 1. 设置测试环境（对应第一张图）

 **`@SpringBootTest`注解的 `webEnvironment`属性**。它决定了测试时将启动何种类型的 Web 环境。

```
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class WebTest {
    // ...
}
```

- **`RANDOM_PORT`**：启动一个真实的嵌入式服务器（如 Tomcat），并监听一个**随机端口**。这是进行**完整集成测试**的常用选择，因为它最接近真实运行环境。
    
- **其他常用选项**：
    
    - **`MOCK`（默认值）**：不启动真实服务器，而是模拟一个 Servlet 环境。通常与 `MockMvc`搭配使用，进行更快速、更隔离的测试。
        
    - **`DEFINED_PORT`**：使用 `application.properties`中定义的端口（如 `server.port=8080`）启动真实服务器。
        
    - **`NONE`**：不提供任何 Web 环境，适用于非 Web 应用的测试。
        
    

#### 2. 构建与执行虚拟请求

如何在不启动真实服务器的情况下（使用 `MOCK`环境），通过 `MockMvc`模拟 HTTP 请求。

```
@SpringBootTest
@AutoConfigureMockMvc // 关键注解：自动配置 MockMvc 实例
public class WebTest {
    @Test
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        // 1. 构建请求：创建一个访问 `/books` 的 GET 请求
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");
        // 2. 执行请求
        ResultActions action = mvc.perform(builder);
    }
}
```

- **`@AutoConfigureMockMvc`**：此注解会自动为您配置一个 `MockMvc`实例，您可以通过 `@Autowired`注入它。它是进行虚拟 MVC 测试的入口。
    
- **`MockMvcRequestBuilders`**：用于构建各种类型的请求（GET, POST, PUT, DELETE 等）。
    
- **`mvc.perform()`**：执行构建好的请求，返回一个 `ResultActions`对象，该对象用于后续的结果验证。
    

#### 3. 匹配与验证响应

使用 `andExpect`方法对执行请求后的结果进行断言验证。

```
@Test
public void testStatus(@Autowired MockMvc mvc) throws Exception {
    // 执行请求，并直接开始链式断言
    ResultActions action = mvc.perform(MockMvcRequestBuilders.get("/books"));
    
    // 定义期望的匹配器：这里期望状态码是 200 (OK)
    StatusResultMatchers status = MockMvcResultMatchers.status();
    ResultMatcher ok = status.isOk();

    // 执行匹配验证
    action.andExpect(ok);
}
```

- **`MockMvcResultMatchers`**：这个工具类提供了丰富的匹配器（Matcher），用于验证响应的不同方面，如图片中演示的**状态码**（`status().isOk()`），以及常用的**响应体内容**（`content()`）和**响应头**（`header()`）。
    
- **`action.andExpect()`**：这是验证的关键方法，你可以链式调用多个 `andExpect`来全面验证响应结果。
    

##### 如何匹配响应体（Content）

###### 1. 匹配 JSON 响应（最常见）

假设您的 `/books`接口返回的 JSON 格式如下：

```
{"id": 1, "name": "Spring Boot 指南", "author": "张三"}
```

您的测试代码可以这样写来匹配这个响应体：

```
@Test
public void testResponseBody(@Autowired MockMvc mvc) throws Exception {
    mvc.perform(MockMvcRequestBuilders.get("/books/1")) // ① 构建请求
       .andExpect(MockMvcResultMatchers.status().isOk()) // ② 匹配状态（图片3的内容）
       .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON)) // 匹配Content-Type头
       // ③ 以下是匹配JSON响应体的核心方法：
       .andExpect(MockMvcResultMatchers.jsonPath("$.id").value(1)) // 验证id字段值
       .andExpect(MockMvcResultMatchers.jsonPath("$.name").value("Spring Boot 指南")) // 验证name字段值
       .andExpect(MockMvcResultMatchers.jsonPath("$.author").exists()); // 验证author字段存在
}
```

- **`jsonPath`**：这是最强大的工具。它使用 **JSONPath 表达式**（类似于 XPath for JSON）来定位和验证 JSON 数据中的特定字段。
    
    - `$.id`表示根节点下的 `id`字段。
        
    - `.value(1)`用于匹配该字段的值。
        
    - `.exists()`用于验证该字段是否存在。
        
    

###### 2. 匹配纯文本或整个响应内容

如果接口返回简单的字符串，可以直接匹配整个响应内容：

```
.andExpect(MockMvcResultMatchers.content().string("Hello, World!"));
```

或者，如果返回值包含某个字符串：

```
.andExpect(MockMvcResultMatchers.content().string(containsString("Boot"))); // 使用Hamcrest匹配器
```

---

##### 如何匹配响应头（Header）

验证服务器返回的响应头是否正确，例如缓存控制、内容类型或自定义头。

```
@Test
public void testResponseHeader(@Autowired MockMvc mvc) throws Exception {
    mvc.perform(MockMvcRequestBuilders.get("/books/1"))
       .andExpect(status().isOk())
       // ④ 匹配响应头
       .andExpect(MockMvcResultMatchers.header().string("Content-Type", MediaType.APPLICATION_JSON_VALUE)) // 匹配Content-Type头的值
       .andExpect(MockMvcResultMatchers.header().exists("X-Custom-Header")) // 验证自定义头是否存在
       .andExpect(MockMvcResultMatchers.header().string("Cache-Control", "no-cache")); // 验证缓存控制头
}
```

- **`header().string("Header-Name", "expected-value")`**：匹配指定响应头的值。
    
- **`header().exists("Header-Name")`**：验证指定响应头是否存在。
    


### 测试中数据库操作不提交（事务回滚）

在 Spring Boot 测试中，**默认情况下，测试方法中所有数据库操作在测试完成后都会被自动回滚**。同时，它也提供了手动控制这一行为的方法。

#### 1. 默认行为：自动回滚

这是 Spring Boot 测试框架提供的一个“开箱即用”的安全措施。

- **目的**：防止测试数据污染您的开发或测试数据库。每次测试都是独立的，不会因为前一个测试插入了数据而影响后一个测试的结果。
    
- **实现方式**：在测试类上添加 `@Transactional`注解。
    
- **工作流程**：
    
    1. 测试开始前，事务开启。
        
    2. 测试方法执行，其间所有的数据库操作（增、删、改）都在这个事务内进行。
        
    3. 测试方法执行完毕后，**事务会自动回滚**，所有数据库操作被撤销，数据库恢复到测试前的状态。
        
    

**代码示例：

```
@SpringBootTest
@Transactional // 关键注解：启用事务管理，并默认在测试后回滚
class DataLayerTest {

    @Test
    void testInsert() {
        // 这里执行插入操作...
        // 测试结束后，这条插入记录会被回滚，不会真正存入数据库
    }
}
```

#### 2. 如何修改默认行为：提交事务（细粒度的控制）

如果您确实需要某个测试方法**真正地**向数据库提交数据（例如，为了验证一个完整的工作流程，或者需要查看提交后的数据状态），可以通过 `@Rollback`注解来覆盖默认行为。

- **实现方式**：在测试方法上添加 `@Rollback(false)`注解。
    
- **效果**：该方法执行后，事务将被提交，对数据库的更改会持久化保存。
    

**代码示例：

```
@SpringBootTest
@Transactional
class DataLayerTest {

    @Test
    @Rollback(false) // 关键注解：设置为 false，表示测试后不回滚，即提交事务
    void testInsertWithCommit() {
        // 这里执行插入操作...
        // 测试结束后，这条插入记录会被提交到数据库
    }
}
```
### 测试数据随机值


#### 1. 基本语法与示例

以下是根据图片内容整理的常用随机值生成方法：

|配置示例 (YAML)|说明|生成的值示例（可能）|
|---|---|---|
|`id: $ {random.int}`|生成一个随机整数 (Integer 范围)|`-1923457283`|
|`id2: $ {random.int(10)}`|生成一个小于 10 的正整数 [0, 10)|`7`|
|`type: $ {random.int[10,20]}`|生成一个在 [10, 20] 范围内的整数|`15`|
|`uuid: $ {random.uuid}`|生成一个随机的 UUID|`c7b3f8a0-...`|
|`name: $ {random.value}`|生成一个随机的字符串 (32位 MD5)|`4f5d7e8a9b...`|
|`publishTime: $ {random.long}`|生成一个随机长整数 (Long 范围)|`98765432109876`|

#### 2. 关键细节说明

1. **范围语法非常灵活**：
    
    图片中特别指出，定义范围的括号 **()`、`[]`、`!!` 等都是有效的**。Spring Boot 在解析时会忽略这些括号字符的差异，只关注其中的数字。
    
    - `$ {random.int(10)}`等价于 `$ {random.int[10]}`等价于 `$ {random.int!!10!!}`
        
    - `$ {random.int(10,20)}`等价于 `$ {random.int[10,20]}`
        
    
2. **主要用途**：
    
    - **测试数据隔离**：为每个测试用例或每次启动生成不同的数据，避免使用固定值可能造成的冲突（如主键重复）。
        
    - **快速填充**：在演示或原型开发中，快速生成有意义的假数据，无需手动编写。
        
    

#### 3. 更多常用随机值类型

除了图片中列出的，Spring Boot 的 `${random.}`还支持其他类型，例如：

|配置示例|说明|
|---|---|
|`$ {random.bytes}`|生成随机字节序列|
|`$ {random.boolean}`|生成随机布尔值 (`true`或 `false`)|
