- 事务传播规则的使用时机：多个事务方法相互调用时候
- [[事务]]传播规则：
	- 加入：方法外部和内部发生都会导致回滚
		- 需要：**REQUIRED**
		- 支持：**SUPPORTS**
		- 强制：**MANDATORY**
	- 挂起：外部事务异常不会影响已经提交的事务异常，内部异常同样不影响
		- 需要新的：**REQUIRES_NEW**
		- 不需要：**NOT_SUPPORTED**
	- 嵌套：嵌套事务回滚不影响外部事务；外部事务回滚会导致嵌套事务回滚
		- **NESTED**
	- 禁止：**NEVER**

| 传播属性               | 当前存在事务       | 当前没有事务   | 关键特点                                | 典型适用场景               |
| ------------------ | ------------ | -------- | ----------------------------------- | -------------------- |
| **REQUIRED**​ (默认) | 加入当前事务       | 创建新事务    | 多方法在同一事务中；任一方法异常导致全部回滚              | 大多数业务方法，确保操作在同一个事务中  |
| **REQUIRES_NEW**​  | 挂起当前事务，创建新事务 | 创建新事务    | 新事务完全独立；外部事务异常不影响已提交的新事务            | 日志记录、审计等需独立留痕的操作     |
| **NESTED**​        | 在嵌套事务内执行     | 创建新事务    | 基于保存点；嵌套事务回滚不影响外部事务；外部事务回滚会导致嵌套事务回滚 | 复杂业务中需要部分回滚的场景，如批量处理 |
| **SUPPORTS**​      | 加入当前事务       | 以非事务方式执行 | 适应调用方的事务环境                          | 查询方法，可在事务或非事务环境下运行   |
| **MANDATORY**​     | 加入当前事务       | 抛出异常     | 强制要求必须在事务中调用                        | 确保关键方法只能在事务中被调用      |
| **NOT_SUPPORTED**​ | 挂起当前事务，非事务执行 | 以非事务方式执行 | 强制非事务执行                             | 不需要事务支持的耗时操作         |
| **NEVER**​         | 抛出异常         | 以非事务方式执行 | 强制要求不能在事务中调用                        | 严格要求在非事务环境下执行的方法     |

- 使用方式
```
@Service
public class OrderService {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void placeOrder(Order order) {
        // 主事务：订单创建
        orderDao.save(order);
        
        // 独立事务：日志记录（即使订单失败，日志也要记录）
        logService.recordOrderLog(order);
        
        // 同一事务：库存扣减（与订单同生共死）
        inventoryService.deductStock(order);
    }
}

@Service
class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void recordOrderLog(Order order) {
        // 独立事务，不受主事务回滚影响
    }
}

@Service
class InventoryService {
    @Transactional(propagation = Propagation.MANDATORY)
    public void deductStock(Order order) {
        // 必须在事务中调用
    }
}
```