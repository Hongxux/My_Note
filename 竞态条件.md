
竞态条件的本质是**基于一种可能失效的观察结果**来做出判断或者执行某个计算。
**竞态条件**的例子：
- “读取-修改-写入”
- “先检查后执行”
## 1. 核心定义

​**竞态条件**​ 是指多个进程或线程并发访问和操作共享数据时，​**最终结果的正确性依赖于特定的事件执行时序**。当程序的执行结果由于线程调度顺序的不确定性而变得不可预测时，就发生了竞态条件。

​**形式化定义**​：

在多线程环境中，如果两个或多个线程同时访问共享资源，且至少有一个线程进行写操作，且没有适当的同步机制，就会产生竞态条件。

**[[并发问题#^7b6c6e|原子性违反]]是竞态条件发生的直接原因，而竞态条件是原子性违反可能引发的后果。它们是描述并发错误的一体两面。原子性违反是代码层面的‘病根’，而竞态条件是这个‘病根’在运行时表现出的‘症状’。我们解决并发问题的核心手段，就是通过锁、原子变量或事务等工具，来修复原子性违反，从而消除竞态条件。**​

## 2. 基本特征

### 关键属性：

1. ​**共享数据**​：存在多个线程可访问的共享资源
    
2. ​**并发访问**​：至少有一个线程修改共享数据
    
3. ​**缺乏同步**​：对共享数据的访问没有适当的同步控制
    
4. ​**时序敏感性**​：结果依赖于线程执行的相对时序
    

### 与数据竞争的区别：

- ​**竞态条件**​：更广义的概念，指任何因执行时序导致的结果不确定性
    
- ​**数据竞争**​：特指多个线程未同步地访问同一内存位置，且至少有一个是写操作
    

## 3. 产生原因与触发条件

### 根本原因：

```
// 典型的竞态条件示例
int counter = 0;

// 线程1
void* thread1() {
    counter = counter + 1;  // 非原子操作
}

// 线程2  
void* thread2() {
    counter = counter + 1;  // 非原子操作
}
```

### 触发条件：

1. ​**非原子操作**​：看似单一的操作实际上由多个步骤组成
    
2. ​**检查后行动**​：检查条件后执行操作，但条件可能已改变
    
3. ​**读写交错**​：读、修改、写操作被其他线程中断
    

## 4. 具体实例分析

### 实例1：银行转账问题

```
// 存在竞态条件的转账操作
typedef struct {
    int balance;
} account_t;

void transfer(account_t* from, account_t* to, int amount) {
    // 检查条件后行动 - 存在时间窗口
    if (from->balance >= amount) {
        // 在此时间窗口内，其他线程可能修改余额
        from->balance -= amount;
        to->balance += amount;
    }
}
```

​**问题分析**​：

- 线程A检查`from->balance >= amount`，条件满足
    
- 在扣款前，线程B可能已经扣除了部分余额
    
- 线程A继续执行时，余额可能已不足，导致透支
    

### 实例2：懒汉式单例模式

```
// 存在竞态条件的单例实现
class Singleton {
private:
    static Singleton* instance;
    
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {          // 第一次检查
            instance = new Singleton();     // 初始化
        }
        return instance;
    }
};
```

​**问题分析**​：

- 线程A和线程B同时调用`getInstance()`
    
- 都通过第一次检查`instance == nullptr`
    
- 可能创建多个实例，违反单例模式原则
    

## 5. 竞态条件的类型

### 5.1 读-改-写竞态

```
// 经典的计数器问题
counter++;  // 实际包含: load → increment → store 三个步骤
```

### 5.2 检查-行动竞态

```
// 文件存在检查竞态
if (access(filepath, F_OK) == 0) {  // 检查文件是否存在
    // 在此时间窗口内，文件可能被删除
    FILE* fp = fopen(filepath, "r");  // 使用文件
}
```

### 5.3 初始化竞态

```
// 延迟初始化竞态
if (resource == NULL) {
    resource = create_resource();  // 可能被多次初始化
}
```

## 6. 检测与诊断方法

### 静态分析工具：

- ​**ThreadSanitizer (TSan)​**​：检测数据竞争
    
- ​**Helgrind**​：Valgrind的线程错误检测工具
    
- ​**静态代码分析器**​：Coverity、PVS-Studio等
    

### 动态测试技术：

```
// 压力测试：人为制造竞态条件
void* stress_test() {
    for (int i = 0; i < 1000000; i++) {
        // 频繁调用存在竞态条件的代码
        transfer(account1, account2, 100);
    }
}

// 创建多个线程进行压力测试
pthread_t threads[10];
for (int i = 0; i < 10; i++) {
    pthread_create(&threads[i], NULL, stress_test, NULL);
}
```

## 7. 解决方案与预防措施

### 7.1 互斥锁（Mutex）解决方案

```
pthread_mutex_t account_mutex = PTHREAD_MUTEX_INITIALIZER;

void safe_transfer(account_t* from, account_t* to, int amount) {
    pthread_mutex_lock(&account_mutex);
    
    if (from->balance >= amount) {
        from->balance -= amount;
        to->balance += amount;
    }
    
    pthread_mutex_unlock(&account_mutex);
}
```

### 7.2 原子操作解决方案

```
#include <atomic>

std::atomic<int> counter(0);

void atomic_increment() {
    counter.fetch_add(1, std::memory_order_relaxed);
}
```

### 7.3 无锁编程技术

```
// 使用CAS（Compare-And-Swap）实现无锁计数器
typedef struct {
    int value;
} atomic_int;

void atomic_increment(atomic_int* obj) {
    int old_value;
    do {
        old_value = obj->value;
    } while (!__sync_bool_compare_and_swap(&obj->value, old_value, old_value + 1));
}
```

## 8. 最佳实践与设计原则

### 防御性编程策略：

1. ​**识别共享数据**​：明确所有可能被多个线程访问的数据
    
2. ​**最小化临界区**​：减少锁的持有时间
    
3. ​**使用线程安全的数据结构**​
    
4. ​**避免全局变量**​：使用线程局部存储或传参
    

### 架构设计原则：

```
// 好的设计：避免共享状态
typedef struct {
    pthread_mutex_t mutex;
    int data;
} thread_safe_container;

// 更好的设计：无共享架构
void process_data(const int* input, int* output, size_t size) {
    // 每个线程处理独立的数据副本
    for (size_t i = 0; i < size; i++) {
        output[i] = transform(input[i]);
    }
}
```

## 9. 面试相关问题与答案

### Q1: 竞态条件和数据竞争有什么区别？

​**参考答案**​：

- ​**数据竞争**是竞态条件的一种特定形式，特指多个线程未同步地访问同一内存位置
    
- ​**竞态条件**范围更广，包括任何因执行时序导致的结果不确定性
    
- 所有数据竞争都是竞态条件，但并非所有竞态条件都是数据竞争
    

### Q2: 如何证明代码中存在竞态条件？

​**参考答案**​：

1. ​**代码审查**​：识别非原子操作和共享数据访问
    
2. ​**压力测试**​：高并发环境下多次运行
    
3. ​**工具检测**​：使用ThreadSanitizer、Helgrind等工具
    
4. ​**确定性测试**​：控制线程调度顺序来重现问题
    

### Q3: volatile关键字能防止竞态条件吗？

​**参考答案**​：

不能。volatile只保证内存可见性（不从寄存器读取缓存值），但不提供原子性或排序保证。它不能防止多个线程交错的读-改-写操作。

### Q4: 单核CPU上会有竞态条件吗？

​**参考答案**​：

会有。虽然单核CPU上不会发生真正的并行执行，但线程可能在任何时刻被抢占。如果关键操作在时间片边界被中断，仍然可能产生竞态条件。

### Q5: 如何设计避免竞态条件的系统？

​**参考答案**​：

1. ​**不可变数据**​：使用只读数据结构
    
2. ​**消息传递**​：线程间通过消息通信而非共享内存
    
3. ​**事务内存**​：将相关操作分组为原子事务
    
4. ​**Actor模型**​：每个Actor处理自己的状态，通过消息交互
    

## 10. 现实世界中的案例

### 经典漏洞案例：

1. ​**Therac-25放射治疗机**​：竞态条件导致患者受到过量辐射
    
2. ​**Android WindowManager**​：权限检查竞态条件可提升权限
    
3. ​**Linux内核**​：多种竞态条件漏洞（CVE-2016-5696等）
    

竞态条件是并发编程中最常见且最难调试的问题之一，理解其本质和防治方法对编写可靠的多线程程序至关重要。