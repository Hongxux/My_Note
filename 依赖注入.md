---
aliases:
  - DI
---

**依赖**是一个模型元素（如类、组件）为了完成其功能所**需要**的其他模型元素。在 Spring 中，这种“需要”的关系由 IoC 容器来**主动满足**，这就是依赖注入（DI）。

### 一、 DI 的双重属性
#### Bean的一个具体的“生命阶段”
在 Spring Bean 的标准化生命周期中，**依赖注入是一个承上启下的明确步骤**，通常紧随在“实例化”（调用构造方法创建对象）之后，而在“初始化”（执行 `@PostConstruct`等方法）之前。

这个阶段的核心任务是：Spring 容器根据配置（如 `@Autowired`、`@Value`或 XML 配置），将当前 Bean 所依赖的其他 Bean 或简单值**注入**到相应的属性中。此阶段完成后，这个 Bean 实例所需的“零件”就全部装配到位了，但它自身可能还需要一些额外的设置才能进入工作状态。
#### 控制反转这一思想的实现技术
- ​**所属范畴**​：​**DI 是 IoC 这种设计思想最主流、最具体的实现技术**。IoC 是“目标”（控制权反转），DI 是“手段”（通过注入实现反转）。
    
- ​**技术基础**​：其实现建立在 ​**Java 反射机制**​ 和 ​**动态代理**​ 之上，容器通过反射来分析类的依赖关系并完成注入。
- 

---

### 二、 工作原理与具体实现
| 特性              | Setter 注入       | 构造器注入                                        |
| --------------- | --------------- | -------------------------------------------- |
| **灵活性**         | 高，可以在任何时候重新注入依赖 | 低，对象创建后依赖不可变                                 |
| **不变性**         | 无法保证，依赖可能为 null | 好，可以用 final 修饰字段，保证线程安全                      |
| **循环依赖**        | 支持              | **不支持**，会抛出 BeanCurrentlyInCreationException |
| **代码简洁性**       | 需要多个setter方法    | 简洁，特别是配合 Lombok                              |
| **Spring 官方推荐** | ❌ 旧版方式          | ✅ **现代首选**                                   |
| **适用场景**        | 可选依赖、有默认值的依赖    | **强制依赖**、必需依赖                                |
- **Setter 方法注入**：通过 setter 方法设置依赖。
        
- **构造器注入**：通过构造方法的参数注入依赖（值得注意的是，这种方式下，实例化和依赖注入可以视为一步完成）。
	    **构造器注入在语义上保证了对象的完整性和不可变性**，这是它最核心的优势。对象在创建（`new`）出来的那一刻，所有必需的依赖就已经就绪，不存在“半成品”状态。
- **字段注入**：直接通过反射在字段上注入，如使用 `@Autowired`注解。


1. **必需依赖**：优先使用构造器注入
    
2. **可选依赖**：使用 Setter 注入，并设置 `required = false`
    
3. **配置值**：使用 Setter 注入配合 `@Value`
    
4. **需要重新绑定的依赖**：使用 Setter 注入

----

#### 1. Setter 方法注入

Setter 注入是通过调用类的 setter 方法来设置依赖关系。

##### XML 配置方式

**Java 类**：

```
public class UserService {
    private UserDao userDao;
    private int timeout;
    
    // Setter 方法
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }
}
```

**XML 配置**：

```
<bean id="userService" class="com.example.UserService">
    <!-- 引用类型依赖：使用 ref -->
    <property name="userDao" ref="userDaoBean"/>
    <!-- 基本类型依赖：使用 value -->
    <property name="timeout" value="30"/>
</bean>

<bean id="userDaoBean" class="com.example.UserDaoImpl"/>
```

##### 注解配置方式

在 Spring 框架中，用于依赖注入（DI）的注解主要有以下几个，它们各自有不同的使用场景和行为方式。
示例


|注解|来源|默认注入方式|主要特点|
|---|---|---|---|
|**`@Autowired`**|Spring 框架|**按类型（ByType）**|是 Spring 原生的注解。可与 `@Qualifier`结合实现按名称注入|
|**`@Resource`**|JSR-250 (Java 规范)|**按名称（ByName）**|JDK 原生提供的注解。如果按名称找不到，会回退到按类型查找|
|**`@Inject`**|JSR-330 (Java 规范)|按类型（ByType）|需要额外依赖（如 javax.inject），功能与 `@Autowired`类似|
|**`@Value`**|Spring 框架|-|用于注入简单值、表达式结果或配置文件中的属性|

###### 主要注入注解详解

**1. @Autowired**

这是 Spring 框架最原生的自动注入注解 。

- **默认行为**：它默认会**按照类型（ByType）**在 Spring 容器中查找匹配的 Bean。如果找不到或找到多个，则会抛出异常 。
    
- **配合 `@Qualifier`**：当容器中存在多个相同类型的 Bean 时，可以通过 `@Qualifier`注解指定需要注入的 Bean 的名称（ID），从而实现按名称注入 。
    
- **可选注入**：可以设置 `@Autowired(required = false)`。这样，如果找不到匹配的 Bean，Spring 将不会抛出异常，但依赖的属性可能为 `null`。使用此功能需谨慎进行空值判断。
```java
@Component
//定义为一个Bean，交给spring容器管理这个类
public class OrderService {
    private PaymentService paymentService;
    private EmailService emailService;

    // 在 setter 方法上添加 @Autowired
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

**2. @Resource**

这是 Java 标准提供的注解（JSR-250）。

- **默认行为**：它默认会**按照名称（ByName）**进行注入。即，它会先根据属性名或 setter 方法名来查找对应的 Bean 。
    
- **回退机制**：如果按名称找不到唯一的 Bean，它会**回退到按类型（ByType）**进行查找 。
    
- **指定名称**：可以通过其 `name`属性直接指定要注入的 Bean 名称，例如 `@Resource(name = "mySpecificBean")`。
```java
@Component
public class OrderService {
    private PaymentService paymentService;
    private EmailService emailService;

    // @Resource 默认按名称匹配
    @Resource
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    // 明确指定 Bean 名称
    @Resource(name = "smsEmailService")
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

**3. @Inject**

此注解来源于 Java 依赖注入标准（JSR-330），需要额外引入 `javax.inject`包 。它的功能与 `@Autowired`非常相似，默认也是按类型进行注入。

**4. @Value**

此注解主要用于注入普通值，而非其他 Bean 的引用 。

- **注入普通值**：可以直接注入字符串、数字等，例如 `@Value("Hello World")`。
    
- **注入配置属性**：更常见的用法是注入来自配置文件（如 `application.properties`或 `application.yml`）的值，例如 `@Value("${server.port}")`。
    
- **注入表达式结果**：支持 SpEL（Spring Expression Language）表达式，实现更灵活的赋值。
```java
@Component
public class DatabaseConfig {
    private String url;
    private int timeout;
    private boolean enabled;

    // 注入配置值
    @Value("${database.url}")
    public void setUrl(String url) {
        this.url = url;
    }

    @Value("${database.timeout:30}") // 默认值 30
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    @Value("${database.enabled:true}") // 默认值 true
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
}
```

###### 如何选择？

- **Spring 环境首选**：在纯粹的 Spring 项目中，**`@Autowired`** 是最常用和最地道的选择。
    
- **需要按名称注入时**：如果你希望明确按名称进行注入，**`@Resource`** 非常直观。
    
- **追求标准规范**：若希望代码与 Spring 解耦，能适用于其他遵循 JSR-330 标准的依赖注入容器，可以考虑使用 **`@Inject`**。
    
- **注入简单值或配置**：毫无疑问，使用 **`@Value`**。
    

---

#### 2. 构造器方法注入

构造器注入是通过类的构造函数来设置依赖关系。

##### XML 配置方式

**Java 类**：

```
public class UserService {
    private final UserDao userDao;
    private final int timeout;
    
    // 构造器
    public UserService(UserDao userDao, int timeout) {
        this.userDao = userDao;
        this.timeout = timeout;
    }
}
```

**XML 配置**：

```
<bean id="userService" class="com.example.UserService">
    <!-- 通过构造器参数注入 -->
    <constructor-arg ref="userDaoBean"/>
    <constructor-arg value="30"/>
</bean>

<bean id="userDaoBean" class="com.example.UserDaoImpl"/>
```

**当有多个构造器或参数类型相同是，需要指定参数位置或名称**：

```
<bean id="userService" class="com.example.UserService">
    <!-- 按索引指定 -->
    <constructor-arg index="0" ref="userDaoBean"/>
    <constructor-arg index="1" value="30"/>
    <!-- 或按名称指定 -->
    <constructor-arg name="userDao" ref="userDaoBean"/>
    <constructor-arg name="timeout" value="30"/>
</bean>
```

##### 注解配置方式

**使用 `@Autowired`在构造器上**：

```
@Component
public class UserService {
    private final UserDao userDao;
    private final int timeout;
    
    @Autowired // Spring 4.3+ 可省略，如果只有一个构造器
    public UserService(UserDao userDao, @Value("${app.timeout:30}") int timeout) {
        this.userDao = userDao;
        this.timeout = timeout;
    }
}
```

##### **3.Lombok插件 简化**

```
@Component
@RequiredArgsConstructor // 为final字段生成构造器
public class UserService {
    private final UserDao userDao;
    
    @Value("${app.timeout:30}")
    private final int timeout;
    // Lombok会自动生成构造器，Spring会自动使用它进行注入
}
```
#### 3.字段注入
**字段注入**：直接通过反射在字段上注入，通常使用 `@Autowired`注解。

```
@Component
public class SomeService {
    @Autowired // 直接注解在字段上
    private OtherService otherService;
}
```
还可以使用@value注入
- 一种是注入简单值@value(123)
- 一种是注入配置值@value(${xxx})[[yaml文件编程式读取#^f760f3]]

---


    

#### ​**易出错点与解决措施**​

- ​**问题1：[[循环依赖]]**。
    
    - ​**描述**​：Bean A 依赖 Bean B，同时 Bean B 又依赖 Bean A。
        
    - ​**触发条件**​：主要发生在构造器注入场景，或复杂的单例 Bean 的 Setter/字段注入场景。
        
    - ​**解决措施**​：
        
        - ​**预防**​：​**优先使用构造器注入**，它能在启动时立即暴露循环依赖，促使你改进设计（如提取公共功能到第三个 Bean 中）。
            
        - ​**框架解决**​：Spring 使用**三级缓存**机制解决单例 Bean 的 Setter/字段注入的循环依赖，但这是一种补救措施，应优先从设计上避免。
            
        
    
- ​**问题2：存在多个同类型候选 Bean（[[NoUniqueBeanDefinitionException的解决方案]]）​**。
    
    - ​**描述**​：`@Autowired`注解默认是按类型（byType）进行自动装配的。​当有多个 Bean 都实现了同一个接口时，容器不知道注入哪一个。
        
    - ​**解决措施**​：

    