---
aliases:
  - 重做日志
---
- 需求背景：实现持久性
	- 方案一：如果每次事务提交都直接将修改的数据页写入磁盘，会遇到严重的性能瓶颈：磁盘的随机I/O速度很慢
		- 数据库以页（16KB）为单位进行磁盘交互
			- 导致事务可能只修改页中几个字节，数据库却不得不以整个页为单位进行读写
		- 数据页分散问题
			- 事务修改的多个数据页在物理磁盘上位置分散，导致大量的随机寻址
	- 方案二：如果为了提升性能，事务提交仅依赖内存缓冲：**断电会导致数据丢失**，违背持久性原则
- 解决方法：redo log
	- 核心思路是：不再在事务提交时立即随机写分散的数据页，而是顺序记录下数据页的物理变更
		- 【数据页的物理变更】： 数据页的物理变化（如"页号X偏移量Y修改为Z"），
		- 好处：不是逻辑SQL语句，恢复时无需解析SQL，直接应用物理修改，速度更快
	- 关键机制：WAL预写式日志，即先写日志，再写数据
		- 首先，必须将本次修改对应的所有redo log记录写入日志文件（先写日志）
			- 合理性：为什么写日志，不写数据：因为日志是顺序IO写入磁盘
				- 由于是顺序追加，磁盘顺序写入性能比随机写入高几个数量级
			- 循环写入机制
				- redo log文件固定大小，写满后从头覆盖旧日志。
				- 只要检查点机制推进得当，就不会丢失未刷盘数据所必需的日志。
		- 之后，才会在后台找合适时机将内存中的脏数据页刷回磁盘。（再写数据）
		- 好处： 实现崩溃恢复：
			- 恢复的目标：未刷盘的已提交事务
			- 恢复时机：数据库重启后
			- 恢复方式：将已提交但未落盘的事务修改重新构造出来

- redo log的性能优化：先将日志写入内存缓冲区，再以页为单位批量刷盘
	- 写入的内存缓冲区：redo log buffer
	- 配置刷盘机制：
		- `innodb_flush_log_at_trx_commit=1`：**最高安全性**（每次提交刷盘）。
		- `innodb_flush_log_at_trx_commit=2`：**平衡策略**（写入page cache，每秒刷盘）。
		- `innodb_flush_log_at_trx_commit=0`：**最高性能**（仅内存，每秒刷盘）。




