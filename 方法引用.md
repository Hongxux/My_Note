**方法引用**​（Method References）是Lambda表达式的自然延伸，也是Java函数式编程的语法糖。
- **Lambda表达式中单一方法调用的冗余语法**问题，但带来了**类型推断复杂性**的副作用，这个副作用通过编译器的**重载解析机制**解决；
- 方法引用是Lambda表达式的**语法简化**，不是功能替代；


---


​**一、核心知识点**​

1. ​**定义与本质**​：
    
    - 方法引用是Lambda表达式的语法糖，使用`::`操作符
	    - **::操作符**：用于分割类名/Object名 与 方法名
	    - **三种方法引用形式：**
	        1. object::instanceMethod

			2. Class::instanceMethod

			3. Class::staticMethod
    - **使用限制：** 当Lambda体仅**包含单一方法调用时**可使用方法引用简化
        
    - **本质：** 
	    - 是Lambda表达式的**语法简化**，不是功能替代。
	    - 不是对象，需赋值给函数式接口变量才生成实例（类似于Lambda表达式）
    - ​**空指针异常时机差异**​：`object::method`在object为null时立即抛出NPE，而等效Lambda在调用时抛出
    
2. ​**三种基本形式及参数传递规则**​：

| 形式       | 语法                       | 等价Lambda                       | 参数规则       |
| -------- | ------------------------ | ------------------------------ | ---------- |
| 对象引用实例方法 | `object::instanceMethod` | `x -> object.method(x)`        | 参数作为方法参数   |
| 类引用实例方法  | `Class::instanceMethod`  | `(x, y) -> x.method(y)`        | 首参为调用者     |
| 类引用静态方法  | `Class::staticMethod`    | `(x, y) -> Class.method(x, y)` | 参数作为静态方法参数 |
- **特殊形式应用**​：`this::method`和`super::method`用于当前对象和父类方法引用
- ​**API设计意图**​：有些API是专门为方法引用而创建的，如`Objects::isNull`专为方法引用场景设计，提高代码可读性
3. ​**编译器处理机制**​：
    
    - ​**重载解析**​：根据目标函数式接口的方法签名选择匹配的重载方法
        
    - ​**类型推断**​：基于上下文确定方法引用的具体类型
        
    - ​**生成实例**​：转换为实现函数式接口的类实例
        



​**二、关键差异对比**​

| 特性    | 方法引用                  | 等效Lambda表达式                  |
| ----- | --------------------- | ---------------------------- |
| 语法简洁性 | `System.out::println` | `x -> System.out.println(x)` |
| 空指针异常 | 创建时检查对象非空             | 调用时检查对象非空                    |
| 可读性   | 更声明式，表达"做什么"，表达意图更清晰  | 更命令式，表达"如何做"                 |
| 适用场景  | 纯方法调用                 | 任意代码块                        |

---

**面试官可能关心的方面及答案**



​**问题2：编译器如何解析`System.out::println`这种方法引用？​**​

​**答案**​：

编译器基于**目标函数式接口的抽象方法签名**进行重载解析：

- 如果赋值给`ActionListener`，需要`void actionPerformed(ActionEvent)`，则选择`println(Object)`
    
- 如果赋值给`Runnable`，需要`void run()`，则选择无参的`println()`
    
    解析依赖上下文类型信息，不是孤立进行的。
    

​**问题3：`String::compareToIgnoreCase`属于哪种方法引用？参数如何传递？​**​

​**答案**​：

属于**类引用实例方法**形式。参数传递规则是：

- 第一个String参数作为`compareToIgnoreCase`方法的调用者（隐式参数）
    
- 第二个String参数作为方法的显式参数
    
    等价Lambda：`(str1, str2) -> str1.compareToIgnoreCase(str2)`
    

​**问题4：什么情况下不能使用方法引用？请举例说明。​**​

​**答案**​：

以下情况不能使用方法引用：

- Lambda体包含多个语句：`s -> { System.out.println(s); log(s); }`
    
- 包含额外操作：`s -> s.length() == 0`（有比较操作）
    
- 方法签名不匹配且无法通过参数调整适配
    
- 需要修改参数或进行其他非方法调用操作时
    

​**问题5：`super::method`有什么特殊用途？​**​

​**答案**​：

`super::method`用于在子类中引用父类版本的方法：

```
class SubClass extends SuperClass {
    public void method() {
        // 引用父类实现
        someMethod(SuperClass::method); // 或 someMethod(super::method)
    }
}
```

这在重写方法但需要调用父类实现时特别有用，提供了更好的多态支持。

​**问题6：方法引用在性能上与Lambda有差异吗？​**​

​**答案**​：

在运行时性能上**没有本质差异**，因为方法引用会被编译器转换为类似的字节码结构。主要区别在于：

- 编译时的语法处理不同
    
- 代码可读性和简洁性有提升
    
- 字节码生成策略相同，都生成实现函数式接口的类实例
    

方法引用的设计体现了Java对代码简洁性和API友好性的持续追求，是函数式编程在Java中自然演进的重要一环。