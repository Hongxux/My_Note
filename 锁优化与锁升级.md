###### **一、 默认行为：使用临键锁防止幻读**

> ​**默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。​**​

- ​**隔离级别**​：MySQL 的默认隔离级别是 ​**REPEATABLE READ**。在这个级别下，核心要解决的是**幻读**问题（即一个事务内多次读取，结果集行数发生变化）。
    
- ​**默认锁算法**​：​**临键锁**。它是**行锁 + 间隙锁**的组合，不仅锁住记录本身，还会锁住记录之前的间隙。这有效防止了其他事务在间隙中插入新数据，从而杜绝了幻读。
    

###### **二、 优化情况：针对唯一索引的等值匹配**

> ​**针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。​**​

这是非常重要的**性能优化点**。在某些特定条件下，严苛的临键锁会“降级”为更宽松的行锁。

- ​**触发条件**​（必须同时满足）：
    
    1. 使用了**唯一索引**​（如主键、唯一约束索引）。
        
    2. 查询是**等值匹配**​（例如 `id = 5`，而非范围查询 `id > 5`）。
        
    3. 匹配的记录**必须存在**。
        
    
- ​**优化效果**​：InnoDB 可以确定只锁定这一条明确的记录，无需锁定一个范围，从而**减少了锁的冲突**，提升了并发性能。
    

​**示例对比**​：

```
-- 情况A：优化为行锁（使用主键等值查询存在记录）
SELECT * FROM users WHERE id = 10 FOR UPDATE; -- 只对id=10这行加行锁（Record Lock）

-- 情况B：仍使用临键锁（范围查询）
SELECT * FROM users WHERE id > 10 FOR UPDATE; -- 对id>10的范围加临键锁（Next-Key Lock），防止插入id=11,12...的新记录
```

###### **三、 风险情况：无索引导致锁升级**

> ​**InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。​**​

这是最需要警惕的**性能陷阱**。

- ​**根本原因**​：InnoDB 的行锁是**通过索引实现的**。如果 `WHERE`条件中的列没有索引，数据库**无法快速定位到目标行**。
    
- ​**后果**​：为了确保数据一致性，InnoDB 会退而求其次，​**锁住整张表**​（实际上是锁住所有行和间隙，效果等同于表锁）。
    
- ​**危害**​：​**并发性能急剧下降**。任何需要修改此表的操作都会被阻塞，极大影响系统吞吐量。
    

​**示例**​：

```
-- 假设 name 字段上没有索引
UPDATE users SET status = 'inactive' WHERE name = '张三';
-- 此操作会导致全表扫描，并对整个 users 表加锁，阻塞其他所有写操作
```

###### 四、 监控命令：查看锁信息

> ​**可以通过以下SQL，查看意向锁及行锁的加锁情况：​**​
> 
> `SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM performance_schema.data_locks;`

这是一个极其重要的**诊断工具**。当发生锁等待或怀疑锁行为不当时，可以用此命令来“破案”。

- ​**关键字段解读**​：
    
    - `LOCK_TYPE`：锁的粒度，`TABLE`为表级锁，`RECORD`为行级锁。
        
    - `LOCK_MODE`：锁的模式，如 `X`（排他行锁）、`IX`（意向排他锁）、`X,REC_NOT_GAP`（行锁）、`GAP`（间隙锁）、`X`（临键锁，即 Next-Key Lock）。
        
    - `LOCK_DATA`：被锁定的具体数据（对于行锁，显示主键值或索引值）。
        
