# 为什么会出现页表过大现象
现代操作系统（如 Linux, Windows, macOS）普遍采用 64 位架构。这意味着一个进程的**虚拟地址空间**大得惊人：2^64 字节，即 16 EB（艾字节）。这是一个理论上无限大的空间。

然而，物理内存是有限的，通常以 GB 或 TB 计。为了管理这个巨大的虚拟空间和有限的物理空间之间的映射，操作系统采用了**分页**​ 机制，将虚拟内存和物理内存都切成固定大小的块（通常是 4KB），称为“页”。

​**关键问题来了**​：一个巨大的虚拟地址空间，即使大部分区域未被使用，**也需要在页表中留有“记录位”来表示该区域是有效、无效还是属于其他地方。**

# 页表过大导致的问题
1. **内存浪费**​： 页表本身需要占用物理内存（称为“页表开销”），这减少了可用于应用程序和缓存的实际内存。
    
2. ​**TLB 压力增大**​： TLB 是缓存页表条目的硬件缓存，容量很小。当页表非常庞大时，TLB 的未命中率会急剧升高。每次 TLB 未命中都需要多次内存访问来遍历多级页表，严重降低性能（这就是“TLB Thrashing”）。
    
3. ​**进程切换开销大**​： 进程切换时需要切换页表（即切换 CR3 寄存器）。如果新进程的页表很大，且不在缓存中，会导致系统性能下降。
    
4. ​**内存访问延迟**​： 即使是单次内存访问，如果页表层级过深，也需要多次访问内存才能完成地址翻译。

# 解决方案
## 1.大页 [[Bigger Pages]]
## 2.多级页表 [[Multi-level Page Tables]]
## 3. 倒置页表 [[Inverted Page Tables]]