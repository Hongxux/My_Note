泛型让我们能够编写可以适用于多种类型的代码，同时又保持了编译时的类型安全。
- **类型参数（Type Parameters）​**​：它就像是一个"占位符"，解决了**代码复用时需要为每种类型重写相似逻辑（A问题）​**​ 的困境，但带来了**类型擦除带来的运行时信息丢失（副作用）​**​ 的挑战，而这个挑战恰恰需要通过**通配符和边界限制（C解决方案）​**​ 来应对。
    
- ​**类型擦除（Type Erasure）​**​：它是Java泛型实现**向后兼容性**的**代价**，虽然保证了与老代码的兼容，但也带来了一些使用上的限制。
    
- ​**容易混淆的概念**​：`<T>`中的`T`是类型参数，`List<String>`中的`String`是类型实参，虽然都涉及类型，但角色完全不同。泛型类/泛型方法/通配符这三者的关系和区别也是重点难点。
---
### 类型参数

**背景：** 在泛型出现之前，Java 用继承实现泛型编程（比如用 `Object`装一切），但这带来了两个大麻烦：​**频繁的类型转换**和**缺乏类型安全检查**​（比如你往 `ArrayList`塞个 `File`对象，编译器也不会报错，直到运行时才崩溃）

**新名词**：
- **菱形语法（diamond syntax）​**​：`new ArrayList<>()`中的 `<>`，编译器能自动推断泛型类型，避免重复写类型参数。
    
- ​**类型参数（Type Parameter）​**​：如 `ArrayList<String>`中的 `String`，用于指定集合元素的类型。

**首先说明泛型出现前用 `Object`实现的缺陷；**​

1. 使用 `Object`实现泛型（如旧版 `ArrayList`）会导致哪两个具体问题？
    
	- 获取值时需强制转换（如 `(String) files.get(0)`）；
        
    - 可添加任意类型对象（如 `files.add(new File(...))`），无编译时类型检查，导致运行时可能抛出 `ClassCastException`。
​**然后引入类型参数如何解决这些问题；**​

1. 泛型类（如 `ArrayList<String>`）如何通过类型参数解决强制转换和类型安全问题？编译器知道了理想的类型，能够自动推断返回类型，自动检查添加操作
     - **编译器**利用类型参数（如 `ArrayList<String>`）自动**推断**返回类型（无需强制转换）；
        
    - **编译器检查**添加操作的类型安全性（如 `files.add(new File(...))`会编译失败）。

​**接着解释类型参数提升代码可读性的表现；**​

1. 声明 `var files = new ArrayList<String>()`时，类型参数如何让代码更易读？
        - 类型参数直接表明集合元素类型（如 `ArrayList<String>`无需阅读上下文即可理解数据结构用途，一眼可知存的是字符串）。
        

​**最后补充菱形语法及其演进（Java 9 匿名类支持）；**​

1. 菱形语法 `<>`的作用是什么？Java 9 对其做了什么重要扩展？
	- 作用：编译器根据上下文（如变量声明类型）自动推断泛型类型，避免冗余代码。（如 `new ArrayList<>()`推断为 `String`）；
        
    - Java 9 扩展：支持在匿名子类中使用菱形语法（如 `new ArrayList<>() { ... }`）。
		![[Pasted image 20251023211321.png]]

---
### 实现泛型

#### ​泛型类
- 泛型类（generic class）是带有一个或多个**类型变量**​（type variable）的类。
	**类型变量详解**​
	- 类名后面的尖括号 `< >`内**声明类型变量**（如 `<T>`）。
	- 一个泛型类**可以有多个类型变量**（例如：`public class Pair<T, U> { ... }`）。
	- 类型变量在整个类定义中用于指定：
	    
	    - 方法的返回类型（如 `T getFirst()`）。
	        
	    - 字段的类型（如 `private T first;`）。
	        
	    - 局部变量的类型。
	- ​**类型变量命名惯例：​**​
	    - 通常使用**大写字母**。
	    - 名称通常**简短**。
	    - Java 库常用约定：
	        - `E`：集合（Collection）的元素类型。
	        - `K`：表（Table）的键类型。
	        - `V`：表（Table）的值类型。
	        - `T`（以及邻近的 `U`, `S`等）：表示“任意类型”。
#### [[泛型方法]]
在普通类或泛型类中定义**独立**支持类型参数的方法。比泛型类更更灵活。

泛型方法是对泛型类的**补充**​（单个方法可独立泛型化），类型推断则是其核心**增强**特性。易混淆点是**显式指定类型参数**​（如 `<String>getMiddle()`）与**隐式推断**的适用场景。

####  **[[约束类型变量的界限]]**
- ​**类型界限（Type Bound）​**​：`<T extends Comparable>`中的 `Comparable`，限制 `T`必须是其子类型，保证 `T`拥有特定方法（如 `compareTo`）。
    
- ​**多重界限（Multiple Bounds）​**​：如 `<T extends Comparable & Serializable>`，用 `&`分隔多个接口界限（类界限只能有一个且必须在前）。

界限是类型参数的**增强**​（赋予类型特定能力），解决了前文泛型方法中“类型无约束”的副作用。易混淆点是 `extends`在泛型中表示**子类型**​（含接口），与继承中的 `extends`含义不同。


---
### 泛型的底层原理
Java泛型转换依赖三大关键机制：

> ​**虚拟机中的泛型**​：
> 
> ​**虚拟机（JVM）不存在泛型概念**。泛型仅在编译阶段存在，字节码中所有泛型类型均被擦除为原始类型（`Object`或边界类型），类型检查由编译器完成。
#### [[类型擦除]]
- **类型擦除（Type Erasure）​**​：编译器移除泛型类型参数，将其替换为界限类型（如 `Comparable`）或 `Object`，字节码中只保留原始类型（Raw Type）。
    
- ​**原始类型（Raw Type）​**​：擦除后的泛型类（如 `Pair`替代 `Pair<String>`），与Java 5前的普通类兼容。
这是Java泛型的核心设计，也是对前文泛型类/方法实现的**底层补充**——它解释了为何泛型能在旧JVM上运行，但也带来一些限制

#### [[泛型表达式的转换]]
这是对类型擦除机制的**关键补充**，同时暴露了擦除的代价（运行时转换开销）。
易混淆点是：​**开发者无需写转换，但转换实际存在**。
- ​**编译器插入转换（Compiler-Inserted Cast）​**​：泛型擦除后，**编译器**在字节码中**自动**添加类型转换指令（如 `(Employee)`），弥补类型信息丢失。
    
- ​**原始方法调用（Raw Method Call）​**​：擦除后调用的方法无泛型信息（如 `Pair.getFirst()`返回 `Object`）。

#### [[桥接方法]]
桥接方法是擦除的**副作用解决方案**，解决了前文擦除导致的**多态断裂**问题。易混淆点是：​**桥接方法由编译器生成，开发者不可见**。
- **桥接方法（Bridge Method）​**​：编译器自动生成的方法（如 `setSecond(Object)`），用于连接擦除后的父类方法和子类重写方法，​**维持多态性**。
    
- ​**协变返回类型（Covariant Return Types）​**​：子类重写方法时返回更具体类型（如 `Employee.clone()`返回 `Employee`而非 `Object`），此时编译器也会生成桥接方法。


#### **[[泛型与遗留代码的共舞]]**
如何让新泛型代码与老旧的**非泛型代码（Legacy Code）​**​ 和平共处？
对类型擦除的**实际应用补充**，揭示了泛型兼容性设计的代价（开发者需手动评估风险）。易混淆点是：​**警告不是错误，而是提醒**。
- **遗留代码（Legacy Code）​**​：未使用泛型的旧代码（如Java 5前的库），通常以**原始类型（Raw Type）​**​ 存在（如 `Dictionary`而非 `Dictionary<K,V>`）。
    
- ​**编译器警告（Compiler Warning）​**​：泛型与遗留代码交互时产生的类型安全提示（如 `unchecked`），需开发者评估风险后决定是否忽略。


---
### **[[泛型的限制与约束]]**
这是**类型擦除带来的**必要妥协。
#未理解

---
### [[泛型继承的规则]]
**泛型类的继承关系与泛型参数的继承关系不相关。** 
**泛型不变性（Invariance）​**​：泛型类之间无继承关系（如 `Pair<Manager>`与 `Pair<Employee>`无关），即使类型参数有继承关系
- **原因**​：类型擦除导致运行时无法区分 `Pair<Manager>`和 `Pair<Employee>`（均为原始 `Pair`）。
    
- ​**关键对比**​：数组支持协变（`Manager[]`可赋给 `Employee[]`），但泛型禁止（避免类型污染）。
    
- ​**后文关联**​：通配符（如 `Pair<? extends Employee>`）是解决此限制的灵活方案
---
### 通配符
泛型体系的**关键补充**,解决了前几章泛型僵化的问题
#待理解 下界通配符为什么能安全写数据，却不能安全读数据，上界通配符为什么能安全读数据，却不能安全写数据？
#### [[上界通配符]] 安全地读数据
#### [[下界通配符]]安全地写数据
#### [[无界通配符]]
只需要操作Object就有的方法时候，为了简便性使用无界通配符
##### [[通配符捕获]] 
在编译器必须确保通配符代表**唯一且确定的类型**时候，利用**不含通配符的泛型辅助方法**，解决编译器无法将通配符 `?`视为具体类型 → 无法声明变量或执行写入操作的问题