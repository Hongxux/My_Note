- 设计目的：最大化写性能而设计的策略，它将写操作的延迟降至最低
	- **用潜在的数据丢失风险来换取极高的性能**
- 工作模式：
	1. 应用程序发起写操作时，数据只被写入缓存，然后立即向应用程序返回成功。此时，数据源中的数据仍是旧的。
	2. 被修改的缓存数据块会被标记为“脏数据”（Dirty），通常通过一个“脏位”（Dirty Bit）来实现 。
	3. 写回的持久化方式：
		1.  **脏数据标记与追踪**：后续所有操作的基础。
		    - 缓存系统会为每个数据项维护一个状态。当数据被应用修改后，它在缓存中被标记为“脏”，表示与数据库中的版本不一致。系统需要维护一个**脏数据列表**，记录哪些数据需要被同步到数据库
		2. **专用的同步线程异步地**将脏数据回写到数据
		    - 这个线程会定期扫描脏数据列表，将数据写入数据库，成功后再将其从脏数据列表中移除。
		3. **配置重试机制,重试失败交由人工处理**
		    - **指数退避**: 第一次失败后等待1秒重试，第二次失败等待2秒，第四次等待4秒，以此类推，避免对数据库造成“雪崩”式冲击。
		    - **最大重试次数**: 设定一个上限。如果重试超过一定次数仍失败，该数据会被标记为同步失败，并触发告警，需要人工介入处理。
- **优点**：
	- **极低的写延迟：** 写操作仅涉及内存操作，速度极快，系统吞吐量大大提高
	- **降低数据源压力：** 可以将多次对同一数据的修改合并为一次写操作，或者将多次写操作批量提交，显著减少了对后端数据源的IO请求次数
- **缺点**：
	- **写回过程中数据库不可用:**
		- 临时故障：重试机制通常能最终成功
			- 在此期间，脏数据会一直保留在缓存中。
		- 长时间故障（如数据库硬盘损坏、长时间停机）：重试会持续失败，直到达到最大重试次数。
			- 脏数据会持续滞留在缓存中，有丢失风险。
			- 解决措施：**服务降级**：
				- 在检测到数据库长时间不可用时，系统可以降级为“只读模式”
				- 甚至直接拒绝新的写请求，防止脏数据进一步堆积，并向用户明确提示。
	- **数据丢失风险：** 这是该策略最大的弊端。如果在脏数据被写回数据源之前，缓存服务发生宕机或断电，那么这部分更新的数据将永久丢失
		1. 评估是否能接受数据丢失
			- **可接受场景**：用户行为日志、点赞数、浏览量等数据，即使丢失一小部分，对核心业务影响甚微，但极致的性能体验更重要。此时，写回策略是很好的选择。
			- **不可接受场景**：金融交易、订单支付等。这类业务要求“数据零丢失”，必须采用更安全的策略（如写穿透或直接写数据库）
		  2. 技术手段降低风险：缓存持久化如AOF和RDB
		  3. 架构设计：采用分布式缓存集群，避免单点故障
	- **实现复杂度高：** 需要精细地管理脏位、写回时机、失败重试、并发控制等逻辑，是所有策略中最复杂的 。
	- **数据不一致性：** 在数据被写回之前，缓存和数据源之间存在明确的数据不一致窗口。如果此时有其他服务或请求绕过缓存直接读取数据源，就会读到旧数据。