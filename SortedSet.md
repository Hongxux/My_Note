---
aliases:
  - ZSET
---
![[Pasted image 20251122140820.png]]
好的，Redis 的 Sorted Set（有序集合，通常简写为 ZSet）是一个非常强大且实用的数据结构。它结合了 Set 的**唯一性**和 Hash 的**可排序性**，是解决排序相关问题的利器。

为了让你快速建立整体认知，下面这个表格清晰地概括了它的核心特征。

|特性维度|说明|
|---|---|
|**数据结构**|元素（member）唯一，但每个元素关联一个分数（score），元素**依据分数进行自动排序**。|
|**核心特点**|元素唯一、有序（按分数排序）、支持高效的分数更新和范围查询。|
|**底层实现**|根据元素数量和大小，动态采用 **ziplist（压缩列表）**或 **skiplist（跳跃表）+ hashtable（哈希表）**。|
|**经典场景**|排行榜、延时队列、带权重的任务调度等。|

接下来，我们深入了解一下它的命令、应用和原理。

###  核心命令详解

Sorted Set 的命令通常以 `Z`开头。下面按功能分类介绍最常用的命令。

#### 1. 基础操作

- **`ZADD key [NX|XX] [CH] [INCR] score member [score member ...]`**
    
    - **功能**：添加一个或多个“分数-元素”对到有序集合。如果元素已存在，则更新其分数（除非使用 `NX`选项）。
        
    - **选项**：
        
        - `NX`：仅添加新元素，不更新已存在元素。
            
        - `XX`：仅更新已存在元素，不添加新元素。
            
        - `INCR`：将操作视为 `ZINCRBY`，对分数进行增量操作。
            
        
    - **示例**：创建游戏玩家得分榜。
        
        ```
        127.0.0.1:6379> ZADD leaderboard 1000 "Alice" 800 "Bob" 1200 "Charlie"
        (integer) 3
        ```
        
    
- **`ZSCORE key member`**
    
    - **功能**：获取指定元素的分数。
        
    - **示例**：
        
        ```
        127.0.0.1:6379> ZSCORE leaderboard "Alice"
        "1000"
        ```
        
    
- **`ZREM key member [member ...]`**
    
    - **功能**：移除有序集合中的一个或多个元素。
        
    - **示例**：
        
        ```
        127.0.0.1:6379> ZREM leaderboard "Bob"
        (integer) 1
        ```
        
    

#### 2. 查询操作
##### 范围查询

###### **按排名查询**（按照角标）

- **`ZRANGE key start stop [WITHSCORES]`**：按照分数**从低到高**（升序）返回指定排名区间（从0开始）的元素。`-1`表示最后一个。
	
- **`ZREVRANGE key start stop [WITHSCORES]`**：按照分数**从高到低**（降序）返回指定排名区间的元素。**这是获取排行榜TOP N最常用的命令。**
	
- **示例**：获取前三名玩家。
	
	```
	127.0.0.1:6379> ZREVRANGE leaderboard 0 2 WITHSCORES
	1) "Charlie"
	2) "1200"
	3) "Alice"
	4) "1000"
	5) "Bob"   # 假设Bob未被移除
	6) "800"
	```
	
    
######  **按分数查询**（滚动分页的redis实现方式）
    
- **`ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]`**：返回分数在 `min`和 `max`之间的元素（升序）。可以用 `-inf`和 `+inf`表示负无穷和正无穷。
![[Pasted image 20251122142228.png]]
- **`ZREVRANGEBYSCORE key max min [WITHSCORES]`**：同上，但按降序。
	
- **示例**：获取分数在900到1100之间的玩家。
	
	```
	127.0.0.1:6379> ZRANGEBYSCORE leaderboard 900 1100 WITHSCORES
	1) "Alice"
	2) "1000"
	```
        
##### 范围统计统计
	
- **`ZCARD key`**：获取有序集合中元素的总数量。
	
- **`ZCOUNT key min max`**：统计指定分数范围内的元素数量。
	
- **示例**：
	
	```
	127.0.0.1:6379> ZREVRANK leaderboard "Alice"
	(integer) 1  # Alice是第二名
	127.0.0.1:6379> ZCARD leaderboard
	(integer) 3
	127.0.0.1:6379> ZCOUNT leaderboard 500 1500
	(integer) 3
	```
	
#####  **获取特定元素的排名与统计**
    
- **`ZRANK key member`**：获取元素的升序排名（从0开始，分数最低的排第0）。
	
- **`ZREVRANK key member`**：获取元素的降序排名（分数最高的排第0）。**这是获取玩家具体名次最常用的命令。**


    

#### 3. 分数操作

- **`ZINCRBY key increment member`**
    
    - **功能**：为指定元素的分数增加增量 `increment`。增量可为负数。这是实现分数变更的**原子性操作**。
        
    - **示例**：Alice赢得比赛，增加50分。
        
        ```
        127.0.0.1:6379> ZINCRBY leaderboard 50 "Alice"
        "1050"
        ```
        
    
### 对分数score的设计
#### 排序优先级
例如实现先按照分数，分数相同再按照时间
- 思路：
	- 时间戳是固定位数的
	- 一个分数中可以划分存储
- 实现方法：
	- 小数部分法：最终分数 = 原始分数 + (1 - 时间戳 / 一个足够大的数，如 1e13)
		- 将时间戳存储在小数后面
	- 整数放大法：最终分数 = 原始分数 * 10^13 + (MAX_TIMESTAMP - 时间戳)
		- 将时间戳放在更小的整数位

### 主要应用场景

1. **排行榜系统**
    
    这是 Sorted Set 最经典的应用。将用户ID作为元素（member），用户的积分、得分、活跃度等作为分数（score）。可以轻松实现：
    
    - **更新分数**：`ZADD`或 `ZINCRBY`。
        
    - **获取TOP N**：`ZREVRANGE key 0 N-1 WITHSCORES`。
        
    - **查看个人排名**：`ZREVRANK`。
        
    
2. **延时队列**
    
    将任务的执行时间戳（例如 `当前时间 + 延迟时间`）作为分数，任务内容作为元素。一个后台进程不断轮询，用 `ZRANGEBYSCORE key 0 <当前时间戳>`获取所有已到期的任务进行处理。
    
3. **带优先级的任务队列**
    
    将任务的优先级（如高、中、低分别对应分数 1, 2, 3）作为分数。消费者使用 `ZRANGEBYSCORE`从高优先级（分数小）到低优先级（分数大）的顺序获取任务。
    
4. **实时统计（如热门文章）**
    
    将文章ID作为元素，文章的点击量、点赞数等综合热度作为分数。每次用户行为使用 `ZINCRBY`增加热度，然后通过 `ZREVRANGE`获取热门列表。
    

### 🔩 底层实现原理

Sorted Set 底层数据结构的要求：
- 键值存储
- 键必须唯一
- 可排序

- **ziplist（压缩列表）**
    
    - **触发条件**：
	    - 当有序集合中的**元素数量小于 `zset-max-ziplist-entries`（默认128）**
		- 并且**每个元素的值的大小都小于 `zset-max-ziplist-value`（默认64字节）**时使用。
    - 实现的方式：ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现![[b1c8bc73cbd1daa57aac4ab91ee2453c.jpeg]]
	    - 实现存储键值对：ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后
	    - 实现可排序：score越小越接近队首，score越大越接近队尾，按照score值升序排列
	- 为什么不方便不自然也要用ziplist：内存和性能的权衡
		- 数据量小的时候，维护和存储两个数据结构（skiplist+dict）占用内存大的同时，也没有特别显著提升性能
        
    
- 组合使用**skiplist（跳跃表） + Dict（字典）**![[Pasted image 20251127132355.png]]![[1fae7e0c2f6a84b1c70828f3aea65cfd.jpeg]]
    
    - **触发条件**：当不满足上述 ziplist 的条件时，会自动转换为此结构。
    - **结构**：在需要不同功能的时候使用不同的数据结构，同时在增删改的时候也要维护两种数据结构
        - **跳跃表（[[skiplist]]）**：
			- 可排序    
        - **哈希表（[[Dict]]）**：
	        - 满足键值存储
	        - 以及键的唯一性

### ⚠️ 重要注意事项

1. **分数相同的情况**：如果多个元素的分数相同，Redis 会**按照元素字符串的字典序（lexicographical order）**进行排序 。
    
2. **分数的精度**：分数是双精度浮点数，可能存在精度问题。如果对精度要求极高，可以考虑将分数放大为整数（如用100表示1.00）来避免浮点数计算误差 。
    
3. **大Key风险**：避免让一个 Sorted Set 存储过量的元素（例如上百万），这会导致在内存重分配（如编码转换时）或执行 `ZRANGE`/`ZREMRANGE`等范围命令时阻塞服务。对于海量数据，应考虑按业务维度进行分片。
    
4. **命令的复杂度**：`ZRANGE`、`ZREM`等命令的时间复杂度与返回的元素数量成正比。避免使用 `ZRANGE key 0 -1`获取超大集合的所有元素，应使用 `ZSCAN`进行游标式迭代。
    

希望这份详细的介绍能帮助你全面掌握 Redis 的 Sorted Set！它是解决排序问题的瑞士军刀，用好了会极大提升应用的性能和开发效率。