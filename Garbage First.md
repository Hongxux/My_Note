---
aliases:
  - G1
---
[G1 垃圾收集器详解G1 垃圾收集器原理详解 theme: smartblue 1 G1的内存模型 传统的GC收集器将连 - 掘金](https://juejin.cn/post/7209266987049844791)
- 设计目标：
	- 在保证高吞吐量的同时，尽可能实现可预测的、低停顿的时间
	- 替代CMS，解决其内存碎片和并发模式失败可能导致长时间Full GC的问题
- 适合场景：
	- 同时注重吞吐量和低延迟
	- 适合有超大堆内存的服务器（4G到64G）
- 数据结构
	- RSet：记录了哪些其他Region引用了本Region中的对象
		- 回收一个Region时，无需扫描整个堆来确定对象存活，只需扫描该Region内部和其RSet即可
	- CSet：本次GC周期中需要被回收的Region的集合
		- G1会根据停顿时间目标（`-XX:MaxGCPauseMillis`）智能地选择回收收益最高的Region组成CSet
- 内存结构：
	- [[Region]]：
	- Card [[卡片]]：
	- Card Table [[卡表]]
	- [[收集集合]] 
	- [[记忆集]]RSet
		
- 核心思想：
	- 实现可预测的停顿时间：增量回收和收益优先
		- 实现基础：独立Region分区
			- G1 能够以 Region 为**最小回收单元**，每次只选择一部分 Region 进行收集
		- 并发标记阶段，会跟踪每个Region的回收价值，在后台维护一个优先列表
		- 混合收集阶段，分多次进行垃圾回收，在停顿间隔中让应用程序运行，从而避免单次STW时间过长，达到`-XX:MaxGCPauseMillis`参数设定的目标停顿时间
- 问题：
	- 出现Full GC
		- 主要原因和对策：
			 - **并发模式失败**：
				 - 原因：在并发标记完成前，老年代就被填满。
				 - 对策：调低IHOP或增加堆大小。
			 - **晋升失败**：从年轻代分区拷贝存活对象时，无法找到可用的空闲分区
				 - 原因：Mixed GC速度跟不上对象从年轻代晋升到老年代的速度。
				 - 对策：优化应用减少对象创建，或调整参数让Mixed GC更积极。
			 - **大对象分配失败**：
				 - 原因： 分配巨型对象`Humongous Object` 时在老年代无法找到足够的连续分区
				 - 对策：避免分配过多大对象，或增大Region大小。
		- 后果：Full GC是**串行**的（Serial Old），停顿极长
- 设计对停顿时间敏感的系统
	- 设定期望最大停顿时间目标，G1会尽力达成但不保证：-XX:MaxGCPauseMillis=200
	- IHOP，触发并发标记的老年代占用阈值，如果Mixed GC跟不上对象晋升速度，可适当调低：XX:InitiatingHeapOccupancyPercent=45

- 回收阶段：![[Pasted image 20251207185935.png]]
	- 新生代垃圾回收（STW）：回收Eden和Survivor区
		- 触发时机：G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 `-XX:MaxGCPauseMills` 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做YoungGC，直到下一次Eden区放满，G1计算回收时间接近参数 `-XX:MaxGCPauseMills` 设定的值，那么就会触发YoungGC。
		  - 工作流程：
			  - 标记：解决RSet加速标记
				  1. 根扫描：得到GC Root
				  2. 更新RSet：处理 dirty card 队列中的 card，更新 RSet
					  - 作用：使得RSet 可以准确的反映老年代对所在的region 分区中对象的引用
				  3. 处理RSet
					  - 识别被老年代对象指向的 Eden 中的对象，这些被指向的Eden中的对象被认为是存活的对象
			  - 复制：
				  - 将 Eden 区存活的对象将被拷贝到 to survivor 区
				  - from survivor 区存活的对象则根据存活次数阈值分别晋升到 PLAB、to survivor 区和老年代中
					  - 如果 survivor 空间不够，Eden区的部分数据会直接晋升到年老代空间。
			  - 处理引用：处理软引用、弱引用、虚引用
	- 全局并发标记：初始标记和根区域扫描，为并发标记提供根对象，最终标记处理在并发过程中的引用关系新更改
		1. 初始标记（STW）：与一次Young GC的STW时间一并完成的，将新生代垃圾回收后的新生代Survivor分区作为根
			- 带来的额外开销非常小。
		2. 根区域扫描（并发）：
			- 工作内容：扫描在初始标记阶段结束时Survivor区中所有的对象（这些对象是根），并标记它们引用的老年代对象。
			- 时间要求：在**下一次Young GC发生之前**完成
				- 新的YoungGC后,Survivor区对象会发生改变
		3. 并发标记（并发）：标记的快照（SATB）
			- 触发时机：老年代的内存占用率达到一个特定的阈值，G1才会在下次Young GC后启动并发标记周期
				- 阈值的目的：G1希望在老年代还没有被完全填满之前，就提前开始分析哪些老年代Region中的垃圾最多，为后续的混合回收​ 做好准备，从而**避免陷入必须进行Full GC**的窘境
			- 标记的起点：
				- 初始标记中确定的Survivor分区
				- 根区域扫描中确定的老年代对象
		4. 最终标记（STW）：
			1. 处理剩余的[[漏标]]缓冲区：它通过捕捉引用删除，保证了在并发环境下标记的准确性，解决了“对象消失”这一核心难题
			2. 引用对象处理
				- 针对对象：**软引用、弱引用、虚引用和最终引用**。
				- 处理方式：G1会判断这些引用指向的对象是否已经被标记为不可达（垃圾），如果是，则会将它们加入到相应的引用队列中，等待Java应用程序自己处理
			3. 类卸载
				- 实现基础：在最终标记阶段确认了所有存活对象后，G1可以识别出**不再被任何存活对象引用的类**（即类的元数据），从而进行类卸载
				- 目的：有助于释放元空间的内存
		5. 回收价值计算
			- 需求背景：传统类卸载（非并发），通常在Full GC的STW阶段进行
				- 增加Full GC的停顿时间
				- 频率低且耗时
			- 实现基础：最终标记阶段结束后，G1对每个Region中存活对象的数据就有了准确的了解
			- 计算：
				- 每个Region的**回收价值**：即回收该Region能释放多少空间
				- 每个Region的**回收成本**：复制其存活对象需要的开销
			- 作用：**筛选回收阶段**决定优先回收哪些Region的直接依据
	- 混合收集：对三类区域进行垃圾回收
		- 工作流程：
			1. **筛选回收集CSet**：
				- 包括所有的年轻代Region，
				- 还会**选择性地加入一部分老年代Region**。
					- 选择的标准是“垃圾优先”，即优先选择垃圾比例高（回收价值大）的老年代Region。
			2. **复制存活对象，清空CSet的Region**：此阶段需要 **STW**。
				- 回收算法：**复制算法**
				- 复制的具体流程：这个过程与Young GC类似，但回收范围扩展到了老年代
					1. 将CSet中所有存活的对象**疏散**（Evacuate）​ 到新的空闲Region中
					2. 然后**清空**整个CSet的Region。
		- 回收特点：**分多次回收**
			- 设计目的：将总停顿时间控制在预期目标
			- 实现方式：分多次回收，在停顿间隔中让应用程序运行，从而避免单次STW时间过长，
			- 次数：G1默认会将混合回收分成**最多8次**进行
				- 可通过 `-XX:G1MixedGCCountTarget`调整。

- 优化：
	- 字符串去重
		- 需求背景：字符串冗余
			- 大量动态创建字符串
		- 解决措施：
			- 字符串入池
				- 使用[[字符串常量池|StringTable]]去重，共享 `String`对象本身在字符串常量池中的引用
				- 可以使用 `==`来快速比较内容是否相同
					- 比 `equals()`方法更快，因为 `==`只比较引用地址
			- G1字符串去重
				- 仍然是不同的字符串对象，共享字符串对象底层的 `char[]`字符数组
		- 开启方式：`-XX:+UsestringDeduplication`
		- 工作流程：
			- 将所有新分配的字符串放入一个队列
			- 当新生代回收时，G1并发检查是否有字符串重复
				- 如果它们值一样，让它们引用同一个 char数组![[Pasted image 20251208103514.png]]

	- 回收巨型对象![[Pasted image 20251208110003.png]]
		- 巨型对象定义：占据region的一半及其以上
		- 回收巨型对象的时候：G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉
			- 回收的时候优先考虑，越早回收越好
			- G1不会对巨型对象进行拷贝
	- 并发标记开始时间调整
		- 需求背景：减少Full GC
		- 核心思想：提早开始并发标记，提早开始混合回收，减少FullGC的发生机率
		- 配置：JDK9之后，能动态调整触发阈值（老年代占用堆空间比例达到阈值）
			- 设置初始值`-XX:InitiatingHeap0ccupancyPercent `用来设置初始值
			- 垃圾回收的时候进行数据采样并动态调整，总会添加一个安全的空间