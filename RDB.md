- 需求背景：解决一个根本矛盾
	- 让一个将所有数据放在内存中、追求极速响应的数据库，在服务器发生故障或重启时，避免数据完全丢失，并能够快速恢复服务
- 解决措施：RDB （Redis Database）
	- **快速的数据恢复**：
		- 实现基础：RDB 文件是某个时间点的完整数据**二进制快照**
		- 工作机制：重启时直接加载到内存
		- 好处：恢复速度远快于需要逐条重放命令的 AOF 方式，适合用于灾难恢复和大数据集的快速重启
	- **紧凑的文件体积**：
		- 实现基础：
			- RDB 文件采用二进制格式
			- 默认压缩：压缩（`rdbcompression yes`）是默认配置
		- 好处：体积相对较小，非常适合做定期的完整备份和归档
	- **对主进程影响最小化**：
		- 通过`BGSAVE`，RDB的持久化工作由子进程在后台完成，主进程可以继续服务客户端，避免了长时间的阻塞
		- 虽然`fork`和COW会带来一定的开销，但在大多数情况下，这种影响是短暂且可控的。
- 问题：
	- 潜在的数据丢失风险：在上一次快照后、下一次快照前服务器发生故障，这期间的所有数据更新都会丢失
	- fork可能带来的延迟：
		- 直接问题：在数据量非常大时可能会耗时较长，导致服务出现短暂的停顿
		- 衍生问题：fork后如果父进程有大量写操作，可能会触发**写时复制**，导致内存占用增加
		- 问题升级：最坏的情况下，如果所有内存页都被修改，系统可能需要额外分配接近原始数据量一倍的内存，这可能导致内存溢出
---
触发方式
- 手动触发RDB快照
	- `SAVE` 命令（同步阻塞）：
	    - 执行过程：当客户端执行`SAVE`命令时，Redis主进程会亲自执行RDB快照的生成过程。
	    - 核心特点：在快照完成之前，主进程会一直处于**阻塞**状态，无法响应任何其他客户端的命令请求。
	    - 适用场景：由于其阻塞特性，`SAVE`命令极少在生产环境中使用，通常只用于维护、迁移或调试等可以接受服务暂停的场景。
	- `BGSAVE` 命令（异步非阻塞）：
		- 执行过程：当执行`BGSAVE`命令时，Redis主进程会调用操作系统`fork()`函数，创建一个与主进程一模一样的**子进程** 。
		- 子进程职责：这个子进程会独立负责将内存数据写入临时的RDB文件。
		- 异步非注射的原理：在子进程工作期间，主进程可以继续处理客户端的命令请求
- 自动触发RDB快照
	- 通过`redis.conf`配置文件中的`save`指令来让Redis自动执行`BGSAVE`
	- `save <seconds> <changes>` 配置指令：
	    - 含义：该指令定义了自动触发`BGSAVE`的条件，即“在`<seconds>`秒内，如果至少发生了`<changes>`次写操作，则自动执行一次`BGSAVE`”。
	    - 默认配置示例 ：
	        - `save 3600 1`：表示在3600秒（1小时）内，如果至少有1个key发生变化，则触发快照。
	        - `save 300 100`：表示在300秒（5分钟）内，如果至少有100个key发生变化，则触发快照。
	        - `save 60 10000`：表示在60秒（1分钟）内，如果至少有10000个key发生变化，则触发快照。
	    - 工作机制：
		    - 实现基础：
			    - 计数器`dirty`：记录了自上次快照以来的写操作次数
			    - 时间戳`lastsave`：记录了上次快照的时间
			- 工作流程：服务器会周期性地（通常是每秒）检查`save`指令配置的条件是否满足，一旦满足，就会自动触发`BGSAVE`。
  -  其他触发场景
	  - `FLUSHALL` / `FLUSHDB` 命令：清空数据库
		  - 前提：配置了自动触发规则
		  - 产出结果：生成一个空的RDB文件，覆盖旧文件。
	  - 主从复制：
		  - 前提：一个从节点首次连接到主节点
		  - 工作模式：
			  1. 主节点会执行一次`BGSAVE`，生成RDB文件
			  2. 主节点将该文件发送给从节点
			  3. 从节点加载RDB文件以完成全量数据同步。
	  - 执行`SHUTDOWN`命令：正常的关闭命令
		  - 目的：确保数据在关闭前被持久化，这是一种安全关闭机制。
----
实现细节
![[Pasted image 20251122165057.png]]
- **`fork()`的作用**：
    - 会**创建**一个与父进程（Redis主进程）几乎完全相同的**子进程**。
    - 子进程拥有父进程在`fork`瞬间的**完整内存数据副本**。
	    - 实现方式：父子进程共享同一份物理内存页。
	    - 好处：`fork`操作本身非常快速，几乎是瞬时完成的。
- **写时复制（Copy-on-Write, COW）机制**、
	- 初始状态：共享阶段
		- 含义：`fork`之后，父子进程共享内存数据
		- 工作模式：
			- 子进程开始读取内存数据并写入RDB文件
			- 父进程继续接收和处理客户端请求。
	- 状态变化：
		- 触发条件：父进程需要**修改**某个内存页上的数据
		- 采取行动：在写入发生之前，操作系统会将被修改的那个内存页**复制一份**，让父进程在新复制的页面上进行修改。
		- 产出结果：
			- 父进程的修改不会影响到子进程。子进程看到的数据仍然是`fork`那一瞬间的、未经修改的原始数据快照。
		- 问题：如果父进程有大量的写操作，会导致频繁的内存页复制，这会消耗额外的内存和CPU资源
	- 