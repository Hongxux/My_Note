---
aliases:
  - 动态字符串
---
- 需求背景：C语言原生字符串存在固有缺陷，无法满足高性能存储需求
	- 获取字符串长度的 需要遍历直至遇到'\0'，时间复杂度为O(n)，
	- 非二进制安全：C字符串以'\0'作为结束符，若字符串中包含'\0'会被截断
		- 无法安全存储二进制数据（如图片、视频）
	- 不可修改：C字符串长度固定
		- **缓冲区溢出风险**：修改时若未手动重新分配足够内存，极易造成**缓冲区溢出**。
		- **频繁内存重分配**：每次增长或缩短字符串，几乎都需要执行内存重分配操作，性能开销大。
- 解决方案：简单动态字符串(Simple Dynamic String)，简称SDS。
	- 高效长度获取：SDS通过`len`属性实现O(1)复杂度获取长度
	- 二进制安全：SDS通过`len`属性判断结束，支持任意二进制数据
	- 动态扩展：SDS支持动态修改，并通过自动扩容杜绝溢出
- SDS的结构
	- len：记录已使用的字节数
		- O（1）获取字符串长度
		- 二进制安全
			- 知道读多少位（len）停止，而不依赖于‘\0’标识符
	- alloc：记录总分配字节数
		- 是内存自动扩容的基础
	- `buf[]`：字符数组，存储实际字符串数据
		- 尾部自动追加'\0'以兼容C字符串函数（如`strlen`），但不计入`len`
	- flags:一个字节，其**低3位**用于标识SDS的类型
- SDS核心机制 
	- 类型优化
		- 需求背景：在 Redis 3.2 之前，所有 SDS 字符串都使用同一个结构体
			- 该结构体中的 `len`和 `free`字段被固定为 `unsigned int`类型（通常为 4 字节）。
			- 这对于很短的字符串（比如一个键名 "user:1"）来说，记录其信息的头部（`len`+ `free`）可能**比实际数据还大，造成浪费**
		- 解决措施：引入了 **5 种不同类型的 SDS 结构体**![[Pasted image 20251126152117.png]]
			- **`sdshdr5`的特殊性**：
				- 它没有独立的`len`和`alloc`字段，长度信息直接编码在`flags`字节的高5位中，因此它只能存储长度小于32的字符串
				- 由于没有预留空间，不适合进行追加操作，所以在实际使用中较少
			- 核心思想：**按需分配**
				- 新创建的时候，根据字符串的初始长度选择最合适的类型
				- 需要扩容时，Redis 会根据字符串的（新）长度，智能地选择或切换到最合适的 SDS 类型
			- 实现机制：
				- 通过`__attribute__ ((__packed__))`编译器指令，让结构体**按1字节对齐**（取消内存对齐填充）。
				- 给定一个指向`buf`的指针`s`，通过`s[-1]`就能直接访问`flags`字段，进而判断类型并定位到结构体起始地址，非常巧妙
			- 好处：仅包含 "Hello"（5字节）的字符串，其头部信息只需 **1 字节的 `len`**​ 和 **1 字节的 `alloc`**（总分配容量），加上 **1 字节的 `flags`**，大大减少了内存占用
	- 自动扩容：内存预分配
		- 需求背景：频繁内存分配需用户态-内核态切换
		- 解决措施：预分配
			- 含义：一次分配多预留空间
			- 作用：减少了后续连续追加操作所需的内存重分配次数
		- 流程：
			1. 第一次声明SDS的时候：len=alloc
			2. 追加字符串的时候，进行内存预分配：
				1. **检查空间**：若剩余空间（`alloc - len`）足够，则直接返回。
				2. **计算新长度**：新长度 = 原长度 (`len`) + 新增内容长度 (`addlen`)。
				3. **预分配规则**：
				    - 若**新长度 < 1MB**，采用加倍策略，分配 `新长度 * 2`的空间。
				    - 若**新长度 ≥ 1MB**，采用固定增量策略，分配 `新长度 + 1MB`的空间
				4. **执行分配**：
					1. 如果扩容后SDS类型不变：使用`realloc`扩展；
					2. 如果扩容后SDS类型变化：使用`malloc`新空间并复制数据
	- 惰性空间释放
		- 需求背景：频繁进行释放会导致内存碎片和分配开销
		- 解决措施：惰性空间释放
			- 字符串缩短时不立即回收内存，而是保留多余空间供未来使用
		- 实现机制：通过`sdsclear`重置`len`但不释放内存，真正释放需调用`sdsfree`
