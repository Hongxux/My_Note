- 表现：指**两个或多个不同的键（Key）经过哈希函数计算后，得到了相同的哈希值，从而被映射到哈希表同一个桶（Bucket）或位置**的情况![[Pasted image 20251204125550.png]]
- 发生的原因：
	- 【发生的必然性】由于抽屉原理，哈希冲突必然发生
	- 【发生的提前性】哈希函数无法实现完美均匀，因此不是在装填因子大于等于1的时候才发生，而是小于1的时候也可能发生
		- 装填因子越大，出现哈希冲突的概率越大
- 解决措施
	- 链地址法
		- ​原理​：不把每个桶看作一个单独的空位，而是看作一个**链表**​（或其它数据结构，如红黑树）的头指针。所有哈希到同一个桶的键值对，都会被放入这个链表中。
		- ​操作​：
		    - ​插入​：计算哈希值找到桶，遍历该桶的链表。如果key已存在则更新value；如果不存在，则将新节点插入到链表末尾（或头部，因实现而异）。
		    - ​查找​：计算哈希值找到桶，遍历该桶的链表，用`equals()`方法逐个比对key。
		    - ​删除​：计算哈希值找到桶，遍历链表找到对应节点并删除。
		- ​优点​：
		    - 实现简单，有效。
		    - 对于负载因子（元素总数/桶数）的容忍度更高。
		- ​缺点​：
		    - 需要额外的空间存储指针。
		    - 如果链表过长，性能会退化为`O(n)`。
		- ​重要优化​：在Java 8的HashMap中，当链表长度超过阈值（默认为8）时，链表会转换为**红黑树**，将最坏情况下的查找时间从`O(n)`优化到`O(log n)`。当桶中节点数因删除而减少到另一个阈值（默认为6）时，又会转换回链表。
	- 开放寻址法
		- ​原理​：当发生冲突时，通过一个探测序列来寻找数组中的“下一个”空位。
			- 【探测序列】往哪个方向移动多少格去一个新的桶
				- 最后一个桶的下一个是第一个桶
			- 元素查找 ：先按照散列函数找到第一个桶，如果桶内数据不符合目标，则根据规定号的探测序列去找接下里的桶，不断比对，直至找到目标
				- 如果查找到一个空桶，则表示这个元素不存在
			- 删除元素：不能直接删除，而是要标记为已删除![[Pasted image 20251204130915.png]]
				- 因为查找到一个空桶，表示元素不存在
				- 如果直接删除了，会截断别的元素的根据探测序列的查找路径
					- 出现明明存在，却找不到的情况
		- ​常见探测方法​：
		    1. ​线性探测​：如果位置`i`被占了，就依次尝试`i+1, i+2, i+3, ...`直到找到空位。
		    2. ​平方探测​：为了解决线性探测的“聚集”问题，尝试`i + 1², i + 2², i + 3², ...`。
			    - 【聚集】因为自己的位置很大概率被别人通过线性探测方式给占领，而自己不得不通过线性探测的方式找新的位置![[Pasted image 20251204130952.png]]
			    - 问题：导致找寻的效率下降
			    - 解决方法：平方探测
			    - 平方探测的问题：
				    - 不一定能探测到所有的散列表位置
				    - 解决措施：确保哈希表的长度为4k+3的质数（比如7），则可以确保能探测到所有的散列表位置
		    3. ​双重哈希​：使用第二个哈希函数来计算探测的步长。
		- ​优点​：
		    - 所有数据都存储在数组中，​**缓存友好**​（CPU读取连续内存更快）。
		    - ​不需要额外的指针，节省空间。
		- ​缺点​：
		    - 对负载因子更敏感​：当负载因子接近1时，性能会急剧下降，因此需要更早地扩容。
		- ​典型应用​：`ThreadLocalMap`

	- ​再哈希法​：准备一组不同的哈希函数，如果第一个哈希函数发生冲突，就换第二个、第三个...直到不冲突为止。计算成本较高，不常用。