---
aliases:
  - Unmodifiable Copies
  - Unmodifiable Views
  - 不可修改的副本
  - 不可修改的视图
---

#### ​**一、不可修改副本（`copyOf`方法）​**​

​**核心机制**​：创建原始集合的**独立快照**​

```
ArrayList<String> names = ...;
Set<String> nameSet = Set.copyOf(names);  // 创建不可修改副本
List<String> nameList = List.copyOf(names);
```

​**特性**​：

1. ​**完全独立**​：原始集合修改不影响副本
    
2. ​**智能优化**​：若原始集合已是不可修改且类型匹配，直接返回原集合
    
    ```
    Set<String> names = Set.of("A", "B");
    Set<String> copy = Set.copyOf(names);  // names == copy
    ```
    ![[Pasted image 20251027085320.png]]
    

#### ​**二、不可修改视图（`Collections.unmodifiableXxx`）​**​
![[Pasted image 20251027085423.png]]
​**核心机制**​：为现有集合添加**运行时保护层**​

```
var staff = new LinkedList<String>();
List<String> view = Collections.unmodifiableList(staff); // 创建视图
```

​**特性**​：

1. ​**动态绑定**​：原始集合修改会实时反映到视图
    
2. ​**操作拦截**​：所有修改操作（如`add`）抛出`UnsupportedOperationException`
    
3. ​**接口限制**​：仅暴露接口方法（如`LinkedList.addFirst()`不可用）
    
4. ​**特殊行为**​：
    
    - `unmodifiableCollection()`使用`Object.equals()`（比较对象地址）
        
    - `unmodifiableSet/List()`使用底层集合的`equals/hashCode`
        
    

#### ​**三、副本 vs 视图：核心区别**​

|​**特性**​|副本 (`copyOf`)|视图 (`unmodifiableXxx`)|
|---|---|---|
|​**数据独立性**​|✅ 完全独立|❌ 依赖原始集合|
|​**内存开销**​|较高（需复制数据）|较低（仅包装对象）|
|​**修改检测**​|不感知原始集合修改|实时反映原始集合变化|
|​**适用场景**​|需要完全隔离的数据快照|临时提供只读访问权限|

---

### ​**学习重点分层指南**​

#### ​**初学者必掌握**​

1. ​**基础操作**​：
    
    - `copyOf`创建独立不可修改副本
        
    - `Collections.unmodifiableList/Set()`创建视图
        
    
2. ​**核心区别**​：
    
    - 副本独立 vs 视图依赖原始集合
        
    
3. ​**修改限制**​：
    
    - 二者均禁止修改操作（抛出异常）
        
    

#### ​**进阶者需深入**​

1. ​**智能优化机制**​：
    
    - `copyOf`对已有不可修改集合的优化逻辑
        
    
2. ​**视图特殊行为**​：
    
    - `unmodifiableCollection()`的`equals/hashCode`特性
        
    - 接口方法限制原理（如无法调用`LinkedList.addFirst()`）
        
    
3. ​**底层原理**​：
    
    - 视图如何通过包装器实现运行时检查
        
    - 修改操作异常抛出机制
        
    

> ​**关键警示**​：
> 
> 使用`Collections.unmodifiableCollection()`时，其`equals()`方法比较对象地址而非内容，这是与`unmodifiableSet/List()`的核心行为差异！
