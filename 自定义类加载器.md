- 需求背景：
	- 需要从标准路径（如数据库、网络、加密文件）外加载类
	- 隔离加载：防止类冲突，实现模块或应用间的类隔离。
		- Tomcat 为每个 Web 应用配备独立的类加载器，让不同应用能使用同一库的不同版本而互不干扰
	- 保护与增强：对字节码进行额外处理，以满足安全或功能需求。
		- 加密/解密：加载经过加密的类文件
		-  字节码增强：在类加载时修改字节码，实现 AOP（面向切面编程）等功能
	- 动态性与模块化：实现热部署、模块化加载等高级特性。
		- 热部署 (HotSwap)：在不重启应用的情况下，动态更新或替换已加载的类
		- 模块化框架：OSGi 或 Spring Boot 的 Fat Jar 机制利用自定义类加载器管理模块的依赖和生命周期
- 实现方式：
	- 方式一：可以创建自定义类加载器。通常只需继承`java.lang.ClassLoader`并重写`findClass(String name)`方法即可
		- 特点：遵循了双亲委派模型
		- 实现流程：读取字节码文件 -> 转为字节数组 -> 调用 `defineClass()`
			```
			import java.io.*;
			
			public class MyClassLoader extends ClassLoader {
			    private String classPath; // 用于指定查找字节码的基路径
			
			    public MyClassLoader(String classPath) {
			        // 可显式指定父加载器，不指定则默认是系统应用类加载器
			        super();
			        this.classPath = classPath;
			    }
			
			    @Override
			    protected Class<?> findClass(String name) throws ClassNotFoundException {
			        // 1. 根据类的全限定名（如 com.example.MyApp）定位到具体的.class文件
			        String path = classNameToPath(name);
			        byte[] classBytes = null;
			        
			        // 2. 从自定义源（这里是文件系统）读取字节码
			        try (InputStream ins = new FileInputStream(path);
			             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
			            byte[] buffer = new byte[1024];
			            int bytesRead;
			            while ((bytesRead = ins.read(buffer)) != -1) {
			                baos.write(buffer, 0, bytesRead);
			            }
			            classBytes = baos.toByteArray();
			        } catch (IOException e) {
			            throw new ClassNotFoundException("Could not load class: " + name, e);
			        }
			
			        // 3. 调用 defineClass 完成最后的解析，将字节数组转换为 Class 对象
			        if (classBytes != null) {
			            return defineClass(name, classBytes, 0, classBytes.length);
			        } else {
			            throw new ClassNotFoundException("Class not found: " + name);
			        }
			    }
			
			    private String classNameToPath(String className) {
			        // 将类名中的点转换为文件路径分隔符
			        return classPath + File.separatorChar + 
			               className.replace('.', File.separatorChar) + ".class";
			    }
			}
			```
	- 方式二：打破双亲委派模型
		- 重写loadClass方法