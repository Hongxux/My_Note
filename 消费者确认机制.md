![[Pasted image 20251210150322.png]]
- 需求背景：如何确保消息被消费者成功处理，而不仅仅是从队列中取出。
	- 消费者从RabbitMQ拉取一条消息后。消息就被MQ删除
	- 如果消费者在处理业务逻辑时（比如更新数据库、调用外部接口）应用突然崩溃。消息将会丢。
	- 导致**消息永远丢失**，业务数据不一致
- 解决措施：消费者确认机制
	- MANUAL模式：
		- 需要自己手动确认
		- 重试机制需要自己通过nack的参数是否重新入队进行控制
			- 可以借助Redis
	- auto模式：
		- **触发 `nack`（消息重新入队）的情况**
			- **默认行为**：当你的业务逻辑中抛出**除了特定异常之外的任何普通异常**（如 `RuntimeException`, `NullPointerException`, 自定义业务异常等），Spring AMQP 在默认情况下会发送 `nack`命令，并且设置 `requeue=true`，这会导致消息**重新放回队列的头部**​
			- **风险**：如果消息处理失败的原因无法自动恢复（如代码Bug、数据错误），此消息会再次被同一个消费者获取，导致**无限循环**，快速消耗系统资源
		- **触发 `reject`（消息被丢弃或进入死信队列）的情况**：通过抛出特定的异常，可以主动控制消息的命运，避免无限循环
			- **抛出 `AmqpRejectAndDontRequeueException`**：这是最明确的方式。当业务中抛出此异常时，框架会发送 `reject`命令，并且设置 `requeue=false`。消息会被立即拒绝，并且**不会重新入队**。如果队列配置了死信交换机，消息会被路由到死信队列；否则，消息会被永久丢弃
			- **抛出 `ImmediateAcknowledgeAmqpException`**：这是一个特例。抛出此异常时，框架会认为消息**已成功处理**，并发送 `ack`！消息会从队列中删除，但**你的业务逻辑其实并未成功**。这通常用于处理一些“可忽略”的错误，但需谨慎使用，因为它可能导致消息丢失
		- Spring的**本地重试（Retry）机制**：改变 `auto`模式的原始行为，使其更健壮
			1. 业务方法抛出异常（非 `AmqpRejectAndDontRequeueException`等特定异常）。
			2. Spring框架会**在消费者本地进行重试**，而不是立即向RabbitMQ发送 `nack`。在此期间，消息在RabbitMQ中一直处于 `unack`状态。
			3. 如果在最大重试次数内成功，则发送 `ack`。
			4. 如果重试次数耗尽依然失败，根据MessageRecover接口采取不同处理策略
			    - RejectAndDontRequeueRecoverer:重试耗尽后，直接reject，丢弃消息。
				    - 默认就是这种方式
				- ImmediateRequeueMessageRecoverer:重试耗尽后，返回nack，消息重新入队
				- RepublishMessageRecoverer:重试耗尽后，将失败消息投递到指定的交换机
					- 使用死信队列

| 确认模式                | 工作机制                                                                          | 优点                           | 缺点                             | 适用场景                            |
| ------------------- | ----------------------------------------------------------------------------- | ---------------------------- | ------------------------------ | ------------------------------- |
| **`none`(无确认)**​    | 消息投递给消费者后，RabbitMQ**立即**将其从队列中删除。                                             | 吞吐量最高。                       | **极其危险**，若消费者处理失败，消息将**永久丢失**。 | 仅适用于可容忍消息丢失的非核心业务，生产环境**不推荐**。  |
| **`manual`(手动确认)**​ | 消费者在代码中**显式调用API**，发送`ack`(成功)、`nack`(失败需重投)或`reject`(失败并拒绝)。                 | 控制粒度**最精细**，可靠性高。            | **代码侵入性强**，需谨慎处理异常和信道状态，实现复杂。  | 需要**精确控制**确认时机的高级场景，如批量处理、条件确认。 |
| **`auto`(自动确认)**​   | Spring AMQP通过AOP**自动**处理。业务成功执行返回`ack`；出现异常时，根据异常类型返回`nack`(重试)或`reject`(丢弃)。 | **无代码侵入**，开发简单，是Spring的默认模式。 | 异常分类和重试策略需合理配置，否则可能陷入无效重试循环。   | **企业级推荐**的通用场景，在简单性和可靠性间取得良好平衡。 |
	
- 问题：
	- **消息重复消费，需要保证幂等性**：当消费者处理成功但返回`ack`网络超时，或因为`nack`触发了重投递，都可能导致消息被**重复消费**。
		- 应对策略：是确保消费者业务的**幂等性**，即无论同一条消息消费多少次，结果都与消费一次相同。常用方法包括在业务逻辑中检查唯一业务ID、使用数据库唯一约束或乐观锁。
	    
	- **消息因为重试而导致无序与消息堆积导致的阻塞**：开启重试后，失败的消息会重新进入队列末尾排队。如果队列中积压了需要重试的消息，可能会**阻塞**后续正常消息的处理，在某种程度上也可能影响消息的处理顺序。
		- 应对策略：对于顺序有严格要求的场景，可能需要考虑单队列单消费者，或更复杂的路由设计。
	- **未确认的消息堆积带来内存与性能压力**：如果消息持续处理失败并不断重试，会导致队列中积压大量`Unacked`（未确认）消息，给RabbitMQ服务器带来内存和性能压力。
		- 应对策略：
			- 合理设置`prefetch`值（每次预取的消息数，通常设为1）和重试次数
			- 监控队列深度
- 使用方式：在企业级应用中，我们通常选择 **`auto`（自动）模式**，因为它提供了最佳的无侵入性体验。但仅仅开启自动模式是不够的，必须配置相应的重试和死信策略来应对风险。

 1. **基础配置**在`application.yml`中配置消费者监听器，开启本地重试模式：
	```
	spring:
	  rabbitmq:
	    listener:
	      simple:
	        acknowledge-mode: auto  # 采用自动确认模式
	        retry:
	          enabled: true          # 开启消费者失败重试
	          max-attempts: 3       # 最大重试次数（包括第一次）
	          initial-interval: 1000ms  # 第一次重试的间隔
	          multiplier: 2         # 间隔倍数（第二次等待 1000 * 2 = 2000ms）
	          stateless: true       # 默认为true，适用于无事务场景
	```
2. **应对无限重试：死信队列**
	
	- 需求背景：避免重试失败导致消息丢失。配置重试后，若重试`max-attempts`次后仍失败，Spring会返回`reject`，消息默认会被RabbitMQ丢弃。直接丢弃失败消息不利于问题排查和修复。
	
	- 解决措施：**死信队列（Dead-Letter Queue, DLQ）**。
		- 移交条件：发生以下情况，它会被重新发布到另一个交换机和队列，即死信队列
			- 消息被拒绝
			- 过期
			- 队列达到最大长度
		- 作用：便于后续人工或自动化处理。
	- 使用方式：
		1. 在Spring中，可以配置一个`RepublishMessageRecoverer`，将最终失败的消息投递到指定的错误交换机和队列，而不是简单地丢弃。
				```
				@Bean
				public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate) {
				    return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
				}
				```
		2. 声明对应的死信交换机和队列：
				```
				@Bean
				public DirectExchange errorMessageExchange() {
				    return new DirectExchange("error.direct");
				}
				@Bean
				public Queue errorQueue() {
				    return new Queue("error.queue", true);
				}
				@Bean
				public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange) {
				    return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");
				}
				```


    
