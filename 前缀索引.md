
### 前缀索引（针对文本数据）
![[Pasted image 20251030212012.png]]
![[Pasted image 20251030212158.png]]
- ​**优势**​：显著减小索引大小，提高查询速度，特别是对于 `TEXT`、长 `VARCHAR`等字段。
    
- ​**劣势**​：因为只使用了部分字符串，所以**无法使用前缀索引进行排序（ORDER BY）​**，并且覆盖索引的特性会失效（辅助索引中存放的数据不完整，必须回表）。
    
- ​**适用场景**​：主要用于长字符串的**等值（=）查询和前缀匹配（LIKE ‘abc%’）查询**。
    

​**核心要点**​：前缀索引是一种有效的优化手段，但其成功的关键在于通过计算**选择性**，为 `n`选择一个合理的值，在索引大小和查询效率之间取得最佳平衡。

#### 一、什么是前缀索引？为什么需要它？

- ​**定义**​：只为字符串字段的**前面一部分字符**创建索引，而不是为整个字符串创建索引。
    
- ​**解决什么问题**​：当字段类型是 `VARCHAR(TEXT)`、`TEXT`或 `BLOB`等长字符串时，为其创建完整索引会导致索引文件非常大，不仅占用大量存储空间，更会显著增加磁盘 I/O，降低查询效率。
    
- ​**核心思想**​：用**空间换效率**。通过牺牲一点点索引的精确度，来换取索引体积的大幅减小和查询性能的提升。
    

#### 二、如何创建前缀索引？

语法非常简单，在创建索引的语句中指定字段名和前缀长度 `n`即可。

```
CREATE INDEX index_name ON table_name(column_name(n));
```

- `index_name`： 你为索引取的名字。
    
- `table_name`： 表名。
    
- `column_name`： 要创建索引的字符串列名。
    
- `n`： ​**前缀长度**，即使用该列的前多少个字符来构建索引。这是前缀索引的**关键决策点**。
    

​**示例**​：

```
-- 为 user 表的 email 字段创建前缀索引，只取前10个字符
CREATE INDEX idx_email_prefix ON user(email(10));
```

#### 三、如何确定最佳的前缀长度 `n`？

图片指出了最关键的一步：前缀长度 `n`的选择依据是**索引的选择性**。

1. ​**什么是选择性？​**​
    
    - 选择性 = `不重复的索引值数量（基数） / 数据表总记录数`。
        
    - ​**选择性越高，查询效率通常越高**。它的取值范围在 `0`到 `1`之间。
        
    - ​**选择性为 1**​：表示该列所有值都是唯一的（如主键、唯一索引），这是最理想的情况。
        
    
2. ​**如何选择 `n`？—— 通过计算不同前缀长度的选择性**​
    
    图片中的 SQL 演示了如何通过计算来选择 `n`：
    
    ```
    -- 1. 先计算完整列的选择性（作为参考基准）
    SELECT COUNT(DISTINCT email) / COUNT(*) FROM tb_user;
    
    -- 2. 然后尝试计算不同前缀长度的选择性，找到最接近完整列选择性的最小长度 n
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 5)) / COUNT(*) FROM tb_user; -- 计算前5个字符的选择性
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 6)) / COUNT(*) FROM tb_user; -- 计算前6个字符的选择性
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 7)) / COUNT(*) FROM tb_user; -- 计算前7个字符的选择性
    ```
    
    ​**决策过程**​：不断增加 `n`的值并计算其选择性，直到选择性非常接近完整列的选择性。此时这个 `n`就是一个比较合理的前缀长度。例如，如果前7个字符的选择性已经达到0.95，而前8个字符的选择性为0.96，提升不大，那么选择 `n=7`就是性价比很高的方案。
    