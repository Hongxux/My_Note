- 需求背景：
	 1. **定时任务与延时触发**
		- **需求**：在特定时间点或延迟一段时间后执行某个任务，而无需外部触发。
		- **传统方案问题**：使用 cron 定时任务轮询数据库，会产生大量无效查询，且精度和实时性差。
		- **延迟消息优势**：消息队列可精确地在指定时间触发任务，无需轮询，减少资源浪费。
	 2. **业务状态的后置检查**
		- **需求**：在业务操作发生后，需要在一段时间后检查业务状态是否满足预期。
		- **典型场景**：
		    - **订单超时关闭**：用户下单后30分钟未支付，自动取消订单。
		    - **优惠券过期**：发放优惠券后24小时失效。
		- **优势**：将超时逻辑与主流程解耦，避免阻塞主流程。
	 3. **重试机制与指数退避**
		- **需求**：操作失败后，不立即重试，而是等待一段时间后重试，且重试间隔逐渐增长。
		- **典型场景**：
		    - **调用外部API**：失败后等待1秒、2秒、4秒...逐步重试。
		    - **分布式事务协调**：事务参与者暂时不可用，延迟后重试。
		- **优势**：避免立即重试对系统造成冲击，提高重试成功率。
	4. **流量控制与限流**
		- **需求**：控制操作的频率，防止短时间内过度频繁执行。
		- **典型场景**：
		    - **短信验证码**：发送后60秒内不允许再次发送。
		    - **API调用限流**：限制每用户每秒请求次数。
		- **优势**：通过延迟消息实现冷却期，简单有效。
	5. **分布式事务的最终一致性**
		- **需求**：在分布式事务中，延迟检查事务状态，确保最终一致性。
		- **典型场景**：
		    - **转账后校验**：转账操作完成后，延迟几分钟检查双方余额是否一致。
		    - **数据同步校验**：主从同步后，延迟检查数据一致性。
		- **优势**：将一致性检查异步化，不影响主交易性能。
	 6. **系统解耦与削峰填谷**
		- **需求**：将非实时任务延迟处理，平滑系统负载。
		- **典型场景**：
		    - **日志分析**：将日志处理任务延迟到系统低峰期执行。
		    - **报表生成**：在夜间生成日报表，避免影响白天业务。
		- **优势**：提高系统资源利用率，保证核心业务性能。
- 解决方式：消息在发送到RabbitMQ后，会在Broker中"休眠"指定的时间，只有等到延迟时间结束后才会进入队列等待消费者消费。
- 实现方式：
	- 死信队列 + TTL（最常用）：通过设置消息的TTL（Time To Live）和死信交换器来实现延迟效果。
		```
		// Spring Boot 配置示例
		@Configuration
		public class RabbitDelayConfig {
		    
		    // 延迟交换器
		    @Bean
		    public DirectExchange delayExchange() {
		        return new DirectExchange("delay.exchange");
		    }
		    
		    // 延迟队列 - 设置TTL和死信交换器
		    @Bean
		    public Queue delayQueue() {
		        return QueueBuilder.durable("delay.queue")
		                .withArgument("x-message-ttl", 60000) // 60秒TTL
		                .withArgument("x-dead-letter-exchange", "process.exchange") // 死信交换器
		                .withArgument("x-dead-letter-routing-key", "process.key") // 死信路由键
		                .build();
		    }
		    
		    // 实际处理队列
		    @Bean
		    public Queue processQueue() {
		        return new Queue("process.queue");
		    }
		}
		```
	- [[rabbitmq_delayed_message_exchange插件]]