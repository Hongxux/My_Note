she- 表面现象：
	- 任务执行时间显著延长
	- 吞吐量急剧下降
	- 甚至出现任务失败

- 监控工具的现象：
	- Old区使用率持续高位（如超过80%）
	- Full GC次数（FGC列）快速增加
- 分析指标：锁定Full GC的严重程度和潜在诱因
	```
	日志中记录的一次full gc
	2025-07-25T10:23:45.123+0800: 3.421: [Full GC (Allocation Failure) ... [Eden: 0.0B(100.0MB)->0.0B(100.0MB) Survivors: 0.0B->0.0B Heap: 2.1GB(4.0GB)->1.9GB(4.0GB)] [Times: user=4.32 sys=0.21, real=1.05 secs]
	```
	- 日志含义：由于分配失败（Allocation Failure）触发Full GC，堆内存从2.1GB回收至1.9GB，但实际暂停时间（real）达1.05秒，且回收效率不高（仅释放200MB）
	- 关注维度：
		- 触发频率：通过日志时间戳计算Full GC间隔，若短于5分钟则属异常
		- 暂停时长：实时应用要求单次Full GC不超过200毫秒，批处理场景也应控制在1秒内
		- 内存回收效率：Old区内存回收率低于60%可能存在内存泄漏或对象晋升过快
  - 原因以及表现：
	- 内存泄露，对象无法回收:
		- 具体日志特征为：在GC日志中表现为老年代使用量持续上升，即使经过Full GC也无法有效回收
			- 多次Full GC后，老年代占用基线不断上移
			- GC前后内存差值逐渐缩小（回收效率降低）
			- 伴随"Allocation Failure"或"Metadata GC Threshold"触发原因
		- 确诊方式：
			- 添加-XX:+HeapDumpAfterFullGC参数，在Full GC后生成堆转储文件。
			- 结合MAT（Memory Analyzer Tool）分析支配树，定位持有大量对象的根节点。日志中的GC原因（如"Allocation Failure"）往往能提示泄漏发生的场景。
	- 配置失当模式：堆内存和新生代老年代区域大小设置不合理
		- Young区过小导致频繁Young GC，日志中短时间间隔出现大量"GC pause (young)"记录
		-  Heap总体过小引发频繁Full GC，日志中频繁出现"Allocation Failure"触发原因
		-  G1GC的Region大小设置不当，导致大量Humongous分配（日志中可见"Humongous allocation"记录）
	- 系统资源（CPU、内存、IO）紧张：获取了大量不必要数据，浪费堆内存
		- 具体日志特征为：出现阶段性变化
			- GC线程耗时异常增加（日志中暂停时间波动剧烈）
			- 并发标记阶段耗时显著延长（G1GC的"Concurrent Cycle"相关日志）
			- 伴随"System.gc()"调用记录（可能由外部监控工具触发）
		 - 确诊方式：将GC日志与应用日志、系统监控数据（CPU、内存使用率）进行时间戳对齐。例如，发现每次Full GC前都出现磁盘IO峰值，可能提示存在大量对象序列化操作；若GC频率与特定业务操作时间点高度重合，则需检查相关代码逻辑。

- 自己代码的问题：代码调优
	- [[内存泄漏]]
	- 取了大量不必要数据，[[避免浪费堆内存]]
- JVM调优
	- 新生代调优：优化空间大，优先调优
		- 新生代特点：
			- new操作的内存分配快：
				- 内存分配存在并发问题
				- 解决措施：TLAB（thread-local allocation buffer）
					- 分配内存的时候，会先去看看每个线程的TLAB区域是否有空闲内存
			- minor GC时间短，复制阶段相对标记阶段用时更长
				- 死亡对象的回收代价为零：采用复制回收算法
				- 大部分对象用过即死，大部分都不会被回收，少部分存活
		- 调优目标：尽可能让对象在新生代就被回收，避免或减少对象不必要的晋升到老年代
			- 幸存区够大，避免只是当前活跃的对象晋升到老年代，让其能在minor gc中就被回收
			- 晋升条件适当降低，让应该晋升的对象尽早晋升
			- 新生代够大，避免频繁触发minor gc
		- 调优方式：
			1. 设置新生代大小：
				- 固定大小：使用 `-Xmn1024m`为新生代分配固定内存（如1GB）。
					- 优先级最高，设定后 `NewRatio`将失效
					- 理想容纳：`并发量*一次请求和响应过程产生的对象占用的内存`的数据
						- 因为每次请求产生的大部分对象都会被回收
						- 能较少地触发或者不触发minor gc
			    - 比例设置：使用 `-XX:NewRatio=3`设定老年代与新生代的比例为3:1（即新生代占堆的1/4）。适用于堆内存固定且对停顿不敏感的场景
				    - 配置方式：最好占比25％到50％
						- 太小会导致MinorGC频繁
						- 太大
							- 会导致老年代可用空间少，可能触发full GC
							- 会导致新生代对象过多，minor GC时间增加：吞吐量和新生代空间大小的关系先升后降
			2. 调整Eden与Survivor区比例
				- 参数 `-XX:SurvivorRatio=8`表示Eden区与一个Survivor区的比例是8:1（例如，新生代1G，则Eden为819MB，每个Survivor为102MB）
				- 调优目标：能容纳当前活跃对象和需要晋升对象
					- 幸存区对象可以分为两类：
						- 当前活跃对象：过会就要被回收，只是目前还在被适用，于是留在幸存区
						- 需要晋升对象：将来会晋升到老年代，只是目前年龄不够，所以才留在幸存区
					- 幸存区过小：JVM动态调整晋升阈值，导致当前活跃对象对象提前晋升到老年代
						- 本来下次minor gc就能将其回收，现在需要下次 full gc才能将其回收
						- 而且增加老年代对象，有导致full gc的风险
			3. 控制对象晋升老年代的条件：当前活跃对象下次就被回收了，需要晋升对象能早日晋升
				- 最大晋升年龄：`-XX:MaxTenuringThreshold=15`（默认15，CMS下默认为6）。**可适当降低**（如设为5-8），让中等寿命对象尽早晋升，减轻Survivor区的复制开销
				- 动态年龄判定：重要机制。若Survivor区中**相同年龄所有对象的大小总和** > 一个Survivor区空间的50%，则年龄大于等于该年龄的对象将直接晋升老年代，无需达到 `MaxTenuringThreshold`因此，保证Survivor区有充足空间至关重要。
	- 老年代调优：
		- 提升老年代空间，避免并发失败
		- CMS收集器调优：
		    - 调整触发阈值：使用`-XX:CMSInitiatingOccupancyFraction`设置老年代空间使用率阈值（如70%），当使用率达到此阈值时开始并发GC周期，为“浮动垃圾”预留空间
		    - 避免并发模式失败：若并发GC期间老年代被填满，会触发STW的Serial Old GC。确保`CMSInitiatingOccupancyFraction`设置留有足够空间
		    - 控制内存碎片：使用`-XX:+UseCMSCompactAtFullCollection`（Full GC后整理碎片）和`-XX:CMSFullGCsBeforeCompaction`（设置经过N次Full GC后整理一次）
		- G1收集器考量：
		    - 若应用堆内存较大（如>4GB）且追求低延迟，可考虑切换到G1收集器`-XX:+UseG1GC`。
		    - G1的关键调优参数包括`-XX:MaxGCPauseMillis`（设定最大停顿时间目标）和`-XX:InitiatingHeapOccupancyPercent`（触发并发周期的堆使用率阈值）。G1会尝试在设定的目标时间内回收尽可能多的垃圾区域。