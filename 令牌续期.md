---
aliases:
  - 双令牌续期机制
---
 - 需求背景：
	 - 用户体验：操作被突然中断，需频繁重新登录，体验差
	 - 安全性：
		 - 令牌有效期过长则被盗用风险高；
		 - 过短则安全性与便捷性失衡。
 - 解决措施：双令牌续期机制：用短期令牌保障安全，用长期令牌维持会话
	 - **短期有效的Access Token**：即使不慎泄露，攻击者能使用它的时间窗口也非常短，就像一张一次性且很快过期的门禁卡。
	 - **长期有效的Refresh Token**：它不直接访问资源，只负责“续费”门禁卡，且本身被严格保护，从而保证了合法用户无需频繁输入密码。
 - 好处：安全性
	- AT被盗，因其有效期极短（如15分钟），攻击者可用的时间窗口很小
	- RT的泄露可被轮换机制即时检测和遏制

- 存储设置：
	- Access Token：建议存放在前端内存或临时存储中
		- 降低被持久化窃取的风险。
	- Refresh Token：
		- 存储方式一：使用 **`HttpOnly`、`Secure`属性的Cookie**进行存储
			- 有效防止跨站脚本（XSS）攻击窃取该令牌
		- 存储方式二：服务端存储
			- 最安全：令牌完全不暴露给客户端，从根源上杜绝前端风险
 - 时长设置：
	 - Access Token：时间越短，令牌泄露后造成的危害越小
		 - 对于普通应用，1-2小时是平衡点；
		 - 对安全性要求极高的应用（如金融），可缩短至15分钟或更短
	 - Refresh Token：时长应覆盖用户的“活跃会话期”。
		 - 推荐时长：7天 ~ 30天
		 - 采用**滑动过期**策略：每次成功使用Refresh Token后，其有效期会从当前时间点重新计算
 - [[刷新令牌轮换]]

 - 工作流程：![[Pasted image 20251214193805.png]]
	 1. **正常请求**：前端在请求API时，在HTTP头部（如 `Authorization: Bearer <access_token>`）携带Access Token
	2. **检测过期**：当服务端返回`401 Unauthorized`状态码时，前端拦截器会捕获此错误，判断为Access Token已过期
	3. **静默刷新**：前端自动发起一个刷新请求，将Refresh Token发送到服务端的专用刷新接口（如 `/auth/refresh`）
	4. **颁发新令牌**：
		- 服务端验证Refresh Token有效后，生成一套新的双令牌返回给前端。前端更新本地存储的Token，并自动重试刚才失败的请求，整个过程对用户无感知
		- **RT 也过期了**：如果 RT 也已过期，续期请求会失败。此时应清除客户端的登录状态，**引导用户重新登录**。这是正常的安全流程