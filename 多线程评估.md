
1. 可行性评估与设计
	- 需求背景：不是所有程序都适合或能从多线程中获益。盲目改造可能增加复杂度却不见性能提升。
		- 引入多线程带来上下文切换的开销
	1. 评估多线程必要性：
		- 【必要】
			- 为了降低延迟（让程序响应更快）
			- 提高**吞吐量**（单位时间处理更多任务）。
		- 【不必要】
			- 程序本身执行很快
			- 没有可并行执行的任务单元
	2. 识别可并行任务：
		- 【可并行】互不依赖、可以同时执行的部分。
		- 常见情况包括
		    - 数据并行：将大数据集拆分，每个线程处理一部分。
		    - 任务并行：程序中存在不同类型的、可同时执行的任务。
	3. 选择并发模型：
	    - 基于线程库的直接管理：如Java的 `java.util.concurrent`包，控制力强，相对底层。
	    - 高级API/框架：如OpenMP，通过编译指导语句实现并行化，能简化代码 。
2. 识别风险与制定策略
	- 【风险一】共享变量
		- [[变量的线程安全评估]]
		- 解决措施：实现同步策略
		    - 互斥锁：保证同一时间只有一个线程能进入临界区。这是最常用的同步原语。
		    - 读写锁：适用于**读多写少**的场景，允许多个读线程并发，提高性能 。
		    - 原子操作：对于简单的计数器等，使用原子变量无锁操作，效率更高。
	- 【风险二】活跃性问题
		- **死锁**：
		- 活锁
		- 饥饿
    
3. 实施、测试与调优
	- **逐步重构与同步**：
	    - 优先保证**正确性**，再考虑**性能**。初始可使用保守的同步策略。
	    - 利用线程安全的数据结构简化开发。
	- **全面的测试与调试**：
	    - **代码审查**：重点关注共享数据的访问、锁的正确使用及异常处理 。
	    - **压力测试**：高并发下长时间运行，暴露不稳定的竞态条件。
	    - **使用专业工具**：如ThreadSanitizer，帮助检测数据竞争和死锁 。
	- **性能调优**：
	    - **设置合理线程数**：参考阿姆达尔定律，线程数并非越多越好 。**CPU密集型**任务线程数可与CPU核心数相近；**I/O密集型**任务可适当增多。
	    - **减少锁竞争**：优化临界区，使其**尽可能短小**。考虑使用**无锁编程**（高级技巧，需谨慎）。
	    - **警惕伪共享**：当多个线程频繁修改位于同一缓存行的不同变量时，会引发缓存行无效，导致性能下降。可通过**字节填充**将热点变量隔离到不同缓存行 。
