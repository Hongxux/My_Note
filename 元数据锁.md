---
aliases:
  - MDL
---
- 需求背景：
	- 在可重复读（RR）隔离级别下，一个事务执行过程中，如果另一个会话修改了表结构（如新增列），可能导致同一事务内多次查询结果集不一致，破坏可重复读的隔离性
	- 在主从复制环境中，如果DDL（如`DROP TABLE`）在DML（如`INSERT`）所在事务提交前先执行并记录到二进制日志（binlog），可能导致从库先执行DDL删除表，再执行DML时因表不存在而复制中断
	- 需要一种机制来协调不同会话对同一张表元数据的并发访问（如多个查询并发读元数据，或查询与修改表结构并发），避免出现脏读、丢失更新等问题
- 解决措施：元数据锁
	- 在事务持续期间持有MDL，防止表结构被修改，确保事务内多次读取时表结构一致
	- 通过事务级别的MDL，确保binlog中DML和DDL的记录顺序与主库上的操作逻辑顺序一致
	- 为元数据操作提供细粒度的锁机制，定义不同操作所需的锁类型（如共享读锁、排他写锁）及其兼容性
- 分类：
	- 共享读锁（SR）和共享写锁（SW）之间是兼容的
		- 这意味着一个事务在读取数据的同时，允许另一个事务修改数据（修改不同行），这也是MySQL实现高并发的基础
	- 排他锁（X）​ 与几乎所有其他锁都不兼容。这是因为DDL操作（如修改表结构）需要绝对独占的访问权，以确保元数据的一致性
- 特点：
	- ​**自动加锁**​：MDL 的加锁和释放过程完全由数据库系统自动控制，开发者无需（也无法）手动干预。只要执行访问表的 SQL 语句，系统就会自动加上相应的 MDL。![[Pasted image 20251102090920.png]]
- 问题：导致MDL锁等待
	- 场景：一个**长事务**（例如，一个未提交的查询或更新事务）持有了某表的MDL读锁。此时，另一个会话尝试执行DDL（如 `ALTER TABLE`）需要获取该表的MDL写锁。由于MDL读锁与写锁互斥，DDL操作会被阻塞，进入等待状态。更严重的是，这个DDL操作排队后，**后续所有新的、针对该表的DML操作**（因为它们需要获取MDL读锁）也会被这个等待中的DDL写锁阻塞，从而可能引起数据库连接数飙升，影响业务
	- 解决措施：当遇到这类等待时，可以`SELECT * FROM performance_schema.metadata_locks`来查看MDL的持有和等待情况，定位是哪个事务持有了锁，从而采取提交事务或终止会话等措施
