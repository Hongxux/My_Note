# 加工数据包

### 网卡的组成：
![[Pasted image 20250917092926.png]]
注：ROM中存放的MAC地址是**全世界唯一**的MAC地址，这是在生产网卡时写入的，将这个值读出之后就可以对MAC模块进行设置，MAC模块就知 道**自己对应的MAC地址**了。


### 网卡完成的对数据包处理：

#### 加工成果：
![[Pasted image 20250917093307.png]]
#### 加工流程：
**这由网卡上的MAC模块和PHY（物理层装置）模块[[网卡加工数据包|分工协作]]完成：。​**


# 接受返回包：
## 如何根据电信号读取信息
![[Pasted image 20250917094158.png]]

- ​**电信号（数据）​**​：就像一长串摩斯密码（···---···），它包含了信息，但只是一连串持续变化的电压。
    
- ​**时钟信号（时钟）​**​：就像一个精准的节拍器，以固定的频率发出“滴答”声。每一个“滴答”声，就指示了一个读取摩斯密码的**时刻**。
    

没有节拍器，你很难保证每个信号点都读得准，速度一快就容易出错。节拍器确保了读取的**节奏和同步**。

---

### 工作原理：同步与采样

在数字电路（如网卡、内存、CPU总线）中，时钟信号和数据电信号是两路不同的物理信号。它们协同工作的流程如下图所示：

```
flowchart TD
A["发送方: <br>准备要发送的数据 (0/1序列)"]
B["接收方: <br>严阵以待, 等待时钟信号"]
C["时钟信号上升沿到来<br>(“滴答”声)"]
D["接收方立即对数据线进行采样<br>并锁存当前电平状态"]
E["将采样到的电平<br>判断为0或1"]
F["完成1个比特的读取<br>等待下一个时钟周期"]

A --> B
B --> C
C --> D
D --> E
E --> F
F -->|循环| B
```

具体来说，接收端芯片内部的核心部件是一个叫做 ​**D触发器（D Flip-Flop）​**​ 的电路。当时钟信号从低电平跳变到高电平（这个瞬间称为“**上升沿**”）的瞬间，D触发器会瞬间读取数据信号线上的电平值，并将其锁定为自己的输出值，直到下一个时钟上升沿到来。

这个“上升沿”的时刻，就是图里的“**采样点**”。在这个点附近，数据信号必须保持稳定。

### 关键概念：建立时间和保持时间

要保证读取正确，数据信号必须在时钟沿前后保持稳定一段时间，这引入了两个至关重要的时序参数：

- ​**建立时间（Setup Time）​**​：在时钟上升沿**到来之前**，数据信号必须已经保持稳定的最短时间。
    
- ​**保持时间（Hold Time）​**​：在时钟上升沿**过去之后**，数据信号必须继续保持稳定的最短时间。
    

时钟和数据信号之间的理想时序关系如下图所示，它确保了采样窗口的稳定性和可靠性：

```
xychart-beta
    title "时钟与数据信号时序关系图"
    x-axis "时间" --> "采样点"
    y-axis "电平" [0 --> 1]
    line [0.3, 0.3, 0.3, 0.9, 0.9, 0.9, 0.1, 0.1, 0.1]
    line [0.1, 0.1, 0.9, 0.9, 0.1, 0.1, 0.9, 0.9, 0.1]
    line [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0]
```

_注：上图示意了时钟上升沿如何锁定数据值，以及建立时间和保持时间窗口的概念。_

如果数据信号在建立时间或保持时间窗口内发生了跳变（如图中红色闪电标示的区域），结果就是**不确定的**，可能读成0，也可能读成1，这就会导致**数据错误**。高速设计中的时序分析，核心就是为了保证满足所有信号的建立时间和保持时间。

### 实际应用：以太网中的时钟恢复

在像网线这样的串行通信中，并不会单独拉一根线来传输时钟信号（那会大大增加成本）。相反，它采用了一种更巧妙的方法：​**时钟恢复**。

- ​**发送方**​：在发送数据电信号时，会采用一种特殊的编码方式（如曼彻斯特编码或4B/5B编码）。这种编码方式确保数据流中**有足够多的电平跳变**。
    
- ​**接收方**​：有一个非常精密的电路——**PLL（锁相环）​**。PLL电路会监测输入数据信号的跳变边沿，并以此为依据，​**在本地生成一个与发送方时钟频率和相位完全同步的时钟信号**。
    
- ​**然后**​：就用这个本地恢复出的时钟信号，按照上述的采样原理，去读取输入的数据信号。
    

这样就实现了“一根线”传输数据，同时又能精准同步。

### 总结

结合时钟信号读取电信号的本质是：

1. ​**同步**​：时钟信号提供了一个**统一的时间基准**，告诉接收端“何时该读取”。
    
2. ​**采样**​：在时钟信号特定的时刻（通常是上升沿），接收电路对数据信号的电平进行**采样和锁存**，将其判断为0或1。
    
3. ​**时序要求**​：为了保证采样正确，数据信号在时钟沿前后必须稳定一段时间（建立时间和保持时间）。
    
4. ​**高级形式**​：在高速串行通信中，接收方通过**PLL电路**从数据流本身恢复出时钟，实现自同步。
    

这种机制是数字世界可靠通信的基础，确保了数十亿个晶体管能够在GHz的频率下协同工作而不出错。
## 具体流程：

整个过程可以概括为：​**信号接收 -> 错误校验 -> 中断通知 -> 协议栈处理 -> 交付应用程序**。

下图清晰地展示了接收返回包时，网卡、驱动与协议栈如何协同工作的完整流程：

```
flowchart TD
A["网线中的模拟电信号"] --> B[PHY模块]
B --> C["数模转换与信号解读<br>（去除报头/SFD）"]
C --> D["MAC模块"]
D --> E{"FCS校验<br>检查数据完整性"}
E -- 校验成功 --> F[将有效帧存入缓冲区]
E -- 校验失败 --> G[丢弃损坏的包]
F --> H[触发中断信号]
H --> I[CPU暂停当前任务]
I --> J[执行网卡驱动程序中断处理程序]
J --> K["协议栈处理<br>（TCP/IP模块）"]
K --> L["协议栈递交数据至<br>目标应用程序"]
```

---

### 详细工作流程解析（依据文档第2.5.10节等）

#### 1. ​**PHY模块：从信号到比特流**​

- ​**信号接收**​：网线的接口（RJ-45）接收到返回包传来的**模拟电信号**​（或光信号）。
    
- ​**信号转换**​：网卡的PHY（MAU）模块首先工作，将这些模拟信号进行放大、整形，并**转换回数字比特流**​（0和1的序列）。这个过程是发送时“数模转换”的逆过程。
    
- ​**时钟同步与帧定界**​：PHY模块利用信号前端的**报头（Preamble）​**​ 来进行时钟同步，并通过**起始帧分界符（SFD）​**​ 来精确锁定帧的起始位置。之后，PHY会将报头和SFD剥离，将后续的数字比特流传递给上层的MAC模块。
    

#### 2. ​**MAC模块：错误检查与地址过滤**​

- ​**接收帧**​：MAC模块接收来自PHY的数字比特流。此时的数据结构是一个完整的以太网帧。
    
- ​**FCS错误校验**​：MAC模块读取帧末尾的**帧校验序列（FCS）​**，并使用相同的算法对帧主体（从目标MAC地址到数据末端）重新计算一遍。
    
    - ​**如果校验失败**​：说明数据在传输过程中因噪声干扰而出现了错误。MAC模块会**直接丢弃这个包**，不做任何处理。TCP协议等上层协议之后会因为超时而重传该包。
        
    - ​**如果校验成功**​：则继续后续流程。
        
    
- ​**MAC地址过滤**​：MAC模块检查帧头部中的**目标MAC地址**。
    
    - ​**如果地址不匹配**​：如果该地址不是网卡自己的MAC地址，也不是它应该接收的广播/组播地址，则MAC模块会**丢弃此包**。这是为了避免让协议栈处理无关的数据，节省CPU资源。
        
    - ​**如果地址匹配**​：MAC模块会将这个正确的帧**存放到网卡自身的接收缓冲区**中。
        
    

#### 3. ​**中断请求（IRQ）：通知操作系统**​

- ​**发起中断**​：当网卡将完整的帧成功存入接收缓冲区后，它会通过计算机的**中断信号线**向CPU发送一个**中断请求**。
    
- ​**CPU响应**​：CPU接收到中断信号后，会暂时中止当前正在执行的任务，保存现场，并转而执行与该中断号相关联的**中断处理程序**——也就是**网卡驱动程序**中的一段代码。
    [[CPU轮询VSCPU终端|为什么采用中断进行数据交换]]

#### 4. ​**网卡驱动程序：协议栈的桥梁**​

- ​**中断处理程序**​：驱动程序的中断处理程序被调用后，会知道网卡已经成功接收了一个包。
    
- ​**分配SKB**​：驱动程序会在系统内存中分配一个数据结构（在Linux中称为 `sk_buff`），以便存放网络包。
    
- ​**从网卡拷贝数据**​：驱动程序指示网卡将接收缓冲区中的数据（完整的以太网帧）​**通过DMA（直接内存访问）或IO端口读取的方式，拷贝到刚刚分配的系统内存中**。
    
- ​**识别协议**​：驱动程序查看帧头中的**以太类型字段**​（EtherType，如 `0x0800`代表IPv4，`0x0806`代表ARP），从而判断应该将这个包交给协议栈中的哪个模块（如IP模块）。
    
- ​**交付协议栈**​：驱动程序最终将这个存放在系统内存中的包**交付给上层的网络协议栈（通常是IP模块）​**进行处理。
    

#### 5. ​**协议栈：层层解包与最终交付**​

协议栈接收到的已经是一个去除了MAC头部和FCS的IP包。

- ​**IP模块处理**​：
    
    - 检查IP头部格式和校验和。
        
    - 核对**目标IP地址**是否是本机的IP地址。
        
    - 如果包是**分片**的，会进行**分片重组**，等待所有分片到达后重组为原始IP包。
        
    - 根据IP头部的**协议号字段**​（Protocol，如 `6`代表TCP，`17`代表UDP），将重组后的数据交付给正确的上层协议（如TCP模块）。
        
    
- ​**TCP模块处理**​：
    
    - 检查TCP头部的**序号**和**ACK号**。
        
    - 根据TCP头部中的**目标端口号**，将数据放入对应应用程序的**接收缓冲区**​（套接字）。
        
    - ​**发送ACK确认**​：如果该包是顺序收到的数据，TCP模块会生成一个**TCP ACK确认包**，并通过相同的路径发送回去，告知发送方“数据已成功接收”。
        
    
- ​**唤醒应用程序**​：最终，当应用程序（如浏览器）调用 `read`等系统调用试图读取数据时，协议栈会将数据从套接字缓冲区中复制到应用程序的内存空间，这样应用程序就收到了Web服务器返回的响应消息。
    

---

### 总结

接收返回包是一个由硬件驱动、高度协同的复杂过程：

1. ​**物理层**​（PHY）：负责信号的接收和转换。
    
2. ​**数据链路层**​（MAC）：负责错误校验和地址过滤，确保只有发给本机的有效数据才会被上报。
    
3. ​**中断机制**​：是硬件通知CPU有数据到达的最高效方式，避免了CPU轮询的低效。
    
4. ​**驱动程序**​：负责在硬件和操作系统之间搬运数据，并识别协议类型。
    
5. ​**网络协议栈**​（IP/TCP）：负责解包、重组、确认，并将数据最终交付给正确的应用程序。
    

整个过程确保了数据能够准确、高效地从网络线缆最终送达等待它的应用程序手中。