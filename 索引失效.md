- 索引失效的核心本质：
	1. **破坏 B+Tree 有序性**：索引的核心价值依赖 B+Tree 的有序性实现二分查找快速过滤，若查询条件或操作破坏该有序性，索引将无法发挥作用，退化为全表扫描。
	2. **MySQL 优化器成本判断**：优化器会对比「使用索引的开销」与「全表扫描的开销」，若判定索引收益更低（如小表、低区分度字段），会主动放弃使用索引。
- 判断方式：通过 `EXPLAIN` 命令验证索引是否失效
	- 若 `type` 字段为 `ALL`（全表扫描），大概率索引失效；
	- 若 `key` 字段为 `NULL`，表示未使用任何索引；
	- 若 `Extra` 字段显示 `Using filesort`（排序失效）/ `Using temporary`（分组失效），表示索引未支撑排序 / 分组功能。

---
常见失效场景
1. 在 `WHERE`子句中，如果对索引列进行运算、使用函数或进行表达式计算，MySQL 将无法使用该列的索引。
	- 原因：索引存储的是列的原始值。对列进行计算或函数处理后，数据库无法直接与索引中的值进行匹配，只能进行全表扫描
	- 常见失效场景：
		- 跳过最左字段：完全失效（不使用索引）
		- 范围查询后字段用于过滤：部分失效，范围查询后的无法用于过滤
		- 语法顺序颠倒（`AND`连接）：不失效（优化器自动调整顺序）
	- 解决措施：
		1. **核心方案：调整查询条件 / 联合索引顺序**
		    - **查询时候**，避免跳过最左字段：查询时尽量携带联合索引的最左高频字段（如上述失效场景，补充`user_id`条件即可）；
		    - **建立联合索引的时候**：优化联合索引顺序：遵循「等值查询字段 > 范围查询字段 > 过滤 / 返回字段」，将范围查询字段后置，避免后续字段过滤失效（如将索引调整为`(user_id, pay_status, create_time)`，`pay_status`等值查询在前，`create_time`范围查询在后）；
		2. **补充方案：新增针对性索引**
			- 若无法携带最左字段（如部分查询仅需`pay_status`），单独为`pay_status`建立单列索引（需满足`pay_status`区分度达标 + 查询频率高），则会使用交叉索引；
		3. **特殊说明：范围查询后字段可用于排序**
2. 索引字段被直接操作（函数 / 运算 / 隐式转换）
	- 原因：对索引字段直接进行「函数调用」「算术运算」「隐式类型转换」，会破坏 B+Tree 的有序性，导致 MySQL 无法通过二分查找定位数据，只能全表扫描。
	- 常见失效场景
		- 函数操作索引字段：函数处理后字段失去有序性
		- 算术运算操作索引字段：运算后字段值与索引存储值不一致
		- 隐式类型转换（字符串 + 数字）：字符串转数字，破坏有序性
	- 解决措施：
		1. **核心方案：避免索引字段直接操作，将操作转移到查询值上**
			- 算术运算优化：将 `age + 1 = 30` 改为 `age = 29`（操作查询值，不操作索引字段）；
			- 函数操作优化：尽量用**前缀索引**替代**字段截取函数**
				- 示例：如`SUBSTR(phone,1,3)='138'`，可建立`phone`前缀索引`idx_phone_prefix11`，直接查询`phone LIKE '138%'`，利用前缀索引过滤
		2. **补充方案：统一字段类型，避免隐式转换**
			- 字符串字段查询时，传入字符串类型值
			- 表设计时，尽量避免「字符串存储数字」的场景，通过字段轻量化优化（如`VARCHAR`→`INT`）从根源规避；
		3. **替代方案：使用函数索引**（MySQL 8.0 + 支持）
			- 若业务无法避免函数操作（如`DATE(create_time) = '2024-01-01'`），可建立函数索引：`CREATE INDEX idx_create_time_date ON order((DATE(create_time)))`，直接支撑函数查询条件。

 3. 如果 `OR`连接的多个条件中，有一个条件涉及的列没有索引，那么整个查询可能无法使用索引。
	- 解决措施：
		- 若非索引字段适合建立索引，则建立索引
		- **用 `UNION ALL` 替代 `OR`**
 4. 使用**前导**通配符的 `LIKE`查询：`LIKE`查询只有在模式不以通配符开头时才能使用索引。
	 - 原因:因为`%`开头无法利用 B+Tree 的前缀有序性进行二分查找；而`LIKE 'xxx%'`（右模糊）可正常使用索引（前缀匹配）。
	- 解决措施：
		- 小表直接进行全表烧苗，收益更高
		- 大表
			- 建立全文索引
			- 业务层缓存 / 预处理数据
 5. 使用 `!=`或 `NOT`操作符
	- 解决措施：
		- 用 `LEFT JOIN` 替代
6. `IS NULL`和 `IS NOT NULL`查询
		```
		-- ❌ 可能失效：取决于数据分布
		SELECT * FROM user WHERE email IS NULL;
		SELECT * FROM user WHERE phone IS NOT NULL;
		
		-- ✅ 解决方案：确保列定义为 NOT NULL 或使用覆盖索引
		ALTER TABLE user MODIFY email VARCHAR(100) NOT NULL DEFAULT '';
		```
 7. 数据区分度太低或者范围查询条件过宽
	- 原因：
		- 当索引列的值重复率很高（区分度低）时，MySQL 优化器可能认为全表扫描比使用索引更高效。
		- 若范围查询条件过宽（如`create_time < '2025-01-01'`，覆盖 90% 以上数据），MySQL 优化器会判定「使用索引的开销（遍历索引 + 回表）＞全表扫描开销」，主动放弃索引。
