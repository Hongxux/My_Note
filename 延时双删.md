- 需求背景：
	- 如果采取：先删缓存再更新数据库，窗口期可能有线程回填旧数据
		- 线程A删除缓存后，在更新数据库完成前，线程B来读取数据。由于缓存为空，B会去数据库读取**旧值**并回填到缓存。随后A才更新数据库成功。导致缓存中一直是**旧数据**，直到下次缓存过期或更新
	- 如果采取：先更新数据库再删缓存，窗口期可能有线程读到旧数据
		- 线程A更新数据库后，在删除缓存前，线程B来读取数据，会直接命中缓存中的**旧数据**。随后A才删除缓存。虽然之后读取能拿到新数据，但**在极短时间窗口内**，用户可能看到旧数据
- 解决策略：先删除缓存，再更新数据库，延迟一段时间后再次删除缓存
	- 第一次删除是为了在更新数据库时清除旧数据。
	- 中间的延迟是为了让可能正在读旧数据并回填缓存的并发请求（如线程B）完成其操作。
	- 第二次删除则是为了清除这些可能被回填的脏数据。
- 使用场景：
	- 延时双删策略更适用于**读多写少**、并且可以接受**短暂数据延迟**的业务场景。
	- 对于**写操作非常频繁**（如秒杀系统）或要求**强一致性**的业务（如金融交易余额），则不太适合
- 问题：有效性严重依赖于对延迟时间的精确预估
	- 时间设短了，可能旧数据还没回填完，第二次删除就执行了，无法清除脏数据；
	- 时间设长了，又会不必要地增加系统响应时间，影响用户体验