

> ​**游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。​**​

您可以将其理解为一个**指向查询结果集的指针**。它允许我们在存储过程或函数中，像编程语言处理数组或集合一样，​**逐行地**遍历和操作查询返回的数据。

### 游标使用的四个核心步骤

图中所列的四个步骤，是使用游标必须遵循的、不可颠倒的固定流程。

#### 1. 声明游标

​**语法**​：

```
DECLARE 游标名称 CURSOR FOR 查询语句；
```

​**作用**​：定义一个游标，并将其与一个 `SELECT`查询语句绑定。此时游标尚未获取任何数据。

​**示例**​：

```
-- 声明一个游标，用于获取所有活跃用户的信息
DECLARE user_cursor CURSOR FOR 
SELECT id, username, email FROM users WHERE status = 'active';
```

#### 2. 打开游标

​**语法**​：

```
OPEN 游标名称；
```

​**作用**​：执行游标所关联的 `SELECT`查询语句，并将查询结果集加载到内存中，使游标处于可操作状态。此时游标指向结果集的第一条记录之前。

#### 3. 获取游标记录

​**语法**​：

```
FETCH 游标名称 INTO 变量1 [, 变量2, ...];
```

​**作用**​：这是最核心的一步。它将游标**当前指向的记录**的各个字段值，依次取出并存入指定的变量中。每执行一次 `FETCH`，游标会自动向后移动一行。

​**示例**​：

```
-- 假设已声明变量 v_id, v_name, v_email
FETCH user_cursor INTO v_id, v_name, v_email;
-- 执行后，v_id, v_name, v_email 变量中就是当前行的数据
```

#### 4. 关闭游标

​**语法**​：

```
CLOSE 游标名称；
```

​**作用**​：​**释放**游标占用的内存和资源。游标使用完毕后必须关闭，这是一个良好的编程习惯，否则可能耗尽服务器资源。

### 完整的工作流程与示例

游标几乎总是与**循环语句**和**异常处理**配合使用。以下是结合所有步骤的一个典型模板：

```
DELIMITER $$
CREATE PROCEDURE ProcessUserData()
BEGIN
    -- 1. 声明变量（用于存放FETCH出来的数据）
    DECLARE v_id INT;
    DECLARE v_name VARCHAR(100);
    DECLARE v_email VARCHAR(100);
    -- 声明一个标志变量，用于判断循环是否结束
    DECLARE done INT DEFAULT FALSE;

    -- 2. 声明游标
    DECLARE user_cursor CURSOR FOR 
    SELECT id, username, email FROM users WHERE status = 'active';

    -- 3. 声明异常处理：当FETCH不到数据时，将done设为TRUE
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 4. 打开游标
    OPEN user_cursor;

    -- 5. 开始循环遍历
    read_loop: LOOP
        -- 获取一行数据
        FETCH user_cursor INTO v_id, v_name, v_email;

        -- 检查是否已经遍历完所有数据
        IF done THEN
            LEAVE read_loop; -- 如果完成，则退出循环
        END IF;

        -- 这里是对每一行数据的业务处理逻辑
        -- 例如：插入到另一张表、更新某些字段、计算等
        INSERT INTO user_audit (user_id, action) VALUES (v_id, 'processed');

    END LOOP;

    -- 6. 关闭游标
    CLOSE user_cursor;
END
$$
DELIMITER ;
```

### [[条件处理程序]]
