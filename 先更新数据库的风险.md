**即使出现了不一致，这个不一致的时间窗口也极短，且出现的条件更苛刻。**
讨论的背景：[[旁路缓存]]
### 解释：
#### 1. 什么是[[缓存一致性]]：
#### 2.先更新数据库的风险
在示例中，最终数据库的值为20（正确的新值），而缓存为10（错误的旧值）
![[Pasted image 20251118124555.png]]
**发生的条件：**
- **条件1：读请求发生时，缓存恰好失效。** 这是步骤4发生的前提。
	- 失效：比如缓存刚好自然过期，或者被其他操作删除。
	- 如果缓存一直有效，读请求会直接命中缓存，不会去触发加载数据库数据。也就不会去更新缓存（发生步骤4）。
    
- **条件2：一个写请求和一个读请求高并发地针对同一个数据。**
    
- **条件3：** 在这个微秒级的==时间窗口==时间窗口内，正好有一个读请求到来并完成了读库、但还未回填缓存。
	- 时间窗口：指的是**完成“更新数据库”操作后，到“删除缓存”操作前**的这段极小的时间间隔
		- 对比：**先删缓存，再更新数据库**的时间窗口在于**数据库更新操作的耗时**（可能较长）
### 兜底方案：
#### TTL
即使发生这种小概率事件，我们还可以通过为缓存设置一个**合理的过期时间（TTL）** 来兜底。过期后缓存自动删除，下次读取就会得到正确数据。
#### **分布式锁**：
在更新和读取同一条数据时，先获取该数据对应的分布式锁。这样可以将并行操作强制串行化，彻底解决并发问题，但会牺牲一些性能。
#### **延迟双删**

### **结论**：
在分布式系统中，没有完美的、100%强一致的缓存方案。工程上的选择往往是权衡利弊。“先更新数据库，再删除缓存”这种策略，用一个**概率极低、影响窗口极短**的不一致风险，换取了**避免大量无效更新、简化实现逻辑、降低并发冲突**的巨大好处，因此成为业界最主流、最推荐的缓存更新策略。