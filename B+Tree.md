**虽然二叉树和红黑树是经典的数据结构，但由于其“深度”问题在磁盘I/O场景下会成为性能瓶颈，因此不适合直接用作数据库的索引结构。​**​ 而B+Tree通过其“多路、矮胖”的特性，完美地解决了这个问题，成为了数据库索引的实际标准。

![[Pasted image 20251029191802.png]]
![[Pasted image 20251029191813.png]]
![[Pasted image 20251029192056.png]]
![[Pasted image 20251029192306.png]]



|核心挑战|二叉树/平衡二叉树（如AVL、红黑树）的不足|B+树的解决方案|
|---|---|---|
|**磁盘I/O效率**​|树的高度较高，**磁盘I/O次数近似为O(log₂n)**。每次访问一个节点都可能需要一次磁盘I/O，当数据量大时，随机I/O次数多，效率低下。|**降低树高**：通过**多路平衡树**结构，一个节点可包含大量键值，极大降低树的高度，从而**显著减少I/O次数**。|
|**利用磁盘预读**​|节点大小通常不匹配磁盘块，**无法有效利用磁盘顺序读的高效性**。每次读取可能只获取少量有用数据。|**节点大小匹配磁盘页**：将节点大小设置为磁盘页（如4KB）的整数倍。一次I/O可加载多个键，**充分利用预读特性，减少I/O次数**。|
|**范围查询效率**​|进行范围查询（如查找某个范围内的所有数据）时，效率较低，可能需要在树中进行多次中序遍历，导致大量随机I/O。|**叶子节点顺序链表**：所有叶子节点通过**指针串联成有序链表**。范围查询只需在链表上顺序遍历，**大量顺序I/O，效率极高**。|
|**稳定性与存储效率**​|数据可能存储在所有节点中，树的结构会因频繁更新而不断调整。|**稳定的查询性能**：所有数据记录只存储在**叶子节点**，任何查询从根到叶子的路径长度相同，**查询性能稳定**。**更高的扇出**：非叶子节点仅存储键（索引信息）和指向子节点的指针，不存储实际数据，使得单个节点能**容纳更多的键（更高的“扇出”）**，树高进一步降低。|
- **应对大规模数据**：对于海量数据（如十亿级别），B+树通过3-4次I/O即可定位到数据，而二叉树可能需要几十次，性能差异巨大
- **适合数据库操作模式**：数据库中存在大量范围查询（如`BETWEEN`、`>`、`<`等操作），B+树的顺序链表结构为此提供了原生支持

 - 节点类型与功能
	- ​**非叶子节点（图示上方的蓝色矩形）​**​：
	    - ​**作用**​：仅起**索引作用**，相当于路标，用于指引搜索方向，不存储实际的数据。
	    - ​**构成**​：由键（Key）和指针（Pointer）交替组成。例如，根节点包含键 `[38, 67]`和三个指针。
	    - ​**搜索过程**​：如果要查找数据55，从根节点开始：55 < 67，所以沿着38和67之间的指针向下查找。
	- ​**叶子节点（图示最下方的绿色矩形）​**​：
	    - ​**作用**​：​**存储所有的实际数据**。
	    - ​**构成**​：包含所有的键和指向对应数据行的指针（或直接存储数据行本身）。
	    - ​**关键特性**​：所有叶子节点之间通过**指针双向连接**，形成一个有序链表。这是B+Tree支持高效范围查询的关键。

 - 特点与规则（以4阶树为例）
	- ​**所有元素都会出现在叶子节点**​：无论你要找6还是98，最终都需要到达叶子节点才能获取数据。
	- ​**叶子节点形成有序链表***（最主要的特点）​：如图所示，叶子节点 `[6,12,16,18]`-> `[29,34]`-> `[38,45]`... -> `[94,98]`通过指针相连。
		- **更适合范围查询**: 叶子节点之间通过双向链表连接，使得进行范围查询时非常高效。找到起始点后，只需沿着链表遍历即可，无需回溯树的上层结构。B树做范围查询则需要复杂的中序遍历。
		- **更方便的全表扫描**: 直接遍历叶子节点的链表即可完成全表扫描，比B树效率高。
	- ​**非叶子节点充当“稀疏索引”​**​：非叶子节点中的键是其子节点中最小（或最大）键的副本，用于路由。