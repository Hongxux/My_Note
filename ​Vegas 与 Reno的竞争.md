- ​**TCP Reno**​ 司机的策略是：​**一直踩油门加速，直到看到车祸（丢包）为止**。一旦看到车祸，他就猛踩刹车，然后再次开始缓慢加速。他的车速总是在剧烈波动。
    
	- ​**TCP Vegas**​ 司机的策略是：​**他时刻关注着车速和导航预计时间（RTT）​**。一旦发现预计时间比平时多了一点点，他就认为“前面可能开始有点堵了”，于是**轻轻地松开油门**，让车速平稳下降一点。
	- 假设一条链路的带宽为 10 Mbps，缓冲区大小为 200 ms 的数据。

		1. ​**初始状态：​**​ 一个 Vegas 流和一个 Reno 流共享该链路。
    
		2. ​**Vegas 先启动：​**​ Vegas 快速增加窗口，同时测量到一个很小的 `BaseRTT`。很快，它的 `Diff`值超过了阈值 β。于是它主动将窗口减小 1，试图将网络中的排队数据量稳定在 β 个包。
    
		3. ​**Reno 的行为：​**​ 此时，从 Reno 的视角看，​**完全没有丢包**​！它认为网络还有大量空闲容量。因此，它严格执行 AIMD（加法增大、乘法减小），在每个 RTT 内将窗口 `cwnd += 1`，持续地、贪婪地抢占所有可用的带宽。
    
		4. ​**Vegas 的困境：​**​ Vegas 每次稍微增加一点窗口，就会导致 `CurrentRTT`微增（因为 Reno 也在增窗，队列在变长）。Vegas 一看到 RTT 增加，就立刻认为拥塞加剧，于是再次减窗。​**Vegas 永远处于“想增不敢增”的状态。​**​
    
		5. ​**正反馈循环（恶性循环）：​**​
    
		    - Vegas 减窗 → 为网络腾出一点点空间。
        
		    - Reno 立刻探测到没有丢包（空间可用）→ 增窗占领该空间。
        
		    - 网络队列长度几乎不变（总是被 Reno 填满），RTT 持续保持高位。
        
		    - Vegas 持续测量到高 RTT，其 `Diff`值始终很大，于是它**持续地、线性地减少自己的发送窗口**。
        
		    - 最终，Vegas 的窗口被压缩到一个很低的水平，吞吐量极低；而 Reno 占据了几乎全部带宽，并在其“锯齿形”带宽曲线的顶端运行。