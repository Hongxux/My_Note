
### 📘 Dijkstra 算法精要：从原理到实践

#### 🔍 1. 核心思想与适用条件

Dijkstra算法是一种解决**带权有向图**​（或无向图）上的**单源最短路径问题**​（Single-Source Shortest Path, SSSP）的**贪心算法**​（Greedy Algorithm）。

- ​**核心策略**​：算法逐步扩展**最短路径树**​（Shortest Path Tree, SPT），每次从未确定的顶点集合中选取**当前距离源点最近**的顶点，将其加入已确定集合，并对其所有出边执行**松弛操作**​（Relaxation）。
    
- ​**关键前提**​：图中所有边的权重必须为**非负**​（`w(e) ≥ 0`）。负权边会破坏算法的贪心选择性质，导致其无法得出正确结果。
    
- ​**算法目标**​：给定源顶点 `s`，找到 `s`到图中所有其他顶点的最短路径（即路径上所有边的权重之和最小）。
    

#### ⚙️ 2. 算法流程与关键技术点
![[Pasted image 20250910101531.png]]

##### 基本步骤

1. ​**初始化**​：
    
    - 创建距离数组 `dist[]`，`dist[s] = 0`，其他顶点初始化为 `∞`（或一个极大值）。
        
    - 创建一个优先队列（通常为**最小堆**，Min-Heap）`PQ`，将 `(0, s)`入队。
        
    - （可选）创建父节点数组 `parent[]`，用于回溯路径，`parent[s] = -1`。
        
    - 创建标记数组 `visited[]`（或直接通过距离比较判断），记录顶点是否已确定最短路径。
        
    
2. ​**主循环**​（当 `PQ`非空）：
    
    a. ​**提取最小元**​：从 `PQ`中取出当前距离 `s`最近的顶点 `u`（即 `dist[u]`最小）。
    
    b. ​**标记已确定**​：将 `u`标记为已处理。​**此时 `dist[u]`即为 `s`到 `u`的最终最短距离**。
    
    c. ​**松弛操作**​：遍历 `u`的所有邻居 `v`：
    
    - 计算新路径长度 `tentative_distance = dist[u] + weight(u, v)`。
        
    - 若 `tentative_distance < dist[v]`，则：
        
        - 更新 `dist[v] = tentative_distance`。
            
        - 更新 `parent[v] = u`（若需记录路径）。
            
        - 将 `(dist[v], v)`加入 `PQ`。
            
        
    

##### 关键操作与数据结构
- ​**松弛操作 (Relaxation)​**​ ：这是算法的核心步骤，基于**三角不等式**的原理。它不断地用新发现的、更短的路径去更新当前已知的距离估计值。形式化定义为：
    
    `if dist[v] > dist[u] + w(u, v): then dist[v] = dist[u] + w(u, v)`
    
- ​**优先队列 (Priority Queue)​**​ ：使用最小堆（如二叉堆）来高效地选择当前 `dist`值最小的顶点，是优化时间复杂度的关键。
    
- ​**图的表示**​：
    
    - ​**邻接矩阵**​：适用于稠密图，但查找邻居需 O(V)。
        
    - ​**邻接表**​：适用于稀疏图，可高效遍历邻居，空间效率更高。
        
    

#### 🤔 3. 原理深究：为什么它是对的？[[Dijkstra算法(求SSSP问题)]]

Dijkstra算法的正确性基于其**贪心选择性质**，并通过**数学归纳法**或**反证法**证明。

- ​**贪心选择性质**​：算法每次选择当前 `dist`值最小的顶点 `u`并标记为已处理，此时 `dist[u]`就是最终的最短距离。
    
- ​**证明要点（反证法）​**​：
    
    1. 假设在顶点 `u`被移出 `PQ`的时刻，存在一条从 `s`到 `u`的更短路径 `P`。
        
    2. 路径 `P`必然包含至少一个未被标记的顶点（否则 `u`的距离已被更短路径更新）。
        
    3. 设 `x`是路径 `P`上第一个未被标记的顶点。则路径 `P`可分解为 `s ~> x -> ... ~> u`。
        
    4. 由于边权非负，有 `dist[x] ≤ length(s ~> x) ≤ length(P) < dist[u]`。
        
    5. 这说明 `x`的当前距离估计 `dist[x]`比 `dist[u]`更小。但算法总是先处理 `dist`值更小的顶点，因此 `x`本应先于 `u`被处理，这与 `x`未被标记的假设矛盾。
        
    6. 故假设不成立，原命题得证。
        
    

​**负权边为何破坏算法？​**​[[负权环]]    若存在负权边，上述推导中的 `length(s ~> x) ≤ length(P)`可能不再成立（因为 `P`后续可能有负权边使总长度变短），从而 `dist[x]`可能大于 `dist[u]`，导致 `x`晚于 `u`被处理，错过了通过 `x`更新 `u`的可能，算法无法得到正确结果。

#### ⚡ 4. 性能分析

Dijkstra算法的时间复杂度主要取决于所使用的数据结构。

|​**实现方式**​|​**时间复杂度**​|​**空间复杂度**​|​**适用场景**​|
|---|---|---|---|
|邻接矩阵 + 线性扫描|O(V²)|O(V²)|稠密图 (E ≈ V²)|
|​**邻接表 + 二叉堆**​|​**O((V+E) log V)​**​|​**O(V + E)​**​|​**稀疏图 (E << V²)​**​|

- ​**堆优化详解**​：使用二叉堆时，每次 `extract-min`操作为 O(log V)，最多执行 V 次。每次 `decrease-key`（通过重新入队实现）也是 O(log V)，最多执行 E 次。故总时间为 O((V+E) log V)。
    
- ​**空间消耗**​：主要用于存储图（邻接表 O(V+E) 或邻接矩阵 O(V²)）和辅助数据结构（`dist`, `parent`, `PQ`，均为 O(V)）。
    

#### 🔄 5. 与其他算法的对比

|​**算法**​|​**时间复杂度**​|​**支持负权**​|​**检测负环**​|​**适用场景**​|
|---|---|---|---|---|
|​**Dijkstra**​|O((V+E) log V)|❌|❌|非负权图，单源最短路径|
|​**Bellman-Ford**​|O(VE)|✅|✅|通用单源最短路径，检测负环|
|​**Floyd-Warshall**​|O(V³)|✅|✅|所有顶点对之间的最短路径|
|​__A_​_*​|Heuristic|❌|❌|启发式搜索，已知目标位置|

#### 💻 6. 代码实现要点（堆优化版）

```
import heapq

def dijkstra(adj_list, start):
    n = len(adj_list)
    dist = [float('inf')] * n
    parent = [-1] * n  # 可选：用于重构路径
    dist[start] = 0
    # PQ 中存储 (current_dist, node)
    min_heap = [(0, start)]
    
    while min_heap:
        d_u, u = heapq.heappop(min_heap)
        # 关键：跳过陈旧值（由于同一节点可能被多次加入堆）
        if d_u != dist[u]:
            continue
        for v, w in adj_list[u]:
            new_dist = d_u + w
            if new_dist < dist[v]:
                dist[v] = new_dist
                parent[v] = u  # 记录前驱
                heapq.heappush(min_heap, (new_dist, v))
    return dist, parent
```

#### ⚠️ 7. 局限与常见误区

- ​**负权边**​：算法**不能处理**含负权边的图。对于存在负权边的图，应使用 ​**Bellman-Ford**​ 或 ​**SPFA**​ 算法。
    
- ​**负环**​：Dijkstra算法无法处理也无法检测负权环（Negative-Weight Cycle）。
    
- ​**堆优化中的“重复入队”​**​：这是**正常且必要**的。由于标准堆不支持直接降低键值（decrease-key），通过重复入队（并配合跳过陈旧的堆顶元素）是实现“降低键值”效果的常用且高效的方法，不会影响正确性。
    
- ​**最短路径重构**​：若要输出具体路径，需维护 `parent[]`数组，从目标顶点 `t`开始，不断回溯 `prev[t]`, `prev[prev[t]]`, ...，直到回溯到源点 `s`。将回溯的路径反转，就得到了从 `s`到 `t`的最短路径。



#### 💎 总结

Dijkstra算法通过**贪心策略**和**松弛操作**，高效地解决了**非负权图**的单源最短路径问题。其正确性由**三角不等式**和**非负权约束**保证。​**优先队列（堆）​**​ 的运用是其高效的关键。


