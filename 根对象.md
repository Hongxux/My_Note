- **思想：** **“正在被使用的”就是活的**。
	- 虚拟机栈中的引用
		- 各个线程方法栈帧中的局部变量表所引用的对象
	- 活跃线程相关的对象：java.lang.Thread​ 对象本身，以及线程内部的一些特定对象
- **思想：** **“外部世界是不可控的”**。
	- 本地方法栈中JNI引用的对象
	- 解释： JNI 代码在 JVM 外部（C/C++），JVM 无法分析其内部逻辑。为了安全，凡是 Native 方法通过 JNI 引用的 Java 对象，都必须视为根，防止被误删导致 Native 代码崩溃。
- **思想：“伴随类生命周期的”就是活的**。
	- 静态属性（static）引用的对象（）
		-  解释：`static` 变量属于类，类的生命周期通常与 JVM 一致（除非显式卸载）。只要类没卸载，它引用的对象就必须存活。这保证了全局状态的可见性。
	- 常量(final)引用的对象
		-  **不变性：** 常量一旦创建，理论上就不会改变。它们的生命周期通常与类的生命周期绑定，或者更长。
		- **共享性：** 比如字符串常量 `"Hello"`，可能被代码中的无数个地方引用。如果它被回收了，下次要用还得重新创建，失去了“常量池”的意义（享元模式）。
		- **类加载契约：** 在类加载的“解析”阶段，符号引用会转变为直接引用，常量池中的引用会被直接加载到内存中。为了保证类加载后的状态稳定，这些被引用的对象必须作为根存在。
- **思想：** **“正在被锁定的，就不能消失”**。
	- 作为 `synchronized`​ 同步锁使用的对象
	- 解释
		- 当你使用 `synchronized (obj)` 时，JVM 需要为这个对象分配一个监视器锁（Monitor）。
		- 如果这个 `obj` 被垃圾回收器回收了，但线程还在持有这个锁（或者试图等待/唤醒），那整个锁机制就崩坏了。这会导致严重的并发安全问题，甚至 JVM 崩溃。
		- **因此，只要一个对象还被当作锁在使用，它就必须被标记为“存活”，绝对不能被回收。**
- JVM内部的引用：
	- 基石不能动：基本数据类型的Class对象
	- 兜底的不能动：常驻的异常对象
		- JVM 预判到某些异常（如 NPE、OOM）在程序运行中极大概率会发生。
		- 如果每次发生 NPE 都去 `new` 一个异常对象，不仅慢，而且在内存极度紧张（甚至发生 OOM）的时候，可能连创建异常对象的内存都没有了，导致错误无法抛出，程序直接僵死。
		- 所以，JVM 提前创建好这些常用的异常对象并作为 GC Roots 挂住，确保即使在内存溢出的情况下，也能抛出对应的错误信息，让程序有机会（哪怕是优雅地）终止。
	- 系统类加载器

