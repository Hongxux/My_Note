1. **件分块**
    
    - **确定块大小**：选择一个合适的块大小（例如256KB或1MB）非常重要。块太小会导致请求次数过多，开销增大；块太大则失去了分块的意义，难以应对网络波动
        
    - **读取与切割**：使用文件流（如Java中的 `FileInputStream`）按预定大小读取文件，并将每个数据块放入缓冲区。关键是**使用循环读取，直到文件末尾**，确保处理整个文件
    
2. **逐块传输**
    
    - **构造请求**：为每个数据块发起一个独立的HTTP请求（通常是POST或PUT）。每个请求的Body部分携带该数据块的二进制数据
        
    - **携带元信息**：在请求头或Body中，需要告知服务器这个数据块的**关键信息**，例如
        
        - `Content-Range`：标明当前数据块在整个文件中的起始和结束字节位置（例如 `bytes 0-99999/1000000`）。
        - `Chunk-Index`或 `Part-Number`：当前数据块的序号。
        - `File-Id`或 `Upload-Id`：整个上传任务的唯一标识符，以便服务器将同一个文件的数据块关联起来。
        
    - **错误重试**：为实现健壮性，应为每个数据块的传输实现**重试机制**。当某块传输失败时，自动进行有限次数的重试
3. **接收与校验**
    
    - **临时存储**：服务器接收到数据块后，先将其作为临时文件存储在磁盘上，或者将内容暂存起来。每个临时文件最好以`File-Id`和`Chunk-Index`等唯一信息命名，以避免混淆。
        
    - **完整性校验**：对接收到的数据块进行校验至关重要。通常使用**哈希校验**（如MD5或SHA-1），客户端在发送数据块时计算并附带其哈希值，服务器端接收后重新计算并比对，确保数据在传输过程中没有出错。
        
    - **响应确认**：校验通过后，服务器应向客户端返回成功响应（如HTTP 200），并可在响应体中告知客户端该数据块已成功接收。
4. **组装完整文件**
    
    - **等待与验证**：服务器需要有一个机制来追踪一个文件的所有数据块是否都已成功上传。这可以通过维护一个上传状态表（如在内存或Redis中记录每个`File-Id`对应的已上传数据块序号）来实现。
        
    - **顺序组装**：当确认所有数据块都已上传后，服务器按照数据块的索引序号，**依次读取每个临时数据块文件，并将其写入到最终的目标文件中**。使用`RandomAccessFile`可以高效地在文件的指定位置写入数据，特别适合根据`Content-Range`信息进行组装。
        
    - **清理工作**：文件合并完成后，服务器应删除所有该文件的临时数据块，释放存储空间