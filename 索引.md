- 需求背景：查询性能瓶颈，没有索引将要全表扫描
- 解决措施：索引，“空间换时间”​ 的优化策略
	- 定位准确：将数据检索的时间复杂度从O(n)降低到O(log n)甚至更低
		- 显著减少磁盘I/O操作：
			- 重要性：磁盘I/O是数据库操作中最耗时的部分。
			- 原因：索引通过减少需要读取的数据页数量，有效降低了磁盘I/O次数，从而提升了系统吞吐量。
		- 加速表连接：在多表关联查询（JOIN）时，如果连接条件字段上有索引，数据库可以高效地找到关联表中的匹配记录，极大提升连接效率
	- 有序性：
		- 优化排序和分组操作：如果`ORDER BY`或`GROUP BY`子句可以用到索引，数据库可以直接按索引的顺序读取数据，避免昂贵的临时表排序和文件排序（Using filesort），从而提升性能。
	- 约束性：
		- 确保数据完整性：唯一索引​和主键索引可以确保表中列值的唯一性，是实施数据完整性约束的关键工具。

- 代价：
	- **占用额外存储空间**：索引是独立的数据结构，需要占用额外的磁盘空间。通常，索引空间可能达到原表数据的20%-30%
	- **增加写操作开销**：当执行`INSERT`、`UPDATE`、`DELETE`操作时，数据库不仅需要修改表数据，还需要更新所有相关的索引，这会**降低写操作的速度**
	- **维护成本**：索引需要定期监控和维护，例如重建索引以消除碎片，或者删除不再使用或低效的索引
		- [[索引碎片]]

---
**基础索引类型：**
InnoDB存储引擎的表都是**索引组织表**
- 核心定义：在索引组织表中，表数据本身就是一个 [[B+Tree]] 索引。
	- 这个索引通常基于主键构建，数据行按照主键值的顺序存储在 B+Tree 的叶子节点中
	- **关系小结**：`InnoDB表`= `索引组织表`= 主要通过 `B+Tree`数据结构来实现其`聚集索引`和`二级索引`。
- 索引组织表分类：
	- 聚集索引：可以形象地理解为，数据表本身就是聚集索引。
		- 特点：
			- 存储内容：聚集索引的B+Tree的**叶子节点**直接存储了**完整的用户数据行**
				- 物理存储顺序和数据行存储顺序的关系：一致
			- 唯一性： 每张InnoDB表**只能拥有一个**聚集索引
		- 选取规则：
			- 如果表定义了 `PRIMARY KEY`，则主键索引就是聚集索引
			- 如果没有 `PRIMARY KEY`，InnoDB会选择第一个 `UNIQUE` 且所有列都 `NOT NULL` 的索引作为聚集索引。
			- 如果以上两者都没有，InnoDB会自动在内部生成一个隐藏的6字节长整型列（通常称为`DB_ROW_ID`或`ROW_ID`）作为聚集索引。
	- 非聚集索引
		- 定义：除聚集索引之外的所有索引都称为非聚集索引
		- 特点：
			- 存储内容：叶子节点存储的是该索引列的值和对应行的主键值
				- 它们的物理存储顺序与数据行的物理存储顺序无关
			- 非唯一性：一张表可以拥有多个非聚集索引
- 核心机制：回表
	- 触发条件：当使用非聚集索引进行查询时，如果查询需要的列不全在非聚集索引中，就会发生“回表”操作
	- 工作模式：
		1. **第一次查找：** 查询首先在非聚集索引的B+Tree中进行搜索，根据查询条件定位到叶子节点，并获取到对应行的**主键值**。
		2. **第二次查找：** 然后，使用这个主键值，在**聚集索引**的B+Tree中再次进行搜索，最终定位到聚集索引的叶子节点，读取完整的行数据。
	- 问题：两次查询降低性能
	- 解决方式：[[覆盖索引]]
- 优化机制：[[自适应哈希索引]]

---

**高级索引类型**
- [[联合索引]]：
- [[全文索引]]
- 空间索引：高效地回答“附近有什么”、“是否在区域内”等与地理位置相关的问题

---
### [[索引基础语法]]
### [[索引创建原则]]
### [[查询中正确使用索引]]

### [[SQL性能分析工具]]

