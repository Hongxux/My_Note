---
aliases:
  - NullPointerException
---
### java 编译器的报错能力
```java
public class Main {  
    public static void main(String[] args) {  
        Employee e = null;  
        String n = e.getAddress().toString();  
    }  
}
```
![[Pasted image 20251016100209.png]]

```java
public class Main {  
    public static void main(String[] args) {  
        Employee e = new Employee("xxx",19);  
        String n = e.getAddress().toString();  
    }  
}
```
![[Pasted image 20251016100441.png]]
空指针报错会直接告诉你哪个是空

### 如何在初始化的时候预防NullPointerException
#### 1.Objects.requireNonNullElse()
name = Objects.requireNonNullElse(n, "unknown");
如果为n空，设置name为unknown

#### 2.Objects.requireNonNull()
name = Objects.requireNonNull(n, "The name cannot be null");
如果为空就报错，但是可以自己设置显示的报错的原因。

#### 二者选择

当你在构造函数中接受一个对象引用作为参数时（例如`String name`），应该主动考虑是否允许该参数为null（即“值可能缺失”）。如果不允许参数为null（即你希望所有参数都必须有实际值），那么优先采用“tough love”方法——严格拒绝null值，而不是宽容地处理（如提供默认值）。
    
- ​**​“Tough love”方法**​：指使用`Objects.requireNonNull`方法在构造函数中验证参数，如果参数为null，立即抛出`NullPointerException`并附带描述性消息。这确保了对象的完整性，避免了后续潜在的null引用错误。
	1. ​**早期失败（Fail-Fast）​**​：在对象构造阶段就检测错误，而不是等到后续方法调用时才发现null值，这简化了调试和错误追踪。
    
	2. ​**清晰的设计契约**​：构造函数明确要求参数非null，使类的使用方式更直观，减少了API的模糊性。
    
	3. ​**避免隐藏错误**​：宽容方法可能掩盖编程错误（如意外传递null），而“tough love”方法强制开发者处理null值，提高代码可靠性。
    
	4. ​**Java 17增强**​：自Java 17起，`NullPointerException`的错误消息会 pinpoint null值的具体来源（如参数名），使“tough love”方法更易于调试。
- ​ **“permissive approach”方法**：使用`Objects.requireNonNullElse`等将null转换为默认值（如将null name设置为"unknown"），但可能隐藏设计缺陷或导致意外行为。
	- 宽容方法仅在业务逻辑确实需要处理“缺失值”时适用。例如：
		- 如果“未知姓名”是有效状态，那么使用默认值（如"unknown"）是合理的。
    
		- 但建议，在大多数情况下，尤其是核心字段（如标识符），应避免null值，优先使用“tough love”。

##### 最佳实践总结

- ​**设计时自问**​：在定义构造函数时，明确每个参数是否允许null。如果不允许，立即使用`Objects.requireNonNull`验证。
    
- ​**一致性**​：在整个类设计中保持null处理策略一致，避免混合使用宽容和严格方法。
    
- ​**文档化**​：使用JavaDoc或注释说明参数的null约束，帮助其他开发者正确使用类。
    