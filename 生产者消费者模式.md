---
aliases:
  - 生产者
  - 消费者
---
### 核心思想和好处
核心思想：通过一个共享的缓冲池，解耦生产者和消费者
- 生产者：往缓冲池放东西的线程
- 消费者：从缓冲池取东西的线程
好处：
- 缓冲池：双方不用互相等待，双方以自己能接受的效率进行处理：
	- 对于慢的一方：当生产速度突然激增（如秒杀活动），缓冲区可以暂时存储这些突发请求，让消费者按照自己的能力平稳处理，避免系统被压垮，
		- **起到了“削峰填谷”的作用**
		-  消费者的处理速度往往更慢（比如与数据库交互）
	- 对于快的一方：不会被慢的一方拖慢，让消费者异步处理，自己放任务到缓冲区后就立即返回
		- 从而**提高了吞吐量**
- **松耦合**：它降低了软件模块之间的依赖性。如果消费者的处理逻辑需要改变，只要它从缓冲区取数据的接口不变，就完全不需要修改生产者的代码，系统的可维护性和可扩展性大大增强。
### 实现
| 考量维度           | 推荐方案                       | 理由                                           |
| -------------- | -------------------------- | -------------------------------------------- |
| **简单单机应用**​    | **BlockingQueue**​         | 实现最快，无外部依赖，JDK内置，线程安全。                       |
| **高性能单机应用**​   | **Lock & Condition**​      | 比synchronized性能更好，控制更精细。                     |
| **分布式系统/微服务**​ | **Redis Stream 或 专业消息队列**​ | 支持跨网络、跨进程通信。Redis Stream更轻量、灵活；专业MQ功能更全面、可靠。 |
| **需要消息广播**​    | **Redis Stream / Kafka**​  | 支持多个独立的消费者组同时消费同一批消息。                        |
| **极高可靠性要求**​   | **专业消息队列 (如RabbitMQ)**​    | 提供完善的持久化、确认、重试、高可用机制。                        |
#### [[阻塞队列]]
**单机环境下最推荐、最简洁**的实现方式.。
JDK提供的 `BlockingQueue`（如 `ArrayBlockingQueue`）内部已经完美处理了所有线程同步问题。
#### [[消息队列]]
当生产者和消费者不在同一个JVM或机器上时，就需要引入外部组件。
