环境变量是操作系统中用于存储配置信息和系统参数的一种机制，它们以键值对（key-value pairs）的形式存在，可以被操作系统和应用程序访问使用。

## 环境变量的基本概念

### 什么是环境变量？

- ​**键值对存储**​：每个环境变量都有一个名称（键）和对应的值
    
- ​**全局可访问**​：在同一个进程空间内，所有程序都可以读取这些变量
    
- ​**继承性**​：父进程的环境变量会被子进程继承
    
- ​**会话级别**​：环境变量通常只在当前会话或进程中有效
    

## 环境变量在进程中的存储和访问

### 在C程序中的使用：

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 获取环境变量
    char* home = getenv("HOME");
    char* user = getenv("USER");
    char* path = getenv("PATH");
    
    printf("Home directory: %s\n", home);
    printf("Username: %s\n", user);
    printf("Path: %s\n", path);
    
    // 设置环境变量（仅对当前进程及其子进程有效）
    setenv("MY_VAR", "my_value", 1);  // 第三个参数1表示覆盖已存在的变量
    
    // 验证设置
    printf("MY_VAR: %s\n", getenv("MY_VAR"));
    
    return 0;
}
```

### 在Shell脚本中的使用：

```
#!/bin/bash

# 显示所有环境变量
env
# 或
printenv

# 显示特定环境变量
echo "User: $USER"
echo "Home: $HOME"

# 设置环境变量（当前Shell会话有效）
export MY_VARIABLE="hello world"

# 设置只对当前命令有效
MY_TEMP_VAR="temporary" some_command

# 在子Shell中执行，不影响父Shell
(export MY_VAR="subshell"; echo "In subshell: $MY_VAR")
echo "In parent: $MY_VAR"  # 输出为空（如果父Shell中没有MY_VAR）
```

## 环境变量的作用域和生命周期

### 作用域类型：

1. ​**系统级环境变量**​
    
    - 存储在 `/etc/environment`、`/etc/profile`等系统配置文件中
        
    - 对所有用户有效
        
    - 需要重启或重新登录才能生效
        
    
2. ​**用户级环境变量**​
    
    - 存储在 `~/.bashrc`、`~/.bash_profile`、`~/.profile`等用户配置文件中
        
    - 仅对相应用户有效
        
    - 重新登录或执行 `source ~/.bashrc`后生效
        
    
3. ​**会话级环境变量**​
    
    - 在当前Shell会话中使用 `export`命令设置
        
    - 仅对当前会话及其子进程有效
        
    - 关闭终端后失效
        
    
4. ​**进程级环境变量**​
    
    - 在程序运行时临时设置
        
    - 仅对当前进程及其子进程有效
        
    

## 环境变量在 `fork()`和 `exec()`中的传递

### 继承机制：

```
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // 子进程
        printf("Child process - USER: %s\n", getenv("USER"));
        
        // 修改环境变量（只影响子进程）
        setenv("CUSTOM_VAR", "child_value", 1);
        printf("Child - CUSTOM_VAR: %s\n", getenv("CUSTOM_VAR"));
        
        // 执行新程序，默认继承当前环境变量
        char *args[] = {"env", NULL};
        execvp("env", args);  // 会显示所有环境变量，包括修改后的
        
    } else {
        // 父进程
        printf("Parent process - USER: %s\n", getenv("USER"));
        
        // 父进程的环境变量不受子进程影响
        printf("Parent - CUSTOM_VAR: %s\n", getenv("CUSTOM_VAR"));  // 可能为NULL
        
        wait(NULL);  // 等待子进程结束
    }
    
    return 0;
}
```

### 在 `exec()`时控制环境变量：

```
// 使用 execle 或 execve 可以指定新的环境变量数组
#include <unistd.h>

int main() {
    char *envp[] = {
        "USER=custom_user",
        "HOME=/custom/home",
        "PATH=/usr/local/bin:/usr/bin",
        NULL  // 必须以NULL结尾
    };
    
    char *args[] = {"env", NULL};
    
    // 使用全新的环境变量数组执行程序
    execve("/usr/bin/env", args, envp);
    
    // 如果成功，不会返回
    perror("execve failed");
    return 1;
}
```

## 环境变量的实际应用场景

### 1. 程序配置

```
# 设置数据库连接信息
export DB_HOST="localhost"
export DB_PORT="5432"
export DB_NAME="mydatabase"

# 程序读取这些变量进行配置
```

### 2. 开发环境切换

```
# 切换不同的开发环境
export NODE_ENV="development"  # 或 "production"
export JAVA_HOME="/usr/lib/jvm/java-11-openjdk"
```

### 3. 路径管理

```
# 添加自定义路径到PATH
export PATH="$HOME/bin:$PATH"

# 设置Python模块搜索路径
export PYTHONPATH="/my/python/modules:$PYTHONPATH"
```

### 4. 调试和日志

```
# 设置调试级别
export LOG_LEVEL="DEBUG"
export DEBUG="app:*"

# 性能分析
export LD_DEBUG="libs"  # 动态链接库调试信息
```

## 管理环境变量的最佳实践

### 持久化设置：

```
# 在 ~/.bashrc 或 ~/.profile 中添加
export EDITOR="vim"
export HISTSIZE=10000
export HISTFILESIZE=20000

# 使用别名简化常用操作
alias ll='ls -alF'
alias ..='cd ..'
```

### 安全注意事项：

```
# 敏感信息不应该放在环境变量中
# 错误做法：
export DB_PASSWORD="mysecretpassword"  # 不安全！

# 应该使用专用配置文件或密钥管理服务
```

环境变量是操作系统和应用程序之间通信的重要桥梁，它们提供了一种灵活的方式来配置程序行为，而不需要修改代码或重新编译程序。