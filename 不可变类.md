- 需求背景：共享的变量如果不可变，则不会出现对该变量的写操作，因此能实现并发安全
- 不可变类设计：确保类的实例一旦创建，其内部状态（成员变量的值）就再也无法被任何方式修改
	 1. **将类声明为 `final`**:这是为了防止类被继承。
	    - 子类可能会重写方法，并改变成员变量的值，从而破坏了父类的不可变性
	2. **将所有字段声明为 `private final`**
	    - `private`确保了字段不能被外部直接访问。
	    - `final`确保了字段一旦在构造器中初始化后，就不能再被重新赋值	    
	3. **不提供修改对象状态的方法**：对象的状态只能通过构造器来初始化
		- 可以提供With风格方法，返回一个新的实例
		- 存在问题：频繁地创建对象
		- 解决方式：[[享元模式]]
	4. **通过构造器初始化所有字段，并进行深拷贝**：避免进行浅拷贝，出现变量引用不可变，但是被引用的变量可变的情况
		- 深拷贝：
			- 对每一个可变引用类型的字段递归地调用其 `clone()`方法，否则将退化为浅拷贝
				- 此方法需要类实现 `Cloneable`标记接口，并重写 `clone()`方法
			- 有的提供构造方法或者工厂方法深拷贝：对每一个可变引用类型的字段递归地调用其 `clone()`方法
			- 使用第三方库
					```
					import org.apache.commons.lang3.SerializationUtils;
					
					// 使用前提同样是所有相关类实现Serializable接口
					Person original = new Person("John", new Address("NYC"));
					Person copy = SerializationUtils.clone(original); // 一行代码完成深拷贝
					```
	5. **在getter方法中返回可变字段的拷贝或不可变视图**
		- 使用 `Collections.unmodifiableList`
	