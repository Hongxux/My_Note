- ​**功能：​**​ 用磁盘上的一个**新程序**替换当前进程正在执行的**内存映像**​（代码、数据、堆、栈等）。调用 `exec()`成功后，原进程的代码不再执行，新程序从它的 `main()`函数开始执行。
    
- ​**工作原理：​**​
    
    - 当进程调用 `exec()`时，操作系统：
        
        1. 销毁调用进程当前的内存映像（代码、数据、堆、栈）。
            
        2. 从指定的可执行文件加载新程序的代码和数据到内存。
            
        3. 为程序设置新的堆栈。
            
        4. 将控制权转移到新程序的入口点（通常是 `main`函数）。
            
        
    - 进程的 ​**PID 保持不变**。它还是原来那个进程，只是“灵魂”（执行的程序）被替换了。
        
    - 新程序**继承**了调用进程的许多属性（除非在 `exec()`前被修改或关闭）：
        
        - 进程 ID (PID) 和父进程 ID (PPID)
            
        - 用户 ID (UID) 和组 ID (GID)
            
        - 当前工作目录
            
        - 文件描述符表（除非设置了 `FD_CLOEXEC`标志）
            
        - 信号处理设置（大部分继承，部分可能重置）
            
        - [[环境变量]]（默认继承父进程环境，但 `exec()`函数可以指定新环境）
            
        
    **`exec()`会丢弃大部分继承来的内存内容，但保留内核层面的资源：​**​ `exec()`替换的是进程的**用户空间**​（代码、数据、堆、栈）。它**不会**改变进程的内核层面属性（如 PID, PPID, UID, GID）和**大多数**打开的资源（如文件描述符），除非特别标记。
    - 子进程获得父进程文件描述符表的**副本**。
    
	- 这意味着子进程拥有指向**相同打开文件表项**的文件描述符。
    
	- 文件偏移量、文件状态标志 (`O_RDONLY`, `O_NONBLOCK`等) 是共享的（因为它们属于打开文件表项）。
- ​**返回值：​**​
    
    - 如果 `exec()`成功，它**不会返回**​（因为原程序已被替换）。
        
    - 如果 `exec()`失败（例如找不到文件、没有执行权限），它会返回 ​**​-1**，并且进程继续执行原代码（通常需要检查错误）。
        
    
- ​**`exec()`家族成员：​**​ 有多个以 `exec`开头的函数，主要区别在于如何指定程序路径、参数列表和环境变量：
    
    - `execl(path, arg0, arg1, ..., (char *) NULL)`：参数作为**可变参数列表**传递，最后一个参数必须是 `NULL`。需要指定完整路径。
        
    - `execv(path, argv[])`：参数作为**字符串数组**​ `argv`传递（`argv[0]`通常是程序名，`argv`最后一个元素必须是 `NULL`）。需要指定完整路径。
        
    - `execle(path, arg0, arg1, ..., (char *) NULL, envp[])`：类似 `execl`，但可以指定**新的环境变量数组**​ `envp`。
        
    - `execve(path, argv[], envp[])`：最底层的系统调用。参数用数组 `argv`传递，环境变量用数组 `envp`传递。需要指定完整路径。
        
    - `execlp(file, arg0, arg1, ..., (char *) NULL)`：类似 `execl`，但会在 `PATH`环境变量指定的目录中**搜索**名为 `file`的可执行文件。
        
    - `execvp(file, argv[])`：类似 `execv`，但会在 `PATH`环境变量指定的目录中**搜索**名为 `file`的可执行文件。这是最常用的之一。
        
    
- ​**关键点：​**​
    
    - `exec()`​**不创建**新进程。它替换**当前**进程的内容。
        
    - 它通常与 `fork()`结合使用：父进程 `fork()`出子进程，子进程调用 `exec()`运行新程序。
        
    
- ​**示例代码片段 (在子进程中)：​**​
    
    ```
    char *args[] = {"ls", "-l", "/", NULL}; // 参数数组
    execvp("ls", args); // 执行 'ls -l /'
    // 如果 execvp 成功，下面的代码永远不会执行
    perror("execvp failed"); // 只有失败时才执行
    exit(1);
    ```
    