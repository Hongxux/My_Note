**堆（Heap or Priority Queue）、[栈](https://zhida.zhihu.com/search?content_id=165894837&content_type=Article&match_order=1&q=%E6%A0%88&zhida_source=entity)（Stack）、[队列](https://zhida.zhihu.com/search?content_id=165894837&content_type=Article&match_order=1&q=%E9%98%9F%E5%88%97&zhida_source=entity)（Queue）、[哈希表](https://zhida.zhihu.com/search?content_id=165894837&content_type=Article&match_order=1&q=%E5%93%88%E5%B8%8C%E8%A1%A8&zhida_source=entity)类（Hashmap、Hashset）：**

- 基础知识：各个数据结构的基本原理，增删查改复杂度。
- Queue题目：

- Leetcode 225. Implement Stack using Queues
- Leetcode 346. Moving Average from Data Stream
- Leetcode 281. Zigzag Iterator
- Leetcode 1429. First Unique Number
- Leetcode 54. Spiral Matrix
- Leetcode 362. Design Hit Counter

- Stack题目：

- Leetcode 155. Min Stack (follow up Leetcode 716 Max Stack)
- Leetcode 232. Implement Queue using Stacks
- Leetcode 150. Evaluate Reverse Polish Notation
- Leetcode 224. Basic Calculator II (I, II, III, IV)
- Leetcode 20. Valid Parentheses
- Leetcode 1472. Design Browser History
- Leetcode 1209. Remove All Adjacent Duplicates in String II
- Leetcode 1249. Minimum Remove to Make Valid Parentheses
- Leetcode 735. Asteroid Collision

- Hashmap/ Hashset题目：

- Leetcode 1. Two Sum
- Leetcode 146. LRU Cache (Python中可以使用OrderedDict来代替)
- Leetcode 128. Longest Consecutive Sequence
- Leetcode 73. Set Matrix Zeroes
- Leetcode 380. Insert Delete GetRandom O(1)
- Leetcode 49. Group Anagrams
- Leetcode 350. Intersection of Two Arrays II
- Leetcode 299. Bulls and Cows
- Leetcode 348 Design Tic-Tac-Toe

- Heap／Priority Queue题目：

- Leetcode 973. K Closest Points
- Leetcode 347. Top k Largest Elements
- Leetcode 23. Merge K Sorted Lists
- Leetcode 264. Ugly Number II
- Leetcode 1086. High Five
- Leetcode 88. Merge Sorted Arrays
- Leetcode 692. Top K Frequent Words
- Leetcode 378. Kth Smallest Element in a Sorted Matrix
- Leetcode 295. Find Median from Data Stream （标准解法是双heap，但是SortedDict会非常容易）
- Leetcode 767. Reorganize String
- Leetcode 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (这个题用单调双端队列、TreeMap、双heap都可以)
- Leetcode 895. Maximum Frequency Stack
---
## 队列

### 📚 先来个快速概览

| 题目 | 核心功能 | 数据结构 | 关键技巧 |
| :--- | :--- | :--- | :--- |
| **225. 用队列实现栈** | 用队列模拟栈的LIFO（后进先出） | 队列 | 元素倒腾、双队列协作[[1]][[2]] |
| **346. 数据流移动平均值** | 计算滑动窗口内的平均值 | 队列 | 滑动窗口、前缀和 |
| **281. 锯齿迭代器** | 交替遍历多个列表 | 队列（存迭代器） | 迭代器、轮询机制[[3]][[4]] |
| **1429. 第一个唯一数字** | 找出数据流中第一个不重复的数字 | 哈希表+双向链表 | LRU类似思想、空间换时间[[5]] |
| **54. 螺旋矩阵** | 按顺时针螺旋顺序遍历矩阵 | 数组 | 边界模拟、方向控制[[6]][[7]] |
| **362. 设计点击计数器** | 统计最近5分钟内的点击次数 | 队列 | 滑动窗口、时间戳处理[[8]][[9]] |

---

### 🔗 区别与联系

这6道题可以分成三大类：

1.  **「基础结构互转」** (225)
    *   这是最经典的结构设计题，核心是**理解栈和队列的本质区别**（LIFO vs FIFO）。你需要通过元素倒腾来模拟另一种结构的行为[[10]][[11]]。这是所有设计题的基础。

2.  **「数据流处理」** (346, 362, 1429)
    *   这三道题都处理**持续输入的数据流**，核心思想是**滑动窗口**。
    *   **346** 和 **362** 非常像，都是计算固定时间窗口内的统计值（平均值 vs 点击次数），通常用一个队列维护窗口内的数据即可。
    *   **1429** 更复杂一些，它需要快速判断“唯一性”，所以光用队列不够，需要**哈希表+双向链表**来同时保证查询和删除的效率[[12]]。

3.  **「特殊遍历方式」** (281, 54)
    *   这两道题关注的是**如何按特定顺序访问数据**。
    *   **281** 是逻辑遍历，用队列管理多个迭代器，然后轮流取数[[13]]。
    *   **54** 是物理遍历，通过维护上下左右四个边界，模拟螺旋的轨迹[[14]][[15]]。

---

### 📈 递进关系与刷题顺序推荐

我强烈建议你按这个顺序来刷，从易到难，循序渐进：

1.  **第一步：理解基础转换 (225)**
    *   从**225. 用队列实现栈**开始。这是所有设计题的基石，帮你彻底理解如何用一种基础结构模拟另一种结构的特性[[16]]。

2.  **第二步：掌握滑动窗口 (346 -> 362)**
    *   然后做**346. 数据流移动平均值**。这是最简单的滑动窗口应用，理解如何维护一个定长的窗口。
    *   接着做**362. 设计点击计数器**。它和346很像，但需要处理时间戳，对窗口的理解要求更高一点[[17]]。

3.  **第三步：挑战复杂数据流 (1429)**
    *   之后攻克**1429. 第一个唯一数字**。这道题综合了哈希表和链表，是数据流问题的一个小高峰，能很好地锻炼你设计复杂数据结构的能力。

4.  **第四步：学习特殊遍历 (281 -> 54)**
    *   然后做**281. 锯齿迭代器**。学习如何使用迭代器和队列来管理多个数据源[[18]]。
    *   最后完成**54. 螺旋矩阵**。这道题虽然不涉及高级数据结构，但对边界条件的控制能力要求很高，是检验你代码严谨性的好题目[[19]]。

### 💡 总结一下

可以把这6道题看作一个**数据结构设计能力的进阶之路**：
*   **225**是入门课，理解结构转换。
*   **346、362**是基础应用课，掌握滑动窗口。
*   **1429**是进阶课，学习复杂数据流处理。
*   **281、54**是实践课，挑战特殊遍历算法。

按这个顺序刷下来，你会对如何设计高效的数据结构有一个系统性的认识。祝你刷题顺利！

----
## 栈
这9道题都是**栈和字符串处理**的经典题目，它们像打怪升级一样，能帮你层层递进地掌握栈的各种妙用。我来帮你捋一捋它们的区别、联系和最佳学习路径。

### 🧠 先来个快速分类

| 题目 | 核心功能 | 数据结构 | 关键技巧 |
| :--- | :--- | :--- | :--- |
| **155. 最小栈** | 支持快速获取栈内最小值 | 栈 + 辅助栈/记录 | 空间换时间，同步记录最小值[[1]][[2]] |
| **716. 最大栈** | 支持快速获取栈内最大值 | 栈 + 辅助栈 | 类似最小栈，但需处理`popMax`[[3]][[4]] |
| **232. 用栈实现队列** | 用栈模拟队列的FIFO | 双栈（输入/输出栈） | 元素倒腾，延迟处理[[5]][[6]] |
| **150. 逆波兰表达式** | 计算后缀表达式 | 栈 | 遇到数字入栈，遇到运算符弹出计算[[7]][[8]] |
| **224/227. 基本计算器** | 处理带括号和优先级的表达式 | 栈 | 双栈（数字栈+运算符栈）或符号处理[[9]][[10]] |
| **20. 有效的括号** | 判断括号是否匹配 | 栈 | 左括号压栈，右括号匹配栈顶[[11]][[12]] |
| **1472. 浏览器历史** | 模拟浏览器前进后退 | 双栈或数组+指针 | 双栈（后退栈+前进栈）[[13]][[14]] |
| **1209. 删除相邻重复II** | 删除连续k个相同字符 | 栈（记录字符和计数） | 栈内存储`(字符, 计数)`[[15]][[16]] |
| **1249. 移除无效括号** | 删除最少括号使有效 | 栈 | 记录无效括号位置，最后统一删除[[17]][[18]] |
| **735. 小行星碰撞** | 模拟行星碰撞（方向+大小） | 栈 | 处理相反方向行星的碰撞[[19]][[20]] |

---

### 🔗 内在联系与核心思想

这9道题可以分成四大类，核心思想都是**栈的灵活运用**：

1.  **「辅助栈」** (155, 716)
    *   这两道是亲兄弟，核心思想都是用**辅助栈**来记录极值（最小值或最大值），用空间换时间，保证在O(1)时间内获取极值[[21]][[22]]。716是155的进阶版，因为它还需要处理`popMax`操作，逻辑更复杂一些。

2.  **「结构转换」** (232)
    *   这道题教你如何用**双栈来模拟队列**的FIFO特性。核心技巧是“**延迟处理**”——一个栈负责接收入队元素，另一个栈负责出队。只有当出队栈为空时，才一次性把入队栈的所有元素“倒腾”过来[[23]][[24]]。这是理解栈和队列本质区别的绝佳练习。

3.  **「表达式处理」** (150, 224/227, 20)
    *   这是一个**表达式处理三部曲**，难度递进：
    *   **20**是基础，学会用栈做**简单的符号匹配**[[25]]。
    *   **150**是进阶，用栈来**计算没有优先级**的后缀表达式（逆波兰式），是理解计算器原理的基础[[26]]。
    *   **224/227**是终极挑战，需要处理**运算符优先级和括号**，通常需要双栈（数字栈和运算符栈）来模拟计算过程，是栈应用的集大成者[[27]][[28]]。

4.  **「特殊场景模拟」** (1472, 1209, 1249, 735)
    *   这几道题都是栈在**特定场景下的巧妙应用**：
    *   **1472**：用**双栈模拟浏览器历史记录**，一个栈存后退历史，一个栈存前进未来[[29]]。
    *   **1209**：栈里不光存字符，还存**连续计数**，用来判断是否达到k个重复[[30]]。
    *   **1249**：用栈来**记录无效括号的位置**，最后统一删除，是20题的变种[[31]]。
    *   **735**：用栈来**模拟行星碰撞**，只有相向而行的行星才会碰撞，同向的相安无事[[32]]。

---

### 📈 最佳刷题顺序推荐

我强烈建议你按这个顺序来刷，从易到难，循序渐进：

1.  **第一步：掌握基础匹配 (20)**
    *   从**20. 有效的括号**开始。这是所有栈应用的基础，先学会最简单的匹配逻辑。

2.  **第二步：理解结构转换 (232)**
    *   然后做**232. 用栈实现队列**。理解如何用栈模拟队列的行为，掌握“双栈”和“元素倒腾”的思想。

3.  **第三步：学习极值辅助栈 (155 -> 716)**
    *   接着攻克**155. 最小栈**，学会用辅助栈记录极值。
    *   之后挑战**716. 最大栈**，它是155的进阶版，处理逻辑更复杂。

4.  **第四步：征服表达式处理 (150 -> 224/227)**
    *   然后做**150. 逆波兰表达式求值**，学习用栈计算表达式。
    *   最后完成**224/227. 基本计算器**系列，这是栈在表达式处理上的终极考验。

5.  **第五步：挑战特殊应用 (1209 -> 1249 -> 735 -> 1472)**
    *   先做**1209. 删除相邻重复II**，学习栈内存储额外信息（计数）。
    *   再做**1249. 移除无效括号**，它是20题的升级版。
    *   然后做**735. 小行星碰撞**，模拟一个有趣的物理过程。
    *   最后用**1472. 设计浏览器历史**收尾，理解栈如何模拟现实中的行为。

### 💡 总结一下

可以把这9道题看作一个**栈应用的完美进阶图谱**：
*   **20**是入门，掌握栈的**基本匹配**功能。
*   **155/232**是基础应用，学习**辅助栈**和**结构转换**。
*   **150/224/227**是核心能力，攻克**表达式处理**这个难点。
*   **1209/1249/735/1472**是灵活运用，解决各种**有趣的实际问题**。

按这个顺序刷下来，你会对栈的理解有一个质的飞跃，再遇到栈相关的问题都能触类旁通。祝你刷题顺利，早日通关！

---
## 哈希

这9道LeetCode题目覆盖了**哈希表、数组操作、设计类问题**等多个核心领域，都是面试中非常高频的题目。我来帮你梳理一下它们的核心考点、内在联系，并给你一个科学的刷题顺序。

### 🧠 快速分类与核心思想

| 题目 | 核心考点 | 数据结构 | 关键技巧 |
| :--- | :--- | :--- | :--- |
| **1. 两数之和 (Two Sum)** | 哈希查找 | 哈希表 | 利用哈希表实现O(1)查找，空间换时间[[1]][[2]] |
| **146. LRU缓存 (LRU Cache)** | 数据结构设计 | 哈希表 + 双向链表 | 哈希表快速访问，链表维护使用顺序[[3]][[4]] |
| **128. 最长连续序列** | 哈希集合 | 哈希集合 | 利用集合快速判断元素是否存在，寻找序列起点[[5]][[6]] |
| **73. 矩阵置零 (Set Matrix Zeroes)** | 空间优化 | 数组 | 利用矩阵首行首列作为标记，实现O(1)空间[[7]][[8]] |
| **380. O(1)时间插入、删除和获取随机元素** | 数据结构设计 | 数组 + 哈希表 | 数组保证随机访问，哈希表实现快速查找[[9]][[10]] |
| **49. 字母异位词分组 (Group Anagrams)** | 哈希映射 | 哈希表 | 将排序后的字符串作为键进行分组[[11]][[12]] |
| **350. 两个数组的交集 II** | 哈希计数 | 哈希表 | 统计元素出现次数，取最小值[[13]][[14]] |
| **299. 猜数字游戏 (Bulls and Cows)** | 哈希计数 | 数组/哈希表 | 分别统计位置相同和仅值相同的数字[[15]][[16]] |
| **348. 设计井字棋 (Design Tic-Tac-Toe)** | 状态记录 | 数组 | 记录每行、每列、对角线的累计值[[17]][[18]] |

---

### 🔗 内在联系与核心思想

这9道题可以分成三大类，它们的核心思想都是**哈希表（Hash Table）的灵活运用**：

1.  **「哈希查找与计数」** (1, 128, 350, 299, 49)
    *   这是最经典的哈希表应用场景。核心思想是利用哈希表实现**O(1)时间的快速查找和频率统计**。
    *   **两数之和 (1)** 是入门题，教你如何用哈希表存储遍历过的值，快速查找`target - current`是否存在[[19]]。
    *   **最长连续序列 (128)** 是技巧题，它教你如何利用哈希集合（HashSet）快速判断一个数是否存在，并巧妙地只从序列的起点开始扩展，保证O(n)时间复杂度[[20]][[21]]。
    *   **两个数组的交集 II (350)** 和 **猜数字游戏 (299)** 都是哈希计数的典型应用，一个统计元素出现次数，一个统计位置和值的匹配情况[[22]][[23]]。
    *   **字母异位词分组 (49)** 则展示了如何**创造性地设计哈希表的键（Key）**。不是用原字符串，而是用排序后的字符串或字符计数数组作为键，将异位词映射到同一个分组[[24]][[25]]。

2.  **「数据结构设计」** (146, 380, 348)
    *   这类问题要求你**组合多种数据结构**，设计一个满足特定操作复杂度要求的类。
    *   **LRU缓存 (146)** 是这类题目的巅峰之作。它要求`get`和`put`操作都是O(1)时间。解决方案是结合**哈希表（快速查找）** 和**双向链表（维护使用顺序）**。哈希表指向链表节点，访问时把节点移到链表头部，淘汰时从尾部删除[[26]][[27]]。
    *   **O(1)时间插入、删除和获取随机元素 (380)** 的设计同样巧妙。它结合了**数组（支持随机访问）** 和**哈希表（记录元素索引，支持快速查找和删除）**。删除时用最后一个元素覆盖要删除的元素，然后更新索引并弹出末尾，保证了O(1)时间[[28]][[29]]。
    *   **设计井字棋 (348)** 的思路是**状态记录**。不必存储整个棋盘，而是为每个玩家记录每行、每列和两条对角线的累计分数。每次落子后检查是否有某条线的绝对值达到n，即可判断胜负，实现了O(1)时间的`move`操作[[30]][[31]]。

3.  **「空间优化技巧」** (73)
    *   **矩阵置零 (73)** 单独成一类，它教你一种非常重要的**空间优化技巧**。常规思路是用两个Set记录需要置零的行和列（O(m+n)空间）。而进阶解法利用矩阵的第一行和第一列来作为标记位，从而将空间复杂度优化到O(1)[[32]][[33]]。

---

### 📈 最佳刷题顺序推荐

我建议你按这个顺序来刷，从易到难，循序渐进，逐步建立知识体系：

1.  **第一步：掌握哈希基础 (1, 350, 299)**
    *   从 **1. 两数之和** 开始。这是所有哈希应用的起点，先学会最基本的“空间换时间”思想。
    *   然后做 **350. 两个数组的交集 II**，学习如何使用哈希表进行计数和频次统计。
    *   接着做 **299. 猜数字游戏**，它是350题的变种，增加了“位置”的维度，帮你巩固哈希计数的应用。

2.  **第二步：理解哈希键设计 (49)**
    *   攻克 **49. 字母异位词分组**。这道题能极大地开阔你的思路，让你明白哈希表的键可以不是原始数据，而是经过转换的、能代表数据某种特征的形态。

3.  **第三步：挑战数据结构设计 (380, 146, 348)**
    *   先做 **380. O(1)时间插入、删除和获取随机元素**。它“数组+哈希表”的设计思想相对直观，是进入设计类题目的良好过渡。
    *   然后挑战 **146. LRU缓存**。这是设计题中的经典，理解并实现它会对你的数据结构设计能力有一个质的提升。
    *   最后完成 **348. 设计井字棋**。它的思路更数学化，是另一种设计思维的体现。

4.  **第四步：攻克空间优化与巧妙思维 (128, 73)**
    *   先做 **128. 最长连续序列**。这道题的巧妙之处在于通过判断`num-1`是否存在来找到序列起点，避免重复计算，非常考验思维。
    *   最后用 **73. 矩阵置零** 收尾，学习如何利用现有空间进行标记，完成极致的空间优化。

### 💡 总结一下

可以把这9道题看作一个**哈希表应用的完美图谱**：
*   **1/350/299**是基础应用，学习**查找与计数**。
*   **49**是思维提升，学习**如何设计哈希键**。
*   **380/146/348**是综合能力，学习**组合数据结构完成复杂设计**。
*   **128/73**是技巧升华，学习**空间优化和巧妙的问题转化**。

按这个顺序刷下来，你会对哈希表和相关数据结构的理解有一个质的飞跃。祝你刷题顺利，早日拿下这些高频题！

---
## 堆

这12道LeetCode题目完美覆盖了**堆（Heap）**、**双指针**、**滑动窗口**和**数据结构设计**等核心算法思想。它们的内在联系非常紧密，很多题都是“一题多解”或“多题一解”的典范。

让我帮你把它们梳理清楚，并给你一个最高效的刷题顺序。

### 🧠 核心思想与分类

这12道题可以清晰地分为四大类，它们的核心思想都是**如何高效地维护和获取极值（最大值/最小值/中位数）**：

| 题目 | 核心考点 | 关键数据结构/技巧 | 难度 |
| :--- | :--- | :--- | :--- |
| **347. 前K个高频元素** | 哈希计数 + 堆 | 最小堆（维护Top K） | 中等 |
| **692. 前K个高频单词** | 哈希计数 + 堆 + 自定义排序 | 最小堆（维护Top K） | 中等 |
| **973. 最接近原点的K个点** | 堆 / 快速选择 | 最大堆（维护Top K）或排序 | 中等 |
| **295. 数据流的中位数** | 双堆维护中位数 | **两个堆（最大堆+最小堆）** | 困难 |
| **23. 合并K个升序链表** | 多路归并 | **最小堆（K指针）** | 困难 |
| **264. 丑数 II** | 多指针动态规划 | 三指针（类似多路归并） | 中等 |
| **378. 有序矩阵中第K小的元素** | 二分查找 / 堆 | 最小堆（多路归并变种） | 中等 |
| **88. 合并两个有序数组** | 双指针 | 从后向前填充 | 简单 |
| **1086. 前五科的均分** | 哈希 + 堆 / 排序 | 最小堆（维护Top 5） | 简单 |
| **767. 重构字符串** | 贪心 + 堆 | **最大堆（按频率贪心）** | 中等 |
| **1438. 绝对差不超过限制的最长连续子数组** | 滑动窗口 + 单调性 | **单调队列 / TreeMap** | 中等 |
| **895. 最大频率栈** | 哈希嵌套 + 堆 | 最大堆（频率+时间戳） | 困难 |

---

### 🔗 内在联系与思想升华

这12道题看似不同，实则环环相扣，核心思想一脉相承：

1.  **「堆（Heap）的极致应用」**
    *   **347, 692, 973, 1086** 是同一类题——**Top K 问题**。它们教你如何用**一个堆（通常是大小为K的最小堆或最大堆）** 来高效维护当前最优的K个元素，避免全局排序的O(n log n)开销[[1]][[2]][[3]]。
    *   **295. 数据流的中位数** 是堆应用的巅峰。它要求你同时维护**两个堆（一个最大堆，一个最小堆）**，分别存储数据流的一半，从而动态地、高效地获取中位数[[4]][[5]][[6]]。
    *   **23. 合并K个升序链表** 和 **378. 有序矩阵中第K小的元素** 是 **“多路归并”** 的经典问题。它们都使用一个最小堆来同时跟踪多条链表或多个数组的当前头部元素，每次取出最小的，从而实现高效合并[[7]][[8]][[9]]。

2.  **「指针与窗口的巧妙移动」**
    *   **88. 合并两个有序数组** 是双指针的入门题，但它巧妙地**从后向前填充**，避免了额外空间[[10]][[11]]。
    *   **264. 丑数 II** 本质上是**三指针动态规划**。它维护三个指针，分别代表下一个丑数可以乘以2、3、5的基底位置，思路与多路归并异曲同工[[12]][[13]][[14]]。
    *   **1438. 绝对差不超过限制的最长连续子数组** 是滑动窗口的进阶题。它要求窗口内的任意两数差都小于limit，关键在于用**单调队列（或TreeMap）** 来动态维护窗口内的最大值和最小值，从而高效判断窗口是否合法[[15]][[16]][[17]]。

3.  **「特殊数据结构设计」**
    *   **767. 重构字符串** 和 **895. 最大频率栈** 都是设计类题目，要求你设计数据结构来满足特定操作。
        *   **767** 要求相邻字符不同，解法是**用最大堆按频率贪心**，每次取剩余最多的字符，如果和上一个相同就取次多的[[18]][[19]]。
        *   **895** 要求弹出频率最高的元素（频率相同则取最晚入栈的），需要巧妙设计**哈希表记录频率**和**栈的映射关系**。

---

### 📈 最佳刷题顺序推荐

我强烈建议你按以下顺序攻关，从易到难，逐步搭建知识体系：

1.  **第一步：掌握基础双指针与堆 (88, 1086, 973)**
    *   从最简单的 **88. 合并两个有序数组** 开始，熟悉双指针操作。
    *   然后做 **1086. 前五科的均分**，学习如何用堆（或排序）为每个学生维护Top 5的成绩。
    *   接着做 **973. 最接近原点的K个点**，巩固Top K问题的堆解法。

2.  **第二步：攻克经典的Top K问题 (347, 692)**
    *   先做 **347. 前K个高频元素**，这是Top K问题的标准模板。
    *   然后做它的变种 **692. 前K个高频单词**，学习如何处理频率相同时的自定义排序（按字母序）。

3.  **第三步：体验多路归并与指针魔法 (23, 264, 378)**
    *   先做 **264. 丑数 II**，理解三指针的动态规划思想，相对直观。
    *   然后挑战 **23. 合并K个升序链表**，这是面试超级高频题，掌握用堆实现多路归并。
    *   最后做 **378. 有序矩阵中第K小的元素**，它是23题的二维变种，可以用堆或二分查找求解。

4.  **第四步：挑战滑动窗口与堆的进阶应用 (1438, 767)**
    *   先做 **1438. 绝对差不超过限制的最长连续子数组**，学习用单调队列维护窗口极值。
    *   然后做 **767. 重构字符串**，学习用贪心+堆来解决排列问题。

5.  **第五步：征服数据结构设计（895, 295)**
    *   先做 **895. 最大频率栈**，设计一个满足特殊弹出规则的数据结构。
    *   最后用 **295. 数据流的中位数** 收尾，这是堆应用的集大成者，彻底理解双堆的精妙之处。

### 💡 总结一下

可以把这12道题看作一个**围绕“堆”和“指针”的完整知识树**：
*   **88/1086/973** 是基础，学习**基本的堆操作和双指针**。
*   **347/692** 是核心，掌握**经典的Top K问题模板**。
*   **23/264/378** 是进阶，学习**多路归并和指针技巧**。
*   **1438/767** 是延伸，探索**堆和滑动窗口在复杂场景下的应用**。
*   **895/295** 是巅峰，挑战**复杂的数据结构设计能力**。

按照这个路径，你不仅能高效通过面试，更能真正理解这些算法思想的内在美和实用性。祝你刷题愉快，一举拿下！