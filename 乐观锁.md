---
aliases:
  - 版本号
  - CAS
---
### 核心思想
假设前提：**数据在并发访问时冲突的概率很低**
在此前提下的举动：
- 读取数据时不加锁
- 在更新数据时，检查自读取后数据是否已被其他操作修改。
	- 如果未被修改，则更新成功；
	- 否则，根据策略（如重试、报错）处理冲突
### 适合场景
- **读多写少**、
- **数据冲突概率低**（操作数据库的时间短）的场景（如计数器、评论点赞）。
### 实现方式
#### 版本号法
![[Pasted image 20251119105949.png]]
![[Pasted image 20251119110021.png]]


**实现步骤**

1. **添加版本字段**：在数据库表和对应的实体类中，添加一个用于版本控制的字段（例如 `version`）。在JPA中，使用 `@Version`注解标记该字段
    
	    ```
	    @Entity
	    public class Product {
	        @Id
	        private Long id;
	        private String name;
	        private Integer stock;
	        @Version // 标识为版本字段
	        private Integer version;
	        // ... getters and setters
	    }
	    ```
    
2.  **更新时检查**：当执行更新操作（如 `entityManager.merge(entity)`）时，JPA/Hibernate会自动在UPDATE语句的WHERE条件中包含版本号检查
    
	    ```
	    -- 生成的SQL类似这样
	    UPDATE product SET stock = 10, version = version + 1 WHERE id = 1 AND version = 1;
	    ```
3. **处理冲突**：如果上述SQL执行后影响的行数为0，意味着在本次更新之前，该条数据已经被其他事务修改（版本号已变化）。此时，JPA会抛出 `OptimisticLockException`异常，你需要捕获这个异常并决定如何处理，例如提示用户或自动重试。
#### [[CAS]]法(版本号法的加强)

### 乐观锁局限性与解决方式

| **ABA问题**​ | 这是CAS机制的一个经典问题：一个变量值从A变为B，后又变回A。CAS操作会误以为它没有变化。**解决方案**是使用带有版本号（或时间戳）的原子引用类，如 `AtomicStampedReference`。 |
| ---------- | ------------------------------------------------------------------------------------------------------- |
| **冲突处理**​  | 乐观锁在更新时可能失败。**必须**有相应的冲突处理策略，例如**有限次数的重试**、向用户抛出友好错误等。没有重试机制的乐观锁在实际应用中价值有限。                             |
| **适用场景**​  | 最适合**读多写少**、**冲突概率较低**的场景。在这种情况下，它避免了加锁的开销，能显著提升系统吞吐量。反之，在写操作非常频繁、冲突严重的场景下，大量的重试会消耗CPU资源，性能可能不如悲观锁。     |
| **范围限制**​  | 版本号机制通常针对单条数据记录。CAS操作通常只能保证一个共享变量的原子操作。如果需要同时检查多个变量，可能需要将它们合并到一个对象中，并使用 `AtomicReference`。              |


#### 实现有限次数重试---**Resilience4j**库使用
Resilience4j是一个轻量级的容错库，重试只是其功能之一。

- **添加依赖**：
    
    
    ```
    <dependency>
        <groupId>io.github.resilience4j</groupId>
        <artifactId>resilience4j-retry</artifactId>
    </dependency>
    ```
    
- **配置并使用**：
    ```
    import io.github.resilience4j.retry.Retry;
    import io.github.resilience4j.retry.RetryConfig;
    
    public class Resilience4jDemo {
        public static void main(String[] args) {
            // 1. 创建重试配置
            RetryConfig config = RetryConfig.custom()
                    .maxAttempts(3) // 最大尝试次数（包括第一次）
                    .waitDuration(Duration.ofSeconds(1)) // 重试间隔
                    .retryOnException(e -> e instanceof RuntimeException) // 只对RuntimeException重试
                    .build();
    
            // 2. 创建Retry实例
            Retry retry = Retry.of("myRetry", config);
    
            // 3. 使用Retry装饰你的业务逻辑（这里使用Supplier包装）
            String result = retry.executeSupplier(() -> {
                // 你的业务逻辑
                if (Math.random() < 0.7) {
                    throw new RuntimeException("Resilience4j 模拟异常");
                }
                return "Success";
            });
            System.out.println(result);
        }
    }
    ```
#### 原子性更新多个字段--[[AtomicReference]]
版本号机制通常针对单条数据记录。CAS操作通常只能保证一个共享变量的原子操作。如果需要同时检查多个变量，可能需要将它们合并到一个对象中，并使用 `AtomicReference`。

#### 避免ABA问题--[[AtomicStampedReference]]