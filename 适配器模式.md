[[继承 接口的三种具体应用]]
### 适配器模式

#### 代表什么？

​**核心思想：将一个类的接口转换成客户端期望的另一个接口。适配器让那些由于接口不兼容而不能一起工作的类可以一起工作。​**​

- ​**接口的角色**​：目标接口是客户端期望的格式。适配器类实现这个目标接口，并内部持有一个被适配者（需要被转换的对象）的引用，将目标接口的方法调用“**翻译**”成对被适配者接口的调用。
- ​**模式结构**​：
    - ​**目标接口**​：客户端希望使用的接口。
    - ​**被适配者**​：已经存在的、功能强大但接口不兼容的类。
    - ​**适配器**​：实现了目标接口，并包装了被适配者，**在目标接口的方法中调用被适配者的方法**。

#### 实际生活生产中的意义

​**意义：解决兼容性问题，让“旧”东西能在“新”系统中继续发挥作用，保护现有投资，促进协作。​**​

​**生活例子：电源转换器**​  
你从中国带了一个笔记本电脑（**被适配者**，三脚插头）到欧洲旅行，但欧洲的墙上的插座（**客户端**，只接受两脚圆形插头）不兼容。你买了一个**电源转换器（适配器）​**。这个转换器的一端是符合欧洲标准的两脚插头（实现了**目标接口**），另一端是接受中国三脚插孔的插座。转换器在内部将电力标准进行转换，让你的电脑能正常工作。

​**生产例子：系统集成与遗留代码复用**​

- 公司新开发了一套系统，规定所有数据访问都必须通过新的 `NewDataAccessInterface` (**目标接口**)。
- 但系统中有一个几年前写的、非常稳定可靠的 `LegacyDataReader` 类 (**被适配者**)，它的方法名是 `getData()`，与新的接口方法 `fetch()` 不匹配。
- 这时你可以创建一个 `LegacyDataAdapter` 类 (**适配器**)，实现 `NewDataAccessInterface`。在它的 `fetch()` 方法内部，去调用 `LegacyDataReader` 的 `getData()` 方法。
- 这样，新系统就可以无缝地使用这个老的、可靠的类了，而无需重写它。

​**核心价值**​：​**充当“中间人”或“转换器”，解决接口不兼容问题，是系统演进和集成中的粘合剂。​**