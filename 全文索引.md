---
aliases:
  - 倒排索引
---
- 需求背景：在全文索引出现之前，用户若想在文章库中搜索包含“数据库优化”的内容，只能使用低效的 SQL `LIKE`操作
	- 无法利用索引，需要全表扫描
- 解决措施：全文索引，即倒排索引
	- 高性能检索：从“扫描全部文档”变为词典。
	- 相关度排序：结果按与查询关键词的**相关性高低**智能排序，而非随机或按时间。
	- 丰富的查询语义：支持布尔逻辑、短语搜索、通配符、模糊搜索、同义词扩展等高级语法
	- 灵活的分词与语言处理：​可根据语言特性分词，支持词干提取、同义词库、停用词过滤等，提升搜索召回率和准确性。
---
实现方式
- 实现基础：
	- **分词器**：将文本切分为有意义的词元，支持多语言，是全文索引的“大脑”。
	- **倒排索引**：存储“词项-文档”映射的核心数据结构。
	- **相关度评分算法**：如 TF-IDF、BM25，用于计算查询与文档的匹配度。
- 工作机制：
	  假设有两篇文档：
		文档1：`I love databases and SQL optimization.`
		文档2：`SQL performance tuning is crucial.`
	1. 分词：对文本进行分词，移除停用词（如 `I`, `and`, `is`）。
		- 文档1分词后：`[love, databases, SQL, optimization]`
		- 文档2分词后：`[SQL, performance, tuning, crucial]`
	2. 创建倒排列表:为每个词项记录它出现在哪些文档中，以及位置、频率等信息。
		```
		Term        | Document List (Posting List)
		------------|------------------------------
		SQL         | -> (Doc1, pos3), (Doc2, pos1)
		databases   | -> (Doc1, pos2)
		optimization| -> (Doc1, pos4)
		performance | -> (Doc2, pos2)
		tuning      | -> (Doc2, pos3)
		crucial     | -> (Doc2, pos4)
		love        | -> (Doc1, pos1)	   
		```
	3. **索引存储**：将这些倒排列表以高效的数据结构（如跳表、哈希表、B+Tree的组合）存储，形成全文索引。
---

- 使用
	- 创建
		```sql
		-- 方法1：创建表时定义
		CREATE TABLE articles (
		    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
		    title VARCHAR(200) NOT NULL,
		    content TEXT NOT NULL,
		    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
		    -- 为单个字段创建全文索引
		    FULLTEXT (content),
		    -- 为多个字段创建联合全文索引
		    FULLTEXT (title, content)
		) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
		
		-- 方法2：为已存在的表添加全文索引
		ALTER TABLE articles ADD FULLTEXT ft_content (content);
		ALTER TABLE articles ADD FULLTEXT ft_title_content (title, content);
		
		-- 方法3：创建索引时指定配置（如中文分词器）
		ALTER TABLE articles ADD FULLTEXT ft_content_zh (content) WITH PARSER ngram;	  
		```
	- 搜索：
		- 基本搜索模式
			- 适用场景：普通关键词搜索
			- 返回值：返回相关度分数，按相关度排序
			- 语法：
				```
				-- 示例1：简单关键词搜索
				SELECT 
				    id, 
				    title,
				    MATCH(title, content) AGAINST('数据库优化') AS relevance
				FROM articles
				WHERE MATCH(title, content) AGAINST('数据库优化' IN NATURAL LANGUAGE MODE)
				ORDER BY relevance DESC
				LIMIT 10;
				
				-- 示例2：获取相关度分数并排序
				SELECT 
				    *,
				    MATCH(content) AGAINST('MySQL索引性能调优') AS score
				FROM articles
				WHERE MATCH(content) AGAINST('MySQL索引性能调优' IN NATURAL LANGUAGE MODE)
				HAVING score > 0.5  -- 可筛选相关度分数
				ORDER BY score DESC;			  
				```
		- 布尔模式
			- 适用场景：复杂条件筛选
			- 特点：支持操作符（+、-、*、>、<等）
			- 语法：
				```sql
				-- + 必须包含
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);
				-- 结果：必须包含 MySQL，不能包含 Oracle
				
				-- - 必须排除
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('数据库 -MySQL' IN BOOLEAN MODE);
				-- 结果：包含数据库，但不包含 MySQL
				
				-- * 通配符
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('data*' IN BOOLEAN MODE);
				-- 结果：匹配 database、databases、data 等
				
				-- 短语搜索（用双引号）
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('"高性能数据库"' IN BOOLEAN MODE);
				-- 结果：必须精确包含短语"高性能数据库"
				
				-- 组合搜索
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('+MySQL >优化 <安全' IN BOOLEAN MODE);
				-- 结果：必须包含 MySQL，优化增加权重，安全降低权重			  
				```
		- 查询扩展模式
			- 适用场景：提高查全率
			- 特点：自动扩展相关词汇搜索
			- 语法：
				```sql
				-- 当搜索结果太少时，自动扩展相关词汇
				SELECT * FROM articles
				WHERE MATCH(content) AGAINST('数据库索引' WITH QUERY EXPANSION);
				-- 会先搜索"数据库索引"，然后从结果中提取关键词再次搜索
				```
-  ngram 分词器
	- 需求背景：中文没有自然分隔符（如英文的空格），传统分词器无法正确处理
	- 作用：MySQL 为处理**中文、日文、韩文等非空格分隔语言**而设计的内置全文索引分词器。
	- 工作原理：滑动窗口切割，ngram 采用固定大小的滑动窗口对文本进行切分
		```
		文本: "数据库优化"
		n=1: ["数","据","库","优","化"]  # 一元分词
		n=2: ["数据","据库","库优","优化"]  # 二元分词（默认）
		n=3: ["数据库","据库优","库优化"]  # 三元分词
		```
	- 相关配置：
		- 令牌大小/滑动窗口大小（n值）：ngram_token_size
			- 默认值为2
			- **推荐配置策略**：
				- 通用网站：`n=2`
				- 电商产品搜索：`n=2`或 `n=3`
				- 专业文献：`n=3`
				- 短文本/评论：`n=1`或 `n=2`