### SQL操作执行频率
​**如何使用 MySQL 内置的命令来监控数据库中各类 SQL 操作（INSERT, UPDATE, DELETE, SELECT）的执行频率，从而进行性能分析。​**​

```
-- 1. 基本命令：查看所有以 'Com_' 开头的服务器状态变量
SHOW GLOBAL STATUS LIKE 'Com_%';

-- 2. 精准命令（图中所示）：专用于查看 DML(数据操作语言) 的执行次数
SHOW GLOBAL STATUS LIKE 'Com_______'; -- 注意：这里有7个下划线 _
```

​**执行结果示例与解读：​**​

当你执行上述命令后，会得到类似下面的结果集：

|Variable_name|Value|
|---|---|
|`Com_insert`|12345|
|`Com_delete`|5678|
|`Com_update`|23456|
|`Com_select`|98765|

​**核心要点与用途：​**​

1. ​**监控指标**​：通过比较这些数值，你可以快速了解当前数据库的**读写比例**。例如，如果 `Com_select`远高于其他项，说明这是一个**读多写少**的数据库；如果 `Com_update`和 `Com_insert`很高，则说明写操作很频繁。
    
2. ​**性能分析切入点**​：
    
    - 如果 `Com_select`的数值异常高，你需要考虑优化查询语句，或者检查是否缺少有效的索引。
        
    - 如果 `Com_update`和 `Com_insert`很高，你可能需要关注磁盘 I/O、事务大小以及锁竞争的情况。
        
    
3. ​**计算频率**​：你可以在不同时间点执行此命令，通过计算差值来了解**单位时间内**​（如每秒）各种操作的执行次数，从而更精确地掌握数据库的负载变化。
    

​**总结：​**​

这张图介绍的工具是 DBA 和开发人员判断数据库工作负载类型、定位性能瓶颈的第一步。通过分析这些基本操作的执行频次，可以为后续的优化（如增加缓存、优化索引、读写分离等）提供关键的数据支持。
优化以查询为主的数据库


![[Pasted image 20251029201327.png]] 

### 慢查询日志
#### 配置慢查询日志(重启生效)
```sql
show variables like '%quer%';
```
![[Pasted image 20251029201854.png]]

将 slow_query_log 全局变量设置为“ON”状态 ，临时生效，mysql重启后就会失效
```
set global slow_query_log='ON';
```
设置慢查询日志存放的位置
```
set global slow_query_log_file='D:\\kpdata\\DataBase\\Data\\mysql.log';
```
找到mysql的安装目录，找到my.ini文件夹在[mysqld]处加入以下代码开启慢查询，永久有效。
```
#开启慢查询  
slow_query_log = ON  
#log-slow-queries:代表MYSQL慢查询的日志存储目录,此目录文件一定要有写权限；  
log-slow-queries="C:/Program Files (x86)/MySQL/MySQL Server 5.0/log/mysql-slow.log"  
#最长执行时间 (查询的最长时间，超过了这个时间则记录到日志中) .  
long_query_time = 1  
#没有使用到索引的查询也将被记录在日志中  
log-queries-not-using-indexes = ON
```

7、重启服务，查看慢查询开启状态。

#### 直接去文件中看mysql
![[Pasted image 20251029212331.png]]
### profile详情

`SHOW PROFILE`是 MySQL 提供的一个强大的性能诊断工具，它能够**深入分析一条 SQL 语句在执行过程中各个阶段的详细耗时**，帮助开发者精准定位性能瓶颈。

---

#### 一、启用 Profile 功能

在使用前，需要按以下步骤确保该功能已开启：

1. ​**检查是否支持**​：首先确认你的 MySQL 版本支持此功能。
    
    ```
    SELECT @@have_profiling;
    ```
    
    如果返回结果为 `YES`，则表示支持。
    
2. ​**开启功能**​：Profile 功能默认是关闭的，需要在当前会话中开启。
    
    ```
    -- 在当前会话中开启
    SET profiling = 1;
    -- 或者在全局级别开启（需要权限）
    SET GLOBAL profiling = 1;
    ```
    

#### 二、使用 Profile 分析 SQL 耗时

启用后，遵循以下流程进行分析：

1. ​**执行你的业务 SQL**​：
    
    正常执行你想要分析的 SQL 语句。例如：
    
    ```
    SELECT * FROM orders WHERE customer_id = 123 AND create_date > '2023-01-01';
    ```
    
2. ​**查看 SQL 查询列表与总耗时**​：
    
    使用以下命令查看最近执行的所有 SQL 语句及其查询 ID (`Query_ID`) 和总耗时。
    
    ```
    SHOW PROFILES;
    ```
    
    执行结果示例：
    
    |Query_ID|Duration|Query|
    |---|---|---|
    |1|0.00015000|SELECT * FROM user WHERE id = 1|
    |2|0.00234500|SELECT * FROM orders WHERE ... (你的慢SQL)|
    
    从这里找到你关心的那条 SQL 对应的 `Query_ID`。
    
3. ​**详细分析指定 SQL 的执行阶段**​：
    
    使用获取到的 `Query_ID`进行深入分析。
    
    - ​**查看各阶段耗时**​：这是最常用的命令，可以查看该 SQL 在**每个执行阶段（如解析、优化、执行、锁等待、数据传送等）的耗时**。
        
        ```
        SHOW PROFILE FOR QUERY 2; -- 这里的 2 是上一步查到的 Query_ID
        ```
        ![[Pasted image 20251029212609.png]]
        结果会显示类似 `starting`, `checking permissions`, `Opening tables`, `System lock`, `Sending data`等阶段的耗时，耗时最长的阶段就是主要性能瓶颈。
        
    - ​**查看 CPU 使用情况**​：
        
        ```
        SHOW PROFILE CPU FOR QUERY 2;
        ```
        ![[Pasted image 20251029212632.png]]
        此命令会额外显示各阶段对 CPU 资源的占用情况。
        
    

#### 核心要点与使用场景总结

- ​**目的**​：精准定位慢 SQL 的性能瓶颈到底出现在哪个环节（是优化器问题？锁等待太久？还是数据传送慢？）。
    
- ​**流程**​：`开启功能 -> 执行SQL -> SHOW PROFILES 获取ID -> SHOW PROFILE ... FOR QUERY [ID] 查看详情`。
    
- ​**应用场景**​：在 SQL 优化过程中，当发现某条语句执行缓慢时，使用此工具可以替代盲目猜测，进行有依据的优化。
    

通过以上步骤，你可以像使用“性能分析仪”一样，清晰地了解 SQL 语句执行的内部细节，从而进行有效的优化。


### explain执行计划

`EXPLAIN`是 MySQL 提供的强大工具，用于**模拟 MySQL 优化器如何执行一条 SQL 查询语句**。通过分析它的返回结果，可以了解查询的执行细节，从而对查询语句或数据库结构进行优化。

---

#### 核心语法与用法

使用方法极其简单：在需要分析的 `SELECT`语句前加上 `EXPLAIN`或 `DESC`关键字即可。

```
-- 两种方式等效
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件；

-- 或者
DESC SELECT 字段列表 FROM 表名 WHERE 条件；
```

#### 执行计划字段解析（关键）

执行 `EXPLAIN`后，MySQL 会返回一个表格，包含若干重要字段。图中示例 `EXPLAIN SELECT * FROM tb_user WHERE id = 1;`的结果展示了这些字段的值，它们是分析性能的关键：

| 字段                  | 含义              | 解读与重要性                                                                                                                                 |
| ------------------- | --------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| ​**id**​            | 查询的序列号          | 表示查询中执行 `SELECT`子句或操作表的顺序。id 越大，优先级越高。                                                                                                 |
| ​**select_type**​   | 查询的类型           | 常见值：`SIMPLE`（简单查询，无子查询或UNION）、`PRIMARY`（最外层查询）、`SUBQUERY`（子查询）等。用于判断查询的复杂度。                                                            |
| ​**table**​         | 正在访问的表名         | 显示数据来自于哪张表。                                                                                                                            |
| ​**partitions**​    | 匹配的分区           | 如果表创建了分区，此字段显示查询命中的分区。                                                                                                                 |
| ​**type**​          | ​**访问类型**​      | ​**这是判断查询效率的极其重要的指标！​**​ 常见值（性能从优到劣）：`system`> `const`（主键访问、唯一索引查询）> `eq_ref`> `ref`> `range`> `index`> `ALL`（全表扫描，需优化）。               |
| ​**possible_keys**​ | 可能使用的索引         | 显示MySQL能使用哪些索引来查找记录。                                                                                                                   |
| ​**key**​           | ​**实际使用的索引**​   | 显示MySQL**最终决定**使用的索引。如果为 `NULL`，则表示未使用索引。                                                                                              |
| ​**key_len**​       | 索引使用的字节数        | 表示索引中使用的字节数，可用于判断索引是否被完全利用。在不损失精度的情况下越短越好                                                                                              |
| ​**ref**​           | 索引的引用           | 显示使用索引时，是与哪些列或常量进行比较。                                                                                                                  |
| ​**rows**​          | ​**预估需要读取的行数**​ | 一个非常关键的指标。MySQL 估算找到所需记录需要读取的行数。​**这个值越小越好**。                                                                                          |
| ​**filtered**​      | 按条件过滤后剩余行的百分比   | 表示存储引擎返回的数据在服务器层过滤后，剩下多少满足查询。表示返回的结果占需读取函数的百分比，值越大越好                                                                                   |
| ​**Extra**​         | ​**额外信息**​      | 包含不适合在其他列显示但十分重要的额外信息。如 `Using where`（使用WHERE过滤）、`Using index`（使用了覆盖索引，性能好）、`Using temporary`（使用临时表，需优化）、`Using filesort`（使用文件排序，需优化）。 |

#### 如何使用 EXPLAIN 进行性能优化？

1. ​**查看是否使用索引**​：检查 `key`字段。如果为 `NULL`，说明是**全表扫描**，需要为查询条件建立索引。
    
2. ​**检查索引使用效率**​：查看 `type`字段。如果值为 `ALL`或 `index`，通常意味着性能不佳，需要考虑优化索引或查询语句。
    
3. ​**评估查询成本**​：关注 `rows`字段。这个数值越大，说明查询需要扫描的数据越多，性能越差。
    
4. ​**发现潜在问题**​：查看 `Extra`字段。如果出现 `Using temporary`或 `Using filesort`，尤其是在大表查询中，这通常是性能瓶颈的信号，需要优化。
    

​**总结来说，`EXPLAIN`执行计划是 SQL 优化的“诊断报告”​**。学会解读其中关键字段（尤其是 ​**type, key, rows, Extra**）的含义，是提升数据库查询性能的关键第一步。