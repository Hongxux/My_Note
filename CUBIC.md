

---

### 1. 核心定义、定位与关系

- ​**核心定义**​：CUBIC (CUBIC TCP) 是一种用于**高速、长距离网络**​ (High-Speed and Long-Distance Networks) 的 ​**TCP 拥塞控制算法**。它的核心创新在于，其拥塞窗口 (Congestion Window, cwnd) 的增长函数是一个关于**时间**的三次函数 (Cubic function)，即 W(t)=C(t−K)3+Wmax​，而不再是传统TCP（如Reno）那样基于**ACK事件**的线性增长。
    
- ​**定位**​：它是 Linux 内核（自 2.6.19 版本起）的**默认 TCP 拥塞控制算法**，旨在解决传统 TCP（如 NewReno）在高带宽延迟积 (Bandwidth-Delay Product, BDP) 网络中带宽利用率低的问题。其设计目标是：​**高可扩展性、高稳定性、良好的 RTT 公平性**​（与相同RTT的流之间）和**TCP友好性**​（与标准TCP流共存时）。
    
- ​**关系**​：
    
    - ​**与标准TCP的关系**​：它是标准TCP（如Reno、NewReno）的演进和替代方案，旨在保持向后兼容性的同时，更好地利用现代网络基础设施的巨大容量。
        
    - ​**与BIC/TCP的关系**​：CUBIC是之前BIC-TCP算法的简化、改进和增强版本。BIC-TCP通过二分搜索寻找最大窗口，其窗口增长曲线类似三次函数，但CUBIC用数学函数明确表达了这一增长，逻辑更清晰，实现更简单。
        
    - ​**在协议栈中的位置**​：它是传输层TCP协议实现的一部分，位于操作系统内核中，负责动态调整cwnd，是TCP可靠性传输和流量控制的基石之一。
        
    

---

### 2. 触发条件与使用情景

- ​**触发条件**​：
    
    - ​**主要触发**​：当发生**丢包**​（连续收到3个重复ACK或超时重传计时器RTO到期）时，CUBIC会像其他基于丢包的算法一样，进入拥塞避免阶段，执行**乘法减小**​ (Multiplicative Decrease, MD)。
        
    - ​**持续运行**​：在**非拥塞状态**下，CUBIC始终根据其三次函数计算窗口大小，这个过程是持续进行的，由时钟驱动而非ACK驱动。
        
    
- ​**使用情景**​：
    
    - ​**高速大带宽网络**​：如数据中心网络、科研网络（ESnet）、跨大陆海底光缆等任何高BDP环境。
        
    - ​**默认配置**​：绝大多数现代Linux发行版，这意味着大部分互联网服务器之间的通信默认使用CUBIC。
        
    - ​**需要高吞吐量的长肥管道**​：如大规模数据传输、视频流服务器、云服务备份等。
        
    

---

### 3. 工作原理与具体实现

CUBIC的核心思想是：在发生拥塞后，记录丢包时的窗口大小 Wmax​，然后将窗口快速恢复到 Wmax​附近，随后在其附近进行“探索”以寻找新的最大可用带宽。

1. ​**三次增长函数**​：
    
    窗口大小 W是自上一次拥塞事件后时间 t的函数：
    
$$
    W(t)=C(t−K)^3+Wmax​ 
$$
    其中：
	-   C：一个缩放常数，控制增长的激进程度。
    - t：距离上一次窗口减小的时间。
    - Wmax​：上一次发生拥塞时的窗口大小。
    - K：函数达到 Wmax​所需的时间，计算公式为 ![[Pasted image 20250923212737.png]]​​。(β是乘法减小因子，通常为0.7)
        
    
2. ​**工作阶段**​：
    
    - ​**凹性增长**​ (Concave Growth)：当 W(t)<Wmax​时，函数增长加速，旨在**快速**逼近之前的最大窗口。
        
    - ​**凸性增长**​ (Convex Growth)：当 W(t)>Wmax​时，函数增长放缓，进入**探索**阶段，缓慢地超过 Wmax​以探测是否有新的可用带宽。这种“慢启动”避免了过于激进的增长。
        
    
3. ​**TCP友好慢启动**​：
    
    为了与标准TCP公平竞争，在连接建立初期或长时间空闲后，CUBIC会使用和标准TCP相同的**慢启动**算法，指数级增长窗口，直到发生丢包。
    
4. ​**关键技术点**​：
    
    - ​**时间驱动而非数据驱动**​：窗口增长由时间决定，与RTT解耦，从而在不同RTT的流之间获得更好的公平性。
        
    - ​**窗口计算**​：在每个ACK到达时，CUBIC并非直接增加cwnd，而是根据上述公式计算“目标窗口”。如果当前cwnd小于目标窗口，则cwnd被设置为目标窗口；否则保持原有增长逻辑。
        
    

---

### 4. 预防措施、解决措施与潜在问题

- ​**预防/解决措施（即CUBIC的设计目标就是为了解决以下问题）​**​：
    
    - ​**低带宽利用率**​：通过三次函数快速恢复和高可扩展性，有效填充高BDP管道。
        
    - ​**RTT不公平性**​：传统AIMD TCP中，RTT小的流窗口增长更快，抢占更多带宽。CUBIC的时间驱动特性使其增长与RTT无关，实现了更好的**RTT公平性**。
        
    - ​**TCP友好性**​：通过 β因子执行乘法减小，并包含TCP友好慢启动，确保在与NewReno等流共存时不会“饿死”对方。
        
    
- ​**潜在问题**​：
    
    - ​**缓冲区膨胀**​ (Bufferbloat)：CUBIC旨在填满网络管道，如果网络中间设备（如路由器）的缓冲区非常大，CUBIC会填满这些缓冲区，导致所有流的数据包经历极高的排队延迟。​**这不是CUBIC的独有问题，是所有基于丢包的拥塞控制算法的通病**。解决方案需要结合**基于延迟的算法**​（如BBR）或**主动队列管理**​（AQM，如CoDel）。
        
    - ​**在浅缓冲区环境中表现**​：在某些缓冲区很小的网络中，CUBIC可能无法充分施展其高吞吐能力。
        
    - ​**延迟敏感应用**​：由于其激进性，可能会引入较高的排队延迟，对实时游戏、视频会议等低延迟应用不友好。
        
    

---

### 5. 面试官可能关心的方面与答案

​**Q1: 为什么需要CUBIC？标准TCP（如Reno）在高BDP网络中有什么问题？​**​

​**A:​**​ 标准TCP使用AIMD，其窗口增长速度为每RTT增加1个MSS。在高速网络中，RTT很大，窗口增长极其缓慢。例如，要维持10Gbps的速率，窗口大小可能需要上万报文。从拥塞中恢复时，Reno需要上千个RTT才能爬升回原有速率，导致链路利用率极低。CUBIC通过其快速的三次增长，能在数十个RTT内恢复，极大提升了利用率。

​**Q2: CUBIC是如何实现RTT公平性的？​**​

​**A:​**​ CUBIC的核心增长是**时间驱动**的。窗口大小是时间 `t`的函数 W(t)=C(t−K)3+Wmax​。无论流的RTT是10ms还是100ms，在距离上一次拥塞事件相同的时间点 `t`，它们计算出的目标窗口大小是相同的。因此，它们的增长曲线一致，从而实现了RTT公平性。而Reno是每RTT增长1，RTT小的流单位时间内经历的RTT多，因此窗口增长更快，导致不公平。

​**Q3: CUBIC中的 `β`因子是什么？作用是什么？​**​

​**A:​**​ `β`是**乘法减小因子**​（通常为0.7或0.8）。当检测到拥塞时（收到3个DupACK），CUBIC不会像Reno那样将窗口减半，而是设置为 `cwnd = cwnd * β`。这是一个更温和的减小策略，避免了窗口的剧烈抖动，提高了算法的稳定性，同时它也是保持与标准TCP友好性的关键参数。

​**Q4: CUBIC和BBR的主要区别是什么？​**​

​**A:​**​ 这是一个非常经典的高级问题。

|特性|CUBIC|BBR|
|---|---|---|
|​**控制理念**​|​**基于丢包**​ (Loss-Based)|​**基于模型**​ (Model-Based)|
|​**探测信号**​|丢包|传输延迟 (RTT) 和交付速率 (Delivery Rate)|
|​**目标**​|填满缓冲区，最大化吞吐量|避免填满缓冲区，工作在**带宽延迟积**​ (BDP) 点，最小化延迟|
|​**对缓冲区膨胀**​|敏感，会加剧问题|不敏感，旨在规避问题|
|​**公平性**​|RTT公平性好|收敛性公平性好|

​**Q5: 如何查看和修改Linux系统当前的拥塞控制算法？​**​

​**A:​**​ 这考察你的动手能力。

- ​**查看当前算法**​：
    
    ```
    sysctl net.ipv4.tcp_congestion_control
    ```
    
- ​**查看可用算法**​：
    
    ```
    ls /lib/modules/$(uname -r)/kernel/net/ipv4/tcp_*.ko
    ```
    
- ​**修改算法（例如改为BBR）​**​：
    
    ```
    echo "bbr" > /proc/sys/net/ipv4/tcp_congestion_control
    ```
    
    或永久修改，在 `/etc/sysctl.conf`中添加：
    
    ```
    net.ipv4.tcp_congestion_control = bbr
    ```
    

希望这份详尽且专业的介绍能帮助你彻底理解CUBIC协议。祝你学习顺利！