---
aliases:
  - 基于游标的分页
---


|特性维度|传统分页|滚动分页|
|---|---|---|
|**交互方式**​|显示页码和上一页/下一页按钮，支持跳转|通过滚动到页面底部自动加载更多内容|
|**数据加载**​|离散式，按页加载，每页数据独立|流式，内容连续不断地追加|
|**技术核心**​|基于 **页码 (Page)**​ 和 **每页大小 (Size)**​|基于 **游标 (Cursor)**​ 或 **时间戳**​|
|**性能表现**​|**深分页性能差**​ (如跳转到第1000页)，因为需要计算和跳过大量前置数据|**性能稳定**，不受“深度”影响，每次只取下一页的数据|
|**数据一致性**​|易受数据增删影响，可能导致重复或遗漏|数据一致性更好，通常在查询上下文中保持一致|
|**用户体验**​|**可控性强**，易于定位和跳转，但交互不连贯|**沉浸感强**，浏览体验流畅，但无法直接跳转到特定位置|
|**适用场景**​|后台管理系统、电商商品列表、需要精确定位的搜索页面|社交媒体信息流（如朋友圈、微博）、新闻推送、内容流|

---

### 💡 深入理解技术原理

表格对比了核心差异，下面我们深入看看它们背后的技术逻辑，这能帮助你更好地进行技术选型和问题排查。

#### **传统分页的关键与瓶颈**
![[Pasted image 20251122141402.png]]
![[Pasted image 20251122134740.png]]
传统分页在数据库查询中通常使用 `OFFSET ... LIMIT`语法。当你请求第 _n_页，每页 _size_条数据时，数据库需要先计算出前 _(n-1)*size_条数据，然后“跳过”它们，再返回接下来的 _size_条 。

- **深分页问题**：这正是其性能瓶颈所在。请求第100页（`OFFSET 990`）和第1000页（`OFFSET 9990`）的代价差异巨大。数据库需要跳过的数据越多，查询速度越慢，资源消耗也越大 。
    
- **数据变动问题**：如果在你浏览过程中，第一页有数据被删除，那么整个列表会向前“移动”，可能导致你翻到第二页时看到一条原本在第一页末尾的数据（重复）。反之，新增数据可能导致某些数据被“挤”到下一页而被遗漏 。
    

#### **滚动分页如何实现高效**

![[Pasted image 20251122134914.png]]
滚动分页（或叫游标分页）不使用页码和偏移量，而是使用一个**标记**（在图中即lastId）（游标）来记录上次查询的位置。下一次查询时，直接从这个标记之后开始获取数据 。

- **游标的选择**：这个游标通常是**唯一的、有序的**字段，例如数据的自增ID、创建时间戳等。
	- MySQL查询语句类似于 `WHERE id > last_seen_id ORDER BY id ASC LIMIT size`。
	- Redis查询语句（采用ZSet数据结构）![[Pasted image 20251122141730.png]]![[Pasted image 20251122142234.png]]
		- max
			- 第一页：当前时间戳
			- 之后：上一次分页结果的最小时间戳
		- count：你每一页的个数
		- offset：在上一次分页，有几个和最小时间戳一样的时间戳，就跳过几个
    
- **性能优势**：由于使用了索引字段（如ID）进行过滤和排序，数据库可以非常快速地定位到数据开始的位置，无需扫描和跳过任何前置记录。因此，无论你“翻”到多“深”，每次查询的效率都几乎一样高 。
    
- **数据一致性**：在许多实现中（如ElasticSearch的Scroll API），初次查询会创建一个数据快照，在游标有效期内，即使底层数据发生变化，也不会影响当前遍历的结果，有效避免了传统分页的数据跳动问题 。
    

### 🎯 如何选择适合的分页策略

了解了原理后，你可以根据具体场景做出选择：

#### **选择传统分页，如果**：

- 用户需要**快速定位到特定范围**，例如直接跳转到第50页查看某个商品。
	
- 应用于**后台管理系统**，需要明确的页码信息进行数据管理和审计 。
	
- 数据量**相对固定且不大**，深分页的性能问题不突出。
        



#### **选择滚动分页（无限滚动），如果**：


- 核心目标是**用户的沉浸式浏览体验**，如社交媒体动态、新闻推送、商品瀑布流 。
	
- 数据是**实时更新**的流式数据，且顺序浏览是主要方式。
	
- 数据量非常**庞大**，需要避免深分页带来的性能风险 。
	
    

### 🔄 混合策略与最佳实践

在实际应用中，也可以考虑混合使用两种策略，以兼顾不同的需求。

一种常见的混合模式是：**初始加载使用滚动分页，但在侧边栏或底部提供一个传统的页码跳转工具**。这样既保证了主流浏览体验的流畅性，又为有精确查找需求的用户提供了入口。

此外，对于一些特殊场景，还有更优化的方案：

- **大数据量导出**：对于需要导出大量数据的场景，ElasticSearch等引擎提供了 **Scroll API**​ 或 **Search After**​ 机制，它们都是滚动分页思想的高级实现，适合深度遍历大量数据。
    
- **搜索引擎结果页**：通常会结合使用两种方式，先提供有限的页码导航（如1-10页），超过一定深度后（如第100页后）可能建议用户细化搜索条件而不是继续深度翻页，这也是对性能和用户体验的一种平衡。
    

希望这些详细的解释能帮助你更好地理解和应用传统分页与滚动分页。根据你的具体业务场景，选择最合适的那一个，或者巧妙地结合它们，就能打造出既高效又用户体验良好的应用。

如果你有特定的使用场景，我很乐意和你一起探讨更具体的实现方案。