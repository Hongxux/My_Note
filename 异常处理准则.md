### Java异常处理最佳实践指南

（用工程师的思维避免常见陷阱）

---

#### 🔍 ​**1. 异常不是流程控制工具**​

​**黄金法则**​：异常处理成本是条件检查的**34倍**​

```
// 错误示范：用异常代替空栈检查
try { stack.pop(); } 
catch (EmptyStackException e) { /* 耗时21秒/千万次 */ }

// 正确做法：前置条件检查
if (!stack.isEmpty()) stack.pop();  // 耗时0.6秒/千万次
```

> 📌 适用场景：文件突然被删除、网络连接中断等**真正意外**的情况

---

#### 🧩 ​**2. 拒绝碎片化try-catch**​

​**问题代码**​（过度拆解）：

```
for (int i=0; i<100; i++) {
    try { n = stack.pop(); } catch(EmptyStackException e) {...}
    try { out.writeInt(n); } catch(IOException e) {...}
}
```

​**优化方案**​（任务级封装）：

```
try {
    for (int i=0; i<100; i++) {
        n = stack.pop();
        out.writeInt(n);
    }
} catch (EmptyStackException | IOException e) {
    // 统一处理：终止任务并记录
    log.error("任务失败", e);
}
```

> 📌 核心思想：​**一个完整业务单元 = 一个异常处理边界**​

---

#### 🌳 ​**3. 善用异常继承树**​

​**三类异常处理原则**​：

|异常类型|使用场景|典型案例|
|---|---|---|
|​**自定义受检异常**​|业务可预见的错误|`PaymentFailedException`|
|​**标准非受检异常**​|参数校验失败|`IllegalArgumentException`|
|​**原始异常转换**​|封装底层异常为业务语义|捕获`SQLException`→ 抛出`DataAccessException`|

​**危险操作**​：

```
catch (Throwable e) {...}  // 吞噬所有错误，包括OutOfMemoryError!
```

---

#### 🚫 ​**4. 禁止吞噬异常**​

​**典型反模式**​：

```
public Image loadImage(String path) {
    try { ... } 
    catch (Exception e) { /* 静默吞噬！ */ } 
}
```

​**后果**​：

- 资源泄漏（文件句柄/DB连接未释放）
    
- 调试噩梦（错误被隐藏）
    

​**正确姿势**​：

```
catch (IOException e) {
    log.error("图片加载失败: {}", path, e);  // 记录原始异常
    throw new ResourceLoadException("加载失败", e);  // 转换语义
}
```

---

#### 💥 ​**5. 错误发生时需果断**​

​**对比两种处理策略**​：

```
// 妥协方案（返回null）
public Object pop() {
    return isEmpty() ? null : realPop(); 
}  // 后续调用可能触发NullPointerException

// 推荐方案（快速失败）
public Object pop() {
    if (isEmpty()) throw new EmptyStackException();
    return realPop();
}
```

> 📌 早崩溃 = 早发现 = 早修复

---

#### 📤 ​**6. 允许异常向上传播**​

​**典型案例**​：

```
// 不必羞于声明throws
public void processFile(String filename) throws IOException {
    try (InputStream in = new FileInputStream(filename)) {
        parseContent(in);  // 可能抛出IOException
    }
}

// 调用方处理更合适
public static void main(String[] args) {
    try {
        processFile("data.txt");
    } catch (IOException e) {
        userDialog.showError("文件处理失败");  // 用户交互层处理
    }
}
```

> 📌 分层原则：底层抛异常 → 高层处理

---

#### 🛡️ ​**7. 参数校验标准化**​

​**Java标准校验API**​：

```
public void update(int index, Object value) {
    // 一行完成参数校验
    Objects.checkIndex(index, data.length);    // 下标越界检查
    Objects.requireNonNull(value, "值不能为空"); // NPE检查
    ...
}
```

> 自动生成标准错误信息：
> 
> `Index 5 out of bounds for length 3`

---

#### 👥 ​**8. 用户界面安全原则**​

​**错误处理对比**​：

```
// 危险做法（暴露堆栈）
catch (DatabaseException e) {
    userUI.showMessage(e.toString()); 
    // 可能显示：com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException...
}

// 安全做法
catch (Exception e) {
    log.error("数据库错误", e);  // 完整日志给开发者
    userUI.showMessage("系统繁忙，请稍后重试"); // 友好提示给用户
}
```

> 📌 OWASP建议：避免向用户暴露**框架版本/SQL语句/文件路径**​

---

### 终极哲学：异常是**契约**而非负担

> “好的异常设计如同消防演习：
> 
> 平时不见踪影，危难时精准响应” —— 遵循这些原则，让你的代码既健壮又优雅！