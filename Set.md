Redis 的 Set（集合）是一个非常有用的数据结构，它最核心的特点就是**无序且元素唯一**。这意味着你不能有重复的成员，并且集合中的元素没有固定的顺序。它支持高效的成员判断和丰富的集合运算，是解决很多实际问题的利器。

为了让你快速建立整体认知，下面这个表格概括了 Set 类型的核心特征。

|特性维度|说明|
|---|---|
|**数据特征**|无序的字符串集合，元素唯一，不可重复|
|**核心操作**|支持集合内的增删改查，以及多个集合间的**交集、并集、差集**等运算|
|**底层实现**|根据元素类型和数量，动态采用 **intset（整数集合）**或 **hashtable（哈希表）**|
|**经典场景**|标签系统、共同好友、抽奖、唯一性控制（如防重复投票）|

### 🔩 核心命令与使用示例

Set 的命令非常直观，主要围绕对元素和集合的操作。

- **元素操作**
    
    - **`SADD key member [member ...]`**：向集合添加一个或多个元素。已存在的元素会被忽略。
        
    - **`SREM key member [member ...]`**：从集合中移除一个或多个元素。
        
    - **`SISMEMBER key member`**：判断指定元素是否是集合的成员。存在返回 `1`，不存在返回 `0`。
        
    - **`SCARD key`**：获取集合中元素的数量。
        
    - **`SMEMBERS key`**：返回集合中的所有成员。**⚠️注意**：如果集合很大，此命令可能会阻塞服务，应使用 `SSCAN`进行渐进式遍历。
        
    - **`SPOP key [count]`**：随机**移除并返回**集合中的一个或多个元素。适用于抽奖等场景。
        
    - **`SRANDMEMBER key [count]`**：随机**返回**集合中的一个或多个元素，但**不移除**它们。适用于随机展示。
        
    
- **集合运算**
    
    - **`SINTER key [key ...]`**：计算所有给定集合的**交集**。
        
    - **`SUNION key [key ...]`**：计算所有给定集合的**并集**。
        
    - **`SDIFF key [key ...]`**：计算第一个集合与其他所有集合的**差集**（即存在于第一个集合，但不在其他任何集合中的元素）。
        
    - **`SINTERSTORE`/`SUNIONSTORE`/`SDIFFSTORE`**：将对应的交集、并集、差集结果**存储到一个新的集合中**。
        
    - **`SMOVE source destination member`**：将指定元素从源集合**移动**到目标集合。
        
    

**示例：基础操作与集合运算**

```
# 1. 添加元素并查看
127.0.0.1:6379> SADD tags:article:1001 "tech" "database" "redis"
(integer) 3
127.0.0.1:6379> SMEMBERS tags:article:1001
1) "database"
2) "tech"
3) "redis"

# 2. 判断元素是否存在
127.0.0.1:6379> SISMEMBER tags:article:1001 "ai"
(integer) 0

# 3. 集合运算：共同标签（交集）
127.0.0.1:6379> SADD tags:article:1002 "redis" "cloud"
(integer) 2
127.0.0.1:6379> SINTER tags:article:1001 tags:article:1002
1) "redis"

# 4. 随机弹出元素（抽奖）
127.0.0.1:6379> SADD lottery "user:1001" "user:1002" "user:1003"
(integer) 3
127.0.0.1:6379> SPOP lottery
"user:1002"
```

### ⚙️ 底层实现原理

Set 的高效性源于其智能的底层编码切换机制。

- **intset（整数集合）**
    
    - **触发条件**：当集合中的**所有元素都是整数值**，并且**元素数量不超过 `set-max-intset-entries`配置的值（默认 512）**时使用。
        
    - **结构**：是一块连续的内存空间，元素按值的大小有序存储。这种结构**内存效率极高**，因为不需要存储额外的指针。
        
    
- **hashtable（哈希表）**
    
    - **触发条件**：当集合中包含**非整数值**，或者**元素数量超过 `set-max-intset-entries`阈值**时，会自动转换为 hashtable。
        
    - **结构**：也就是字典（dict）。每个键（key）就是一个集合元素，而值（value）全部被设置为 `NULL`。这种实现支持 O(1) 时间复杂度的查找、插入和删除。
        
    

这种设计使得 Redis 能够在满足条件时，优先使用更节省内存的 intset；当条件不满足时，则切换到功能更强大、性能依旧优秀的 hashtable。

### 💡 主要应用场景

1. **标签系统**
    
    这是 Set 最典型的应用。可以为每个对象（如文章、用户）打上标签，然后轻松地通过集合运算找到具有共同标签的对象，实现关联推荐。
    
    - **添加标签**：`SADD article:1001:tags "java" "redis"`
        
    - **查找共同标签**：`SINTER user:1001:interested_tags article:1001:tags`
        
    
2. **唯一性控制与去重**
    
    利用 Set 元素的唯一性，可以防止重复行为，例如确保每个用户只能投票一次，或者统计网站的独立访客数。
    
    - **用户投票**：`SADD votes:article:1001 user:2001`（返回值若为 0，则表示该用户已投过票）
        
    - **统计独立IP**：`SADD daily_ips 192.168.1.1`
        
    
3. **社交关系**
    
    轻松实现共同关注、共同好友等功能。
    
    - **共同关注**：`SINTER user:1001:followings user:1002:followings`
        
    
4. **随机抽奖与推荐**
    
    使用 `SPOP`可以进行公平抽奖（抽中即移除），使用 `SRANDMEMBER`则适合随机展示内容（不破坏原集合）。
    
5. **黑名单/白名单**
    
    使用 `SISMEMBER`可以快速判断一个用户或 IP 是否在名单内，实现快速拦截或放行。
    

### ⚠️ 重要注意事项

1. **谨慎使用 `SMEMBERS`**：对于包含大量元素的 Set，使用 `SMEMBERS`命令可能会因为返回数据量过大而阻塞 Redis 服务并占用大量网络带宽。应优先使用 `SSCAN`命令进行游标式的增量迭代。
    
2. **警惕大集合运算的阻塞风险**：Set 的差集、并集和交集的计算复杂度较高。在数据量巨大的情况下，如果直接执行这些计算（特别是涉及多个大集合时），可能会导致 Redis 实例暂时阻塞。对于此类聚合统计，可以考虑在从库上执行，或者将数据返回给客户端，由客户端来完成计算。
    
3. **无序性**：Set 中的元素是无序的。如果你需要保持插入顺序或按分数排序，应考虑使用 **List**或 **ZSet（有序集合）**。
    

希望这份详细的介绍能帮助你深入理解并高效运用 Redis 的 Set 类型！