- 需求背景：生产者的可靠性需要感知以下两种情况
	1. **消息未到达交换机**：由于网络闪断、RabbitMQ Broker 异常重启，或生产者指定的交换机不存在，可能导致消息根本未能送达 RabbitMQ 服务器。此时，生产者无法感知此次发送已失败
	2. **消息无法路由到队列**：消息成功到达交换机，但可能因为路由键错误、没有匹配的绑定，或者没有任何队列绑定到该交换机，导致消息无法被正确路由到任何队列。如果没有相应机制，消息会被直接丢弃，生产者同样无法知晓
- 存在三种情况：
	- 没有到达交换机
	- 到达交换机，但是交换机路由失败
	- 到达交换机，并且成功路由到消息队列
- 解决措施：生产者确认机制，识别到底是哪种情况
	- Publisher-Confirm (ConfirmCallback)回调
		- 作用：用于判断消息是否到达交换机
		- 回调触发的条件：消息被Rabbit接受后回调
		- 返回结果
			- ack(true): 消息已成功到达交换机
			- nack(false): 消息未能到达交换机，通常会附带原因 (cause)
	- Publisher-Return (ReturnCallback)回调
		- 作用：消息到达交换机后，用于判断是否被成功路由到消息队列
		- 回调触发的条件：路由失败了才会发生回调
		- 返回结果：返回消息本身、回复码、回复文本、交换机名和路由键等信息，说明路由失败的具体原因（如 `NO_ROUTE`)
- 使用方式：在 Spring Boot 中开启并配置生产者确认机制，需要以下几个步骤：
1. **基础配置（application.yml）**
    在配置文件中启用相关功能，这是最基础也是必需的一步。
    ```
    spring:
      rabbitmq:
        # ... (其他连接配置，如host, username, password等)
        publisher-confirm-type: correlated  # 开启异步确认回调
        publisher-returns: true             # 开启消息退回模式
        template:
          mandatory: true                   # 必须设置为true，ReturnCallback才会生效
    ```
    其中，`publisher-confirm-type`通常设置为 `correlated`以实现异步回调，这是最常用的方式。
2. **配置 RabbitTemplate 的回调**
    你需要配置一个 `RabbitTemplate`Bean，并为其设置回调函数来处理确认结果。
    ```
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.amqp.rabbit.connection.ConnectionFactory;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    @Configuration
    public class RabbitMQConfig {
    
        @Bean
        public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
            RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
            rabbitTemplate.setMandatory(true); // 确保消息退回机制生效
    
            // 设置 ConfirmCallback
            rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
                if (ack) {
                    System.out.println("ConfirmCallback: 消息成功到达交换机! 消息ID: " + 
                      (correlationData != null ? correlationData.getId() : "unknown"));
                } else {
                    System.err.println("ConfirmCallback: 消息未能到达交换机! 消息ID: " + 
                      (correlationData != null ? correlationData.getId() : "unknown") + ", 原因: " + cause);
                    // 此处应进行重试或记录日志等逻辑
                }
            });
    
            // 设置 ReturnsCallback (Spring AMQP 2.3+ 推荐使用此方式替代旧的 ReturnCallback)
            rabbitTemplate.setReturnsCallback(returned -> {
                System.err.println("ReturnsCallback: 消息路由到队列失败！回应码: " + 
                  returned.getReplyCode() + ", 原因: " + returned.getReplyText() + 
                  ", 交换机: " + returned.getExchange() + ", 路由键: " + returned.getRoutingKey());
                // 此处应处理路由失败的消息
            });
            return rabbitTemplate;
        }
    }
    ```
    
1. **发送消息时关联标识**
    在发送消息时，务必提供 `CorrelationData`对象。这个对象携带了一个唯一标识（如消息ID），以便在回调中能够准确识别是哪条消息的确认结果。
    ```
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendMessage() {
        String message = "Hello, RabbitMQ!";
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString()); // 唯一标识
        rabbitTemplate.convertAndSend("your_exchange", "your_routing_key", message, correlationData);
    }
    ```
    
