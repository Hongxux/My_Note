
- **联合索引**​：一个索引包含多个列。
- 好处：
	- 节约磁盘：创建一个 `(a, b, c)` 的联合索引，相当于间接创建了 `(a)`、`(a, b)` 两个索引。
	- 加速多条件查询：对于 `WHERE a = ? AND b = ?` 这样的查询，联合索引可以一次性过滤掉大量数据，效率远高于两个单列索引。
	- 避免排序： 如果查询的 `ORDER BY` 子句的列和顺序与联合索引完全一致，且没有中断，那么MySQL可以直接利用索引的有序性，避免额外的文件排序（filesort）操作，从而大幅提升性能 。例如，`ORDER BY a, b` 就可以利用 `idx(a, b, c)`
	- 避免回表查询：合理的联合索引设计能避免回表查询
- 生效前提：
	- 索引过滤生效前提：满足[[最左前缀法则]]
	- 索引排序生效前提：查询扫描的索引区间内保持有序即可
		- 查询排序和索引排序不一致的时候
			- 默认是按照ASC正序排序
			- 如果**单字段**排序要求`DESC`，MySQL 会利用 B+Tree 的有序性，反向遍历索引的叶子节点链表，此时仍然利用**索引排序**，只是多一层“反向遍历” 的逻辑开销
			- 如果是**多字段**混合排序，查询排序方向与索引排序**方向不一致**，会无法利用索引排序（触发文件排序）
				- 例如：索引是`a ASC, b ASC`，查询是`ORDER BY a DESC, b ASC`（混合正倒序），此时无法反向遍历实现，会触发文件排序；
				- 而单字段（如`total_amount`）的正 / 倒序切换，通过反向遍历即可实现，不影响索引排序使用。
		- 例如，当`a`固定、`b`用范围查询时，扫描到的所有`c`虽然不是全局有序，但在「`a`固定 +`b`范围区间」内是按`c`排序的（因 B+Tree 的层级排序特性），因此`ORDER BY c`可直接利用索引有序性，避免额外的「文件排序（Using filesort）」。
- 建立联合索引的索引列顺序：
	- 等值字段＞过滤字段＞范围字段
	- 高选择性字段优先， **选择性低不代表无用，只要能有效缩小索引扫描范围，就有必要纳入**
		- **选择性极低**（如仅 2 个值，占比 99% 和 1%），此时纳入索引会增加索引长度（降低扇出数），且无法有效缩小扫描范围（筛选占比 99% 的值时，扫描条目数几乎无变化），则**不建议纳入**
---
工作模式：![[Pasted image 20251030212910.png]]
- 底层结构：B+Tree：
- 键值的组织方式： 联合索引B+Tree节点中存储的键值，是由创建索引时指定的多个列的值拼接而成的。
- 排序规则（至关重要）： 联合索引的排序遵循严格的字典序
	- 先按照最左边字段排序，接着依次往后排序（排序优先级）
