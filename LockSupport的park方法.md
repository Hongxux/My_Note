---
aliases:
  - park
  - unpack
---
- 需求背景：`Object.wait()/notify()``
	- 无需获取锁 ：`Object.wait()/notify()`必须在 `synchronized`同步块中先获得锁
		- 性能降低（等待锁和竞争锁上下文切换消耗性能）
		- 可能导致死锁
	- 调用顺序固定：先notify后wait会导致唤醒丢失
		- 导致程序无限等待和死锁
	- 需要精确唤醒指定的线程：`notify()`随机唤醒一个，`notifyAll()`唤醒所有，不够精确
		- 导致惊群效应
- 解决方案：LockSupport的park/unpack方法
	- 暂停当前线程：Locksupport.park();
	- 恢复某个线程的运行：Locksupport.unpark(暂停线程对象)
- 实现基础：Packer对象，每个线程都有自己的一个
	- `_mutex`：互斥锁，用于保护 `_counter`等状态
		- 使用原因：需要确保同一时间只有一个线程能操作 Parker 的内部状态。
			- Packer内的counter和cond是共享变量
			- 在park和unpark的操作中，有先检查后操作的过程（存在竞态条件）
	- `_cond`：与特定线程绑定的条件变量
		- 当线程需要等待（park）时，就在这个条件变量上休眠
		- 当需要唤醒（unpark）其他线程时，就通过这个条件变量发送信号
	- `_counter`：一次性许可，只有0和1，
		- 不可累加，也不可过度消费
			- 连续多次调用 `unpark`并不会让许可累积。
			- 连续多次调用 `park`只会消费掉一个许可
				- 后续的 `park`调用依然会等待
- 实现原理：维护一个每个线程独立的变量--许可
	- 使用前提：打断标记为false
		- 打断标记为true的时候，park会失效 
	- 初始值：0（标记为无许可）
	- 更新：
		- 添加许可：调用 `unpark(Thread thread)`方法
			- 如果thread在等待，则唤醒thread
			- 如果thread在运行，则为thread这个线程添加许可（标记为有许可）
				- 用于该线程以后调用park消耗许可
		- 尝试消费许可：调用 `park()`方法
			- 调用时有许可
				- 它会立即消费该许可并返回，线程继续执行
			- 调用时没有许可
				- 当前线程进入等待状态，WAITING
				- 进入等待状态，直到发生以下三种情况之一
					1. 有其他线程调用本线程的 `unpark`方法，使得许可可用。
					2. 有其他线程中断（interrupt）了本线程。
						- 当因线程被中断而导致 `park`返回时，它**不会抛出 `InterruptedException`**，但线程的中断状态会被设置。
							- 因此，通常需要在 `park`返回后检查中断状态并做相应处理。
					3. 调用不合逻辑地（毫无理由地）返回（这种情况通常与底层操作系统调度有关，比较罕见）
- 工作流程：
	- 当线程调用 `LockSupport.park()`时​
		1. 首先，它会原子性地将 `_counter`的值置为 0，并检查其旧值。
		2. 如果旧值 大于 0（通常为 1）:在该线程调用 `park`之前，已经有其他线程为它调用了 `unpark`（发放了许可）
		    
		3. 如果旧值等于 0:表示没有可用的许可，线程需要等待，被系统挂起
			- 线程会获取内部的互斥锁。
			- 线程会再次检查（例如，检查中断状态），
			- 然后调用 `pthread_cond_wait`之类的函数，在**条件变量**上等待，并释放互斥锁。
		4. 当线程被唤醒（通常
			- 唤醒触发：
				- 由其他线程调用 `unpark`触发
				- 有其他线程中断（interrupt）了本线程。
				- 调用不合逻辑地（毫无理由地）返回（这种情况通常与底层操作系统调度有关，比较罕见）
			- 后续操作：原子性地修改`_counter`，然后继续操作 
				1. 它会重新获取互斥锁
				2. 并将 `_counter`再次置为 0，
				3. 然后释放锁，
				4. 继续执行。
	- 当其他线程调用 `LockSupport.unpark(Thread thread)`时
		1. 它会找到目标线程关联的 `Parker`对象。
		2. 获取内部的互斥锁。
		3. 将 `_counter`的值设置为 1。
		4. 然后，检查目标线程是否正在条件变量上等待（即是否已经处于 park 状态）。如果是，则通过 `pthread_cond_signal`等函数唤醒在条件变量上等待的目标线程。
		5. 释放互斥锁。
- 两种模式：
	- 先park再unpark
	- 先unpark再park