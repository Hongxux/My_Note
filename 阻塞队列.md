---
aliases:
  - Blocking Queue
---
## JDK实现的阻塞队列
### 分类
| 队列实现                       | 核心特性                                                           | 适用场景                            |
| -------------------------- | -------------------------------------------------------------- | ------------------------------- |
| **ArrayBlockingQueue**​    | **有界队列**，基于数组，FIFO（先进先出），可选公平策略<br><br>。                       | 需要明确限制队列大小以防止资源耗尽的场景，如固定大小的任务池。 |
| **LinkedBlockingQueue**​   | **可选有界**（默认`Integer.MAX_VALUE`，近乎无界），基于链表，FIFO<br><br>。        | 生产者和消费者速度不均，需要高吞吐量的通信场景。        |
| **PriorityBlockingQueue**​ | **无界队列**，支持优先级排序（自然顺序或自定义`Comparator`）<br><br>。                | 需要按优先级处理任务的场景，如系统告警级别。          |
| **SynchronousQueue**​      | **不存储元素**，每个插入操作必须等待对应的移除操作<br><br>。                           | 直接传递任务的场景，吞吐量较高<br>。            |
| **DelayQueue**​            | **无界队列**，元素只有在指定的延迟时间到期后才能被取出<br><br>。                         | 定时任务调度、缓存过期失效。                  |
| **LinkedTransferQueue**​   | **无界队列**，多了`transfer`和`tryTransfer`方法，实现更灵活的生产者-消费者交互<br><br>。 | 当生产者希望等待消费者接收元素后再继续执行的场景        |
###  核心 API 与操作行为

阻塞队列提供了一系列方法，这些方法在队列状态不同时（满或空）表现出四种不同的行为，这是使用它的关键。

1. **抛出异常**
    
    - `add(e)`: 插入元素，成功返回`true`，**队列满时抛出**​ `IllegalStateException。
        
    - `remove()`: 移除并返回队首元素，**队列空时抛出**​ `NoSuchElementException。
        
    - 通常不推荐在并发编程中使用，因为异常会中断正常的控制流。
        
    
2. **返回特殊值**
    
    - `offer(e)`: 插入元素，成功返回`true`，**队列满时返回**​ `false。
        
    - `poll()`: 移除并返回队首元素，**队列空时返回**​ `null`
        。
        
    - `peek()`: 返回队首元素（不移除），队列空时返回`null。
        
    - **非常常用**，适合在无法等待时进行快速失败的操作。
        
    
3. **无限期阻塞**
    
    - `put(e)`: 插入元素，**如果队列满，则阻塞当前线程，直到有空间可用**。
        
    - `take()`: 移除并返回队首元素，**如果队列空，则阻塞当前线程，直到有新元素加入。
        
    - 这是实现经典生产者-消费者模式的核心方法。
        
    
4. **超时等待**
    
    - `offer(e, timeout, timeUnit)`: 尝试插入元素，在指定的超时时间内阻塞等待，超时后返回`false。
        
    - `poll(timeout, timeUnit)`: 尝试获取元素，在指定的超时时间内阻塞等待，超时后返回`null。
        
    - 提供了阻塞和灵活性之间的平衡，避免线程永久等待。
    - 
### 示例:
```
import java.util.concurrent.*;

public class ProducerConsumerExample {
    public static void main(String[] args) {
        // 创建一个容量为10的阻塞队列作为缓冲区
        BlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(10);

        // 生产者线程
        Runnable producer = () -> {
            int value = 0;
            while (true) {
                try {
                    // 生产数据
                    buffer.put(value);
                    System.out.println("Produced: " + value);
                    value++;
                    // 模拟生产耗时
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        };

        // 消费者线程
        Runnable consumer = () -> {
            while (true) {
                try {
                    // 消费数据。如果队列为空，此方法会阻塞等待
                    Integer value = buffer.take();
                    System.out.println("Consumed: " + value);
                    // 模拟消费耗时
                    Thread.sleep(1500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        };

        // 启动生产者和消费者线程
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```
### 问题：
1. 内存限制：使用的是JVM内存
2. 数据安全：服务宕机，订单信息会丢失


## 使用Lock与Condition (ReentrantLock)

这种方式提供了比 `synchronized`更灵活的控制，例如可以创建多个条件变量实现“精确唤醒”。
```
import java.util.concurrent.locks.*;

public class LockConditionExample {
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();  // 队列“未满”条件
    private final Condition notEmpty = lock.newCondition(); // 队列“非空”条件
    private final Object[] items = new Object[100];
    private int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await(); // 队列已满，生产者等待在notFull条件上
            }
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            count++;
            notEmpty.signal(); // 生产了一个元素，唤醒一个等待在notEmpty（消费者）线程
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await(); // 队列为空，消费者等待在notEmpty条件上
            }
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            count--;
            notFull.signal(); // 消费了一个元素，唤醒一个等待在notFull（生产者）线程
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```
与 `synchronized`的 `wait()`/`notifyAll()`相比，`Condition`的 `await()`/`signal()`可以**精确控制唤醒哪种条件的线程**，避免了无效的线程竞争，提升了性能。