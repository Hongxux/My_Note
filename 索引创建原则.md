
#### 阶段一：索引创建决策——是否要建？
- **问题背景：** 创建和维护索引的具有开销
- **核心问题**：这个表真的需要索引吗？
- **判断标准**：[[判断 MySQL 索引方案合理性与有效性]]
- **结论**：如果两者都满足，则进入下一阶段；否则，暂不创建索引，避免不必要的开销。
#### 阶段二：索引字段选择——为谁建？
- **目标字段**：选择在查询中真正发挥作用的字段。
    - **查询条件**：常出现在 `WHERE`子句中的字段。
    - **排序操作**：常用于 `ORDER BY`的字段。
    - **分组操作**：常用于 `GROUP BY`的字段。
- **质量评估**：在候选字段中，优先选择**高区分度**的字段。
    - **计算方法**：`SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;`
    - **经验值**：比率越接近1，索引效果越好（如唯一标识符）；低于0.1则效果较差（如状态、类型字段）。
#### 阶段三：索引结构设计——如何建？

1. 字段选型：是否选对「高价值字段」
	- 优先选择：高频查询条件（WHERE）、高频排序（ORDER BY）、高频分组（GROUP BY）字段（通过慢查询日志统计Top N字段）；
	- 避免选择：低价值字段（如查询频率极低、过滤效率极差的字段）、大字段（如TEXT、VARCHAR(255)以上，未做优化直接纳入索引）。
2. 结构设计：是否遵循「最优结构原则」
	- **单列索引 vs 联合索引**：优先联合索引（遵循最左前缀法则），避免“多个单列索引”的无效冗余（InnoDB仅支持索引合并，效率低于联合索引）；
	- **联合索引字段顺序**：严格遵循「等值查询字段 > 精准过滤字段 > 范围查询字段 > 返回字段」「高选择性字段 > 低选择性字段」，最大化过滤效率和排序效率；
	- **长字段优化**：若包含长字段，需采用「字段轻量化」「前缀索引」「字典表映射」等方法，控制索引条目长度 ≤ 30字节（保障扇出数）；[[ 降低索引长字段负面影响的核心方法]]
	- **特殊索引选型**：仅等值查询用哈希索引（或手动哈希优化），范围/排序查询禁用；唯一长字符串用前缀索引，枚举长字符串用字典表。
 3. 冗余控制：是否无无效/重复索引
	- 重复索引：如`(a)`与`(a,b)`（前者是后者的最左前缀，重复无效）；
	- 无效索引：从未被使用的索引（可通过`sys.schema_unused_indexes`视图排查）；
	- 核心：单表索引数量 ≤ 6个，避免索引冗余导致的存储浪费和维护开销。

#### 阶段四：索引成本控制——如何管？
- **数量控制**：索引并非越多越好。每个索引都会带来写操作（INSERT/UPDATE/DELETE）的维护成本。定期审查并删除未使用或重复的索引。
- **约束优化**：为索引列添加 `NOT NULL`约束，这能为查询优化器提供更明确的信息，有助于生成更优的执行计划。
- **持续监控**：使用数据库提供的性能分析工具（如 MySQL 的 EXPLAIN命令或 Slow Query Log）定期分析索引的有效性，并进行调整。
    


