- 基础知识：常见双指针算法分为三类，同向（即两个指针都相同一个方向移动），背向（两个指针从相同或者相邻的位置出发，背向移动直到其中一根指针到达边界为止），相向（两个指针从两边出发一起向中间移动直到两个指针相遇）
- 背向双指针：(基本上全是回文串的题)

- Leetcode 409. Longest Palindrome
- Leetcode 125. Valid Palindrome (I、II)
- Leetcode 5. Longest Palindromic Substring
- Leetcode 647. Palindromic Substrings

- 相向双指针：(以two sum为基础的一系列题)

- Leetcode 1. Two Sum （排序后用双指针）
- Leetcode 15. 3Sum
	- 枚举第一个数` nums[left] `，转化为target =`-nums[left]` 的二数求和问题，避免重复就是枚举的一个数和前一个数相等则跳过。
	- 优化：
		- 如果` nums[left] `和` nums[left+1] `` nums[left+2] `（left后最小两个数字）加起来>0 说明此时最小的三个数字加起来都大于0，不可能再找到等于0的三元组，则跳出循环
		- 如果` nums[left] `和` nums[numSize-1] `` nums[numSize-2] `（left后最大两个数字）加起来<0 说明此时三元组累加不可能等于0，则跳出循环
- Leetcode 16. 3Sum Closest
	-
- Leetcode 18. 4Sum
- Leetcode 454. 4Sum II
- Leetcode 277. Find the Celebrity
- Leetcode 11. Container With Most Water
- Leetcode 186 Reverse Words in a String II

- 同向双指针：（个人觉得最难的一类题，可以参考下这里 [TimothyL：Leetcode 同向双指针/滑动窗口类代码模板](https://zhuanlan.zhihu.com/p/390570255)）

- Leetcode 283. Move Zeroes
- Leetcode 26. Remove Duplicate Numbers in Array
- Leetcode 395. Longest Substring with At Least K Repeating Characters
- Leetcode 340. Longest Substring with At Most K Distinct Characters
- Leetcode 424. Longest Repeating Character Replacement
- Leetcode 76. Minimum Window Substring
- Leetcode 3. Longest Substring Without Repeating Characters
- Leetcode 1004 Max Consecutive Ones III
- Leetcode 1658 Minimum Operations to Reduce X to Zero

### 相向双指针
根据我搜索到的资料，双指针算法是解决数组和链表问题的重要技巧，主要通过两个指针的协同移动来降低时间复杂度。你列出的这些题目在应用场景、技巧和难度上既有区别也有联系，存在一定的递进关系。以下是详细分析和推荐的做题顺序：

#### **一、题目区别与联系**

| 题目编号                                  | 核心技巧              | 特点与难点                                         | 与其他题目的联系                     |
| :------------------------------------ | :---------------- | :-------------------------------------------- | :--------------------------- |
| ==**166. Two Sum II**==               | **基础对撞指针**        | 输入已排序，指针从两端向中间移动，根据和与目标值比较决定移动方向。             | 是所有N Sum问题的基础原型。             |
| ==**1. Two Sum**==                    | 排序+对撞指针           | 需先排序，但会丢失原索引，通常更推荐哈希法。用双指针解可作为技巧练习。           | 与167题解法核心一致，但输入未排序。          |
| ==**14. 3Sum**==                      | **排序+固定指针+对撞指针**  | 固定一个数，转化为两数之和问题。**难点在于去重**。                   | 是167题的进阶，引入了“固定”和“去重”概念。     |
| ==**15. 3Sum Closest**==              | 同15题技巧            | 与15题解法几乎一致，但判断条件变为寻找最接近值，而非相等。                | 与15题是直接的姊妹题，思路一致。            |
| **17. 4Sum**                          | **排序+双固定指针+对撞指针** | 固定两个数，转化为两数之和。多重循环下，**去重逻辑更复杂**。              | 是15题的自然延伸，将“固定一个数”变为“固定两个数”。 |
| **453. 4Sum II**                      | **哈希表分组**         | 严格来说**不是双指针题**。将四数之和转化为两组两数之和的和与频次统计。         | 提供了解决N Sum问题的另一种思路（用空间换时间）。  |
| ==**11. Container With Most Water**== | **对撞指针（贪心）**      | 指针移动策略不同：**移动高度较小的指针**以寻求更大面积。                | 是对撞指针在优化问题上的经典应用，移动策略独树一帜。   |
| **277. Find the Celebrity**           | **逻辑判断型双指针**      | 通过已知API（knows）进行逻辑排除，**单向遍历即可**，不属于经典对撞/快慢指针。 | 技巧较为独立，考察逻辑推理能力。             |
| **186. Reverse Words in a String II** | **多次翻转（双指针）**     | 先整体翻转，再逐个单词翻转。**指针用于定位单词边界**。                 | 是双指针在字符串操作中的应用，技巧独立。         |


#### **二、递进关系与推荐做题顺序**
遵循**从基础到复杂、从经典到变体**的原则，推荐按以下顺序练习，以系统性地掌握双指针技巧：

1.  **起步与基础（理解对撞指针）**
    *   **167. Two Sum II**：这是所有对撞指针的入门题，帮你掌握指针移动的最基本模式（根据和的大小移动指针）。
    *   **11. Container With Most Water**：在对撞指针的基础上，学习一种**新的移动策略**（移动矮板），这是理解双指针如何解决优化问题的关键。

2.  **核心进阶（掌握N Sum问题）**
    *   **[[15. 3Sum]]**：这是**最重要的进阶题**。在167的基础上，学会了“固定一个数”的降维思想和**复杂的去重技巧**。
    *   **16. 3Sum Closest**：趁热打铁，巩固15题的技巧，仅需微调判断条件。
    *   **18. 4Sum**：将15题的技巧扩展到“固定两个数”，**挑战多重循环下的去重和代码掌控能力**。
    *   **1. Two Sum**：此时再回头用双指针解法做此题，会加深对“排序的影响”的理解。
    *   **454. 4Sum II**：作为思维拓展，学习用**哈希表**高效解决N Sum问题，体会不同解法的优劣。

3.  **拓展应用（接触其他类型）**
    *   **277. Find the Celebrity**：换一种思路，体验双指针在**逻辑推理和候选人淘汰**中的应用。
    *   **186. Reverse Words in a String II**：学习双指针如何用于**字符串的原地操作**，掌握多次翻转的技巧。

#### **三、总结**
这些题目的联系在于都运用了“多个指针协同遍历”的核心思想来优化效率。其递进关系主要体现在：
*   **从两数之和到三数、四数之和**：问题维度增加，**固定指针+去重**的技巧不断深化。
*   **从查找 exact target 到优化问题**：移动策略从**比较大小**变为**寻求极值**（如11题）。
*   **从数组到字符串**：双指针的应用场景得到拓展。


----
### 同向双指针
#### 一、题目区别与联系

**1. 基础数组操作（双指针）**
- **[283. Move Zeroes（移动零）]()**：基础双指针，将零移到数组末尾并保持非零元素顺序。是理解“快慢指针”思想的入门题。（思路转变，不是交换0，而是在最后排0）（一个负责**遍历**，一个负责**记录**哪个位置应该是下个非零数）[讲解视频](https://www.bilibili.com/video/BV1n7411n7Af/?spm_id_from=333.337.search-card.all.click&vd_source=d72d89f64e3acc7c73191e3aed96fb3a)
- **26. Remove Duplicates from Sorted Array（删除有序数组中的重复项）**：在已排序数组中使用双指针去重，要求原地修改。是“快慢指针”的经典应用，注重指针移动和条件判断。

**2. 滑动窗口核心（字符串子串问题）**
这类问题都涉及维护一个窗口（通常用左右指针表示），通过移动右指针扩大窗口，移动左指针缩小窗口，来寻找满足条件的子串。
- **3. Longest Substring Without Repeating Characters（无重复字符的最长子串）**：滑动窗口的“始祖题”。核心是维护一个窗口，确保窗口内所有字符都是唯一的。是理解滑动窗口基本原理的最佳起点[[4]][[5]]。
- **340. Longest Substring with At Most K Distinct Characters（至多包含 K 个不同字符的最长子串）**：是第3题的泛化。从“无重复”变为“最多K种字符”，需要用一个哈希表来实时记录和维护窗口内不同字符的数量[[6]][[7]]。
- **424. Longest Repeating Character Replacement（替换后的最长重复字符）**：这道题的窗口很特别。它允许你进行K次字符替换，目标是让窗口内变成同一个字符。关键在于计算“当前窗口长度”减去“窗口内出现最多次的字符的次数”，这个差值要 <= K[[8]][[9]]。
- **76. Minimum Window Substring（最小覆盖子串）**：滑动窗口的“天花板”。难度较高，需要找到一个包含目标字符串所有字符的最短子串。它需要两个哈希表来精确统计和匹配字符数量，是前面所有滑动窗口技巧的综合运用[[10]][[11]]。
- **1004. Max Consecutive Ones III（最大连续1的个数 III）**：可以看作是**424题在二进制数组上的变体**。把“替换字符”操作理解为“翻转0为1”，问题就转化为：最多进行K次翻转，求最长的连续1的子数组。是滑动窗口思想从字符串到数组的迁移应用[[12]][[13]]。

**3. 特殊方法**
- **395. Longest Substring with At Least K Repeating Characters（至少有 K 个重复字符的最长子串）**：这道题不太适合用常规的滑动窗口。它更常用的方法是“分治”或“枚举”。核心思路是：如果一个字符的出现次数小于K，那么包含它的子串肯定不满足条件，可以以这个字符为分割点，将字符串拆开，然后递归地在子串中寻找答案[[14]][[15]]。
- **1658. Minimum Operations to Reduce X to Zero（将 x 减到 0 的最小操作数）**：这道题的思路很巧妙，需要**转换问题**。从数组开头和末尾移除元素使得和为X，等价于在数组中间寻找一个最长的子数组，其和为 `总和 - X`。找到了这个最长的中间子数组，移除操作次数就是最少的。这通常用前缀和+哈希表来解决，是另一种重要的解题思维[[16]][[17]]。

#### 二、递进关系与刷题顺序推荐

建议按以下顺序由浅入深地刷题，逐步构建知识体系：

1.  **阶段一：双指针基础**
    *   **[283. Move Zeroes](https://leetcode.cn/problems/move-zeroes/submissions/674610333)**：理解快慢指针如何协作，对数组进行原地修改。
    *   **[26. Remove Duplicates from Sorted Array](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)**：巩固快慢指针在有序数组中的应用。
![[Pasted image 20251030104757.png]]
快指针：遍历指针
慢指针：记录指针（记录一个可用的位置）、划分指针

----
**收缩时机、收缩的方式、需要的数据结构**



1.  **阶段二：滑动窗口入门与核心**
    *   [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)**必做**。掌握滑动窗口的基本框架和用哈希集合维护窗口内字符唯一性的方法。
    *   **340. Longest Substring with At Most K Distinct Characters**：学习用哈希映射来统计和维护窗口内不同字符的数量，是第3题的升级版。
    *   **[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)**：将滑动窗口应用到一个经典的数组问题上，理解其变通性。

2.  **阶段三：滑动窗口进阶**
    *   **[424. Longest Repeating Character Replacement](https://leetcode.cn/problems/longest-repeating-character-replacement/)**：学习一种特殊的窗口维护技巧，核心是关注“窗口长度”与“最大重复字符数”之间的关系。
    *   **[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)**：**挑战**。综合运用前面所学的滑动窗口和哈希表技巧，是检验滑动窗口掌握程度的试金石。

3.  **阶段四：拓展思维**
    *   **[395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)**：换一种思路，学习用分治法解决不适合直接滑动窗口的问题。
    *   **1658. Minimum Operations to Reduce X to Zero**：学习“正难则反”的问题转换思维，掌握前缀和与哈希表的结合使用。

#### 总结
这些题目覆盖了面试中大部分数组和字符串的高频考点。核心是掌握**双指针**和**滑动窗口**的思想。先打好基础，再攻克核心模型，最后挑战综合难题并拓展思维，这样刷题会事半功倍！

---
### 没有单调性考虑的双指针问题
---

#### 奇偶数字归位

![[Pasted image 20251025154813.png]]
发货的思想：维护两个指针，一个指向奇数位，一个指向偶数位，盯着最后一个数，不断根据这个最后一个数的奇偶发配到对应指针位置，更新指针位置，直至出现一个指针位置越界。

----




---

#### 寻找重复数（快慢指针）287
1. 如果数组中存在重复数，那么数组中的值会形成环。如果存在环，则快慢指针必然相遇
2. 环的入口点就是重复数。让快指针或者慢指针回到起点，两个指针都一步步走，则必然在重复元素处相遇。证明略
	
```c
int findDuplicate(int* nums, int numsSize) {
    if (nums == NULL || numsSize <= 1) return -1;
    
    int slow = nums[0];
    int fast = nums[0];
    
    // 第一阶段：找到相遇点
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);
    
    // 第二阶段：找到环的入口
    slow = nums[0];
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return slow;
}
```

##### 数学证明

设：

- 从起点到环入口的距离为：F
    
- 环入口到相遇点的距离为：a
    
- 相遇点回到环入口的距离为：b（整个环的长度为a+b）
    

当快慢指针第一次相遇时：

- 慢指针走了：F + a
    
- 快指针走了：F + a + k(a+b)（k为整数，表示快指针在环中绕的圈数）
    

因为快指针速度是慢指针的2倍：

复制

```
2(F + a) = F + a + k(a+b)
=> F + a = k(a+b)
=> F = k(a+b) - a
=> F = (k-1)(a+b) + b
```

这个等式说明：

- 从起点到环入口的距离F等于从相遇点继续走b步（即回到环入口）加上(k-1)圈
    
- 因此，当两个指针分别从起点和相遇点以相同速度移动时，它们会在环入口相遇


---
### 有单调性考虑的双指针问题

先想有辅助空间的解法，发现双指针可以用于优化

---
#### 一维接雨水42

1. 只要算出来单格能装多少水就行了，最后累加每格子的大小，但是最左和最右格子无需遍历，必然无法接住水。
	而单格是能装多少水，只需要考虑我的高度，左侧的最大高度，右侧的最大高度
		情况一我的高度三者最小：min(left_max,right_max)- 我的高度 **（木桶原理）**
		情况二我的高度三者最大：0
		![[Pasted image 20251025163750.png]]

![[Pasted image 20251025162217.png]]
2. 怎么求出左右两侧最大值——构建一个预处理的数据结构
	- `left_max[i]` = 0到 i处的最大值
		- ![[Pasted image 20251025163316.png]]
		- 从左到右遍历，不断更新最大值
			
	- `right_max[i]` = i到n-1处的最大值
		- 同理，只是遍历方向不同
		  
	 ![[Pasted image 20251025163602.png]]
2. 双指针优化，对预处理结构优化，空间利用率提高
    ![[Pasted image 20251025164109.png]]
   若lmax <= rmax 说明你的瓶颈来自于左侧，此时结算左指针的格子，并且更新左侧最大值
   若rmax <= lmax说明你的瓶颈来自于右侧，此时结算右指针的格子，并且更新右侧最大值
---
#### 供暖器

![[Pasted image 20251025190011.png]]
1. 对热水器和房屋进行排序
2. 能利用 **同向双指针**遍历得到房子距离哪个供暖气最近，且距离为多少，**规则如下：**
	如果下个热水器的距离更近**或者相等**，热水器的指针继续往下动。
	如果下个热水器的距离更远，则房子的指针继续往下动
	![[Pasted image 20251025190903.png]]
	
	![[Pasted image 20251025192351.png]]
	![[Pasted image 20251025192531.png]]
3. 求出距离最大值即是解
### 基于贪心考虑的双指针
----

#### 救生艇
![[Pasted image 20251025165613.png]]
1. 先排序
2. 首尾双指针，基于**贪心的考虑**
	1. 如果`n[left]+n[right]<=limit`，则两个指针都更按照自己的方向前进一步（right-- left++）。船数量+1
	2. 如果不满足，则right指针自己走(right--)。船数量+1 
	![[Pasted image 20251025171101.png]]
---
#### 盛最多水的容器
![[Pasted image 20251025171254.png]]
	![[Pasted image 20251025171654.png]]
**水量:`** min(h[left],h[right]) * (right-left)`

**思路：** 首尾双指针，哪边小结算哪边
![[Pasted image 20251025172417.png]]
**证明思路：** 确保这样的遍历方式不会错过最优解

---
#### 缺失的第一个正数
![[Pasted image 20251025192845.png]]
首尾双指针
规定：
1. 指针l：数组nums中l指针的左侧都满足`nums[i] = i+1`
2. 指针r：r到n-1的区域（r的右侧）为垃圾区
我祈望在1到r的正数都能找到位置

有如下规则，循环判断直至l == r：
1. `nums[l] == l+1`，则l++
2. `nums[l] <= l`或者`nums[l] > r`则说明`nums[l]`不在所指望的区域，你这个数是没有用的，还占用了我一个位置，能都找到位置的正数个数又变小了，因此被判定为垃圾，与`nums[r-1] `交换数字且r--
3. `nums[nums[l] -1 ] == nums[l]`，则说明出现重复了，因此被判定为垃圾，与`nums[r-1] `交换数字且r--
4. `nums[nums[l] -1 ]` 与  `nums[l]`交换数字
缺失的第一个数就是r+1
示例：![[Pasted image 20251025195546.png]]
![[Pasted image 20251025200043.png]]

----
### 滑动窗口

![[Pasted image 20251030110109.png]]


---
#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
![[Pasted image 20251030110331.png]]
**指针介绍：**
两个指针，一个左边界，一个右边界
两个边界不回退，但是有不一样的功能
- 左边界走是缩小子串长度，但是会减小和
- 右边界走是增长子串长度，但是会加大和
**思路：**
- 如果值太小，就右边界走
- 如果值够大，就试试看能缩小多少左边界
---
#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

![[Pasted image 20251030153143.png]]
**欠债表**：维护一个表，这个表记录这个滑动窗口中的字符还缺少什么以及缺少多少个，如果为正就是富余

![[Pasted image 20251030143515.png]]

指针i：右边界，遍历指针
更新时机：总负债为0了
	指针j：左边界，往右走，再欠一个字符，如果这个字符不会让对应的欠债表上的数据变为负数（富余），则可以继续走
记录start：左边界，len：字符串长度

![[Pasted image 20251030144445.png]]
![[Pasted image 20251030144637.png]]

---

#### [1234. 替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)
![[Pasted image 20251030152156.png]]

- **核心思路：** 目标是找到一个子串，**其中这个串必须包含多余的字符，且至少有多余的个数**
	比如QQWE中，多余的字符为Q，个数为1，则子串'Q'满足要求
- **实现结构：** 维护一个**欠债表**，这个表记录这个滑动窗口中的字符还缺少什么以及缺少多少个，如果为正就是富余
	因此如果词频不足平衡数（str.length/4），则不需要；
	如果超出了，则需要；

![[Pasted image 20251031093943.png]]
![[Pasted image 20251031094000.png]]
1.先统计词频
2.再统计负债


---
#### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
![[Pasted image 20251031100535.png]]
![[Pasted image 20251030141819.png]]

**更新方式：**
	右边界i：遍历指针
	左边界j：max{j，`c[i]`字符上次位置+1}
**实现方式：**
	维护一个数据结构：一个数组记录`last` ,`last[c[i]]`表示`c[i]`字符上次位置，-1表示未出现（初始化为-1）**(跨越式收缩窗口)**

![[Pasted image 20251030142640.png]]

  ----
  #### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

  ![[Pasted image 20251031105137.png]]
右边界right：遍历指针
收缩窗口时机：右指针指向一个0，而窗口中0的个数太多了
**收缩窗口方式：** 左边界left指向上一个0出现的位置+1 **(跨越式收缩窗口)**

实现方式：维护一个集合LinkedList，记录0的位置：
![[Pasted image 20251031105918.png]]

---
#### [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

收缩时机：当滑动窗口内的要替换的个数（滑动窗口大小-最大字符词频）> k
更新方式：往右走

![[Pasted image 20251031124123.png]]
![[Pasted image 20251031124133.png]]

优化：不需要遍历数组找max，记录上一个max，不断更新max即可
![[Pasted image 20251031124437.png]]


---
####   [134. 加油站](https://leetcode.cn/problems/gas-station/)
![[Pasted image 20251030144838.png]]
![[Pasted image 20251030150317.png]] 
所谓能转一圈其实就是指从某个位置出发，不断累加到自己之前（可以用取余数实现），不会出现<0的情况
![[Pasted image 20251030150729.png]]
更新方式：
右指针：如果sum>0，则不断向前走
更新时机：右指针往下走出现sum<0的情况
左指针：跳到r+1的位置，r等于l
- 原因：如果你带着l到r-1的余量都无法走到r的位置，**你从l到r的中途开始走，获得的余量肯定更少，更不可能走过去**，因此必然中间点作为起点不可能到达，所以全跳过。
	- ![[Pasted image 20251030151616.png]]
![[Pasted image 20251030151950.png]]



---

#### [992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)
![[Pasted image 20251030153240.png]]

**转化**：
设置一个函数f（arr,k）返回不同整数的个数小于等于k的子数组的个数（符合窗口范围和整数种类具有单调性的目标）
则我们的好子数组个数为f(arr,k)-f(arr,k-1)

再用双指针求f(arr,k)
![[Pasted image 20251030154355.png]]
指针i：遍历指针，右边界
- 往右走，`cnt[arr[i]] != 0`则新加整数种类，同时`cnt[arr[i]]++`，如果整数种类<=k，则增加子数组个数，增加j-i+1个，否则更新左边界指针j
指针j：左边界
- 更新时机：如果整数种类>k
- 更新方式，左指针不断走，且不断更新cnt，直到更新完后出的`cnt[arr[i]] == 0`，此时数将整数种类-1，然后i继续遍历
数据结构：
- collect：记录整数种类
- cnt：数组，记录以该下标结尾的好子数组个数
![[Pasted image 20251031130225.png]]
![[Pasted image 20251031130233.png]]

---


#### [395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)
![[Pasted image 20251030160022.png]]

**转化：** 求以下的最长，求max
![[Pasted image 20251030160308.png]]![[Pasted image 20251030161006.png]]
三种数据结构：
- collect:收集到几种字符
- satisfy:满足k的有几种字符
- 字频：记录窗口中每一种字符出现的频率

收缩时机：
- 根据collect，得知多收集了，尝试开始缩窗口，直至collect满足要求

记录长度时机：satisfy == require

![[Pasted image 20251030161803.png]]
![[Pasted image 20251031131022.png]]