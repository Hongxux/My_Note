
###  索引的介绍

![[Pasted image 20251029190851.png]]
索引的设计思想是空间换时间，利用B+Tree，帮助Mysql高效获取数据。
它主要通过三个关键设计来解决数据库的性能瓶颈问题：
1. ​**首先，它通过‘矮胖’的多路平衡树结构，极大地减少了磁盘I/O次数。​**​ 因为数据库最大的性能瓶颈在于磁盘I/O，B+树让每一次I/O都能加载大量索引键值，从而用最少的磁盘访问次数定位到目标数据。这是它最核心的价值。
    
2. ​**其次，它的叶子节点通过指针串联成有序链表，这让范围查询的效率非常高。​**​ 一旦通过树结构定位到范围的起点，就可以通过链表顺序扫描，高效地获取所有范围内的数据。这个设计使得`BETWEEN`、`>`、`<`等操作以及`ORDER BY`排序的成本大大降低。
    
3. ​**最后，基于索引的精准定位能力，数据库的锁机制得以实现更小的粒度。​**​ 引擎可以直接锁定必要的行，而不是整个表或数据页，这显著提升了高并发场景下的性能。
当然，它带来的副作用是**会增加写操作的开销**，因为每次`INSERT`、`UPDATE`、`DELETE`都需要维护树结构。所以，我们的优化思路就是在**读性能提升**和**写成本增加**之间找到一个最佳平衡点。

#### 索引结构
|索引类型|InnoDB|MyISAM|Memory|
|---|---|---|---|
|​**B+Tree索引**​|支持|支持|支持|
|​**Hash索引**​|不支持|不支持|支持|
|​**R-tree索引**​|不支持|支持|不支持|
|​**Full-text索引**​|5.6版本之后支持|支持|不支持|

##### [[B+Tree]]索引

##### [[hash算法（散列算法）]]


### 索引分类
#### 按数据结构
##### 1 B+Tree索引（最常用）

- ​**特点**​：多路平衡搜索树，适合范围查询和排序
    
- ​**适用场景**​：`=, >, <, BETWEEN, ORDER BY, GROUP BY`
    
- ​**示例**​：MySQL的InnoDB默认索引类型
    

```
CREATE INDEX idx_user_age ON users(age); -- 创建B+Tree索引
```

##### 2 哈希索引

- ​**特点**​：基于哈希表，O(1)时间复杂度查找
    
- ​**限制**​：仅支持等值查询，不支持范围查询和排序
    
- ​**示例**​：MySQL Memory引擎
    

```
CREATE INDEX idx_user_email ON users(email) USING HASH;
```

##### 3 全文索引

- ​**特点**​：用于文本内容的全文搜索，支持关键词匹配和相关性排序
    - 专门用于解决文本内容的模糊查询（`LIKE '%关键词%'`）效率低下的问题。它通过分析文本中的关键词来进行搜索，适用于 `CHAR`、`VARCHAR`、`TEXT`等类型的列。
- ​**示例**​：MySQL的FULLTEXT索引
    

```
CREATE FULLTEXT INDEX idx_article_content ON articles(content);
SELECT * FROM articles WHERE MATCH(content) AGAINST('数据库 优化');
 ```   
    
    
    
##### 4 空间索引（R-Tree）

- ​**特点**​：用于地理空间数据，支持地理位置查询
    
- ​**示例**​：MySQL的SPATIAL索引
    


```
CREATE SPATIAL INDEX idx_location ON maps(coordinates);
SELECT * FROM maps WHERE ST_Contains(area, point);
```

#### 按数据存储方式
![[Pasted image 20251029194747.png]]
   InnoDB 中的索引根据存储形式分为以下两种：

|索引类型|含义|特点|
|---|---|---|
|​**聚集索引**​|将数据行和索引存储在同一个结构中。|​**必须有，而且只有一个**。索引结构的**叶子节点直接保存了完整的行数据**。|
|​**二级索引**​|将数据与索引分开存储。|​**一个表可以存在多个**。索引结构的**叶子节点关联的是对应数据行的主键值**。|
**聚集索引的性能比二级索引性能高，因为二级索引索引到主键值之后还要利用聚集索引获得行数据**
###### 1. 聚集索引

- ​**核心特点**​：​**数据即索引，索引即数据**。表中的数据行实际就存储在聚集索引的叶子节点上。因此，表数据的物理存储顺序与聚集索引的顺序是一致的。
    
- ​**为什么必须有且只有一个？​**​ 因为一份数据只能以一种物理顺序存储。
    

###### 2. 二级索引

- ​**核心特点**​：​**独立于数据存储的目录**。二级索引的叶子节点不存储行数据，只存储该索引列的值和对应的**主键值**。
    
- ​**查询过程**​：当通过二级索引查询时，需要先根据二级索引找到对应的主键值，然后再拿着这个主键值去**聚集索引**中查找完整的行数据。这个过程称为 ​**回表查询**。
    
##### 聚集索引的选取规则

InnoDB 会按照以下**优先级**为每张表选择一个聚集索引：

1. ​**主键优先**​：如果表定义了主键（PRIMARY KEY），则主键索引自动成为聚集索引。
    
2. ​**唯一索引备选**​：如果表没有主键，但存在一个唯一索引（UNIQUE），则第一个被定义的非空唯一索引（NOT NULL UNIQUE）会被选中作为聚集索引。
    
3. ​**自动生成**​：如果表既没有主键，也没有合适的唯一索引，InnoDB 会自动在内部生成一个名为 `rowid`的隐藏列作为主键，并以此构建聚集索引。
#### 按字段特性

| 分类         | 含义                      | 特点                                                              | 关键字        |
| ---------- | ----------------------- | --------------------------------------------------------------- | ---------- |
| ​**主键索引**​ | 针对表中的主键字段创建的索引。         | - ​**默认自动创建**​  <br>- 一个表**只能有一个**​  <br>- 确保主键的**唯一性**和**非空**​ | `PRIMARY`  |
| ​**唯一索引**​ | 避免同一个表中某个列的值出现重复。       | - 一个表**可以有多个**​  <br>- 确保列值的**唯一性**​（允许为空）                      | `UNIQUE`   |
| ​**常规索引**​ | 用于快速定位特定数据，是最基本的索引类型。   | - 一个表**可以有多个**​  <br>- 无唯一性约束                                   | (无特定关键字)   |


#### 1. ​**主键索引 (PRIMARY KEY)​**​
    
- 这是最重要的索引，通常在创建表时通过 `PRIMARY KEY`指定。它不仅是索引，还强制了数据的唯一标识约束。
        
    
##### 2. ​**唯一索引 (UNIQUE)​**​

- 与主键索引类似，保证数据的唯一性，但一个表可以创建多个唯一索引（例如，为手机号、邮箱字段创建），且允许字段值为 NULL。
        
    
##### 3. ​**常规索引 (KEY/INDEX)​**​
    
- 这是最常用的索引类型，唯一目的就是提高查询速度。它没有任何唯一性的约束。使用 `KEY`或 `INDEX`关键字创建。
        
    

### [[索引基础语法]]
### [[索引创建原则]]
### [[查询中正确使用索引]]

### [[SQL性能分析工具]]

