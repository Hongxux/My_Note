- 设计思想：以空间换时间，以写性能换读性能
- 含义：为每个节点分配左值（lft）​ 和 右值（rgt），所形成的区间，都会完全包含其所有后代节点的区间
	- 左值右值的确定方式：通过对树进行一次**深度优先遍历**（DFS）​ 来确定的![[Pasted image 20251214202719.png]]
		- 当首次访问某个节点时，为其分配一个左值，并将计数器加一。
		- 当处理完该节点的所有后代并回溯离开该节点时，为其分配一个右值，并将计数器加一。
- 好处：
	- 通过简单的范围比较（BETWEEN...AND...），一条SQL查询就能获取任意节点的所有后代或所有祖先，完美避免了递归查询或多次连接，性能卓越
- 问题：
	- 插入、删除或移动一个节点，都可能需要更新该节点右侧大量其他节点的左右值，以维持整个编号体系的正确性。这个过程通常需要复杂的SQL语句或事务来保证数据一致性，性能开销很大
- 使用场景：
	- 强烈考虑嵌套集当：你的应用需要频繁地进行复杂的树形查询（例如，频繁计算整个子树的大小、生成完整的树状视图、查找任意深度的所有节点），但树的结构相对稳定，不经常发生变更
	- 避免使用嵌套集当：你的应用需要频繁地插入、删除或移动节点。在这种情况下，邻接表（如果数据库支持递归查询）或闭包表可能是更合适的选择