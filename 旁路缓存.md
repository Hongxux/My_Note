---
aliases:
  - Cache Aside
---
- 含义：**缓存旁路模式**是最常用的缓存读写策略。
	- 读请求先查缓存，未命中则读数据库并回填；
		- **缓存的存在是为了加速读取，而不是作为数据的权威来源。数据库才是“真相之源”。**
	- 写请求直接更新数据库，然后**使缓存失效 (删除缓存)**。
		- 通过对缓存的**失效**操作来保证数据的一致性
- 合理性：![[Pasted image 20251118124127.png]]
	- 删除缓存还是更新缓存
		- 论证
			1. [[删除缓存 ]](Invalidate)
				- 保证数据的一致性。
			2. 更新缓存 (Update)
				- 适合场景：读多写少
					- 原因：在数据不常变更但被频繁读取（读多）的场景下，确保缓存中始终是最新的数据价值很高。采用“更新缓存”策略，可以在每次数据变更后立即让缓存保持最新，从而保证后续大量的读请求都能直接命中新鲜数据，获得最佳性能。 
				- 劣势：如果写操作也很频繁，就会如上面所述，产生大量无效的缓存更新开销。
		- 结论：
			- 场景：写的多
			- 选择删除缓存使得缓存失效来
		
			- 
	- 先操作数据库还是先操作缓存
		- 论证：基于发生概率的权衡下的最优解
			- 如果顺序反过来（先删缓存，再更新数据库），在并发环境下，可能会出现一个旧数据在数据库更新前被重新加载到缓存，导致脏数据。
			- 虽然“先更新数据库，再删缓存”也有极小的不一致风险，但概率更低，影响窗口更小。[[先更新数据库的风险]]
		- 结论：先更新数据库，再删除缓存。
			- 窗口期具有兜底和保障策略
- 优点：
	- **鲁棒性较好：** 即使缓存服务暂时不可用，系统仍然可以通过直接读写数据库来保证核心功能的运行，尽管性能会下降
- 缺点：
	- **首次请求延迟高：** 对于冷数据或新数据，第一次读取时必然会发生缓存未命中，导致需要同时访问缓存和数据库，延迟较高。
		- 解决措施：[[缓存预热]]
	- **代码逻辑耦合：** 缓存维护逻辑散布在业务代码中，可能导致代码冗余和维护困难。
		- 解决措施：可以通过AOP（面向切面编程）或装饰器模式来解耦[[缓存旁路解耦--AOP]]
	- **数据不一致性问题**：更新数据库和删除缓存之间有窗口期，
		- 会导致读取到旧数据
			- 情况一：线程A更新数据库，然后准备删除缓存。与此同时，线程B来读取数据，发现缓存中有旧数据（因为线程A还没来得及删除），直接返回了旧数据。
			- 情况二：缓存脏读
				- i. 线程A读取数据，缓存未命中。  
				- ii. 线程A去数据库读取旧值 `v1`。  
				- iii. 此时，线程B更新了数据库，将值更新为 `v2`，并删除了缓存。  
				- iv. 线程A将它之前读取到的旧值 `v1` 写入了缓存。  
				- v. 此后，所有读请求都将从缓存中读到已经过期的 `v1`，直到下一次数据更新或缓存过期，导致长时间的数据不一致。
		- 解决措施：
			- 直接解决策略：[[延时双删]]
			- 强一致性：请求串行化，将针对同一数据的读写请求路由到同一个队列中顺序执行，避免并发冲突
			- 兜底方案：缓存过期策略
	- **删除缓存失败：** 如果更新数据库成功，但删除缓存的操作因为网络抖动、缓存服务宕机等原因失败，将导致数据库是新数据而缓存是旧数据，产生不一致。
		- 解决措施
			- 消息队列重试：将删除缓存的操作异步化，失败后由消息队列的重试机制保证最终成功
			- ​订阅Binlog”方案
- 如何保证操作数据库和操作缓存的原子性
	- 单体系统：用事务包裹“数据库操作”和“缓存操作（删除/更新）”，简单有效。
	- 分布式系统：这是难点。分布式事务（如TCC）太重，业界更常用的可靠模式是：
	    1. 先更新数据库
	    2. 再删除缓存
	    3. 若删除缓存失败，通过消息队列重试或订阅数据库binlog补偿，确保最终一致。
		    - 删除失败的原因：比如网络抖动导致删除命令未发送成功
