拓扑排序是针对**有向无环图（DAG, Directed Acyclic Graph）​**​ 的一种顶点线性排序算法。
其**核心要求是：对于图中的任意一条有向边 u→v，在排序结果中顶点 u必须出现在顶点 v之前。**

为了让你快速理解拓扑排序的核心概念、算法和应用，我准备了一个表格：

|方面|说明|备注/例子|
|---|---|---|
|​**核心图结构**​|​**有向无环图 (DAG)​**​|图中边有方向，且不存在任何环路。|
|​**排序目标**​|将所有顶点排成一个线性序列。||
|​**核心规则**​|对于任意边 u→v，u在序列中必须排在 v前面。|保证所有边的方向性在序列中得以体现。|
|​**排序性质**​|​**结果不唯一**​：一个DAG可能有多个有效的拓扑序列。|只要满足所有边的先后约束即为有效序列。|
|​**环的影响**​|如果图中有环，则**无法**进行拓扑排序。|因为环上的顶点相互依赖，无法打破循环。|
|​**典型算法**​|​**Kahn算法 (基于BFS/入度)​**​ ​**DFS算法**​||
|​**常见应用场景**​|任务调度、课程安排、依赖关系管理（如软件包、编译顺序）等。|任何存在先后依赖关系的问题都可以考虑使用拓扑排序。|

### 🔧 算法过程简介

#### DFS算法
##### 正确性
- DFS算法保证了子节点一定后于父节点出现，满足拓扑排序的性质。
- 而源节点之间不存在先后顺序，并且A源节点出发遍历的遍历完，再从B源节点出发后，之后的节点不存在是A系列节点的孩子节点的情况，仅存在是A系列节点的父亲节点情况，此时仍然满足拓扑排序性质

#### 步骤

DFS遍历，倒序打印
> 实际上不需要选择入度为0的顶点，可以从任意顶点开始，直至访问了所有顶点



#### Kahn算法

拓扑排序的常用算法是 ​**Kahn算法**​（基于入度的BFS方法），其主要步骤如表格所示：

|​**步骤**​|​**操作**​|​**说明**​|
|---|---|---|
|​**1**​|初始化|计算每个顶点的**入度**​（指向该顶点的边的数量）。|
|​**2**​|将所有**入度为0**的顶点加入一个队列（或栈）。|这些顶点没有前置依赖，可以立即输出。|
|​**3**​|从队列中取出一个顶点，将其加入结果序列。||
|​**4**​|将该顶点的所有邻接顶点（即它指向的顶点）的入度减1。|相当于在图中“移除”这个顶点和它发出的边。|
|​**5**​|检查这些邻接顶点，如果某顶点的入度因此变为0，则将其加入队列。||
|​**6**​|重复步骤3-5，直到队列为空。||
|​**7**​|​**结果判断**​：若结果序列包含所有顶点，则排序成功；否则，说明图中存在环，无法拓扑排序。||

### 🧠 主要应用场景

拓扑排序擅长处理任何具有**先后依赖或顺序约束**的问题：

- ​**任务调度与项目管理**​：确定一系列存在依赖关系的任务的执行顺序，保证前置任务先完成。
    
- ​**课程安排与学习计划**​：根据课程之间的先修关系，合理安排学期的学习顺序。
    
- ​**软件包依赖管理**​：在安装软件包时，根据依赖关系确定正确的安装顺序。
    
- ​**编译器技术**​：确定源代码文件的编译顺序，以及函数或变量的解析顺序。
    
- ​**数据流与流水线设计**​：组织数据处理管道中各个阶段的执行顺序。
    

### 💎 核心特点与要求

理解拓扑排序，还需要注意以下几点：

- ​**仅适用于DAG**​：拓扑排序的前提是图必须为**有向无环图（DAG）​**。如果图中存在环，则无法进行拓扑排序，因为环上的顶点互为前驱，无法确定先后。
    
- ​**结果不唯一**​：一个DAG通常存在**多个**有效的拓扑序列。只要满足所有边的顺序约束，都是正确的答案。
    
- ​**环的检测**​：尝试对一幅有向图进行拓扑排序，可以有效地**判断图中是否存在环**。如果在排序过程中发现没有入度为0的顶点可处理，但仍有顶点未输出，则说明图中存在环。
    
