副本和视图的存在让数据操作更加灵活：

- ​**视图**提供了高效的数据访问方式，适合只读操作和临时分析
    
- ​**副本**确保了数据操作的独立性，适合需要修改数据的场景
#### ​**一、核心概念：视图 (View)​**​

​**1. 它是什么？​**​

视图不是一个真正存储数据的**副本 (Copy)​**，而是一个“窗口”或“视角”，通过这个窗口去查看或操作另一个**已有的**集合。

​**2. 关键例子：`Map`的 `keySet()`方法**​

这是理解视图的最佳例子。

- ​**错误理解**​：`map.keySet()`方法把 Map 中所有的键拿出来，复制到一个新的 Set 里并返回。
    
- ​**正确理解（视图）​**​：`keySet()`返回的 Set ​**直接关联着原始的 Map**。当你在这个 Set 上进行操作（如删除一个键），原始 Map 里对应的键值对也会**立刻被删除**。
    
- ​**记住典型例子**​：`keySet()`, `values()`, `entrySet()`都是返回视图。
    

#### ​**二、核心技能：[[创建小型不可变集合]] (Small Immutable Collections)​**​
介绍了使用 `List.of()`, `Set.of()`, `Map.of()`等方法快速创建小型、不可变集合的简便方式。这是创建独立集合副本的现代方法。

----
### 三、视图和副本选择

#### 总结概述表

| 技术                 | 需求背景                                                        | 提供的解决方案                                                                                                             | 与其他技术的关系                                                                                                               |
| ------------------ | ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| ​**一、不可修改的副本/视图**​ | 需要共享集合数据，但希望防止接收方意外修改原始集合，保证数据完整性。                          | - ​**不可修改副本**​： 创建集合的完整拷贝，并设置为只读。原集合的修改不影响副本。  <br>- ​**不可修改视图**​： 为原集合创建一个“只读代理”。不复制数据，但任何修改操作都会抛出异常。原集合修改会反映在视图上。 | - ​**与子范围视图**​： 可以为一个子范围视图再创建不可修改视图，实现对一个子集的只读保护。  <br>- ​**与同步视图**​： 可以为一个同步视图创建不可修改视图，但通常没必要，因为同步是为了可修改的并发访问。        |
| ​**二、子范围视图**​      | 需要处理集合的一部分（如前10个元素、某个键值范围），而不需要创建新的物理副本，以提高效率。              | 返回一个与原集合“动态链接”的视图对象。对该视图的操作会直接作用于原集合的相应部分。修改原集合会影响子范围视图的有效性。**（相互影响）**                                              | - ​**与不可修改视图**​： 可以创建子范围视图的不可修改视图，以保护该子集不被修改。  <br>- ​**是其他视图的基础**​： 受检视图和同步视图可以应用在子范围视图上。                             |
| ​**三、受检视图**​       | 在泛型代码中，与遗留的原始类型代码交互时，防止在运行时插入错误类型的元素，将“堆污染”异常从不可预测处提前到插入时。  | 在运行时检查所有插入操作的类型安全性。任何尝试插入类型不匹配元素的操作会立即抛出 `ClassCastException`。这是一个“动态类型安全”的包装器。                                     | - ​**与不可修改视图**​： 两者可结合使用，例如创建一个受检的不可修改视图，既保证类型安全又防止修改。  <br>- ​**通常应用于**​ `Collection`, `List`, `Set`, `Map`等核心接口。     |
| ​**四、同步视图**​       | 在多线程环境下，需要对非线程安全的集合（如 `ArrayList`, `HashMap`）进行同步访问，确保线程安全。 | 通过包装器，将所有方法用同步锁（通常是`synchronized`块）包裹，实现粗粒度的线程安全。​**​（注意：Java 5+ 后，更推荐使用 `java.util.concurrent`包下的并发集合）​**​         | - ​**与不可修改视图**​： 可以为同步视图创建不可修改视图，但这会使同步失去意义。  <br>- ​**与其他视图**​： 是线程安全的一种传统实现方式，但与现代并发集合相比性能较差。可以与其他视图（如子范围视图）组合，但需谨慎。 |

---

#### 详细说明

##### 一、不可修改的副本和不可修改的视图

- ​**核心区别**​：“副本”是数据的完整拷贝，占用新空间，与原集合独立。“视图”只是一个访问接口，不复制数据，与原集合生命共存。
    
- ​**选择策略**​：
    
    - 如果希望原集合的变更不影响共享方，且数据量不大，用**不可修改副本**​（`CopyOnWriteArrayList`是这种思想的极致体现）。
        
    - 如果希望共享方看到原集合的最新状态，但要防止其修改，用**不可修改视图**。这是更常用、更高效的做法。
        
    

##### 二、子范围视图

- ​**动态性**​：这是其最关键的特性。例如，对 `list.subList(from, to).clear()`可以高效地移除原列表中的一个片段。
    
- ​**有效性**​：子范围视图的有效性依赖于原集合。如果原集合被结构性修改（如直接增删元素），子范围视图可能会失效，再次使用时会抛出 `ConcurrentModificationException`。
    

##### 三、受检视图

- ​**防御性编程**​：主要用于在泛型系统和非泛型代码（遗留代码）的边界上设置“检查点”，是一种重要的防御性编程技术。
    
- ​**局限性**​：它只能保证“放入”集合的元素类型正确，无法保证通过非受检路径（如直接操作原集合）放入的元素类型。它也不能在编译时提供额外的类型检查。
    

##### 四、同步视图

- ​**历史与现状**​：在Java早期（<1.5），这是实现集合线程安全的主要方式。但由于是粗粒度锁（锁住整个集合对象），性能瓶颈严重。
    
- ​**现代替代方案**​：​**强烈推荐**使用 `java.util.concurrent`包下的并发集合，如 `ConcurrentHashMap`, `CopyOnWriteArrayList`, `ConcurrentLinkedQueue`等。它们使用了更精细的锁机制（如分段锁）、无锁算法（CAS），能提供高得多的并发性能。
    

#### 总结

这四种技术本质上是**装饰器模式**​ 的应用，通过包装一个原有的集合对象，在不改变其内部结构的前提下，增加新的功能（只读、范围控制、类型检查、线程安全）。它们可以组合使用，但需要理解其相互作用，特别是当涉及到并发和修改时，需要格外小心。在现代Java开发中，应优先考虑更高级的替代方案（如并发集合），而不是简单地使用同步视图。

---
### 四、**可选操作**
#### 需求背景：

在集合框架中，视图（如集合的键视图或子列表）通常具有特定的访问限制（例如只读、不可改变大小等）。为了在统一的接口中容纳这些不同限制的视图，Java API 将某些方法标记为“可选操作”。这解决了接口设计上的矛盾：接口本应强制实现所有方法，但实际中某些视图无法支持所有操作（如修改方法）。这种设计避免了接口数量爆炸（如为每种限制创建独立接口），但引入了理论上的不完美性。

#### 解决方法：

通过将不支持的方法标记为“可选操作”，并在调用时抛出 `UnsupportedOperationException`异常来处理限制。这种机制平衡了接口的统一性和实际视图的局限性，但建议开发者不要在自定义设计中滥用此模式，因为集合框架的需求极端（需兼顾易用性、效率和通用性），而普通应用场景通常不需要这种妥协。