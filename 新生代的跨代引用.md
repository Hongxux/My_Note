---
aliases:
  - 卡表
  - RSet
---
- 协同方式：
	- 并发标记阶段
		- 并发标记时期，为了跟踪并发过程中对象引用关系的变化，G1为所有写操作插入了**写屏障**。当你执行类似 `objA.field = objB`这样的操作时，写屏障会执行以下关键逻辑：
			- 它会检查这是否是一个跨Region的引用（即 `objA`和 `objB`是否不在同一个Region）。
			- 如果是跨Region引用，写屏障并不会直接更新RSet，因为这样性能开销太大。相反，它会将`objA`所在的**卡**在卡表中标记为“脏”，这是一个非常快速的操作。
		- 后台会有专门的GC线程（通常是`RefineThread`）来处理卡表中积累的“脏卡”。
			- 这些线程会扫描每一个“脏卡”对应的内存块，精确找出其中所有的跨Region引用。
			- 然后，它们会将这些引用关系**更新到目标Region的RSet中**。例如，如果Region A中的对象引用了Region B中的对象，那么这个关系会被记录到Region B的RSet里。
	-   最终标记阶段
		- 并发标记阶段的基础：由于RSet已经包含了完整的跨Region引用信息，G1在进行可达性分析时，要确定一个Region中的对象是否存活，就**无需从GC Roots开始扫描整个堆**。
		- 它只需要以GC Roots为起点，并**额外检查该Region的RSet**。RSet指明了所有可能指向该区域存活对象的外部引用，G1只需扫描这些引用即可精确判断对象的存活状态。
		- 作用：这极大地缩小了扫描范围，从“全堆扫描”变成了“**局部扫描**”，从而显著缩短了STW停顿时间。

