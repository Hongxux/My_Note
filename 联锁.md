---
aliases:
  - multilock
---
![[Pasted image 20251119201614.png]]
在主从同步设置锁的时候，主节点发生宕机，而新的主节点还没有保存锁的相关信息，从而出现并发安全问题
解决方案：放弃一主多重，改成多主多从，设置锁向多个主节点，获取锁也是去多个主节点，这称为[[联锁]]（multilock）
- 什么时候才算成功获取锁：能从所有主节点都获取锁（全有），如果有一个获取失败，则释放之前成功获取的锁（全无）。
- 多个锁的封装：将多个 `RLock`对象封装在一个 `List`中，并按其名称的哈希值排序，以**避免循环等待死锁**

### 🧠 核心概念与价值

想象一个场景：你需要同时操作A、B、C三个资源，并且要求这三个资源要么同时被锁定，要么都不可用。如果使用三个独立的锁，处理它们加锁、解锁的成功与失败会非常复杂，容易导致死锁。`MultiLock`的价值就在于解决这种复杂的协同加锁问题。

它的设计目标是：**当向`MultiLock`申请加锁时，只有在它包含的所有单个锁都成功获取后，`MultiLock`才算加锁成功。只要有一个锁获取失败，那么已经获取成功的锁也会被释放，确保操作的原子性。**

下面的流程图直观地展示了`MultiLock`在加锁和解锁过程中的核心逻辑与状态流转：

### 🛠️ 如何使用MultiLock
#### 配置多个节点
![[Pasted image 20251119202811.png]]
#### 使用联锁
使用`MultiLock`的代码结构非常清晰，以下是一个典型的示例：

```
import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import java.util.concurrent.TimeUnit;

public class MultiLockExample {

    public static void main(String[] args) {
        // 1. 创建Redisson客户端
        RedissonClient redisson = Redisson.create();

        // 2. 创建多个独立的锁对象
        RLock lock1 = redisson.getLock("lock:resource:1");
        RLock lock2 = redisson.getLock("lock:resource:2");
        RLock lock3 = redisson.getLock("lock:resource:3");

        // 3. 创建联锁，将多个锁捆绑在一起
        RLock multiLock = redisson.getMultiLock(lock1, lock2, lock3);

        try {
            // 4. 尝试为所有锁申请一个统一的许可
            // 参数: waitTime-等待时间, leaseTime-锁持有时间, unit-时间单位
            boolean isLocked = multiLock.tryLock(10, 30, TimeUnit.SECONDS);
            if (isLocked) {
                // 5. 成功获取联锁，执行需要同时锁定多个资源的业务逻辑
                System.out.println("成功获取联锁，开始执行原子性操作...");
                // ... 你的业务代码 ...
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("获取锁过程被中断");
        } finally {
            // 6. 无论如何，最终都要释放锁
            if (multiLock.isHeldByCurrentThread()) {
                multiLock.unlock();
                System.out.println("联锁已释放");
            }
            redisson.shutdown();
        }
    }
}
```

### 💡 关键特性和注意事项

1. **原子性保证**：如上所述，`MultiLock`的核心是提供“全有或全无”的加锁语义，这对于需要强一致性的操作至关重要。
    
2. **锁的独立性**：组成`MultiLock`的每个`RLock`仍然是独立的分布式锁，它们可以单独使用。`MultiLock`只是在它们之上提供了一层协同管理。
    
3. **避免死锁**：通过统一的等待时间和租约时间，并确保在失败时自动释放已获得的锁，`MultiLock`有效避免了在复杂加锁场景中常见的死锁问题。
    
4. **性能考量**：由于需要与Redis集群进行多次网络通信（锁的数量决定），`MultiLock`的加锁开销通常比获取单个锁要大。因此，要谨慎选择需要捆绑的锁，只将真正有关联的资源锁在一起。
    
5. **选择正确的键**：每个底层锁的名称（即Redis的Key）决定了它锁定的资源范围。确保键的名称能够准确、唯一地标识目标资源。
    

### ⚖️ 典型应用场景

- **分布式事务**：在需要同时更新多个资源（如不同的数据库记录、不同的系统）时，可以使用`MultiLock`来保证在事务开始前锁定所有相关资源。
    
- **批量操作**：执行一个需要原子性的批量任务，例如同时迁移多个关联的数据块。
    
- **资源编排**：在需要严格顺序访问多个资源的复杂业务流程中，使用`MultiLock`可以简化并发控制逻辑。
    

希望这些解释能帮助你透彻地理解Redisson的`MultiLock`。如果你对特定场景下的应用有更具体的问题，我们可以继续深入探讨。