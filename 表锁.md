
- 需求背景：
	- 需要更新或读取表中绝大部分记录
		- 行锁的局限性：需要对大量甚至全部数据行逐一加锁。
			- 产生巨大的系统开销，执行效率反而低下
			- 可能因长时间持有大量锁而导致严重的锁等待和冲突。
		- 表锁的优点：一次性锁定整个资源，事务执行效率更高，整体耗时更短
	- 复杂多表事务
		- 行锁局限性：如果按照不同顺序访问这些表，行锁很可能导致死锁
		- 表锁的优点：可以彻底避免在事务执行过程中发生死锁，虽然这会暂时降低并发性，但保证了事务的确定性和成功率
- 表锁分类：![[Pasted image 20251102085549.png]]
	1. ​表共享读锁（Read Lock）​​
	    - ​适用场景​：适用于需要确保在读取过程中数据不被更改，但允许其他会话并发读取的场景。
	    - ​特性​：
		    - 多个会话可以同时获得同一张表的读锁，即“共享”。
		    - 获得读锁后，会话只能读表，不能写表，并且会阻塞其他会话申请写锁。
	2. ​表独占写锁（Write Lock）​​
	    - ​适用场景​：适用于需要对表进行数据更新（INSERT、UPDATE、DELETE）或表结构变更（ALTER）等操作，需要严格排他的场景。
	    - ​特性​：写锁是独占和排他的。
		    - 一个会话获得某张表的写锁后，​既可以去写，也可以去读
		    - 但其他会话不能再对该表加任何锁（无论是读锁还是写锁）​，直到该锁被释放。
		    - 其他会话的读写操作都会被阻塞。
- 使用方式：锁是由会话持有和释放的
	1. ​**加锁语法**：该操作会隐式提交当前会话中所有未提交的事务。
		- 加读锁：`LOCK TABLES 表名 [AS 别名] READ;`
		- 加写锁​：`LOCK TABLES 表名 [AS 别名] WRITE;`
	2. ​**释放锁语法**​
	    - ​**显式释放**​：`UNLOCK TABLES;`
	    - ​**隐式释放**​：当客户端会话断开连接时，也会**自动释放**该会话持有的所有锁。