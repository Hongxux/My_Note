- 设计目的：提供强一致性
- 工作模式
	1. 应用程序发起写操作时，数据首先被写入缓存。
	2. 缓存服务在成功写入自身后，会立即、同步地将该数据写入后端数据源 。
	3. 只有当缓存和数据源都成功写入后，操作才算完成，并向应用程序返回成功。

- **优点**：强一致性。由于写操作是同步的，可以保证缓存和数据库的数据始终一致 。
- **缺点**：
	- **写性能开销大，不适合高频写场景** 每次写操作都必须等待后端数据源写入完成，这使得写操作的延迟等于“写缓存的耗时 + 写数据源的耗时”，显著增加了写请求的响应时间
	- **实现复杂性：** 与读穿透类似，通常需要缓存提供商的支持。在分布式环境中，保证缓存和数据库写的事务性是一个挑战。
	- **持久化失败**：如果写缓存成功了，但同步写数据库失败，系统会处于一种**不一致的中间状态**，如果缓存服务此时发生重启或该缓存项因内存不足被淘汰，那么这笔“成功”写入的数据就会彻底丢失，因为数据库中并没有备份。
		- 解决措施：
			- 即时回滚与重试：实现了**强一致性**的回滚，但用户体验不佳，需要用户自己重试
				- 在检测到数据库写入失败后，立即删除缓存中的新值，客户端返回失败
			- 异步重试：牺牲了强一致性，但保证了最终一致性，并提升了用户体验
				- -**请求快速返回**：在数据库写入失败后，可以记录下失败的操作和参数，然后先返回用户“操作正在处理中”。
				- **后台任务重试**：启动一个异步任务（或将该操作放入一个重试队列），在后台不断尝试将数据写入数据库，直到成功为止。在重试成功前，缓存中的脏数据需要被清理掉，或者读请求在命中脏缓存时能识别并正确处理这种中间状态。