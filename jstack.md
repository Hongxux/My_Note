
### 🔧 命令语法与核心参数

`jstack` 的基本命令格式如下：
```bash
jstack [options] <pid>
```
其中，`pid` 是你要诊断的 Java 进程的进程 ID。你可以使用 `jps` 或 `ps` 命令来查看当前运行的 Java 进程及其 PID。

常用的 `options` 参数包括：

| 参数 | 说明 |
| :--- | :--- |
| **`-l`** | **长列表**。输出关于**锁的附加信息**，例如属于 `java.util.concurrent` 的 ownable synchronizers 列表。在分析死锁时特别有用。 |
| **`-F`** | **强制生成线程快照**。当普通的 `jstack` 命令没有响应（例如进程处于 `hung` 状态）时使用此选项。 |
| **`-m`** | **混合模式**。打印 **Java 和本地方法**（C/C++）的栈帧信息。当问题可能源自 JNI 本地代码时使用。 |
| **`-h`** 或 **`--help`** | 显示帮助信息。 |


#### 1. 排查死锁（Deadlock）

死锁是指两个或多个线程互相持有对方所需的资源，导致所有线程都无法继续执行的情况。

- **操作步骤**：
    1.  获取目标 Java 进程的 PID：`jps`。
    2.  生成包含锁信息的线程快照：`jstack -l <pid> > thread_dump.log`。
    3.  分析生成的 `thread_dump.log` 文件，直接搜索 **`deadlock`** 关键字。如果存在死锁，`jstack` 通常会在文件开头明确标识出来，并清晰展示出每个线程持有什么锁、在等待什么锁，以及相互等待的关系链。

#### 2. 定位 CPU 占用过高

某个线程长时间占用大量 CPU 资源，通常是代码中存在死循环或耗时计算导致的。

- **操作步骤**：
    1.  使用 `top` 命令找到 CPU 占用率高的 Java 进程 PID。
    2.  查看该进程内各个线程的 CPU 使用情况：`top -Hp <pid>`。
    3.  将占用率最高的线程 PID（十进制）转换为十六进制：`printf '%x\n' <高CPU线程的十进制PID>`。
    4.  生成线程快照：`jstack <pid> > high_cpu.log`。
    5.  在 `high_cpu.log` 文件中，用**第3步得到的十六进制线程ID**进行搜索。找到对应的线程后，查看其**调用栈**，就能定位到导致 CPU 高的具体代码方法。

#### 3. 分析线程阻塞（Blocked）与长时间等待

线程处于 `BLOCKED`、`WAITING` 或 `TIMED_WAITING` 状态，可能是由于等待资源（如数据库连接、网络IO）、锁竞争或协调不当引起的。

- **操作步骤**：
    1.  生成线程快照：`jstack <pid> > thread_blocked.log`。
    2.  在日志中搜索 `BLOCKED`、`WAITING` 等状态线程。重点关注线程栈中的**锁信息**和**等待条件**。例如，`waiting to lock <0x00000000xxxx>` 表示线程在等待获取某个锁，`waiting on condition` 可能表示在等待资源或条件触发。



