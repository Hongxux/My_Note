---
aliases:
  - 数据预热
---
- 需求背景![[Pasted image 20251125133142.png]]
- 预热的时机与触发方式
	- 变更不频繁的基础数据，在应用启动完成后立即执行：如城市列表、配置信息等
		- 实现方式：
			- `@PostConstruct`：初始化当前 Bean 的简单逻辑，不依赖其他复杂 Bean 或需要应用完全启动
				- 执行时机：最早，在单个 Bean 的**依赖注入完成后**立即执行
				- 特点：初始化当前 Bean 的简单逻辑，不依赖其他复杂 Bean 或需要应用完全启动
					- 执行时机早，但**无法保证**其他 Bean 或整个应用上下文已完全准备就绪
			- 实现ApplicationRunner接口：需要处理复杂命令行参数，或执行需要完整 Spring 上下文支持的任务
				- 执行时机：较晚，在 **Spring 容器完全启动后**执行
				- 特点：
					- 能获得所有 Spring Bean 的支持
					- 其 `run`方法参数为 `ApplicationArguments`，**支持对命令行参数进行结构化解析**（如区分选项参数和非选项参数）
			- 实现CommandLineRunner接口：只需简单处理命令行参数或不需要参数处理的任务
				- 执行时机：与 `ApplicationRunner`相近，但默认**稍晚于**它执行
				- 特点：
					- 同样在容器完全启动后执行。
					- 其 `run`方法参数为字符串数组 `String... args`，提供**原始的命令行参数**
			- 监听 `ApplicationReadyEven`：执行最终的安全检查、或作为应用就绪的最后信号
				- 执行时机：最晚，在 `ApplicationRunner`和 `CommandLineRunner`**执行完毕后**才触发
				- 特点：这是应用**完全准备就绪、可以接收外部请求的标志**
		- 注意：
			- **控制多个 Runner 的执行顺序**：当有多个 `CommandLineRunner`或 `ApplicationRunner`Bean 时，可以使用 **`@Order`注解**或实现 **`Ordered`接口**来定义它们的执行顺序，数值越小优先级越高
			- **注意异常处理**：在所有这些方式的实现代码中，如果抛出异常，**都会导致应用启动失败**。因此，务必做好异常处理
	- **可预测的热点数据**可以使用**定时预热**：例如电商平台可以在秒杀活动开始前5分钟，将参与秒杀的商品信息加载到缓存中。
		- 使用定时任务框架（如Quartz、`@Scheduled`）在固定时间或周期性地执行预热。
			- 单实例部署：[[@Scheduled]]
			- 集群/分布式：[[Quartz]]
			  
	- **事件触发预热**：当发生特定事件时触发预热，例如后台管理员手动设置了某个商品为爆款，或者有新品上架需要重点推广时
	- **智能动态预热**：通过监控数据访问频率，当系统识别出某个数据在短时间内（如5分钟）访问次数超过阈值，就异步触发该数据的预热。这是一种更高级、更智能的策略。
- 热点数据的识别策略
	- **基于静态规则**：运维或开发人员根据业务经验直接指定需要预热的数据，例如首页轮播图对应的商品
	- **基于历史访问数据**：分析历史访问日志（如PV/UV），将排名靠前的数据视为热点。可以结合**时间衰减因子**（如LFU算法或其变种），更准确地反映近期真实热度
	- **基于业务规则预测**：在大促前，根据营销计划（如即将主推的商品）提前预热相关数据。
- 预热数据的方式：
	- **并发控制**：
		- 需求：对于需要预热大量数据的情况，使用**多线程**或**异步化**（如`CompletableFuture`）可以显著缩短预热时间。
		- 问题：要控制并发度，避免对数据库造成过大压力。
	- **错峰与降级**：
		- 错峰：将预热任务安排在系统流量低谷期（如凌晨）执行。
		- 降级：预热任务本身不应影响系统的核心业务，如果预热失败，应有日志记录和告警机制，但不应导致应用启动失败
	- **缓存失效与更新**：为防止大量缓存同时失效导致的“缓存雪崩”，建议为不同的缓存数据设置**一个随机范围的过期时间**。当源数据发生变化时，要通过**延迟双删**等策略保证缓存与数据库的一致性



