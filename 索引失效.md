
#### 1. 在索引列上进行运算或使用函数

在 `WHERE`子句中，如果对索引列进行运算、使用函数或进行表达式计算，MySQL 将无法使用该列的索引。

```
-- ❌ 失效：对索引列进行运算
SELECT * FROM user WHERE id + 1 = 10;
-- ✅ 有效：将运算移到等号另一边
SELECT * FROM user WHERE id = 9;

-- ❌ 失效：在索引列上使用函数
SELECT * FROM user WHERE UPPER(name) = 'JOHN';
SELECT * FROM user WHERE YEAR(create_time) = 2023;
SELECT * FROM user WHERE LENGTH(email) > 10;
-- ✅ 有效：对常量使用函数，保持索引列"干净"
SELECT * FROM user WHERE name = 'john' AND create_time >= '2023-01-01';
```

#### 2. 数据类型不匹配（隐式类型转换）

当查询条件中的值与索引列的数据类型不匹配时，MySQL 会进行隐式类型转换，导致索引失效。

```
-- 假设 user_id 是字符串类型（VARCHAR），但用数字查询
-- ❌ 失效：MySQL 需要将每行的 user_id 转换为数字来比较
SELECT * FROM orders WHERE user_id = 12345;
-- ✅ 有效：使用相同数据类型
SELECT * FROM orders WHERE user_id = '12345';

-- 假设 phone 是字符串类型，但存储的是数字
-- ❌ 失效：隐式类型转换
SELECT * FROM user WHERE phone = 13800138000;
-- ✅ 有效
SELECT * FROM user WHERE phone = '13800138000';
```

#### 3. 使用 `OR`连接条件

如果 `OR`连接的多个条件中，有一个条件涉及的列没有索引，那么整个查询可能无法使用索引。

```
-- 假设 name 有索引，但 age 没有索引
-- ❌ 失效：因为 age 无索引，优化器会选择全表扫描
SELECT * FROM user WHERE name = 'John' OR age > 30;

-- ✅ 有效：使用 UNION 或分别查询
SELECT * FROM user WHERE name = 'John'
UNION
SELECT * FROM user WHERE age > 30;
```

#### 4. 使用前导通配符的 `LIKE`查询

`LIKE`查询只有在模式不以通配符开头时才能使用索引。

```
-- ❌ 失效：以通配符开头，无法使用索引
SELECT * FROM product WHERE name LIKE '%手机%';
SELECT * FROM product WHERE name LIKE '%旗舰';

-- ✅ 有效：不以通配符开头，可以使用索引
SELECT * FROM product WHERE name LIKE '苹果%';
SELECT * FROM product WHERE name LIKE '小米手机%';

-- 如果需要全文搜索，考虑使用全文索引
ALTER TABLE product ADD FULLTEXT(name);
SELECT * FROM product WHERE MATCH(name) AGAINST('手机' IN NATURAL LANGUAGE MODE);
```

#### 5. 范围查询导致右边列索引失效

在联合索引中，如果对某一列使用了范围查询（`>`、`<`、`BETWEEN`、`IN`等），那么它右边的所有列将无法使用索引排序和过滤。

```
-- 假设有联合索引 (a, b, c)
-- ❌ c 列索引失效：因为 b > 10 是范围查询
SELECT * FROM table WHERE a = 1 AND b > 10 AND c = 5;

-- ✅ 有效：调整索引顺序或查询条件
-- 创建新索引 (a, c, b)
ALTER TABLE table ADD INDEX idx_a_c_b (a, c, b);
```

#### 6. 使用 `!=`或 `NOT`操作符

不等于操作符通常无法有效使用索引。

```
-- ❌ 失效：不等于操作无法有效利用索引
SELECT * FROM user WHERE status != 'active';
SELECT * FROM product WHERE price <> 100;

-- ✅ 有效：改为范围查询或分别查询
SELECT * FROM user WHERE status IN ('inactive', 'pending');
SELECT * FROM product WHERE price < 100 OR price > 100;
```

#### 7. `IS NULL`和 `IS NOT NULL`查询

在某些情况下，`IS NULL`和 `IS NOT NULL`可能无法有效使用索引。

```
-- ❌ 可能失效：取决于数据分布
SELECT * FROM user WHERE email IS NULL;
SELECT * FROM user WHERE phone IS NOT NULL;

-- ✅ 解决方案：确保列定义为 NOT NULL 或使用覆盖索引
ALTER TABLE user MODIFY email VARCHAR(100) NOT NULL DEFAULT '';
```

#### 8. 数据区分度太低

当索引列的值重复率很高（区分度低）时，MySQL 优化器可能认为全表扫描比使用索引更高效。

```
-- 假设 status 只有 'active', 'inactive' 两个值，且数据分布均匀
-- ❌ 可能失效：优化器选择全表扫描
SELECT * FROM user WHERE status = 'active';

-- ✅ 解决方案：使用复合索引或强制使用索引
SELECT * FROM user FORCE INDEX(idx_status) WHERE status = 'active';
```
#### 如何诊断索引失效？

使用 `EXPLAIN`命令分析查询执行计划：

```
EXPLAIN SELECT * FROM user WHERE name LIKE '%John%';
```

关注以下关键字段：

- ​**type**​：如果是 `ALL`，表示全表扫描
    
- ​**key**​：显示实际使用的索引，如果为 `NULL`则表示未使用索引
    
- ​**Extra**​：包含 `Using where`但无 `Using index`可能表示索引失效
    

#### 最佳实践建议

1. ​**保持索引列"干净"​**​：避免在索引列上使用函数或运算
    
2. ​**注意数据类型**​：确保查询条件与列数据类型匹配
    
3. ​**合理设计索引**​：基于实际查询模式创建复合索引（范围查询）
    
4. ​**定期维护索引**​：使用 `ANALYZE TABLE`更新索引统计信息
    
5. ​**监控慢查询**​：使用慢查询日志识别需要优化的查询