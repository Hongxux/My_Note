---
aliases:
  - 面向切面编程
---
![[Pasted image 20251108095313.png]]
好处
①通用的**交叉业务**代码（日志记录，安全，事务管理）得到复用
②通用的**交叉业务**代码与业务代码分离，便于维护







### 第一部分：为什么要用 AOP？

在传统编程模式下的**两大痛点**，这也是 AOP 要解决的核心问题。

1. **交叉业务代码泛滥**：
    
    - **现象**：日志、事务、安全等“交叉业务”代码（又称“横切关注点”）混杂在核心业务代码（如订单处理、用户管理）中。
    - **后果**：
        - **代码复用性差**：相同的日志记录代码出现在无数个方法中。
        - **难维护**：修改日志格式需要改动大量文件。
        - **专注度分散**：程序员需要同时关心业务逻辑和技术细节。
            
2. **AOP 的解决方案**：
    - **核心思想**：将交叉业务代码（如日志）从核心业务代码中**剥离出来**，独立设计和开发。
    - **实现方式**：通过**动态代理技术**，在程序运行期间，将剥离出来的交叉业务代码**动态地“织入”** 到核心业务代码的特定位置。
    - **最终效果**：代码结构清晰，核心业务模块高度内聚，交叉业务模块得以复用。
        ![[Pasted image 20251108101151.png]]
### 第二部分：AOP 的核心概念

![[Pasted image 20251108100803.png]]
通知：起增强作用的代码
切点：要被通知增强的方法
连接点：通知可以织入的地方
切面：切点+通知（类似于[[InvocationHandler]]的invoke()方法的代码）

| 概念      | 官方定义与理解                                                    |
| ------- | ---------------------------------------------------------- |
| **连接点** | 程序执行过程中（如方法调用、异常抛出）可以插入切面的**所有可能的位置**。                     |
| **切点**  | 通过**切点表达式**来**精确匹配**出的、**真正需要织入通知的连接点**。一个切点对应多个连接点。       |
| **通知**  | 想要织入的**具体代码逻辑**，如日志记录。分为前置、后置、环绕、异常、最终通知。                  |
| **切面**  | **切点 + 通知 = 切面**。它是一个完整的模块，定义了“在**何处**（切点）”执行“**什么**（通知）”。 |
| 织入      | 将**切面**应用到**目标对象**上，从而创建出**代理对象**的**过程**。                  |
| 目标对象    | 被一个或多个切面**织入**的那个对象。                                       |
| 代理对象    | 目标对象被织入通知后**产生的新对象**。                                      |

#### 切点表达式


        
    

### 第三部分：Spring 如何实现 AOP？

图6指出了 Spring 实现 AOP 的三种方式，并给出了最佳实践建议。

1. **Spring + AspectJ（基于注解）**：**当前主流和首选方式**。通过在 Java 代码中使用注解（如 `@Aspect`, `@Before`, `@After`等）来定义切面。代码直观，配置方便。
    
2. **Spring + AspectJ（基于 XML）**：通过 XML 文件来配置切面、切点、通知。优点是与代码解耦，但配置较为繁琐，可读性不如注解。
    
3. **纯 Spring XML 配置**：Spring 框架自己实现的 AOP，配置更原始，功能较弱，**已不推荐使用**。
    

**最佳实践**：在现代 Spring Boot 应用中，**毫无争议地使用第一种基于注解的方式**（Spring + AspectJ）。
