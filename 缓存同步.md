---
aliases:
  - 缓存一致性
  - 一致性
---
感谢分享这张非常实用的缓存更新策略图解！它清晰地对比了三种核心策略。我来为您深入解析每种策略的适用场景和实战要点：

## 🎯 三种缓存更新策略深度解析

### 1. **设置有效期（TTL失效）策略**
运作机制：为缓存数据设置生存时间，到期自动失效，下次查询时触发更新。

实战示例：
```java
// Spring Boot中的简单实现
@Service
public class ProductService {
    @Cacheable(value = "products", key = "#id", unless = "#result == null")
    public Product getProduct(Long id) {
        // 从数据库查询，结果会自动缓存
        return productRepository.findById(id);
    }
}
```

适用场景：
• 用户画像数据（更新频率低）

• 商品分类信息（时效性要求不高）

• 配置信息等静态数据


风险提示：可能产生缓存击穿——热点key过期瞬间大量请求直达数据库。解决方案：
```java
@Cacheable(value = "products", key = "#id", sync = true) // 添加同步锁
```

### 2. **同步双写策略**
运作机制：在同一个事务内完成数据库更新和缓存更新，保证强一致性。

实战示例：
```java
@Service
@Transactional
public class ProductService {
    public void updateProduct(Product product) {
        // 1. 更新数据库
        productRepository.update(product);
        
        // 2. 同步更新缓存
        redisTemplate.opsForValue().set(
            "product:" + product.getId(), 
            product, 
            30, TimeUnit.MINUTES
        );
        
        // 3. 如果第二步失败，整个事务回滚
    }
}
```

适用场景：
• 库存扣减（要求实时一致性）

• 账户余额变更

• 订单状态更新


风险提示：需要考虑操作原子性，建议将缓存操作放在事务末尾，失败时自动回滚。

### 3. **异步通知策略**
运作机制：通过消息队列解耦，数据库变更后发送事件，消费者异步更新缓存。
- 使用[[canal]]实现异步通知策略

实战架构：
```java
// 1. 数据库变更后发送事件
@Service
public class ProductService {
    @Transactional
    public void updateProduct(Product product) {
        productRepository.update(product);
        // 发送消息到MQ，不阻塞主流程
        kafkaTemplate.send("product-update", product.getId());
    }
}

// 2. 独立的缓存更新服务
@Component
public class CacheUpdateListener {
    @KafkaListener(topics = "product-update")
    public void updateCache(Long productId) {
        Product product = productService.getProduct(productId);
        redisTemplate.opsForValue().set(
            "product:" + productId, product, 30, TimeUnit.MINUTES
        );
    }
}
```

适用场景：
• 用户信息更新（可接受秒级延迟）

• 商品价格变更

• 需要多个系统同步缓存的场景


## 🏗️ 混合策略实战建议

在实际项目中，通常根据业务特性组合使用多种策略：

### **读写分离策略**
```java
@Service
public class HybridCacheService {
    // 读多写少：缓存失效 + 异步更新
    public Product getProduct(Long id) {
        // 先读缓存，失效时从数据库加载
        return cacheService.getOrLoad("product:" + id, 
            () -> productRepository.findById(id), 30, TimeUnit.MINUTES);
    }
    
    // 写操作：同步双写保证一致性
    @Transactional
    public void updateProduct(Product product) {
        productRepository.update(product);
        cacheService.set("product:" + product.getId(), product);
    }
}
```

### **分级缓存策略**
```java
@Service
public class MultiLevelCacheService {
    // L1: 本地缓存（Caffeine） + L2: Redis缓存
    @Cacheable(value = "products", key = "#id", cacheManager = "caffeineCacheManager")
    public Product getProduct(Long id) {
        Product product = redisTemplate.opsForValue().get("product:" + id);
        if (product == null) {
            product = productRepository.findById(id);
            redisTemplate.opsForValue().set("product:" + id, product, 1, TimeUnit.HOURS);
        }
        return product;
    }
}
```

## 📊 策略选择决策矩阵

| 策略 | 一致性要求 | 性能要求 | 实现复杂度 | 业务场景 |
|------|------------|----------|------------|----------|
| 设置有效期 | 最终一致 | 高 | 低 | 配置信息、商品分类 |
| 同步双写 | 强一致 | 中 | 高 | 库存、账户余额 |
| 异步通知 | 最终一致 | 高 | 中 | 用户画像、商品信息 |

## ⚠️ 生产环境注意事项

1. 缓存降级：任何缓存策略都要有降级方案，确保缓存故障时系统仍可用
2. 监控告警：监控缓存命中率、延迟等关键指标
3. 容量规划：合理设置内存大小和淘汰策略
4. 异常处理：网络超时、序列化异常等边界情况处理

这三种策略没有绝对的好坏，只有最适合当前业务场景的选择。通常建议：优先考虑异步通知，对一致性要求极高的场景使用同步双写，对变更不频繁的数据使用TTL失效策略。

希望这个详细的解析对您有帮助！