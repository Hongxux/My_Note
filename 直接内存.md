- 需求背景：传统 I/O 的瓶颈，将数据放入JVM堆内存
	- 拷贝的负担：数据需要在JVM堆内存和操作系统内核内存之间来回拷贝，不必要的数据复制耗时耗力![[Pasted image 20251207133844.png]]
		- 拷贝到JVM堆空间，Java程序才能处理
	- GC回收影响：位于JVM堆内的缓冲区会受垃圾回收影响，特别是Full GC时可能造成显著停顿
	- 堆内存有限：单个JVM实例堆内存大小受限，无法处理超大规模数据
- 解决措施：直接内存，存储在内核态的内存，且可以被JAVA代码访问![[Pasted image 20251207133943.png]]
	- 来源：直接向操作系统申请内存
		- 不受堆内存限制：理论上容量只受本机物理内存和操作系统限制，可操作更大数据块
		- 分配在JVM堆外，减轻GC压力
			- 尤其适合需要管理大量缓存或长时间存活数据的场景
	- 使用：Java代码可直接访问操作系统缓冲区
		- 零拷贝：直接内存存储在操作系统缓存区，无需来回拷贝
- 问题：
	- 分配与回收成本较高：创建和销毁`DirectByteBuffer`的开销通常比堆内对象大
		- 更适合用于需要缓存或生命周期较长的数据，而不是需要频繁创建和销毁的场景
	- 内存泄露风险：脱离JAVA的GC自动回收机制
		- 可以通过 `-XX:MaxDirectMemorySize`参数来限制其大小
- 使用方式：
	- 分配内存：
		- 方式：
			- 分配 1024 字节的直接内存`ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);`
				- DirectByteBuffer对象：它封装了在操作系统内存中分配的直接内存区域
			- 使用内存池（如 Netty 提供的 `ByteBuf`分配器）来管理直接内存
		- 注意：分配速度慢，要避免频繁分配和释放小内存
	- 写入数据：
		- `directBuffer.put("Hello, Direct Memory!".getBytes()); // 写入字节数组`
	- 切换读写模式：
		- 写入数据后，需要调用 `flip()`方法，将缓冲区从写模式切换为读模式，以便后续读取
		- `directBuffer.flip(); // 切换为读模式，position置0，limit指向上次写入的位置`
	- 读数据：
		- `directBuffer.get(new byte[directBuffer.remaining()]); // 根据剩余字节数创建数组,将数据读入字节数组`
	- 释放内存：通过反射调用 `Cleaner`的 `clean()`方法，使用 `Cleaner`机制显式释放
		```java
		// 示例：显式释放直接内存的方法
		public static void cleanDirectMemory(ByteBuffer buffer) throws Exception {
			if (buffer == null || !buffer.isDirect()) return;
			try {
				Method cleanerMethod = buffer.getClass().getMethod("cleaner");
				cleanerMethod.setAccessible(true);
				Object cleaner = cleanerMethod.invoke(buffer);
				Method cleanMethod = cleaner.getClass().getMethod("clean");
				cleanMethod.setAccessible(true);
				cleanMethod.invoke(cleaner);
			} catch (Exception e) {
				// 处理异常
					throw new Exception("释放直接内存失败", e);
			}
		}
		// 使用示例
		cleanDirectMemory(directBuffer);
		```
- 分配和释放直接内存的原理：
	- 分配内存：使用unsafe对象完成
		1. 向操作系统申请内存： 通过 `sun.misc.Unsafe`类的 `allocateMemory(size)`这个 **Native 方法
			- 其底层本质是调用了类似 C 语言的 `malloc()`函数
		2. 内存初始化：调用 `Unsafe.setMemory()`将这块新内存初始化为零值
			- 目的：防止读到残留的“脏数据”
		3. 注册清理机制：创建一个 `Cleaner`对象，关联着刚创建的 `DirectByteBuffer`对象，并持有一个 `Deallocator`对象
			- Cleaner是一个虚引用
			- `Cleaner`对象的clean方法会执行之前注册的 `Deallocator`的 `run()`方法
				-  `Deallocator`的 `run()`方法调用Unsafe.freeMemory()释放内存
	- 释放内存：
		- 被动释放（依赖GC）
			- 监控：ByteBuffer 使用了 Cleaner (虚引用)来监测 ByteBufer 对象
			- 触发时机：BvteBufer 对象被垃圾回收
			- 释放方式： ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存
				- clean方法中调用`Deallocator`的 `run()`方法
		- 主动释放
			- 通过 `DirectByteBuffer`对象获取其关联的 `Cleaner`，
			- 直接调用`Cleaner`的 `clean()`方法
				