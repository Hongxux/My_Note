---
aliases:
  - Fork/Join
---
- 需求背景：为什么有ThreadPoolExecutor（传统线程池）还要这个
	- ThreadPoolExecutor是任务并行的思想，在处理大型可分解任务的时候复杂度高
		- 需要手动分割任务，创建Callable对象，再提交给线程池
		- 任务完成后需要后动遍历Future再组合结果
	- ThreadPoolExecutor分配任务可能存在负载不均衡的情况
		- 【负载不均衡】一个线程长时间执行任务，而其他线程处于空闲状态
	- 管理大量存在依赖关系的子任务及其 `Future`会引入显著的协调开销
- 解决措施：Fork/Join
	- 组成成分：
		- ForkJoinPool 特殊的线程池，管理工作线程
		- ForkJoinTask：表示任务的抽象类，有两个重要子类
			-  `RecursiveAction`：用于没有返回结果的任务
			- `RecursiveTask`：用于有返回结果的任务
	- 数据结构：
		- 每个工作线程有一个双端队列，称为工作队列
			- 【更新方式】
				-  调用`subTask.fork()`:将subTask加入工作队列尾部
				- 
	- 
- 使用：
	- ForkJoinPool
		- 构造方法：
			- `ForkJoinPool()`：使用默认并行级别（Runtime.getRuntime().availableProcessors()）
			- `ForkJoinPool(int parallelism)`：指定并行级别
		- 重要方法：
			- `invoke(ForkJoinTask<T> task)`：执行任务并等待结果
			- `execute(ForkJoinTask<?> task)`：异步执行任务
			- `submit(ForkJoinTask<T> task)`：提交任务并返回Future
	- ForkJoinTask
		- 关键方法：
			- `fork()`：异步执行子任务
				- 设计目的：
					- 分治：将一个较大的任务异步分解
					- 窃取：把子任务推入当前工作线程自身的任务队列中，以便其他空闲线程（或当前线程后续）能够窃取并执行它
				- 工作流程：
					1. **任务入队**：将子任务加入自己的工作队列
					2. **触发工作线程**：将任务放入队列后，`fork()`方法会触发 `ForkJoinPool`的 `signalWork()`方法。
						- 此方法会尝试唤醒或创建一个新的工作线程，以便及时处理队列中的任务
			- `join()`：获取子任务结果
				- 设计目的：
					- 同步：等待通过 `fork`提交的子任务执行完成，并获取其计算结果
				- 工作流程：
					1. 检查子任务状态：
						- 【检查】方式：调用 `doJoin()`方法来检查子任务的状态
					2. 已经完成：
						- 判断依据：【返回值】为NORMAL表示子任务已经正常完成
						- 处理措施：直接返回结果
					3. 未完成
						- 核心思想：不阻塞等待子任务完成，主动找活干
							- 提升cpu利用率，不阻塞暂停等待
						- 处理措施：窃取其他线程工作队列的任务
							- 检查当前线程的工作队列是否有其他任务可以执行（从队头pop）
								- 保证了最大的缓存局部性：最新产生的任务最可能访问到仍在缓存中的热点数据
							- 窃取其他线程的工作队列的任务（从队尾poll）
								- 负载均衡：
									- 队列中最早的任务通常是“最大块”的工作
									- 窃取走大任务能更有效地均衡负载
						- 周期性检查：
							- 【检查时期】在执行其他任务的过程中
							- 【检查】内容：它所 `join`的那个子任务是否完成。
								- 一旦完成，就获取结果
			- `invoke()`：开始执行任务并等待结果
			- `invokeAll(ForkJoinTask<?>... tasks)`：执行多个任务
