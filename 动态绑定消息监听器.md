### 1.创建动态绑定消息监听器的工具类
```
package com.hmdp.utils;  
  
import lombok.extern.slf4j.Slf4j;  
import org.redisson.api.RLock;  
import org.redisson.api.RedissonClient;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.data.redis.connection.stream.*;  
import org.springframework.data.redis.core.StringRedisTemplate;  
import org.springframework.data.redis.stream.StreamListener;  
import org.springframework.data.redis.stream.StreamMessageListenerContainer;  
import org.springframework.stereotype.Component;  
  
import java.util.Map;  
  
/**  
 * 动态Redis Stream消费者管理器  
 *  
 * <p>该类负责动态注册和管理Redis Stream消息监听器，支持为指定的Stream和消费者组创建多个消费者实例。  
 * 通过使用分布式锁确保消费者组创建的原子性，避免并发环境下的重复创建问题。</p>  
 *  
 * <p><b>主要功能：</b>  
 * <ul>  
 *   <li>动态注册Stream消息监听器到指定的消费者组</li>  
 *   <li>自动创建消费者组（可选）</li>  
 *   <li>为每个消费者同时注册新消息和待处理消息的监听请求</li>  
 *   <li>提供线程安全的消费者组初始化机制</li>  
 * </ul>  
 *  
 * @author 您的姓名  
 * @version 1.0  
 * @since 2024  
 * @see StreamMessageListenerContainer  
 * @see StreamListener  
 */@Component  
@Slf4j  
public class DynamicStreamConsumerManager {  
  
    @Autowired  
    private StreamMessageListenerContainer<String, MapRecord<String, String, String>> container;  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    @Autowired  
    private RedissonClient redissonClient; // 用于分布式锁，确保组创建原子性  
  
    /**  
     * 创建Stream读取请求  
     *  
     * <p>构建一个Stream消息读取请求，配置消费的偏移量、消费者信息及确认模式。</p>  
     *  
     * @param readOffset 读取偏移量（如">"表示新消息，"0"表示待处理消息）  
     * @param requestName 请求名称，用于日志标识  
     * @param streamKey Stream的键名  
     * @param consumerGroup 消费者组名  
     * @param consumerName 消费者名称  
     * @return 配置好的Stream读取请求对象  
     * @see ReadOffset  
     * @see Consumer  
     */    private StreamMessageListenerContainer.StreamReadRequest<String> createReadRequest(  
            String readOffset, String requestName, String streamKey,  
            String consumerGroup, String consumerName) {  
  
        return StreamMessageListenerContainer.StreamReadRequest  
                .builder(StreamOffset.create(streamKey, ReadOffset.from(readOffset)))  
                .consumer(Consumer.from(consumerGroup, consumerName))  
                .autoAcknowledge(false) // 手动ACK，确保消息处理完成后再确认  
                .build();  
    }  
  
    /**  
     * 为核心方法：为某个Service方法动态注册一个消费者  
     *  
     * <p>该方法会为指定的Stream和消费者组注册消息监听器，支持同时创建多个消费者实例。  
     * 使用分布式锁确保消费者组创建的原子性，避免并发问题。</p>  
     *  
     * <p><b>执行流程：</b>  
     * <ol>  
     *   <li>获取分布式锁，确保组创建操作的原子性</li>  
     *   <li>根据需要创建消费者组（如果启用autoCreateGroup）</li>  
     *   <li>为每个消费者名称创建两个监听请求：  
     *     <ul>  
     *       <li>主请求：监听新消息（偏移量">"）</li>  
     *       <li>待处理请求：监听处理失败的消息（偏移量"0"）</li>  
     *     </ul>  
     *   </li>  
     *   <li>将监听器注册到容器并启动消息消费</li>  
     * </ol>  
     *  
     * @param streamKey Redis Stream的键名，不能为null  
     * @param consumerGroup 消费者组名称，不能为null  
     * @param consumerNames 消费者名称数组，支持多个消费者实例  
     * @param readOffset 消费者组创建时的初始读取偏移量  
     * @param autoCreateGroup 是否自动创建消费者组（如果不存在）  
     * @param listener 消息监听器实现，包含具体业务处理逻辑  
     * @throws Exception 当获取分布式锁失败或消费者组创建异常时抛出  
     * @see RLock  
     */    public void registerListener(String streamKey, String consumerGroup, String[] consumerNames,  
                                 String readOffset, boolean autoCreateGroup,  
                                 StreamListener<String, MapRecord<String, String, String>> listener) {  
  
        // 1. 使用分布式锁确保并发安全地创建消费者组  
        RLock lock = redissonClient.getLock("stream:lock:" + streamKey + ":" + consumerGroup);  
        try {  
            lock.lock();  
            // 检查并创建消费者组（如果需要且不存在）  
            if (autoCreateGroup) {  
                createConsumerGroupIfNotExists(streamKey, consumerGroup, readOffset);  
            }  
        } finally {  
            lock.unlock();  
        }  
  
        for (String consumerName : consumerNames) {  
            // 创建新消息监听请求  
            StreamMessageListenerContainer.StreamReadRequest<String> mainRequest =  
                    createReadRequest(">", "ReadNewMessage", streamKey, consumerGroup, consumerName);  
  
            // 创建待处理消息监听请求（用于重新处理失败的消息）  
            StreamMessageListenerContainer.StreamReadRequest<String> pendingRequest =  
                    createReadRequest("0", "ReadPendingMessage", streamKey, consumerGroup, consumerName);  
  
            // 注册监听器  
            container.register(mainRequest, listener);  
            container.register(pendingRequest, listener);  
  
            log.info("动态RedisStream消费者注册成功: stream={}, group={}, consumer={}, offset={}",  
                    streamKey, consumerGroup, consumerName, readOffset);  
        }  
    }  
  
    /**  
     * 安全地创建消费者组  
     *  
     * <p>如果指定的Stream不存在，此方法会先创建Stream再创建消费者组。  
     * 如果消费者组已存在，会捕获异常并记录调试信息。</p>  
     *  
     * @param streamKey Stream键名  
     * @param groupName 消费者组名称  
     * @param readOffset 读取偏移量（如"$"表示从最新消息开始）  
     * @throws Exception 当创建消费者组失败时抛出  
     */  
    private void createConsumerGroupIfNotExists(String streamKey, String groupName, String readOffset) {  
        try {  
            // 尝试创建组。如果流不存在，MKSTREAM参数会先创建流  
            redisTemplate.opsForStream().createGroup(streamKey, ReadOffset.from(readOffset), groupName);  
            log.info("创建RedisStream消费者组: stream={}, group={}", streamKey, groupName);  
        } catch (Exception e) {  
            // 组通常已存在，可以忽略此错误  
            log.debug("消费者组可能已存在（可忽略）: stream={}, group={}, error={}",  
                    streamKey, groupName, e.getMessage());  
        }  
    }  
}
```
### 2.在业务中使用
#### 1.创建一个监听器处理器内部类
注意其泛型
```
@Component  
private class SeckillVoucherConsumerListener implements StreamListener<String, MapRecord<String, String, String>> {  
  
    @Override  
    public void onMessage(MapRecord<String, String, String> message) {  
        //1.解析消息  
        log.debug("message.getValue()=" + message.getValue());  
  
        Map<String, String> messageMap = message.getValue();  
        String voucherIdStr = messageMap.get("voucherId");  
        String userIdStr = messageMap.get("userId");  
        String orderIdStr = messageMap.get("orderId");  
        // 2. 构造订单对象 (这里需要将字符串转换回对应的类型)  
        VoucherOrder voucherOrder = new VoucherOrder();  
        voucherOrder.setId(Long.parseLong(orderIdStr));  
        voucherOrder.setUserId(Long.parseLong(userIdStr));  
        voucherOrder.setVoucherId(Long.parseLong(voucherIdStr));  
  
        //3.对数据库进行操作  
        //使用乐观锁扣减库存,确保不超买  
        seckillVoucherService.update()  
                .setSql("stock = stock-1")  
                .eq("voucher_id", voucherOrder.getVoucherId())  
                .gt("stock", 0)  
                .update();  
        //创建订单  
        VoucherOrderServiceImpl.this.save(voucherOrder);  
        //ack  
        stringRedisTemplate.opsForStream().acknowledge("stream.orders","seckillVoucherConsumerGroup",message.getId());  
  
    }  
}
```
#### 2.在Bean初始化完成后
```
@Autowired  
private DynamicStreamConsumerManager dynamicStreamConsumerManager;
@Autowired  
private StreamMessageListenerContainer<String, MapRecord<String, String, String>>  streamMessageListenerContainer;


@PostConstruct  
public void init() {  
    if(!streamMessageListenerContainer.isRunning()){  
        streamMessageListenerContainer.start();  
    }  
    dynamicStreamConsumerManager.registerListener("stream.orders","seckillVoucherConsumerGroup",new String[]{"c1","c2"},"$",true,new SeckillVoucherConsumerListener());  
  
}
```
- 判断监听器容器有没有跑起来，没有跑起来我就手动让他跑起来
	- 监听器跑起来后，会持续监听我们的消息队列的有没有消息
- 然后我们动态注册我们的消费者组，规定其从最新消息开始读取，并且设定自动创建消费者组（如果不存在），并且绑定一个监听器处理器SeckillVoucherConsumerListener