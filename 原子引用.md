---
aliases:
  - AtomicReference
  - "`AtomicStampedReference"
---
- 需求背景：共享数据不是基本类型
- 实现类：
- `AtomicReference<V>`：不关心引用被修改的历史记录
- `AtomicStampedReference<V>`：解决ABA问题，还能知道被修改了几次
	- 引用变化的跟踪方式：关联一个整型版本号（Stamp）
	- 实现方式：一个对象引用 + 一个`int`版本号，两者绑定更新。
	- CAS操作：同时比较引用和版本号，确保二者均符合预期才更新
	- 适用示例：
		```
		public class ABADemo {
			private AtomicStampedReference<String> ref = 
				new AtomicStampedReference<>("A", 0); // 初始值"A"，版本号0
		
			public void update() {
				int[] stampHolder = new int[1];
				String current = ref.get(stampHolder); // 获取当前值和版本号
				int newStamp = stampHolder[0] + 1;
				// 更新值并增加版本号
				ref.compareAndSet(current, "B", stampHolder[0], newStamp);
			}
		
			public boolean isModified() {
				return ref.getStamp() > 0; // 通过版本号判断是否被修改过
			}
		}
		
		```
- `AtomicMarkableReference<V>`：解决ABA问题，只关心是否被修改的场景
	- 引用修改的跟踪方式：关联一个布尔型标记位（Mark）
	- 实现方式：一个对象引用 + 一个`boolean`标记位，两者绑定更新。
	- 原子操作：同时比较引用和标记位，确保二者均符合预期才更新。
	- 适用示例：
		```
		public class Cache<T> {
			private AtomicMarkableReference<T> data = 
				new AtomicMarkableReference<>(null, false); // 初始无数据，标记为未失效
			
			// 更新缓存并标记为有效
			public void updateCache(T newData) {
				data.set(newData, true); // 设置新数据，标记为有效
			}
			
			// 检查缓存是否有效（未被失效）
			public T getCache() {
				boolean[] markHolder = { false };
				T value = data.get(markHolder);
				return markHolder[0] ? value : null; // 仅返回有效数据
			}
		}
		
		```