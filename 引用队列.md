- 需求背景：
	- 希望得知一个引用所引用的对象被GC回收了
		- GC回收是自动的，无感的
	- 希望实现清理操作的解耦与自动化：
		- 清理操作：如关闭文件句柄、释放堆外内存、从缓存映射中移除无效条目
- 解决措施：引用队列
	- 工作流程：
		1. **关联注册**：当你创建一个引用对象时，可以选择将一个`ReferenceQueue`对象作为参数传入其构造函数。这样，你就将这个引用“注册”到了这个队列上。
		2. **GC 触发与入队**：
			- 入队时机：当垃圾回收器（GC）发现某个对象**只剩下软、弱或虚引用**时，会根据其引用类型决定是否回收。在回收该对象**之后**，GC 会将被回收对象对应的**引用对象本身**（即那个`SoftReference`，`WeakReference`或`PhantomReference`实例）放入其关联的引用队列中。
		3. **程序轮询处理**：你的应用程序中可以启动一个单独的线程，不断地从`ReferenceQueue`中轮询或取出这些已被放入队列的引用对象。通过这个引用对象，你可以知道是哪个原始对象被回收了，从而执行相应的清理逻辑。
	- 使用场景：
		- 当与它关联的引用对象被放入队列时，就意味着它指向的对象已经被GC回收了
		- 你的清理线程可以从队列中取出这些引用，并同步地清理缓存中对应的键值对，防止缓存无限膨胀