---
aliases:
  - cast
---

**核心原则**：应尽量减少转换的使用，优先通过多态和**设计优化（如在超类中添加通用方法）** 来避免转换需求。转换通常是**设计缺陷的标志**。
- **转换目的**​：转换的主要原因是使用对象的全部功能，当对象实际类型被多态暂时隐藏时（如将`Employee`引用转换为`Manager`以访问`setBonus`方法）。
	对于改写父类的方法，Java通过动态绑定能自动处理方法调用，无需显式转换。只有在调用子类新增的方法的时候才要用到类型转换。
**转换语法**​：使用括号和目标类型进行转换，例如 `(int) x`用于基本类型，`(Manager) staff[0]`用于对象引用。这允许在继承层次结构内将超类引用转换为子类引用。
	类型转换可能引发`ClassCastException`，导致程序不稳定。

	
**instanceof检查类型**：
- **新模式：** 减少样板代码。传统`instanceof`检查后需要显式类型转换（如`if (obj instanceof Manager) { Manager m = (Manager) obj; ... }`）。新模式允许直接在`instanceof`中声明变量：`if (obj instanceof Manager m) { ... }`，自动绑定变量并跳过转换。
	- ![[Pasted image 20251018205319.png]]
	- ![[Pasted image 20251018205335.png]]
	- **作用域规则**​：模式变量（如`m`）仅在`instanceof`检查成功的作用域内可用。
		- 在 **`if`块内或逻辑与（`&&`）** 的后续表达式中可安全使用（只有在前面为真，&&后面才执行），
		- 在**逻辑或（`||`）** 中会导致错误（前面不为真，||后面才执行），因为变量可能未绑定。
		- **三元运算符：** 模式变量可用于三元运算符，如`double bonus = e instanceof Manager m ? m.getBonus() : 0;`，变量`m`仅在真分支有效。
- **null：** null代表没有指向的对象。
- ​**错误处理**​：无意义的模式（如`Manager m instanceof Employee e`）会编译错误，因为`Manager`显然是`Employee`子类。但传统`instanceof`检查（无变量）仍允许以保持兼容性。

**实际使用推荐：**
- **利用多态**: 设计类层次时，确保通用方法在超类中定义，子类通过**重写**来实现特定行为，而不是依赖转换。
	- **重构考虑**: 如果发现多个地方需要转换来调用同一方法，考虑重构超类以包含该方法，提高代码一致性。
- **异常处理**: 如果必须使用转换，总是通过`instanceof`检查来确保安全，并处理可能的异常。
	- **代码审查**: 定期检查代码中是否有不必要的转换或`instanceof`使用，这可能是设计问题的信号。