---
aliases:
  - CMS
---
- 设计目的：低延迟
	- 低延迟意味着更短的停顿时间
- 实现方式：
	- 初始标记、并发标记和并发清除，在此阶段不会发生STW
		- 只有在重新标记阶段，为了保证引用关系的不变性，会使用STW
	- 老年代垃圾回收算法为标记清除，停顿时间更短
		- 问题：会产生内存碎片
		- 权衡：老年代中的对象存活率高，生命周期长，垃圾产生的频率相对较低。因此碎片化问题虽然存在，但演进较慢
	- 引入卡表和RSet优化[[新生代的跨代引用]]问题
- 问题：
	- **吞吐量会下降**
		- 因为有一部分cpu用于垃圾回收，用于用户线程的cpu就少了
		- 缓解方式：通过参数`-XX:ParallelCMSThreads`调整CMS后台线程数
			- 默认值为`(ParallelGCThreads + 3) / 4)`
	- **浮动垃圾产生**
		- 浮动垃圾的定义：并发清理时用户线程仍在运行，会产生新垃圾
		- 采取行动：提前触发GC，为“浮动垃圾”预留空间
		- 调整触发阀值：
			- `XX:+UseCMSInitiatingOccupancyOnly`必须与 `-XX:CMSInitiatingOccupancyFraction`搭配使用，以确保JVM始终采用你设定的阈值
	- **并发模式失败**：
		- 发生时期：CMS并发清理执行期间
		- 原因：
			- 根本原因：当CMS在并发清理期间，用户线程还在运行并产生新垃圾
			- 直接原因：老年代预留的空间被快速填满，无法容纳从年轻代晋升上来的对象
				- 浮动垃圾产生过快
				- 对象晋升速度超预期
				- CMS是标记清除，会导致内存碎片化
					- 即使总剩余内存足够，也无法找到连续空间分配大对象
					- 从而触发晋升失败或并发模式失败
		- 后果：JVM会不得不停止并发周期，并启动一次Serial Old Full GC
			- 停顿时间通常会很长
		- 解决措施：让CMS更早、更有效地工作
			- 根本优化：分析晋升到老年代的对象数量和频率。如果晋升过快
				- 优化新生代配置
					- 如增大Survivor区以减少不必要的提前晋升
				- 从代码层面减少对象创建。
			- 参数调整：
				- 合理设置 `-XX:CMSInitiatingOccupancyFraction`（如70%）
				- 为老年代分配更大空间（如调整 `-Xmn`设置新生代大小，为老年代留出更多内存）。
	- **重新标记会STW**，缓解措施
		- 在重新标记前强制进行一次Young GC：XX:+CMSScavengeBeforeRemark
			- 目的：清理掉大部分已消亡的年轻代对象大大减少需要从年轻代扫描到老年代的引用数量
		- 允许使用多个GC线程并行完成重新标记工作： `-XX:+CMSParallelRemarkEnabled`
- 工作模式：![[Pasted image 20251207181556.png]]
	1. 初始标记（STW）：标记根对象 
		- 由于浮动垃圾的存在，要在一定的阈值，就开始进行垃圾回收
	2. 并发标记 ：
		- 在这期间使用卡表记录变更的发生，[[增量更新]]进行查缺补漏
		- 由于此阶段的存在，导致了浮动垃圾的产生
	3. 重新标记（STW）：在并发标记的时候，用户线程更改了引用关系
		- 可以通过配置，在此之前先进行一次minor GC,减少重新标记的对象，减少STW时停
		- 可以通过配置，触发此阶段并行执行
	4. 并发清除：采用[[标记清除]]的方式，在“并发清除”阶段实现低停顿
		- 如果采用“标记-整理”，就需要在回收过程中移动存活对象，这个操作非常复杂且需要暂停所有应用线程（STW），这与CMS追求低延迟的设计目标相悖
		- CMS用空间碎片来换取并发收集时的低延迟。
- 开启方式：
	- 启用基于复制的ParNew收集器负责新生代回收：`-XX:+UseParNewGC`
	- 启用CMS收集器负责老年代回收:`-XX:+UseConcMarkSweepGC`
		- 用户线程和垃圾回收线程并发运行 
	- 在现代JDK 8中，通常只设置 `-XX:+UseConcMarkSweepGC`，JVM会自动启用ParNew与之配合