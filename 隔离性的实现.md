
1. **读未提交**​：事务会**直接读取数据页上的最新版本**，而**不生成任何快照**。
	- 因为**不生成快照**，意味着**完全绕过了MVCC机制**，不去undo log版本链中寻找历史版本。
		- 而**直接读取数据页最新版本**，意味着能读取到其他事务**最新修改但未提交的数据**。
			- 该数据可能来自其他**活跃且未提交的事务**，其修改可能被回滚。
因此，事务可能读取到其他事务未提交的、可能被回滚的中间状态数据，导致了**脏读**问题。（未上锁，直接读）

2. **读已提交** ：​**每次** `SELECT` 都会生成一个独立的**快照**。
	使用**快照读**，意味着去**undo log版本链中找寻数据**，
		而**版本链中数据**必然源自于**已提交的事务**
因此使用快照读读取的数据必然是已经被提交的事务的数据，解决了脏读问题。

3. **可重复读**​：事务中**第一次**​ `SELECT`会生成一个**快照**，并在整个事务期间**复用**此快照。
	- 使用**快照读**，意味着去 ​**undo log 版本链中找寻数据**。
		- 而**找寻哪个版本**，由事务开始时生成的 ​**ReadView 可见性规则**决定。
			- 该 ​**ReadView 规则**在整个事务生命周期内**保持不变**，因此对同一数据版本的**判定结果也保持不变**。
因此，在整个事务中，无论其他事务是否提交修改，每次快照读读取到的都是**同一个一致性视图下的数据**，解决了不可重复读问题。

4. **当前读**​：执行语句时**直接读取数据页上的最新版本**。
	- 使用**当前读**，意味着**绕过 MVCC 的快照机制**
		- 而为了确保读取期间数据**不被其他事务修改**，会对读取的数据**直接加锁**。
			- 该**锁机制**会**阻塞**其他事务的写操作，直至当前事务结束。
因此，当前读通过加锁的方式，强制读取已提交的最新数据并保证期间数据不被修改，实现了数据的强一致性。（先上锁，再读取）

当前读和串行化隔离级别的区别在于，当前读是通过SQL语句主动指定的，而串行化则是被动被数据库调整成当前读。


| 隔离级别       | 快照读的生成时机                        | 行为解读                                                                            |
| ---------- | ------------------------------- | ------------------------------------------------------------------------------- |
| ​**读已提交**​ | ​**每次 `SELECT`**​ 都会生成一个独立的快照。  | 这意味着在同一事务内，两次相同的 `SELECT`可能会看到不同的结果（如果中间有其他事务提交了修改）。​**它解决了脏读，但可能出现不可重复读。​**​   |
| ​**可重复读**​ | 事务中**第一个 `SELECT`**​ 语句执行时生成快照。 | 在整个事务期间，所有的快照读都会使用这个**同一个**快照。因此，多次读取同一数据的结果始终一致。​**它解决了不可重复读。​**​              |
| ​**串行化**​  | ​**退化为当前读**。                    | 在此隔离级别下，普通的 `SELECT`也会自动转换为 `SELECT ... LOCK IN SHARE MODE`，通过加锁来保证绝对的隔离，并发性最低。 |


