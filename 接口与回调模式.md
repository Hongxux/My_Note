

想象一下，你告诉一个朋友："当我的包裹到达时，请打电话通知我"。这就是回调的本质——在某个事件发生时执行特定的操作。在编程中，这种模式无处不在，而接口正是实现它的完美工具！
	假设你正在开发一个监控系统，需要在特定时间间隔检查服务器状态。如果没有回调机制：

```
// 笨拙的实现方式
while (true) {
    Thread.sleep(1000); // 等待1秒
    checkServerStatus(); // 执行检查
    // 但这样会阻塞主线程！
}
```

这种实现不仅效率低下，还难以扩展。回调模式正是解决这类问题的优雅方案！
**具体案例：​**​

1. ​**用户界面**​：按钮点击、菜单选择、键盘输入
    
2. ​**定时任务**​：定期备份、缓存刷新、心跳检测
    
3. ​**网络编程**​：HTTP响应处理、Socket消息接收
    
4. ​**文件监控**​：文件创建/修改通知
    
5. ​**系统集成**​：外部设备状态变化通知
---

#### 1. 回调模式的核心概念

- ​**定义**​：指定在特定事件发生时应执行的操作
    
- ​**实现机制**​：通过接口定义回调契约
    
- ​**关键组件**​：
    
    - ​**事件源**​：产生事件的对象（如Timer）
        
    - ​**监听器**​：实现回调接口的对象
        - **implments 接口**：能确保事件源知道调用哪个方法
        - **实现类**：自由定义具体行为（发生事件后就执行这个处理函数）
    - **​[[事件对象]]**：封装事件相关信息
        
    

#### 2. Timer类的回调实现

```
// 1. 定义监听器类
class TimePrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        // 事件处理逻辑
        System.out.println("At the tone, the time is " + 
            Instant.ofEpochMilli(event.getWhen()));
        Toolkit.getDefaultToolkit().beep();
    }
}

// 2. 创建并启动定时器
ActionListener listener = new TimePrinter();
Timer timer = new Timer(1000, listener); // 1000ms间隔
timer.start();
```

#### 3. 关键API详解

|组件|功能|重要方法|
|---|---|---|
|​**Timer**​|定时事件发生器|`Timer(int delay, ActionListener listener)`  <br>`start()`  <br>`stop()`|
|​**ActionListener**​|回调接口|`actionPerformed(ActionEvent e)`|
|​**ActionEvent**​|事件信息容器|`getWhen()`（事件时间戳）  <br>`getSource()`（事件源）|
|​**Toolkit**​|系统工具|`getDefaultToolkit().beep()`（系统提示音）|


---

## 面试官关心的方面及答案

### 问题1：为什么Java使用对象传递而不是函数指针实现回调？

​**答案：​**​

​**面向对象优势：​**​

```
// 函数式语言可能这样实现
Timer.setCallback(function() { 
    System.out.println("Callback executed");
});

// Java面向对象实现
Timer.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Callback executed");
        // 可以访问对象状态
        this.updateCounter(); 
    }
});
```

​**关键优势：​**​

1. ​**状态保持**​：回调对象可以封装状态（字段）
    
2. ​**多方法支持**​：单个对象可实现多个回调接口
    
3. ​**扩展性**​：可以通过继承创建更专业的监听器
    
4. ​**类型安全**​：编译器检查接口实现
    

### 问题2：ActionListener为什么只定义一个方法？

​**答案：​**​

​**单一职责原则：​**​

```
// 单一方法接口示例
public interface ActionListener {
    void actionPerformed(ActionEvent e);
}

// 使用lambda表达式简化
timer.addActionListener(e -> handleTimerEvent());
```

​**设计考量：​**​

1. ​**专注性**​：每个事件类型对应专门接口
    
2. ​**清晰性**​：明确区分不同事件处理
    
3. ​**函数式兼容**​：Java 8+支持lambda实现
    
4. ​**避免冗余**​：不需要的方法不必实现
    

​**其他事件接口：​**​

- `MouseListener`（5个方法）处理复杂鼠标事件
    
- `KeyListener`（3个方法）处理键盘事件
    
- 简单事件使用单一方法接口
    


​