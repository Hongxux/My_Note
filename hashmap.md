- 扩容
	- 触发时机：
		- 元素数量 `size`> 当前阈值 (threshold)
			- threshold = capacity * loadFactor
		- 当有桶的链表长度 ≥ 8 但数组容量 < 64
	- 新容量：旧容量的 **2 倍**（`oldCap << 1`）
		- 直到达到最大容量 `MAXIMUM_CAPACITY`(1 << 30)
	- 新阈值：新容量乘以负载因子，即 `newCap * loadFactor`
	- 数据迁移：原链表拆分为低位链表和高位链表
		- 判断方式：e.hash & oldCap== 0
			- oldCap的二进制特点：oldCap是一个2的幂次数，其二进制表示是单个1后面跟着若干个0（例如，16的二进制是10000）
			- 按位与的目的：检查哈希值 `e.hash`的二进制表示中，与 `oldCap`那个`1`相对应的位置上是`0`还是`1`
				- 高位索引：为1
				- 低位索引：为0
		- 迁移方式：
			- 链表
				- 低位索引：索引不变
				- 高位链表：索引=原索引+旧容量
			- 树：根据新的分布情况决定
				- 将树拆分成两个链表
				- 还是保持树结构
				- 甚至在节点过少时退化成链表
		- 设计目的：
			- 避免了重新计算每个节点的哈希值，提升了效率
	- 插入方式：DK 1.8 将 JDK 1.7 的头插法改为尾插法，
		- 避免了多线程环境下扩容时可能产生的环形链表问题
	- 