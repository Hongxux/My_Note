
- 覆盖索引（Covering Index）是指 **索引包含查询语句所需的所有列**，MySQL 无需回表（访问聚簇索引）即可从索引中直接获取所有查询结果，这种索引扫描被称为「索引 - only 扫描」（Index-Only Scan）。

- 核心逻辑：
	- InnoDB 的索引结构中，聚簇索引（主键索引）的叶子节点存储完整数据行，而二级索引（非主键索引）的叶子节点仅存储 **索引列值 + 主键值**。
		- 普通二级索引查询：若查询列包含非索引列（如用 `name` 索引查询 `id、name、age`），需先通过二级索引找到主键，再回表查询聚簇索引获取 `age`，即「回表查询」；
		- 覆盖索引查询：若二级索引包含所有查询列（如索引为 `(name, age)`，查询 `name、age`），则直接从二级索引叶子节点获取数据，无需回表。
- 核心价值：避免回表查询聚簇索引的**随机 I/O**，减少磁盘 I/O 次数
	- 回表的一次随机IO速度比覆盖索引的顺序IO速度慢100倍
- 滥用覆盖索引的问题
	- 索引体积膨胀，占用额外存储
		- 衍生问题：
			- Buffer Pool 中缓存的有效索引减少，反而降低整体查询命中率。
			- 如果为了避免回表，而将查询列加入索引，会导致B+Tree的非叶子的扇出减少，树高增加，IO读取次数增加
	- 写入性能下降： 每次 `INSERT/UPDATE/DELETE` 操作，需要维护索引。列数越多的覆盖索引，维护开销越大（如更新索引中的 `age` 列，需重新调整 B + 树结构）
- 覆盖索引失效：
	- 大字段覆盖索引失效（InnoDB 限制）：若覆盖索引包含 `TEXT/BLOB` 等大字段，MySQL 可能无法使用索引 - only 扫描（因大字段可能存储在溢出页，需额外读取），最终仍会回表。
	- 若覆盖索引的选择性差（如索引 `(gender, name)`，`gender` 只有男 / 女两个值），MySQL 可能选择全索引扫描（比回表查询更慢）；
----
- 如何权衡是否要建立覆盖索引：
	- 权衡依据：**当 “回表的随机 IO 开销” > “覆盖索引新增的顺序 IO 开销 + 索引维护成本” 时，优先建覆盖索引**
	- 量化计算：
		1. 查询核心参数（决策的前提）
			- 查询特征：
				-  条件字段（如`age`）；
				-  返回字段（如`name, phone`）；
				-  单查询返回数据量（如 500 条）
			- 数据特征：
				-  表数据量（如 1000 万）
				-  字段类型及占用空间（如`VARCHAR(20)`=20 字节）
			- 业务特征：
				- 查询频率（如每秒 100 次，高频 / 低频）
				- 写入频率（如每秒 10 次，写少读多 / 写多读少）
		2. 量化两种方案的 IO 开销（核心计算）
			- 关键前提：
				- 磁盘 Page 大小：InnoDB 默认 16KB；
				- 顺序 IO 耗时：≈10ms / 次（单 Page 读取）；
				- 随机 IO 耗时：≈1000ms / 次（离散 Page 读取，因磁头寻道 + 旋转延迟）；
				- 扇出数计算：`单节点扇出数 = 16*1024 / 单个索引条目的总字节数`；
				- 树高计算：`树高 = log_扇出数(表数据量)`（向上取整，如 log₂₀₄₈(1000 万)≈2 层）。
			- 计算公式：
				- 不建覆盖索引：（二级索引树高 × 10ms） + （单查询返回数据量 × 1000ms）
				- 建覆盖索引：覆盖索引树高 × 10ms
		3. 叠加索引维护成本（不可忽略的隐藏代价）
			- 新增代价：写入数据时，需同时更新覆盖索引（额外 1 次顺序 IO）；
			- 更新代价：若更新的字段包含在覆盖索引中（如`name`），需同步更新覆盖索引的叶子节点（可能触发页分裂，增加 IO）；
			- 删除代价：删除数据时，需同步删除覆盖索引中的对应条目（额外 1 次顺序 IO）。
		4. 追踪决策：
			1. 先通过步骤 2 计算两种方案的「查询 IO 耗时」，若覆盖索引的查询耗时 ≤ 不建方案的 1/10（因随机 IO 开销巨大，通常满足），进入下一步；
			2. 再判断「业务读写比例」：
			    - 写少读多：直接建覆盖索引；
			    - 写多读少：
				    - 若查询是核心链路（如支付流程），仍可建（牺牲部分写入性能换查询稳定性）；
				    - 若是非核心链路，不建；
			3. 特殊限制：若覆盖索引包含「大字段」（如`VARCHAR(255)`、`TEXT`），会导致单索引条目字节数过大，扇出数急剧降低，树高飙升（如树高从 3 层增至 5 层），此时覆盖索引的顺序 IO 耗时可能超过回表开销，不建。
- 替代方案：
	- 接受回表：在写的频率高的场所，接受回表，实现读写性能均衡
	- 字段优化 + 字典表：如果需要加入的索引列是个长字段或者可变字段（`name`），可以使用固定长度的字段（name_code），如果通过字典表映射完整名称，实现覆盖索引
		- 可缓存`name_code`映射到本地缓存或者Redis中优化插入性能；
		- 原理：使用join进行联查，性能比回表查询性能好