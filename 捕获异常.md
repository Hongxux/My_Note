- ​**解决的问题**​：防止未处理异常导致程序崩溃（如GUI程序中文件读取失败时保持界面响应）
    
- ​**副作用与解决**​：过度捕获可能掩盖真正问题（副作用），可通过精确匹配异常类型和层级控制
    
- ​**易混淆点**​：`catch`（捕获处理） vs `throws`（声明传播）
    

思考这个经典困境：你开发的文本编辑器遇到文件损坏时，如果直接崩溃，用户未保存的数据将永久丢失。但若用`try-catch`捕获异常，你既能记录错误信息，又能提示用户保存其他文件——这就是健壮性设计的魅力！

---

### ​**一、未捕获异常的后果**​

#### ​**1. 控制台程序**​

```
public static void main(String[] args) {
    throw new RuntimeException("未捕获异常");
}
```

​**后果**​：

- 程序立即终止
    
- 在控制台打印异常类型及完整堆栈轨迹
    
- 输出示例：
    
    ```
    Exception in thread "main" java.lang.RuntimeException: 未捕获异常
          at Main.main(Main.java:3)
    ```
    

#### ​**2. GUI程序特殊处理**​

```
JButton button = new JButton("点击");
button.addActionListener(e -> {
    try {
        riskyOperation();
    } catch (Exception ex) {
        ex.printStackTrace(); // 打印堆栈
        JOptionPane.showMessageDialog(null, "操作失败");
    }
});
```

​**关键机制**​：

- GUI事件循环（Event Dispatch Thread, EDT）内置异常捕获
    
- 异常发生后：
    
    1. 打印堆栈轨迹（不终止程序）
        
    2. 返回事件循环继续响应
        
    3. 需手动添加用户提示（如上例的`JOptionPane`）
        
    

> ​**危险场景**​：EDT中未捕获异常会导致界面冻结但进程不退出

---

### ​**二、`try-catch`执行流程**​

```
try {
    // 步骤1：正常执行
    operationA(); 
    // 步骤2：抛出IOException
    operationB();  
    operationC();  // 跳过
} catch (IOException e) {
    // 步骤3：执行此块
    handleError(e);
} catch (SQLException e) {
    // 不执行（异常类型不匹配）
}
// 步骤4：继续后续代码
```

​**跳转规则**​：

1. 异常抛出 → 立即终止`try`块剩余代码
    
2. 按`catch`顺序匹配异常类型
    
3. 执行首个匹配的`catch`块
    
4. 继续`try-catch`后的代码
    

​**未匹配异常**​：

- 跳过所有`catch`块
    
- 向调用方法传播异常
    

---

### ​**三、文件读取案例：为何捕获`IOException`**​

```
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    String line = br.readLine(); // 可能抛出IOException
} catch (FileNotFoundException e) { 
    // 仅处理文件不存在（不全面）
} catch (IOException e) {
    // 覆盖所有I/O问题：
    // 1. 文件不存在
    // 2. 磁盘错误
    // 3. 读取中断
    // 4. 字符编码错误
}
```

​**设计依据**​：

1. `FileNotFoundException`是`IOException`子类
    
2. 其他I/O错误（如磁盘损坏）也属`IOException`
    
3. 避免多层`catch`导致代码冗余
    

> ​**最佳实践**​：捕获最通用的受检异常父类（除非需要特殊处理子类异常）

---

### ​**四、“捕获 vs 传播”决策原则**​

#### ​**决策树**​
![[Pasted image 20251022164406.png]]

#### ​**具体场景**​

|​**场景**​|​**策略**​|​**示例**​|
|---|---|---|
|可本地恢复的错误|捕获处理|文件不存在时使用默认配置|
|需通知调用方的业务错误|抛自定义异常|`throw new InsufficientBalanceException()`|
|底层技术异常|抛原始异常|`throws IOException`|
|不可控系统错误|不捕获|`OutOfMemoryError`|

​**核心公式**​：

```
能否处理？ 
  → 能：捕获 
  → 不能：传播
```

---

### ​**五、继承场景的特殊约束**​

#### ​**重写方法异常声明规则**​

```
class Parent {
    void process() { /* 无throws */ }
}

class Child extends Parent {
    @Override
    void process() {
        try {
            readFile(); // 可能抛出IOException
        } catch (IOException e) { // 必须捕获！
            handleError(e);
        }
    }
    
    private void readFile() throws IOException { ... }
}
```

#### ​**三条铁律**​

1. ​**子类不能声明更通用的受检异常**​
    
    - ❌ 父类抛`IOException`，子类抛`Exception`
        
    
2. ​**可以声明更具体的异常**​
    
    - ✅ 父类抛`Exception`，子类抛`FileNotFoundException`
        
    
3. ​**父类无`throws`时，子类禁止任何受检异常**​
    
    - ❌ 父类无声明，子类抛`IOException`
        
    

#### ​**设计原理**​

- 确保**里氏替换原则**​（LSP）
    
- 调用父类接口的代码无需修改即可处理子类异常
    

> ​**特例**​：子类方法可抛出父类未声明的非受检异常（如`RuntimeException`）

---

### ​**总结：异常处理决策矩阵**​

|​**维度**​|​**捕获**​|​**传播（throws）​**​|
|---|---|---|
|​**适用场景**​|能就地解决错误|需上层处理|
|​**代码位置**​|方法内部|方法签名|
|​**继承约束**​|子类重写无throws父类方法时必须用|子类throws范围 ≤ 父类|
|​**异常类型**​|所有异常（含Error）|仅受检异常|
|​**性能影响**​|栈解构开销|几乎无开销|