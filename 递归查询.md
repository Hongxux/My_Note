- 需求背景：处理具有父子或上下级关系的层级数据，如组织架构、评论回复、分类导航等
- 问题：
	- 性能瓶颈：每一次递归都是一次新的连接操作，会产生大量的中间结果，尤其是在层级非常深的情况下，效率会急剧下降
		- 解决措施：确保关联字段（如`parent_id`）上有索引
	- 循环深度有限制
		- 默认：100层
		- 解决措施：使用`OPTION (MAXRECURSION N)`来调整
	- 循环依赖会导致死循环
- 替代方案：
	- 物化路径通过增加冗余存储来记录完整的层级路径
		- 比如引入path字段，path可以为`1/23/55`
	- [[闭包表]]：
- 核心组成：
	- **锚点成员**：这是递归的起点，一个返回初始结果集的非递归查询。
	- **递归成员**：这个部分会引用 CTE 自身，并通常与锚点成员通过 `UNION ALL`合并，从而逐步扩展结果集。
- 执行流程：先执行锚点成员，然后用其结果执行递归成员，再将新结果叠加进去，循环往复，直到递归成员不返回任何新行（即满足终止条件）为止
- 语法示例
	```sql
	WITH RECURSIVE 表达式名称 (列名列表) AS (
	    -- 1. 锚定点：选择初始记录
	    SELECT ...
	    UNION ALL
	    -- 2. 递归部分：基于CTE自身进行迭代
	    SELECT ... FROM 表名, 表达式名称 WHERE ...
	)
	SELECT ... FROM 表达式名称;
	```
	```sql
	WITH RECURSIVE EmployeeHierarchy AS (
	    -- 从ID为1的经理开始
	    SELECT id, name, manager_id
	    FROM employees
	    WHERE id = 1
	    
	    UNION ALL
	    
	    -- 递归地找到每个员工的下属
	    SELECT e.id, e.name, e.manager_id
	    FROM employees e
	    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.id
	)
	SELECT * FROM EmployeeHierarchy;
	```