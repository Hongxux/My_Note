#### undo log版本链的实现基础--数据库记录的隐藏字段
![[Pasted image 20251102171053.png]]

|隐藏字段名|含义|功能与重要性|
|---|---|---|
|​**`DB_ROW_ID`（隐藏主键）​**​|行ID（Row ID）|当数据表**没有显式定义主键（PRIMARY KEY）​**​ 时，InnoDB 会自动生成一个唯一的 `DB_ROW_ID`来作为行的唯一标识。如果表有自定义主键，则该字段不会生成。|
|​**`DB_TRX_ID`（事务ID）​**​|最近修改该行数据的事务ID|记录**插入**或**最后一次更新**这条记录的事务的唯一ID。这是实现 ​**MVCC**​ 的关键，用于判断数据版本对当前事务的可见性。|
|​**`DB_ROLL_PTR`（回滚指针）​**​|指向该行数据上一个版本的指针|指向 ​**undo log**​ 中一条记录，该记录保存了本行数据**被当前版本覆盖前的旧值**。所有旧版本通过此指针形成一个链表，即“版本链”。|

隐藏的 `DB_TRX_ID`（最近修改它的事务ID）和 `DB_ROLL_PTR`（回滚指针，指向历史版本）。Undo Log 用于存储数据被修改前的旧值，这些旧版本通过回滚指针连成一个链表。

#### ​**1. Undo Log 记录的生成**​

- ​**目的**​：用于事务**回滚**和 ​**MVCC**。
    
- ​**产生**​：在执行 `INSERT`、`UPDATE`、`DELETE`时，会生成对应的 Undo Log。
    
- ​**生命周期**​：
    
    - ​`INSERT`​ 的 Undo Log：事务提交后即可删除，因为新插入的数据在回滚时直接删除即可，MVCC 不可见。
	    - **`INSERT`的"旧版本"是"不存在"。让数据"看起来像不存在"很简单（它只需要在判断时，因为其 `DB_TRX_ID`属于活跃事务而直接过滤掉它即可。），不需要通过Undo Log来构造一个"不存在"的状态。​**
        
    - ​ `UPDATE`/ `DELETE`   的 Undo Log：​**事务提交后不能立即删除**，因为它需要为其他并发事务的**快照读**提供数据的历史版本。
        
    

#### ​**2.  Undo Log 版本链的形成​**​
![[Pasted image 20251102171132.png]]
- ​**核心字段**​：每行数据都有两个隐藏字段：
    
    - ​**`DB_TRX_ID`**​：最近一次修改本行数据的事务ID。快照读决定了事务在执行快照读时能看到哪些数据时候的重要依据。
        
    - ​**`DB_ROLL_PTR`**​：​**回滚指针**，指向该行数据**上一个历史版本**在 Undo Log 中的位置。
        
    
- ​**版本链**​：通过 `DB_ROLL_PTR`，一行数据的所有历史版本被连接成一个链表。最新版本在表数据中，旧版本按修改时间倒序存放在 Undo Log 里。
    
    - ​**如图例**​：当前数据是 `(30, 10, 'A3')`，它由**事务4**修改。通过指针，可以找到事务3修改的版本 `(30, 3, 'A3')`，再找到事务2修改的版本 `(30, 3, 'A30')`，最终找到事务1插入的原始版本 `(30, 30, 'A30')`。
        