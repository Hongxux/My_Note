---
aliases:
  - readview
---
有了版本链，一个新问题产生：对于一个发起查询的事务（例如“事务A”），版本链上的哪个版本对它来说是“可见”的？----readview 决定快照读 读取undo log 中的哪一个版本

这就是 ​**ReadView**​ 的作用，它是一个**快照**，决定了事务在执行快照读时能看到哪些数据。
​**​“可重复读”如何避免幻读？“读已提交”为何不可重复读？​**​ 答案就在于 ReadView 的生成时机。

|隔离级别|ReadView 生成时机|效果|
|---|---|---|
|​**读已提交（READ COMMITTED）​**​|​**每次**执行快照读（`SELECT`）时都**生成一个新的 ReadView**。|每次读都能看到**最新已提交**的数据。这会导致**不可重复读**​（同一事务内两次读取结果可能不同）。|
|​**可重复读（REPEATABLE READ）​**​|​**仅在第一次**执行快照读时生成一个 ReadView，后续**所有读操作都复用这个快照**。|在整个事务期间，每次读看到的都是**同一个一致性快照**。这避免了不可重复读和幻读（在当前读配合下）。|

#### ​**ReadView 的访问规则**​
![[可见性规则 2025-11-02 18.48.26.excalidraw]]
ReadView 包含几个关键属性（用于与版本链中每个版本的 `DB_TRX_ID`比较）：

- `creator_trx_id`： 创建本 ReadView 的事务ID（即“事务A”自己的ID）。
    
- `min_trx_id`： 生成 ReadView 时，系统中**活跃的（未提交的）​**​ 最小事务ID。
    
- `max_trx_id`： 生成 ReadView 时，系统**将要分配的下一个事务ID**​（即当前最大事务ID+1）。
    
- `m_ids`： 生成 ReadView 时，系统中所有**活跃事务ID**的列表。
    

​**判断流程（核心！）​**​：

当“事务A”读取某行数据时，会从最新的数据版本开始，沿版本链依次判断每个版本是否可见：

1. ​**`trx_id == creator_trx_id`？​**​
    
    - ​**成立**​：说明这个数据版本是“事务A”​**自己修改**的，​**可见**。
        
    
2. ​**`trx_id < min_trx_id`？​**​
    
    - ​**成立**​：说明这个数据版本在“事务A”启动**之前就已经提交**了，​**可见**。
        
    
3. ​**`trx_id >= max_trx_id`？​**​
    
    - ​**不成立**​：说明这个数据版本是由在“事务A”启动**之后才开启的事务**修改的，​**不可见**。
        
    
4. ​**`min_trx_id <= trx_id <= max_trx_id`？​**​
    
    - 检查 `trx_id`是否在 `m_ids`（活跃事务列表）中。
        
    - ​**不在**​：说明该版本在“事务A”启动时**已经提交**了，​**可见**。
        
    - ​**在**​：说明该版本在“事务A”启动时**还未提交**，​**不可见**。
        
    

如果某个版本不可见，就顺着 `DB_ROLL_PTR`找到上一个版本，重复上述判断，直到找到可见的版本或版本链结束。

#### readview的工作流程--决定应该看到[[undo log的版本链]]中的哪一个数据


从最新的数据开始（在数据库中而不在undo log中），然后沿着数据行指针在undo log版本链里面依此判断readview可见性规则，直至符合可见性规则，则该快照对应的数据找到了。

假设隔离级别为**可重复读**，事务A（ID=100）执行 `SELECT * FROM users WHERE id=1;`：

1. ​**生成快照**​：InnoDB 为事务A创建一個 ReadView（假设此时 `min_trx_id=50`, `max_trx_id=110`, `m_ids=[60, 80]`）。
    
2. ​**定位数据**​：找到 `id=1`这行数据的最新版本，其 `DB_TRX_ID=90`。
    
3. ​**可见性判断**​：
    
    - 规则1：90 != 100（否）
        
    - 规则2：90 < 50?（否）
        
    - 规则3：90 >= 110?（否）
        
    - 规则4：50<=90<=110? 是。检查90是否在[60,80]中？​**不在**。
        
    - ​**结论**​：该版本可见。事务A读到的是事务90提交后的数据。
        ![[Pasted image 20251102190626.png]]
    
4. ​**情景变化**​：如果最新版本的 `DB_TRX_ID=70`（即修改它的事务70仍在活跃列表中）：
    
    - 规则4：50<=70<=110? 是。检查70在[60,80]中？​**在**。
        
    - ​**结论**​：该版本不可见。事务A将沿版本链向上查找，直到找到一个 `DB_TRX_ID`满足可见性条件的版本（例如，`DB_TRX_ID=40`，40<50，可见）。
        
    

