
### ​**LFS 的核心写入机制：顺序与缓冲**​

LFS 的核心目标是**将所有写入（包括数据和元数据）转换为高效的顺序写入**。但这一定义比听起来更微妙，其高效性依赖于关键的实现细节。

---

#### ​**一、 基本理念：将更新序列化**​

LFS 的基本思想是避免在原地更新文件和元数据。相反，任何更新（如写入数据块 D）以及相关的元数据更新（如更新其 inode I），都被作为新的条目**顺序追加**到磁盘的日志中。

- ​**初始布局**​： 写入数据块 `D`到地址 `A0`。
    
    ```
    A0: D
    ```
    
- ​**更新布局**​： 随后，更新指向 `D`的 inode `I`，并将其也写入磁盘的下一个空闲位置 `A1`。
    
    ```
    A0: D
    A1: I  [ blk[0]: A0 ]
    ```
    
- ​**核心思想**​： 通过这种“只追加”的方式，LFS 将随机的小写入转换为连续的写入流。
    ![[Pasted image 20251013091649.png]]

> ​**提示：细节至关重要**​
> 
> LFS 的总体思想容易理解，但构建一个可工作的系统需要处理所有复杂情况。真正的挑战在于实现细节。

---

#### ​**二、 关键挑战：实现 _高效_的顺序写入**​

仅保证写入地址的顺序连续是不够的。要实现接近磁盘峰值的写入性能，必须解决**磁盘机械特性**带来的问题。

- ​**问题场景**​：
    
    1. 在时间 `T`，向地址 `A`写入一个块。
        
    2. 在稍后的时间 `T + δ`，向地址 `A+1`写入下一个块。
        
    
- ​**性能陷阱**​：
    
    - 在两次写入的间隔 `δ`内，磁盘一直在旋转。
        
    - **当第二次写入命令到达时**，磁头可能已经越过了 `A+1`这个扇区。
        
    - 因此，磁盘必须**等待几乎一整圈**​（时间约为 `T_rotation - δ`）才能将 `A+1`再次转到磁头下进行写入。
        
    - 这导致一次本应快速的写入，却要支付一次完整的**旋转延迟**开销，性能急剧下降。
        
    
- ​**结论**​： 要实现高效写入，不仅需要**地址连续**，更需要**时间上连续**地发出大量写入请求，即进行**大块连续写入**。
    

---

#### ​**三、 解决方案：写入缓冲与段写入**​

为了解决上述挑战，LFS 采用了 ​**写入缓冲**​ 这一经典技术。

1. ​**机制**​：
    
    - LFS 不会立即将每个更新写入磁盘，而是在内存中**缓冲**它们。
        
    - 当积累到足够数量的更新后，LFS 将它们组织成一个大的连续块，称为 ​**段**。
        
    - 最后，将整个**段**一次性、顺序地写入磁盘的空闲区域。
        ![[Pasted image 20251013091634.png]]
    
2. ​**示例**​：
    
    - LFS 在内存中缓冲对文件 `j`的 4 个数据块及其 inode 的更新，以及对文件 `k`的一个数据块及其 inode 的更新。
        
    - 然后将这总共 7 个块作为一个段，一次性写入磁盘。最终磁盘布局如下：
        
    
    ```
    A0: D[j,0]  A1: D[j,1]  A2: D[j,2]  A3: D[j,3]  A4: I_j  A5: D[k,0]  A6: I_k
    ```
    
    - 通过一次性提交大段写入，确保了磁盘磁头能够连续、不间断地写入数据，从而充分利用磁盘的高顺序带宽。
        
    

---

#### ​**四、 核心参数：需要缓冲多少数据？（段大小）​**​

一个关键问题是：LFS 在写入磁盘前应该缓冲多少数据？这取决于磁盘的性能特征。

通过数学模型可以计算出为了达到特定效率所需缓冲的数据量 `D`：

- ​**定义参数**​：
    
    - `T_position`： 每次写入前的定位时间（寻道 + 旋转延迟）。
        
    - `R_peak`： 磁盘的峰值传输速率（MB/s）。
        
    - `F`： 目标有效带宽与峰值带宽的比率（例如，0.9 表示希望达到峰值带宽的 90%）。
        
    
- ​**计算公式**​：
    
    为达到目标效率 `F`，需要缓冲的数据量 `D`为：
    
    ​**`D = (F / (1 - F)) * R_peak * T_position`**​
    
- ​**计算示例**​：
    
    - 假设 `T_position = 10 ms`, `R_peak = 100 MB/s`。
        
    - 要达到 90% 的效率 (`F = 0.9`)：
        
        `D = (0.9 / 0.1) * 100 MB/s * 0.01 s = 9 MB`
        
    - 要达到 95% 的效率 (`F = 0.95`)：
        
        `D = (0.95 / 0.05) * 100 MB/s * 0.01 s = 19 MB`
        
    - 要达到 99% 的效率 (`F = 0.99`)：
        
        `D = (0.99 / 0.01) * 100 MB/s * 0.01 s = 99 MB`
        
    
- ​**结论**​： 越接近峰值性能，所需的段大小就越大。LFS 正是通过这种**用内存空间换取代价高昂的磁盘定位时间**的策略，实现了极高的写入吞吐量。