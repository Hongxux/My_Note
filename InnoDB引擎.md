## 逻辑存储结构
![[Pasted image 20251102105301.png]]


#### 1. 行（Row）

- ​**是什么**​：存储数据的**最小单位**，即我们常说的“一行记录”。
    
- ​**内容**​：包含用户定义的表字段数据（如 id, name）、事务ID（DB_TRX_ID）、回滚指针（DB_ROLL_PTR）等系统隐藏列。
    
- ​**行格式**​：InnoDB 支持多种行格式（如 `COMPACT`, `DYNAMIC`），影响如何存储变长字段（如 VARCHAR, TEXT）和溢出页的使用。
    

#### 2. 页（Page）

- ​**是什么**​：InnoDB ​**磁盘管理的最小单元**，也是内存与磁盘交互的基本单位。所有读写操作最终都以页为单位进行。
    
- ​**大小**​：默认 ​**16KB**，可在初始化数据库时通过参数 `innodb_page_size`调整（但一旦初始化就不能更改）。
    
- ​**功能**​：一个页内包含多行数据。页是 B+Tree 索引的节点，数据页之间通过双向链表连接。
    

#### 3. 区/簇（Extent）

- ​**是什么**​：由**连续的页**构成的物理分配单位。
    
- ​**大小**​：​**1MB**​（因为 `1MB / 16KB = 64`，所以一个区包含 ​**64 个连续的页**）。
    
- ​**目的**​：为了**顺序I/O和性能**。当为表或索引分配空间时，InnoDB 每次至少分配一个区（1MB），而不是单个页（16KB）。这可以减少随机I/O，提升大量数据插入和范围查询的性能。
    

#### 4. 段（Segment）

- ​**是什么**​：由一个或多个区构成的逻辑概念，是**表空间的主要组成部分**。
    
- ​**分类**​：
    
    - ​**叶子节点段**​：B+Tree 中存储实际行数据的区的集合。
        
    - ​**非叶子节点段**​：B+Tree 中存储索引指针的区的集合。
        
    - ​**回滚段**​：用于存储事务回滚所需信息的区的集合。（undo log）
        
    
- ​**管理**​：一个索引会生成两个段：一个用于非叶子节点（索引），一个用于叶子节点（数据）。
    

#### 5. 表空间（Tablespace）

- ​**是什么**​：InnoDB 存储结构的**最高层级**，是段、区、页的物理容器，对应磁盘上的一个或多个文件。
    
- ​**分类**​：
    
    - ​**系统表空间**​：存储数据字典、回滚段、双写缓冲区等元数据。
        
    - ​**独立表空间（默认）​**​：每个表有自己独立的 `.ibd`文件，包含该表的数据和索引。这正是图中描述的 `users.ibd`文件。
        
    

### 核心设计思想与价值

1. ​**层次化与模块化**​：将大问题分解为小问题，便于管理、空间分配和回收。
    
2. ​**预分配与连续性**​：通过“区”的概念一次性分配连续的大块空间，极大提升了顺序I/O性能，减少了磁盘碎片。
    
3. ​**固定大小单元**​：“页”作为固定大小的操作单元，简化了内存管理和磁盘读写。
    
4. ​**链接性**​：页与页之间通过双向链表连接，便于范围扫描。
    
## 架构
### 内存缓冲区结构
内存缓冲区结构是数据库实现高性能读写的关键。
这些组件共同协作，极大地提升了数据库的并发处理能力和响应速度。它们之间的关系与分工可以通过下图直观展示：
![[Pasted image 20251102111627.png]]




![[Pasted image 20251102111745.png]]
#### 1. 缓冲池 - Buffer Pool：主内存缓存区

缓冲池是 InnoDB 引擎中最大、最重要的内存区域，是数据库的“工作台”。

- ​**功能**​：缓存磁盘上的表数据和索引数据。当执行查询时，InnoDB 首先在 Buffer Pool 中查找所需的数据页（Page）。如果找到（称为“缓存命中”），则直接返回；如果未找到，则从磁盘读取并加载到 Buffer Pool 中。
    
- ​**工作单元**​：以 ​**Page（页，通常16KB）​**​ 为单位进行管理。
    
- ​**页的状态**​：
    
    - ​**Free Page**​：空闲页，可供使用。
        
    - ​**Clean Page**​：干净页，内容与磁盘一致，未被修改。
        
    - ​**Dirty Page**​：脏页，内容已被内存中的事务修改，与磁盘数据不一致，需要被刷回磁盘。
        
    
- ​**价值**​：通过将“热数据”留在内存中，​**极大减少了昂贵的磁盘I/O操作**，是提升性能的基石。
    

#### 2. 更改缓冲区 - Change Buffer：非唯一索引的写优化器

更改缓冲区是针对**非唯一二级索引**的特殊优化结构，是提升写入性能的关键。

- ​**解决的问题**​：当对表进行 `INSERT`、`UPDATE`、`DELETE`操作时，如果受影响的**二级索引页不在 Buffer Pool**​ 中，传统做法需要先将索引页从磁盘读入内存再修改，这会产生大量的随机磁盘I/O，性能低下。
    
- ​**工作原理**​：如图中“变更路径”所示，如果目标索引页不在内存中，Change Buffer 会先将这些修改操作**缓存起来**，而不是立即从磁盘读取索引页。当未来该索引页被读取时，再将 Change Buffer 中缓存的修改**合并**到该页上。
    
- ​**价值**​：将多次随机的磁盘I/O**合并为更少的顺序I/O**，显著提升了涉及二级索引的DML操作性能。
    

#### 3. 自适应哈希索引 - Adaptive Hash Index：查询加速器

自适应哈希索引是 InnoDB 为优化查询性能而自动构建的**内存哈希表**。

- ​**功能**​：InnoDB 引擎会监控对表上索引的查找。如果发现某个索引值被频繁用等值查询（如 `WHERE id = 5`），且建立一个哈希索引可以提升速度，它就会在内存中**自动**为这些“热”索引页建立哈希索引。
    
- ​**关键特性**​：​**完全自适应，无需人工干预**。
    
- ​**价值**​：对于频繁的等值查询，可以将B+Tree的3-4次查找**优化为接近O(1)的哈希查找**，极大提升查询速度。可通过参数 `adaptive_hash_index`开启或关闭。
    

#### 4. 日志缓冲区 - Log Buffer：日志的中间站

日志缓冲区是用于缓存重做日志的小块内存区域。

- ​**功能**​：用来缓冲即将写入磁盘的重做日志和 undo 日志。所有事务的日志信息会先写入 Log Buffer，然后再根据一定策略批量刷新到磁盘上的日志文件。
    
- ​**关键参数**​：
    
    - `innodb_log_buffer_size`：缓冲区大小，默认16MB。对于大事务，可以适当调大。
        
    - `innodb_flush_log_at_trx_commit`：​**控制日志刷盘时机**，是数据安全与性能的关键权衡点：
        
        - ​**1（默认）​**​：事务提交时**立即写入并刷新**到磁盘。最安全，性能最低。
            
        - ​**0**​：日志每秒**写入并刷新**一次。性能高，但服务器崩溃可能丢失1秒内的事务。
            
        - ​**2**​：事务提交时**立即写入**操作系统缓存，但每秒才**刷新**到磁盘。性能与安全性的折中方案。
            
        
    
- ​**价值**​：通过缓冲和批量写入，减少了频繁的磁盘日志写入操作，提升了事务处理的吞吐量。
    

#### 总结

这四大缓冲区共同构成了 InnoDB 高性能的支柱：

1. ​**Buffer Pool**​ 是核心缓存，优化了**读操作**。
    
2. ​**Change Buffer**​ 是辅助缓存，专门优化了对**非唯一二级索引的写操作**。
    
3. ​**Adaptive Hash Index**​ 是智能索引，自动优化了**频繁的等值查询**。
    
4. ​**Log Buffer**​ 是日志中转站，通过批量I/O优化了**事务的持久化过程**。
    

### 磁盘结构
 ![[Pasted image 20251102161138.png]]
#### 1. 表空间

表空间是 InnoDB 存储结构的最高层级，是数据文件的逻辑容器。它分为几种类型：

​**a) 系统表空间**​

- ​**文件**​：默认名为 `ibdata1`。
    
- ​**存储内容**​：
    
    - ​**数据字典**​：存储表、列、索引等元数据的系统表。
        
    - ​**Change Buffer**​：更改缓冲区的磁盘存储部分。
        
    - ​**双写缓冲区**​：为提高数据页写入安全性而设计的结构。
        
    - ​**Undo Logs**​：在 MySQL 5.7 及更早版本中，默认将 Undo 日志放在系统表空间。8.0 已独立。
        
    
- ​**管理建议**​：在生产环境中，建议启用 `innodb_file_per_table`并将 Undo 日志独立出来，以避免系统表空间过大难以管理。
    

​**b) 独立表空间**​

- ​**文件**​：每个表对应一个独立的 `.ibd`文件（如 `users.ibd`）。
    
- ​**启用**​：通过参数 `innodb_file_per_table = ON`控制。
    
- ​**存储内容**​：该表的**数据**和**索引**​（B+Tree 结构）。
    
- ​**优势**​：
    
    - ​**易于管理**​：可以单独对表进行备份、恢复和迁移。
        
    - ​**空间回收**​：当表被删除或截断时，空间可以直接释放给操作系统。
        
    - ​**减少碎片**​：表之间相互独立，避免空间碎片交叉。
        
    

​**c) Undo 表空间**​

- ​**功能**​：专门存储 ​**Undo Logs**。
    
- ​**作用**​：用于事务回滚和实现多版本并发控制。它记录了数据被修改前的旧版本。
    
- ​**文件**​：默认名为 `undo_001`, `undo_002`。
    

​**d) 临时表空间**​

- ​**功能**​：存储用户创建的临时表和磁盘内部的临时表。
    
- ​**文件**​：默认名为 `ibtmp1`。
    

#### 2. 重做日志

这是 InnoDB 实现 ​**Crash-Safe**​ 能力的核心组件，即保证数据库在发生宕机等故障后数据不丢失。

- ​**文件**​：通常为 `ib_logfile0`和 `ib_logfile1`，循环写入。
    
- ​**工作方式**​：
    
    1. 当数据发生变更时，变更产生的**重做日志**会先被写入 ​**Log Buffer**。
        
    2. 根据策略（如事务提交时），日志被顺序、批量地刷入这些重做日志文件。
        
    3. ​**关键点**​：重做日志的写入是**顺序追加**的，比随机写入数据页要快得多。
        
    
- ​**崩溃恢复**​：当数据库重启时，InnoDB 会检查重做日志，将那些已提交但尚未刷盘的数据变更（脏页）重新应用（重做）到数据页上，从而保证持久性。
    
- ​**配置**​：通过 `innodb_log_file_size`和 `innodb_log_files_in_group`参数控制文件大小和数量。
    

#### 3. 双写缓冲区

这是一个提高数据页写入可靠性的安全网。

- ​**问题背景**​：操作系统和磁盘硬件以“块”为单位进行写入（如 4KB），而 InnoDB 数据页通常是 16KB。如果发生部分页写入（例如写入16KB时只写了8KB后断电），会导致页数据损坏，即使有重做日志也无法恢复，因为重做日志的恢复依赖于页本身的完整性。
    
- ​**解决方案**​：
    
    1. 在将脏页刷到表空间数据文件**之前**，InnoDB 会先将它们顺序地写入磁盘上一个名为双写缓冲区的连续区域。
        
    2. 然后再将脏页散落地写入其真正的数据文件位置。
        
    
- ​**崩溃恢复**​：如果发生部分页写入，InnoDB 可以从双写缓冲区中找到该页的一个完好副本，用它来恢复损坏的页。
    
- ​**性能权衡**​：双写机制会增加一次额外的磁盘写入，但通过顺序写入来降低性能开销。在支持原子写的现代存储设备上可以考虑关闭。
    

### 后台线程
后台线程组是连接内存（缓冲池）和磁盘（数据/日志文件）的桥梁。
#### 1. Master Thread：核心调度与总管

这是 InnoDB 的**大脑和总指挥**，负责全局性的调度和关键任务的执行。

- ​**核心职责**​：
    
    - ​**缓冲池刷新**​：定期将内存缓冲池中的**脏页**异步刷新到磁盘数据文件，确保内存和磁盘数据的一致性。
        
    - ​**合并插入缓冲**​：将 Change Buffer 中缓存的对二级索引的更改，合并到实际的索引页中。
        
    - ​**Undo 页回收**​：回收不再需要的 Undo 日志空间。
        
    - ​**协调调度**​：负责管理和协调其他后台线程的活动。
        
    
- ​**重要性**​：它的健康运行直接关系到数据库的整体性能和数据安全性。它通过异步操作将随机 I/O 转换为相对顺序的 I/O，平衡了性能和数据持久化。
    

#### 2. IO Thread：异步 I/O 处理引擎

为了应对高并发的 I/O 请求，InnoDB 使用了**异步 I/O**​ 模型，而 IO Thread 专门负责处理这些 I/O 请求的回调。

- ​**工作模式**​：使用 ​**AIO**，数据库发起一个 I/O 请求后无需等待其完成，可以立即处理下一个请求。当 I/O 操作完成后，由对应的 IO Thread 执行回调函数处理结果。
    
- ​**分类与职责**​：
    
|线程类型|默认个数|职责说明|
|---|---|---|
|​**Read thread**​|4|负责处理数据文件的**读请求**，如将数据页从磁盘加载到缓冲池。|
|​**Write thread**​|4|负责处理数据文件的**写请求**，如将缓冲池的脏页刷回磁盘。|
|​**Log thread**​|1|专门负责将**重做日志缓冲区**的内容刷新到磁盘的日志文件。|
|​**Insert buffer thread**​|1|负责将 ​**Change Buffer**​ 中的更改刷到磁盘。|
    
- ​**性能调优**​：对于 I/O 密集型的应用，可以通过参数（如 `innodb_read_io_threads`和 `innodb_write_io_threads`）适当增加读写线程的数量，以提升并发 I/O 处理能力。
    

#### 3. Purge Thread：事务垃圾回收器

专门用于回收**已经提交的事务**所不再需要的 ​**Undo Log**。

- ​**背景知识**​：为了实现事务的 MVCC（多版本并发控制），当数据被更新或删除时，旧版本数据会保存在 Undo Log 中，以便其他正在运行的事务可以读取到一致性的快照。
    
- ​**工作时机**​：当没有任何事务需要这些旧版本数据时，这些 Undo Log 就成为了可回收的“垃圾”。
    
- ​**作用**​：Purge Thread 会定时清理这些无用的 Undo Log，释放磁盘空间，防止 Undo 表空间无限增长。
    
- ​**演化**​：在 MySQL 5.6 之后，可以配置多个 Purge Thread（`innodb_purge_threads`）来提升回收效率。
    

#### 4. Page Cleaner Thread：脏页刷新专家

这是一个为了**减轻 Master Thread 负担**而引入的专用线程。

- ​**要解决的问题**​：在早期版本中，脏页刷新工作完全由 Master Thread 负责。在写入密集型场景下，这会给 Master Thread 带来巨大压力，可能成为性能瓶颈。
    
- ​**专用化职责**​：Page Cleaner Thread 从 Master Thread 中接过了**脏页刷新**这一重要且繁重的任务。它专门负责在后台将缓冲池中的脏页刷新到磁盘。
    
- ​**带来的好处**​：
    
    - ​**降低延迟**​：使 Master Thread 能更专注于调度，减少用户请求的阻塞。
        
    - ​**提升性能**​：专门的线程可以更高效地管理脏页刷新策略，提升整体吞吐量。
        
    


 ### 内存和磁盘协同工作

1. ​**写入流程**​：
    
    - 事务修改数据，在 ​**Buffer Pool**​ 中产生**脏页**。
        
    - 日志先被写入 ​**重做日志文件**​（WAL 机制）。
        
    - 脏页通过后台线程刷盘时，先经过**双写缓冲区**，再写入**用户表空间**的 `.ibd`文件。
        
    - 事务回滚或 MVCC 所需的信息保存在 ​**Undo 表空间**。
        
    
2. ​**读取流程**​：
    
    - 所需数据页从 ​**表空间文件**​（.ibd）被加载到 ​**Buffer Pool**。
        
    - 如果需要旧版本数据，则从 ​**Undo 表空间**​ 中构造。
        
    
3. ​**崩溃恢复**​：
    
    - 重启后，比较**重做日志**和**数据页**。
        
    - 利用**双写缓冲区**修复损坏的页。
        
    - 应用重做日志中已提交的事务，回滚未提交的事务（使用 Undo 日志）。
        
    

简单来说，InnoDB 通过这种精巧的磁盘结构设计，在保证数据**持久性（Durability）​**​ 和**一致性（Consistency）​**​ 的前提下，最大限度地提升了数据库的**性能和可靠性**。理解这些组件是进行高级数据库管理和性能调优的基础。
## 事务原理（ACID的实现）

![[Pasted image 20251102162346.png]]

| 特性         | 重做日志                                  | 回滚日志                             |
| ---------- | ------------------------------------- | -------------------------------- |
| ​**日志类型**​ | ​**物理日志**​                            | ​**逻辑日志**​                       |
| ​**记录内容**​ | ​**数据页的物理变化(在哪里被修改+修改前后的磁盘中的二进制数据)**​ | ​**执行过的SQL逻辑**​                  |
| ​**目的**​   | ​**崩溃恢复**，保证持久性                       | ​**事务回滚**​ 和 ​**MVCC**，保证原子性和隔离性 |
### redo log
可参考操作系统中的[[数据日志化]]
> ​**一种物理日志，记录的是事务对数据页的物理修改内容。​**​ 其唯一且最重要的目的，就是确保事务的持久性——一旦事务提交，它对数据所做的更改就永远不会丢失。

重要机制：WAL
#### 一、Redo Log 的组成结构

图中明确指出，Redo Log 由两部分组成，这对应了数据库的“内存-磁盘”两级存储结构：

1. ​**重做日志缓冲（Redo Log Buffer）​**​
    
    - ​**位置**​：​**内存**中一个易失性的连续空间。
        
    - ​**作用**​：作为临时缓冲区。当事务执行数据修改操作（`INSERT`/`UPDATE`/`DELETE`）时，首先会将产生的重做日志信息写入到此缓冲区中，以提升性能。
        
    
2. ​**重做日志文件（Redo Log File）​**​
    
    - ​**位置**​：​**磁盘**上的一组文件，通常命名为 `ib_logfile0`、`ib_logfile1`。
        
    - ​**作用**​：持久化存储。Redo Log Buffer 中的内容会按照一定策略刷盘，最终保存到这些文件里。​**即使数据库发生崩溃，这些文件也会存活**，用于崩溃恢复。
        
    

#### 二、Redo Log 的工作流程与核心价值

图中的文本描述了一个关键的工作流程，这背后是数据库领域一个至关重要的原则：​**[[WAL]]（Write-Ahead Logging，预写式日志）​**。

​**工作流程如下：​**​

1. ​**事务执行**​：事务对数据进行修改（例如，将 id=1 的用户的余额从 100 改为 200）。
    
2. ​**日志先行**​：(WAL)
    
    - 这个修改操作（物理变化）会首先被封装成一条 ​**[[Redo Log]]**，并写入内存中的 ​**Redo Log Buffer**。
        
    - ​**当事务提交时，核心步骤来了**​：为了保证持久性，事务必须确保其对应的所有 Redo Log 记录已经从 Buffer 中**持久化到磁盘**的 Redo Log File 中。
        
    
3. ​**后台刷脏**​：在事务提交后，内存**缓冲池（Buffer Pool）​**​ 中被修改过的“脏页”​**并不需要立即刷回磁盘**。InnoDB 有后台线程（Master Thread / Page Cleaner Thread）在合适的时机（如系统空闲、缓冲池满时）慢慢地将这些脏页刷新到表空间文件（.ibd）中。
    

​**核心价值：为什么需要这个“多余”的WAL步骤？​**​

- ​**性能极致优化**​：​**顺序 I/O vs. 随机 I/O**​
    
    - 将 Redo Log 刷盘是**顺序追加写入**，速度极快。
        
    - 将脏页刷盘是**随机写入**​（数据页在磁盘上分散存储），速度很慢。
        
    - WAL 机制通过将每次事务提交所需的**随机写磁盘**转换为一小批**顺序写日志**，极大地提升了数据库的写入吞吐量。
        
    
- ​**崩溃恢复（Crash Recovery）​**​
    
    - ​**场景**​：假设事务已提交，但脏页还未刷盘，此时数据库突然断电。
        
    - ​**恢复**​：数据库重启后，InnoDB 会检查 Redo Log。由于事务提交时其 Redo Log 已持久化，InnoDB 会根据 Redo Log 的记录，​**重做**​（redo）一遍所有已提交但未落盘的操作，将数据恢复到崩溃前的状态，从而保证了持久性。
        
    

#### 三、关键配置参数

图中虽未明确列出，但与 Redo Log 刷盘行为最相关的参数是 ​**`innodb_flush_log_at_trx_commit`**，它控制事务提交时日志缓冲区的刷盘策略，是在性能和数据安全性之间进行权衡的关键杠杆：

|取值|行为|安全性|性能|
|---|---|---|---|
|​**0**​|日志每秒写入并刷盘一次。|最低（崩溃可能丢失1秒数据）|最高|
|​**1**​（默认）|​**事务提交时立即写入并刷盘**。|​**最高**​（严格持久性）|最低|
|​**2**​|事务提交时立即写入系统缓存，但每秒才刷盘一次。|中等（系统崩溃会丢数据，服务器断电不会）|中等|

​**生产环境强烈建议保持默认值 1**，以确保数据的绝对安全。

### undo log
它记录了数据变化的历史，使得数据库能够“回到过去”（回滚）或为不同用户“展示不同的历史版本”（MVCC），从而实现了数据的一致性和高并发访问。
#### 一、Undo Log 是什么？

图中开宗明义地指出：

> ​**回滚日志，用于记录数据被修改前的信息。​**​

您可以将其理解为一个**数据库的“后悔药”或“操作记录备份”​**。每当要修改数据时，会先把数据修改前的状态记录下来。这样，如果事务需要回滚或取消，就可以根据这份记录将数据恢复到原来的样子。

#### 二、Undo Log 的两大核心作用

图中明确指出了 Undo Log 的两个关键使命：

1. ​**提供回滚，保证原子性**​
    
    - ​**原子性定义**​：一个事务中的所有操作，要么全部完成，要么全部不完成。
        
    - ​**如何实现**​：当事务执行 `ROLLBACK`时，InnoDB 会根据 Undo Log 中记录的逻辑，执行相反的操作来恢复数据。
        
        - 对于 `INSERT`，回滚时会执行相应的 `DELETE`。
            
        - 对于 `DELETE`，回滚时会执行相应的 `INSERT`。
            
        - 对于 `UPDATE`，回滚时会执行一个相反的 `UPDATE`，将数据改回旧值。
            
        
    
2. ​**实现多版本并发控制**​
    
    - ​**MVCC 定义**​：使数据库能够提供非阻塞读的一种技术。不同的事务可以看到数据在不同时间点的快照。
        
    - ​**如何实现**​：当某个事务需要读取数据，但该数据正在被另一个未提交的事务修改时，InnoDB 会通过 Undo Log 链**构建该行数据的旧版本快照**，提供给当前读取事务。这样就实现了读操作不会被写操作阻塞，极大提升了并发性能。
        
    

#### 三、Undo Log 的本质：逻辑日志

图中特别强调了一个关键区别：

> ​**undo log 和 redo log 记录物理日志不一样，它是逻辑日志。​**​

这是理解 Undo Log 的核心：

|日志类型|记录内容|类比|
|---|---|---|
|​**Redo Log**​|​**物理日志**，记录的是“在某个数据页的某个偏移量处，将值 `abc`改为 `def`”。|像硬盘的**扇区读写**，记录的是最底层的物理变化。|
|​**Undo Log**​|​**逻辑日志**，记录的是“执行了一个 `INSERT`操作，插入的值是 `...`”。|像软件的 ​**`Ctrl+Z`撤销操作记录**，记录的是高层的业务逻辑。|

​**示例说明（如图中所述）：​**​

- 当执行 `DELETE FROM users WHERE id = 1;`时，Undo Log 会记录一条等价的 `INSERT`语句逻辑。
    
- 当执行 `UPDATE users SET name = 'Lee' WHERE id = 1;`（原名为 `Wang`）时，Undo Log 会记录一条等价的 `UPDATE users SET name = 'Wang' WHERE id = 1;`语句逻辑。
    

#### 四、Undo Log 的生命周期与存储

##### 1. 产生与销毁

- ​**产生**​：在事务**执行**数据修改操作（DML）时产生。
    
- ​**销毁**​：​**事务提交时，并不会立即删除 undo log**。
    
    - ​**原因**​：这些日志可能还被其他正在运行的事务用于 ​**MVCC**，以读取数据的一致性快照。Undo Log 的清理是在确定没有任何事务再需要它之后，由后台 ​**Purge 线程**异步完成的。
        
    

##### 2. 存储方式

- ​**管理单元**​：Undo Log 采用**段**​ 的方式进行管理。
    
- ​**存储位置**​：存放在**回滚段**​ 中。一个回滚段中包含多个 ​**Undo Log Segment**。
    


## MVCC

### 一、基础概念--数据读取机制
| 特性         | 当前读                                         | 快照读             |
| ---------- | ------------------------------------------- | --------------- |
| ​**读取目标**​ | 数据的最新提交版本                                   | 历史的一致性数据快照      |
| ​**是否加锁**​ | ​**是**​（共享锁或排他锁）                            | ​**否**​         |
| ​**并发性能**​ | 较低（会阻塞写操作）                                  | ​**极高**​（读写不阻塞） |
| ​**核心保证**​ | 数据的**强一致性**​                                | 读的**非阻塞和高并发**​  |
| ​**典型操作**​ | `SELECT ... FOR UPDATE`, `UPDATE`, `DELETE` | 普通的 `SELECT`    |
| ​**实现技术**​ | 锁（Locking）                                  | 多版本并发控制（MVCC）   |

#### 一、 当前读

​**1. 核心定义**​

当前读是一种**悲观锁**的实现方式。它要**确保**自己读取到的数据是**绝对最新**的，并且在读取的瞬间就**阻止其他事务并发修改**这些数据，以保证数据的一致性。

​**2. 操作方式与加锁类型**​

- ​**操作**​：通过在 SELECT 语句后加锁指令，或直接执行写操作。
    
    - `SELECT ... LOCK IN SHARE MODE;`（加**共享锁**）
        
    - `SELECT ... FOR UPDATE;`（加**排他锁**）
        
    - `INSERT`, `UPDATE`, `DELETE`（这些操作本身会隐式地对涉及的数据加**排他锁**）
        
    
- ​**锁类型**​：
    
    - ​**共享锁**​：允许其他事务也加共享锁来读，但阻止任何事务加排他锁来写。
        
    - ​**排他锁**​：最严格的锁，阻止其他事务加任何锁（既不能读也不能写）。
        
    

​**3. 应用场景**​

- ​**余额扣减**​：`SELECT balance FROM account WHERE id = 1 FOR UPDATE;`确保查询余额后，在事务提交前，其他事务无法修改此余额，防止超扣。
    
- ​**库存检查与预留**​：在生成订单时，先通过当前读锁定库存，防止超卖。
    

#### 二、 快照读

​**1. 核心定义**​

快照读是 InnoDB 实现**高并发读**的关键——**多版本并发控制（MVCC）​**​ 的具体体现。它读取的不是数据的最新版本，而是**事务开始时的某个一致性快照**。它**不加锁**，因此不会阻塞其他事务的读写操作。

​**2. 操作方式**​

- ​**操作**​：普通的 `SELECT`语句（不加任何锁）。
    
- ​**实现原理**​：InnoDB 通过 ​**Undo Log**​ 链为每个事务在启动时构造一个**一致性视图**。即使其他事务修改了数据，当前事务仍然能看到它开始时的数据版本。
    

​**3. 在不同隔离级别下的行为（图中的关键区别）​**​

|隔离级别|快照读的生成时机|行为解读|
|---|---|---|
|​**读已提交**​|​**每次 `SELECT`**​ 都会生成一个独立的快照。|这意味着在同一事务内，两次相同的 `SELECT`可能会看到不同的结果（如果中间有其他事务提交了修改）。​**它解决了脏读，但可能出现不可重复读。​**​|
|​**可重复读**​|事务中**第一个 `SELECT`**​ 语句执行时生成快照。|在整个事务期间，所有的快照读都会使用这个**同一个**快照。因此，多次读取同一数据的结果始终一致。​**它解决了不可重复读。​**​|
|​**串行化**​|​**退化为当前读**。|在此隔离级别下，普通的 `SELECT`也会自动转换为 `SELECT ... LOCK IN SHARE MODE`，通过加锁来保证绝对的隔离，并发性最低。|


#### 实践建议

1. ​**默认使用快照读**​：在大多数查询场景下，使用普通的 `SELECT`（快照读）以获得最佳并发性能。
    
2. ​**谨慎使用当前读**​：仅在需要**绝对确保**在后续操作前数据不被更改的“先查后改”场景中（如支付、库存扣减），才使用 `SELECT ... FOR UPDATE`等当前读操作，因为它会影响并发。
    
3. ​**理解隔离级别**​：根据业务对一致性的要求选择合适的隔离级别。默认的**可重复读**级别在保证数据一致性和并发性能之间取得了很好的平衡。
    



### 二、基础概念---数据库记录的隐藏字段

MySQL InnoDB 存储引擎中**每行记录都包含的三个核心隐藏字段**。这些字段是实现**多版本并发控制（MVCC）​**​ 和**事务回滚**等高级功能的基石。
简单来说，​**这些隐藏字段是 InnoDB 为每行数据自动添加的“身份证”`DB_ROW_ID`、“修改记录”`DB_TRX_ID`和“历史档案链接”`DB_ROLL_PTR`**。

|隐藏字段名|含义|功能与重要性|
|---|---|---|
|​**`DB_ROW_ID`（隐藏主键）​**​|行ID（Row ID）|当数据表**没有显式定义主键（PRIMARY KEY）​**​ 时，InnoDB 会自动生成一个唯一的 `DB_ROW_ID`来作为行的唯一标识。如果表有自定义主键，则该字段不会生成。|
|​**`DB_TRX_ID`（事务ID）​**​|最近修改该行数据的事务ID|记录**插入**或**最后一次更新**这条记录的事务的唯一ID。这是实现 ​**MVCC**​ 的关键，用于判断数据版本对当前事务的可见性。|
|​**`DB_ROLL_PTR`（回滚指针）​**​|指向该行数据上一个版本的指针|指向 ​**undo log**​ 中一条记录，该记录保存了本行数据**被当前版本覆盖前的旧值**。所有旧版本通过此指针形成一个链表，即“版本链”。|

    
### 三、基础概念---undo log的版本链

![[Pasted image 20251102171053.png]]
![[Pasted image 20251102171132.png]]

​**1. Undo Log 的生成与生命周期**​

- ​**目的**​：用于事务**回滚**和 ​**MVCC**。
    
- ​**产生**​：在执行 `INSERT`、`UPDATE`、`DELETE`时，会生成对应的 Undo Log。
    
- ​**生命周期**​：
    
    - ​`INSERT`​ 的 Undo Log：事务提交后即可删除，因为新插入的数据在回滚时直接删除即可，MVCC 不可见。
        
    - ​ `UPDATE`/ `DELETE`   的 Undo Log：​**事务提交后不能立即删除**，因为它需要为其他并发事务的**快照读**提供数据的历史版本。
        
    

​**2. 版本链的形成（图2）​**​

- ​**核心字段**​：每行数据都有两个隐藏字段：
    
    - ​**`DB_TRX_ID`**​：最近一次修改本行数据的事务ID。快照读决定了事务在执行快照读时能看到哪些数据时候的重要依据。
        
    - ​**`DB_ROLL_PTR`**​：​**回滚指针**，指向该行数据**上一个历史版本**在 Undo Log 中的位置。
        
    
- ​**版本链**​：通过 `DB_ROLL_PTR`，一行数据的所有历史版本被连接成一个链表。最新版本在表数据中，旧版本按修改时间倒序存放在 Undo Log 里。
    
    - ​**如图例**​：当前数据是 `(30, 10, 'A3')`，它由**事务4**修改。通过指针，可以找到事务3修改的版本 `(30, 3, 'A3')`，再找到事务2修改的版本 `(30, 3, 'A30')`，最终找到事务1插入的原始版本 `(30, 30, 'A30')`。
        
    
### 四、快照读的实现原理--readview


有了版本链，一个新问题产生：对于一个发起查询的事务（例如“事务A”），版本链上的哪个版本对它来说是“可见”的？

这就是 ​**ReadView**​ 的作用，它是一个**快照**，决定了事务在执行快照读时能看到哪些数据。
​**​“可重复读”如何避免幻读？“读已提交”为何不可重复读？​**​ 答案就在于 ReadView 的生成时机。

|隔离级别|ReadView 生成时机|效果|
|---|---|---|
|​**读已提交（READ COMMITTED）​**​|​**每次**执行快照读（`SELECT`）时都**生成一个新的 ReadView**。|每次读都能看到**最新已提交**的数据。这会导致**不可重复读**​（同一事务内两次读取结果可能不同）。|
|​**可重复读（REPEATABLE READ）​**​|​**仅在第一次**执行快照读时生成一个 ReadView，后续**所有读操作都复用这个快照**。|在整个事务期间，每次读看到的都是**同一个一致性快照**。这避免了不可重复读和幻读（在当前读配合下）。|

#### ​**ReadView 的访问规则**​
![[InnoDB引擎 2025-11-02 18.48.26.excalidraw]]
ReadView 包含几个关键属性（用于与版本链中每个版本的 `DB_TRX_ID`比较）：

- `creator_trx_id`： 创建本 ReadView 的事务ID（即“事务A”自己的ID）。
    
- `min_trx_id`： 生成 ReadView 时，系统中**活跃的（未提交的）​**​ 最小事务ID。
    
- `max_trx_id`： 生成 ReadView 时，系统**将要分配的下一个事务ID**​（即当前最大事务ID+1）。
    
- `m_ids`： 生成 ReadView 时，系统中所有**活跃事务ID**的列表。
    

​**判断流程（核心！）​**​：

当“事务A”读取某行数据时，会从最新的数据版本开始，沿版本链依次判断每个版本是否可见：

1. ​**`trx_id == creator_trx_id`？​**​
    
    - ​**成立**​：说明这个数据版本是“事务A”​**自己修改**的，​**可见**。
        
    
2. ​**`trx_id < min_trx_id`？​**​
    
    - ​**成立**​：说明这个数据版本在“事务A”启动**之前就已经提交**了，​**可见**。
        
    
3. ​**`trx_id >= max_trx_id`？​**​
    
    - ​**不成立**​：说明这个数据版本是由在“事务A”启动**之后才开启的事务**修改的，​**不可见**。
        
    
4. ​**`min_trx_id <= trx_id <= max_trx_id`？​**​
    
    - 检查 `trx_id`是否在 `m_ids`（活跃事务列表）中。
        
    - ​**不在**​：说明该版本在“事务A”启动时**已经提交**了，​**可见**。
        
    - ​**在**​：说明该版本在“事务A”启动时**还未提交**，​**不可见**。
        
    

如果某个版本不可见，就顺着 `DB_ROLL_PTR`找到上一个版本，重复上述判断，直到找到可见的版本或版本链结束。

#### readview的工作流程
![[Pasted image 20251102190626.png]]
假设隔离级别为**可重复读**，事务A（ID=100）执行 `SELECT * FROM users WHERE id=1;`：

1. ​**生成快照**​：InnoDB 为事务A创建一個 ReadView（假设此时 `min_trx_id=50`, `max_trx_id=110`, `m_ids=[60, 80]`）。
    
2. ​**定位数据**​：找到 `id=1`这行数据的最新版本，其 `DB_TRX_ID=90`。
    
3. ​**可见性判断**​：
    
    - 规则1：90 != 100（否）
        
    - 规则2：90 < 50?（否）
        
    - 规则3：90 >= 110?（否）
        
    - 规则4：50<=90<=110? 是。检查90是否在[60,80]中？​**不在**。
        
    - ​**结论**​：该版本可见。事务A读到的是事务90提交后的数据。
        
    
4. ​**情景变化**​：如果最新版本的 `DB_TRX_ID=70`（即修改它的事务70仍在活跃列表中）：
    
    - 规则4：50<=70<=110? 是。检查70在[60,80]中？​**在**。
        
    - ​**结论**​：该版本不可见。事务A将沿版本链向上查找，直到找到一个 `DB_TRX_ID`满足可见性条件的版本（例如，`DB_TRX_ID=40`，40<50，可见）。
        
    

​**核心价值**​：通过 ​**Undo Log 版本链 + ReadView 可见性规则**，InnoDB 无需加锁，就能为每个事务提供一份**独立的数据快照**，完美实现了**读不阻塞写，写不阻塞读**的高并发能力。

readview 决定快照读 读取undo log 中的哪一个版本