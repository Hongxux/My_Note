### 索引对性能的提升
创建索引耗时
![[Pasted image 20251030181651.png]]
性能对比：
```
select * from big_data_table where age = 50 \G;
```
没有索引用时
![[Pasted image 20251030181716.png]]
有索引用时
![[Pasted image 20251030182003.png]]

---
## 索引使用法则
### 最左前缀法则（针对联合索引）
联合索引生效的前提

​**最左前缀法则**指的是：在使用复合索引时，查询条件必须从索引的**最左列开始**，并且**不跳过索引中的中间列**。

- ​**复合索引**​：指的是一个索引包含多个列。例如，为 `(A, B, C)`三列创建了一个索引。
    
- ​**最左列**​：在这个例子中，`A`就是最左列。
    
- ​**法则的精髓**​：MySQL 的索引结构（B+Tree）决定了它只能按照索引定义时列的顺序从左到右进行匹配。想象一下电话簿，它是先按姓排序，再按名排序。如果你只知道名而不知道姓，是无法快速查找的。

**最左前缀法则**是设计和优化索引时必须遵守的第一准则。它的要点可以概括为：

- ​**领头列不可少**​：查询必须包含复合索引的最左列。
    
- ​**中间列不能断**​：不要跳过索引中的列，否则后续列无法使用。
    
- ​**范围之后全失效**​：范围查询会使它右边的索引列失效。
    

在设计复合索引时，应将**最常被作为查询条件**且**区分度高**的列放在最左边。
#### 法则详解与示例

假设我们有一张 `user`表，并为其 `(profession, age, status)`三个字段创建了一个复合索引，名为 `idx_pro_age_sta`。

​**1. 完全遵循法则（索引有效）​**​

查询条件中包含了索引的最左列 `profession`。

- `WHERE profession = '软件工程师' AND age = 30 AND status = '1'`（**索引生效**，三个字段都用了）
    
- `WHERE profession = '软件工程师' AND age = 30`（**索引生效**，使用了 `profession`和 `age`）
    
- `WHERE profession = '软件工程师'`（**索引生效**，只使用了 `profession`）
    

> ​**只要查询条件中包含最左列 `profession`，索引就会生效。使用的索引列越多，过滤效果越好。​**​

​**2. 违反法则（索引失效）​**​

查询条件**不包含**最左列 `profession`。

- `WHERE age = 30`（**索引失效**）
    
- `WHERE status = '1'`（**索引失效**）
    

- `WHERE age = 30 AND status = '1'`（**索引失效**）
    

> ​**跳过最左列，直接使用后面的列，复合索引将完全失效，会导致全表扫描。​**​

​**3. 特殊情况（部分生效）​**​

查询条件包含最左列，但跳过了中间的列。

- `WHERE profession = '软件工程师' AND status = '1'`（**索引部分生效**）
    

> 在这种情况下，索引**不会完全失效**。MySQL 仍然会使用复合索引，但它只能使用到 `profession`这一列（这被称为“索引前缀”）。`status`列无法被用于索引过滤，因为中间的 `age`列缺失了，破坏了索引的有序性。

#### 注意事项与特殊情况

1. ​**条件的顺序不重要**​：SQL 是声明式语言，查询优化器会帮你优化条件的顺序。以下两条 SQL 对于索引的使用是等价的：
    
    - `WHERE profession = '软件工程师' AND age > 30`（索引生效）
        
    - `WHERE age > 30 AND profession = '软件工程师'`（索引同样生效，优化器会调整顺序以匹配索引）
        
    
2. ​**范围查询右边的列索引失效**​：如果对索引中的某一列使用了范围查询（如 `>`， `<`， `like '%abc'`， `BETWEEN`），则它**右边的所有列**将无法再使用索引进行过滤。
    
    - 例如：`WHERE profession = '软件工程师' AND age > 30 AND status = '1'`
        
    - 在这个查询中，`profession`和 `age`会使用索引，但 `status`不会。因为 `age > 30`是一个范围查询，它右边的 `status`列在索引中变得无序，无法被高效利用。
        
    



###  索引失效的情况（where条件）

#### 1. 在索引列上进行运算或使用函数

在 `WHERE`子句中，如果对索引列进行运算、使用函数或进行表达式计算，MySQL 将无法使用该列的索引。

```
-- ❌ 失效：对索引列进行运算
SELECT * FROM user WHERE id + 1 = 10;
-- ✅ 有效：将运算移到等号另一边
SELECT * FROM user WHERE id = 9;

-- ❌ 失效：在索引列上使用函数
SELECT * FROM user WHERE UPPER(name) = 'JOHN';
SELECT * FROM user WHERE YEAR(create_time) = 2023;
SELECT * FROM user WHERE LENGTH(email) > 10;
-- ✅ 有效：对常量使用函数，保持索引列"干净"
SELECT * FROM user WHERE name = 'john' AND create_time >= '2023-01-01';
```

#### 2. 数据类型不匹配（隐式类型转换）

当查询条件中的值与索引列的数据类型不匹配时，MySQL 会进行隐式类型转换，导致索引失效。

```
-- 假设 user_id 是字符串类型（VARCHAR），但用数字查询
-- ❌ 失效：MySQL 需要将每行的 user_id 转换为数字来比较
SELECT * FROM orders WHERE user_id = 12345;
-- ✅ 有效：使用相同数据类型
SELECT * FROM orders WHERE user_id = '12345';

-- 假设 phone 是字符串类型，但存储的是数字
-- ❌ 失效：隐式类型转换
SELECT * FROM user WHERE phone = 13800138000;
-- ✅ 有效
SELECT * FROM user WHERE phone = '13800138000';
```

#### 3. 使用 `OR`连接条件

如果 `OR`连接的多个条件中，有一个条件涉及的列没有索引，那么整个查询可能无法使用索引。

```
-- 假设 name 有索引，但 age 没有索引
-- ❌ 失效：因为 age 无索引，优化器会选择全表扫描
SELECT * FROM user WHERE name = 'John' OR age > 30;

-- ✅ 有效：使用 UNION 或分别查询
SELECT * FROM user WHERE name = 'John'
UNION
SELECT * FROM user WHERE age > 30;
```

#### 4. 使用前导通配符的 `LIKE`查询

`LIKE`查询只有在模式不以通配符开头时才能使用索引。

```
-- ❌ 失效：以通配符开头，无法使用索引
SELECT * FROM product WHERE name LIKE '%手机%';
SELECT * FROM product WHERE name LIKE '%旗舰';

-- ✅ 有效：不以通配符开头，可以使用索引
SELECT * FROM product WHERE name LIKE '苹果%';
SELECT * FROM product WHERE name LIKE '小米手机%';

-- 如果需要全文搜索，考虑使用全文索引
ALTER TABLE product ADD FULLTEXT(name);
SELECT * FROM product WHERE MATCH(name) AGAINST('手机' IN NATURAL LANGUAGE MODE);
```

#### 5. 范围查询导致右边列索引失效

在联合索引中，如果对某一列使用了范围查询（`>`、`<`、`BETWEEN`、`IN`等），那么它右边的所有列将无法使用索引排序和过滤。

```
-- 假设有联合索引 (a, b, c)
-- ❌ c 列索引失效：因为 b > 10 是范围查询
SELECT * FROM table WHERE a = 1 AND b > 10 AND c = 5;

-- ✅ 有效：调整索引顺序或查询条件
-- 创建新索引 (a, c, b)
ALTER TABLE table ADD INDEX idx_a_c_b (a, c, b);
```

#### 6. 使用 `!=`或 `NOT`操作符

不等于操作符通常无法有效使用索引。

```
-- ❌ 失效：不等于操作无法有效利用索引
SELECT * FROM user WHERE status != 'active';
SELECT * FROM product WHERE price <> 100;

-- ✅ 有效：改为范围查询或分别查询
SELECT * FROM user WHERE status IN ('inactive', 'pending');
SELECT * FROM product WHERE price < 100 OR price > 100;
```

#### 7. `IS NULL`和 `IS NOT NULL`查询

在某些情况下，`IS NULL`和 `IS NOT NULL`可能无法有效使用索引。

```
-- ❌ 可能失效：取决于数据分布
SELECT * FROM user WHERE email IS NULL;
SELECT * FROM user WHERE phone IS NOT NULL;

-- ✅ 解决方案：确保列定义为 NOT NULL 或使用覆盖索引
ALTER TABLE user MODIFY email VARCHAR(100) NOT NULL DEFAULT '';
```

#### 8. 数据区分度太低

当索引列的值重复率很高（区分度低）时，MySQL 优化器可能认为全表扫描比使用索引更高效。

```
-- 假设 status 只有 'active', 'inactive' 两个值，且数据分布均匀
-- ❌ 可能失效：优化器选择全表扫描
SELECT * FROM user WHERE status = 'active';

-- ✅ 解决方案：使用复合索引或强制使用索引
SELECT * FROM user FORCE INDEX(idx_status) WHERE status = 'active';
```

#### 如何诊断索引失效？

使用 `EXPLAIN`命令分析查询执行计划：

```
EXPLAIN SELECT * FROM user WHERE name LIKE '%John%';
```

关注以下关键字段：

- ​**type**​：如果是 `ALL`，表示全表扫描
    
- ​**key**​：显示实际使用的索引，如果为 `NULL`则表示未使用索引
    
- ​**Extra**​：包含 `Using where`但无 `Using index`可能表示索引失效
    

#### 最佳实践建议

1. ​**保持索引列"干净"​**​：避免在索引列上使用函数或运算
    
2. ​**注意数据类型**​：确保查询条件与列数据类型匹配
    
3. ​**合理设计索引**​：基于实际查询模式创建复合索引（范围查询）
    
4. ​**定期维护索引**​：使用 `ANALYZE TABLE`更新索引统计信息
    
5. ​**监控慢查询**​：使用慢查询日志识别需要优化的查询



### SQL提示

| 提示类型               | 强制程度 | 适用场景             |
| ------------------ | ---- | ---------------- |
| ​**USE INDEX**​    | 建议性  | 提供优化建议，优化器可能不接受  |
| ​**IGNORE INDEX**​ | 建议性  | 避免优化器选择低效索引      |
| ​**FORCE INDEX**​  | 强制性  | 确信某个索引最优，覆盖优化器选择 |

---

#### 1. `USE INDEX`- 建议使用索引

- ​**语法**​：`SELECT ... FROM 表名 USE INDEX (索引名) WHERE ...`
    
- ​**作用**​：​**建议**查询优化器使用指定的索引。
    
- ​**场景**​：当你认为优化器有更好的索引选择时，给予提示。但优化器仍可能根据自己的判断选择忽略此建议。
    

#### 2. `IGNORE INDEX`- 忽略索引

- ​**语法**​：`SELECT ... FROM 表名 IGNORE INDEX (索引名) WHERE ...`
    
- ​**作用**​：​**建议**查询优化器忽略指定的索引。
    
- ​**场景**​：当某个索引的区分度很低（如“性别”字段索引），使用它反而可能比全表扫描更慢时，使用此提示避免优化器选错。
    

#### 3. `FORCE INDEX`- 强制使用索引

- ​**语法**​：`SELECT ... FROM 表名 FORCE INDEX (索引名) WHERE ...`
    
- ​**作用**​：​**强制**查询优化器使用指定的索引。
    
- ​**场景**​：当你确信某个索引是最优选择，而优化器因统计信息过期等原因未能选择时，使用此提示进行强制干预。这是三者中强制性最强的。

### 覆盖索引（优化查询返回的字段）
查询使用了索引，​**并且需要返回的列，在该索引中已经全部能够找到**。

![[Pasted image 20251030191255.png]]
覆盖索引是一种**用空间换时间**的优化策略。通过创建合理的联合索引，并养成 `SELECT 具体字段`而非 `SELECT *`的习惯，可以避免耗时的回表操作，使查询性能获得数量级的提升。这是数据库索引优化中最有效的手段之一。
#### 一、核心概念

​**覆盖索引**​ 指的是：一个 SQL 查询**只需要通过扫描索引**，就能获取到所有需要的数据字段，而**无需再回到主键索引（聚簇索引）中进行“回表”查询**。

图片中的定义非常关键：

> “查询使用了索引，​**并且需要返回的列，在该索引中已经全部能够找到**。”

#### 二、为什么覆盖索引能大幅提升性能？

要理解其优势，首先要明白没有覆盖索引时的查询过程（回表查询）：

1. ​**索引扫描**​：在辅助索引（如 `idx_name`）的 B+Tree 中找到符合条件的记录。
    
2. ​**回表操作**​：由于辅助索引的叶子节点只存储了当前索引字段和对应的主键 ID，如果要获取 `SELECT *`中的其他字段，就必须根据找到的主键 ID，再回到主键索引的 B+Tree 中重新查找一遍，以获取完整的行数据。
    
3. ​**性能开销**​：这个“回到主表”的过程就是**回表**。每一条符合条件的记录都可能产生一次磁盘 I/O，当数据量巨大时，性能开销非常大。
    

而**覆盖索引避免了回表**​：

- 因为需要返回的所有列都包含在索引中，所以数据库引擎在扫描完辅助索引的 B+Tree 后，​**已经得到了全部所需数据**，无需再访问主键索引。这极大地减少了磁盘 I/O 操作，从而显著提升查询速度。
    

#### 三、实践建议：`减少 SELECT *`

图片中给出的建议 `减少select *`是使用覆盖索引最直接、最有效的方法。

- ​**`SELECT *`的问题**​：它要求返回所有列。除非你为所有查询字段建立了极其庞大的联合索引，否则几乎必然导致**回表查询**。
    
- ​**正确的做法**​：只查询业务逻辑真正需要的列。
    

​**对比示例：​**​

假设有一张 `user`表，有主键 `id`，并在 `(name, age)`上建立了联合索引 `idx_name_age`。

```
-- 查询1：低效查询（需要回表）
SELECT * FROM user WHERE name = '张三';

-- 查询2：高效查询（覆盖索引）
SELECT name, age FROM user WHERE name = '张三'; 
-- 以及
SELECT id, name, age FROM user WHERE name = '张三';
```

​**分析**​：

- ​**查询1**​：虽然 `name`条件用到了 `idx_name_age`索引，但要获取 `*`（如 email, phone 等未在索引中的列），数据库必须进行**回表**操作。
    
- ​**查询2**​：要返回的 `name`, `age`（以及主键 `id`默认存在）​**全部包含在 `idx_name_age`索引中**。数据库引擎在扫描 `idx_name_age`索引后就直接得到了结果，无需回表，速度极快。
    


### 前缀索引（针对文本数据）
![[Pasted image 20251030212012.png]]
![[Pasted image 20251030212158.png]]
- ​**优势**​：显著减小索引大小，提高查询速度，特别是对于 `TEXT`、长 `VARCHAR`等字段。
    
- ​**劣势**​：因为只使用了部分字符串，所以**无法使用前缀索引进行排序（ORDER BY）​**，并且覆盖索引的特性会失效（辅助索引中存放的数据不完整，必须回表）。
    
- ​**适用场景**​：主要用于长字符串的**等值（=）查询和前缀匹配（LIKE ‘abc%’）查询**。
    

​**核心要点**​：前缀索引是一种有效的优化手段，但其成功的关键在于通过计算**选择性**，为 `n`选择一个合理的值，在索引大小和查询效率之间取得最佳平衡。

#### 一、什么是前缀索引？为什么需要它？

- ​**定义**​：只为字符串字段的**前面一部分字符**创建索引，而不是为整个字符串创建索引。
    
- ​**解决什么问题**​：当字段类型是 `VARCHAR(TEXT)`、`TEXT`或 `BLOB`等长字符串时，为其创建完整索引会导致索引文件非常大，不仅占用大量存储空间，更会显著增加磁盘 I/O，降低查询效率。
    
- ​**核心思想**​：用**空间换效率**。通过牺牲一点点索引的精确度，来换取索引体积的大幅减小和查询性能的提升。
    

#### 二、如何创建前缀索引？

语法非常简单，在创建索引的语句中指定字段名和前缀长度 `n`即可。

```
CREATE INDEX index_name ON table_name(column_name(n));
```

- `index_name`： 你为索引取的名字。
    
- `table_name`： 表名。
    
- `column_name`： 要创建索引的字符串列名。
    
- `n`： ​**前缀长度**，即使用该列的前多少个字符来构建索引。这是前缀索引的**关键决策点**。
    

​**示例**​：

```
-- 为 user 表的 email 字段创建前缀索引，只取前10个字符
CREATE INDEX idx_email_prefix ON user(email(10));
```

#### 三、如何确定最佳的前缀长度 `n`？

图片指出了最关键的一步：前缀长度 `n`的选择依据是**索引的选择性**。

1. ​**什么是选择性？​**​
    
    - 选择性 = `不重复的索引值数量（基数） / 数据表总记录数`。
        
    - ​**选择性越高，查询效率通常越高**。它的取值范围在 `0`到 `1`之间。
        
    - ​**选择性为 1**​：表示该列所有值都是唯一的（如主键、唯一索引），这是最理想的情况。
        
    
2. ​**如何选择 `n`？—— 通过计算不同前缀长度的选择性**​
    
    图片中的 SQL 演示了如何通过计算来选择 `n`：
    
    ```
    -- 1. 先计算完整列的选择性（作为参考基准）
    SELECT COUNT(DISTINCT email) / COUNT(*) FROM tb_user;
    
    -- 2. 然后尝试计算不同前缀长度的选择性，找到最接近完整列选择性的最小长度 n
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 5)) / COUNT(*) FROM tb_user; -- 计算前5个字符的选择性
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 6)) / COUNT(*) FROM tb_user; -- 计算前6个字符的选择性
    SELECT COUNT(DISTINCT SUBSTRING(email, 1, 7)) / COUNT(*) FROM tb_user; -- 计算前7个字符的选择性
    ```
    
    ​**决策过程**​：不断增加 `n`的值并计算其选择性，直到选择性非常接近完整列的选择性。此时这个 `n`就是一个比较合理的前缀长度。例如，如果前7个字符的选择性已经达到0.95，而前8个字符的选择性为0.96，提升不大，那么选择 `n=7`就是性价比很高的方案。
    

### 单列索引和联合索引的选择
联合索引的B+Tree，键为多个字段的组合，先按照最左边字段排序，接着依次往后排序（排序优先级）
![[Pasted image 20251030212910.png]]

设计合理的联合索引能避免回表查询

实践推荐：根据业务需求选择联合索引的组合，并且根据区分度选择哪个在更前面
#### 1. 索引类型对比

首先明确了两种索引的定义：

- ​**单列索引**​：一个索引只包含一个列。
    
- ​**联合索引**​：一个索引包含多个列。
    

重要建议：​**当查询条件有多个时，建议建立联合索引，而不是为每个列创建单列索引。​**​

#### 2. 实例分析：单列索引的局限性

图中的 SQL 语句和其执行计划（`EXPLAIN`结果）完美地演示了单列索引的问题。

- ​**查询语句**​：
    
    ```
    EXPLAIN SELECT id, phone, name FROM tb_user 
    WHERE phone = '17799990010' AND name = '韩信';
    ```
    
    这是一个包含两个查询条件（`phone`和 `name`）的语句。
    
- ​**表上的索引情况**​：从 `possible_keys`列可以看出，表 `tb_user`上存在两个单列索引：`idx_user_phone`和 `idx_user_name`。
    
- ​**优化器的选择**​：`key`列显示，优化器**最终只选择了**​ `idx_user_phone`索引来执行查询。它无法同时利用两个单列索引。
    

#### 3. 为什么会这样？—— 底层原因

这是因为数据库对于单列索引的处理方式：

1. MySQL 在大部分情况下，​**对于多个查询条件，只会选择一个它认为最有效的索引**​（此处选择了区分度可能更高的 `phone`索引）。
    
2. 对于 `name = '韩信'`这个条件，MySQL 无法使用 `idx_user_name`索引进行检索，只能在通过 `idx_user_phone`索引找到候选记录后，再**回表**到主键索引中取出完整的 `name`字段值进行过滤（这体现在 `Extra`列虽然没有显示 `Using where`，但过滤确实发生了）。
    
3. 这种机制效率较低，因为另一个条件 (`name`) 没有索引加速。
    

### 结论与优化建议

这个例子揭示了单列索引在多条件查询时的核心短板：​**数据库优化器通常难以高效地合并使用多个单列索引**。

​**正确的做法**​：

根据这个查询模式，应该创建一个 `(phone, name)`的联合索引（或者 `(name, phone)`，取决于哪个条件区分度更高）。

```
CREATE INDEX idx_user_phone_name ON tb_user(phone, name);
```

创建此联合索引后，数据库可以直接在一个索引树中同时处理 `phone`和 `name`两个条件，查询效率会远高于使用两个单列索引。

​**总结**​：在进行数据库索引设计时，不应孤立地为每个查询列创建索引，而应**根据实际的、频繁使用的多列组合查询条件来创建联合索引**，这样才能发挥索引的最大效能。