[[继承 接口的三种具体应用]]
### 策略模式

#### 代表什么？

​**核心思想：定义了一组封装好的算法，这些算法分别执行不同的操作。在实际运行中，这些算法可以动态切换来满足不同场景下的需求。策略模式让算法的变化独立于使用算法的客户端。​**

> [!含义]也就是说
> **策略模式将一组完成相同工作的不同方式的代码分别放到不同的类中，并通过策略模式实现在运行中的相互切换。**


​%% 比如说 排序算法的实现，客户端只要调用排序算法，算法段则根据数据的大小，规模等选取不同的算法完成排序，如快排，堆排等等，客户端不需要知道到底是用什么算法实现的排序 %%


- ​**接口的角色**​：策略接口定义了算法的契约。所有具体的策略类都实现这个接口。
- ​**模式结构**​：
    - ​**策略接口**​：定义了所有支持算法的方法。
    - ​**具体策略类**​：实现了策略接口，提供了具体的算法实现。
    - ​**上下文类**​：持有一个策略接口的引用，并不关心具体是哪种策略，只负责调用接口方法。

```java
//接口
public interface Strategy {
   public int doOperation(int num1, int num2);
}
 
//接口实现类
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
 
//上下文
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
 
//具体调用
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());        
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubstract());        
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());        
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}

```

#### 实际生活生产中的意义

​**意义：将“做什么”和“怎么做”分离开，提供了巨大的灵活性和可扩展性。​**​

​**生活例子：支付方式**​

- ​**策略接口**​：`PaymentStrategy` (包含一个 `pay(amount)` 方法)
- ​**具体策略**​：`CreditCardPayment`（信用卡支付）, `AlipayPayment`（支付宝支付）, `WeChatPayment`（微信支付）
- ​**上下文**​：`Checkout`（收银台）  
    你去购物结账时，收银员问你“怎么支付？”。无论你选择哪种支付方式（策略），收银员（上下文）的操作都是统一的“请支付100元”。具体刷信用卡、扫二维码这些“如何支付”的细节，由相应的支付策略去完成。增加一个新的支付方式（如数字货币），完全不需要修改收银台的代码，只需新增一个策略类即可。
    **向上转换：向上转化在继承中是指子类可以向上转化为父类


`

​**生产例子：数据排序**​

- 系统需要一个排序功能，但数据量小时用快速排序，数据量大时用归并排序，数据几乎已排序时用插入排序。你可以定义 `SortStrategy` 接口，并实现多种排序算法。程序运行时根据数据情况动态切换排序策略，而不需要修改调用排序的代码。

​**核心价值**​：​**应对“算法”或“策略”频繁变化的场景，符合“开闭原则”（对扩展开放，对修改关闭）。​**










