---
aliases:
  - Redis内存淘汰机制
---
- 需求背景：内存是有限且昂贵的资源
	- 防止内存溢出：为了避免Redis内存耗尽，导致 Redis 进程被系统强制终止（OOM Killer）
	- 清理僵死数据：很多数据（尤其是缓存数据）具有明确的**时效性**。过期后若不清理，就会成为“僵尸数据”，白白占用宝贵的内存空间
- 解决措施：Redis的数据清理机制
	- 核心思想：考虑到Redis是单线程事件循环模型，因此清理操作必须在**高效释放内存**和**最小化对主线程性能影响**之间取得平衡
	- 核心机制： 三层互补的清理机制
----
- 定期删除：作为一种折中方案，限定了每次执行的时长和频率，有效平衡了 CPU 和内存的占用
	- **触发时机**：Redis内部有一个定时任务（默认每秒运行10次），周期性抽样检查并删除过期Key
	- **执行流程**：
		1. 每次随机从数据库中抽取**20个**Key进行检查。
		2. 删除其中所有已过期的Key。
		3. 判断：如果本轮删除的过期Key数量**超过5个**（25%）‍，则**重复**步骤1；如果少于5个，则停止本轮检查
	- **设计目的**：在CPU消耗和内存释放之间取得平衡，减少过期Key的堆积。
- 惰性删除：它是定期删除的补充，确保过期键在被访问时能被正确清理
	- **触发时机**：客户端访问某个Key时（如GET、HGET），Redis会先检查它是否过期
	- **执行动作**：如果过期，则立即删除该Key，并向客户端返回 `nil`。
	- **优点**：对CPU友好，只在访问时消耗资源
	- **缺点**：内存泄露的风险。如果过期Key永远不被访问，就会一直占用内存，造成“内存泄漏”
- 内存淘汰策略：防止服务因内存不足而崩溃的最后手段
	- 触发时机：当内存使用达到 `maxmemory` 限制时，Redis会根据配置的 `maxmemory-policy` 来决定如何行为
	- 淘汰策略：
		- **不淘汰**：noeviction（默认策略）
			- 含义：不删除任何Key，当内存不足时，新写入命令会报错。
			- 适用场景：数据绝对不能丢失的场景
		  - **对全体Key淘汰**：
			  - allkeys-lru：从**所有Key**中，淘汰**最近最少使用**的Key。最常用的缓存策略
			  - allkeys-lfu：从**所有Key**中，淘汰**最不经常使用**的Key。适用于访问频率差异明显的场景
			  - allkeys-random：从**所有Key**中，**随机**淘汰。
		  - **仅对设置TTL的Key淘汰**：
			  - volatile-lru：仅从**设置了TTL的Key**中，淘汰最近最少使用的。
			  - volatile-lfu：仅从**设置了TTL的Key**中，淘汰最不经常使用的。
			  - volatile-random：仅从**设置了TTL的Key**中，随机淘汰。
			  - volatile-ttl：仅从**设置了TTL的Key**中，淘汰**剩余存活时间最短**的
	  - **LRU/LFU是近似算法**：
		  - 实现基础：Redis 在每个键对应的值的`redisObject`中，都设置了一个 **24 位的 `lru`字段
		  - 实现机制：随机采样，在样本集中使用lru/lfu淘汰算法
			  - 随机采样的目的：精确的LRU/LFU算法需要为**每一个Key**维护一个完整的链表或排序结构
				  - 消耗大量额外内存
				  - 且每次访问都要更新链表，对性能影响很大
			  - LRU
				  - `lru`字段含义：记录键**最后一次被访问**的时间戳（精度为秒，取模后存储）
				  - 热度评估：
					  1. 计算每个样本键的 **"空闲时间"**：当前时间减去其 `lru`字段记录的时间
					  2. 空闲时间越长的键，被认为热度越低
				  - 淘汰选择：从样本集中**淘汰空闲时间最长的那个键**
			  - LFU
				  - `lru`字段含义：24 位字段被拆分为两部分：
					- 高 16 位 (ldt)：记录上一次计数器衰减的时间
					- 低 8 位 (logc)：记录访问**频率计数器**。
						- 增长规律：
							- 规律：访问次数越多，计数器值增加的概率就越低
							- 设计目的：
								- 用极小的空间（仅8位）就能表示非常大的访问量级（比如百万次）
								- 并且能区分出高频、中频、低频的访问
						- 衰减机制：
							- 设计目的：防止过去的“热点”数据永远霸占内存
							- 具体机制：
								- 衰减时机（惰性衰减）：在**访问Key时**
								- 衰减值：根据当前时间与 `ldt` 的差值，按一定公式计算衰减值
						- 新键的 `logc`初始值为 5
							- 目的：避免新键立即被淘汰
							- 配置方式：`LFU_INIT_VAL`
						- 整体变化：每次访问都会让其下降，然后又有概率地上升一点
				- 热度评估：近期访问频率
				- 淘汰选择：从样本集中淘汰**频率计数器值**最低的键
			- 优化：​淘汰池
				- 设计思想：淘汰池保留了之前多轮采样的“成果”，使得淘汰决策更准确，效果更接近全局LRU
				- 实现基础：淘汰池是一个固定大小的最小堆
					- 采样对比后最冷的数据不直接淘汰，而是与淘汰池中最“热”的候选键进行比较
					-  如果更冷则进入淘汰池，并挤掉原先最“热”的那个候选
				- 淘汰机制：当需要释放内存时，Redis直接从淘汰池中最“冷”的数据






