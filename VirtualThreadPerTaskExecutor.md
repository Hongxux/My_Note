
- 创建线程的数量受限于内存和系统资源，远远不够几万级别的高并发情况
- 阻塞代价高：在I/O密集型应用中，线程大部分时间在等待。
	- 在线程池模型中，一个被阻塞的平台线程无法处理其他任务，即使CPU是空闲的。
	- 传统线程池的解决方法是，增加线程数量，但是很快就会碰到内存和系统资源的瓶颈
- 解决方法：虚拟线程执行器，提供挂载-卸载调度机制
	1. **提交任务**：当你向 `newVirtualThreadPerTaskExecutor()`提交一个任务时，它会立即创建一个新的虚拟线程来执行该任务。
	2. **挂载到载体线程**：JVM 的调度器会将这个虚拟线程**挂载**到一个实际的平台线程（称为**载体线程**）上开始执行。默认情况下，这些载体线程是一个高效的 `ForkJoinPool`。
	3. **遇到阻塞时卸载**：当虚拟线程中的代码执行到阻塞操作（如 `Thread.sleep()`, 网络I/O, 文件操作）时，魔法发生了。JVM 不会让载体线程空等，而是会将当前虚拟线程从载体线程上**卸载**。虚拟线程的状态（栈帧、执行点）被保存到堆内存中，然后该载体线程被释放。
	4. **载体现身**：被释放的载体线程不会闲着，它会立刻去执行队列中的下一个虚拟线程任务。
	5. **恢复执行**：当之前阻塞的操作完成时（如睡眠时间到、网络数据到达），JVM 调度器会找到一个空闲的载体线程，并将之前卸载的虚拟线程重新**挂载**上去，从上次阻塞的地方继续执行。