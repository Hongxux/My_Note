
### 🚦 线程池拒绝策略选择与配置

当线程池和队列已满时，拒绝策略决定了如何应对新提交的任务。

1. 四种拒绝策略对比

| 拒绝策略 | 工作原理 | 适用生产场景 |
| :--- | :--- | :--- |
| `ThreadPoolExecutor.CallerRunsPolicy` | 由提交任务的线程自己执行任务。 | 最常用，提供简单背压，避免数据丢失，适合大多数异步场景。 |
| `ThreadPoolExecutor.AbortPolicy` | 直接抛出 `RejectedExecutionException` 异常。 | 适用于关键任务，需要明确知道系统已过载，并快速失败进行降级的场景。 |
| `ThreadPoolExecutor.DiscardPolicy` | 默默丢弃新任务，不抛异常。 | 适用于允许丢弃非核心任务的场景，如不重要的统计信息上报。 |
| `ThreadPoolExecutor.DiscardOldestPolicy` | 丢弃队列中最老的任务，然后尝试重新提交新任务。 | 适用于允许丢弃旧任务、希望处理最新任务的场景，如实时数据流处理。 |

2. 生产环境选择建议

•   追求平稳性：首选 `CallerRunsPolicy`。它能让生产任务的线程稍作“休息”，给线程池缓冲的机会，避免系统在过载时完全崩溃。

•   追求可靠性：对于绝不能丢失的任务，可结合 `AbortPolicy` 与外部持久化队列。当任务被拒绝时，将其存入数据库或Kafka等中间件，后续进行重试。

•   监控与动态调整：无论选择哪种策略，都必须配合监控（如线程池活跃度、队列大小），并考虑使用动态线程池（如Hystrix、Sentinel）以便根据负载实时调整参数。


3. 配置线程池示例

