![[Pasted image 20251004165511.png]]
这段代码展示了一个**混合锁**的实现，它巧妙地结合了**自旋锁**的快速响应和**队列管理**的公平性，旨在解决纯自旋锁在竞争激烈时浪费CPU资源的问题。

### 🔍 锁的核心组件解析

这个锁结构（`lock_t`）包含三个关键部分：

-  **`flag`（主锁标志）​** ​：表示主锁是否被占用（1表示已占用，0表示空闲）。这是线程最终要获取的锁。
    
- **​`guard`（守护锁）** ：一个用于保护`flag`和队列`q`的**自旋锁**。确保对`flag`和队列的操作是原子的。
    
- **​`q`（等待队列）**  ：管理未能立即获取`flag`锁的线程，确保唤醒的公平性（通常是FIFO）。
    

```
typedef struct __lock_t {
    int flag;       // 主锁状态：0=空闲, 1=占用
    int guard;      // 保护锁（自旋锁），用于保护对flag和队列的操作
    queue_t *q;     // 等待线程队列
} lock_t;
```
### 核心函数
- **park()**：让某个线程进入休眠状态
- **unpark()**：让某个线程从休眠状态唤醒
### 🔄 代码流程详解

#### ​**1. 初始化锁 (`lock_init`)​**​

```
void lock_init(lock_t *m) {
    m->flag = 0;   // 主锁初始状态为空闲
    m->guard = 0;  // 守护锁初始状态为未加锁
    queue_init(m->q); // 初始化等待队列
}
```

在锁初始化时，将主锁`flag`和守护锁`guard`都设为0（未锁定状态），并初始化等待队列`q`，为锁的使用做好准备。

#### ​**2. 加锁过程 (`lock`)​**​

加锁操作是核心，其流程如下：

1. ​**获取守护锁（自旋）​**​：
    
    ```
    while (TestAndSet(&m->guard, 1) == 1)
        ; // 通过自旋获取guard锁
    ```
    
    线程首先使用[[TestAndSet]]原子指令尝试获取`guard`锁。如果失败，就在此处**忙等待**。这个自旋时间预期非常短，因为`guard`只用于保护一小段临界区代码。
    
2. ​**检查主锁状态**​：
    
    - ​**若主锁空闲（`m->flag == 0`）​**​：
        
        ```
        m->flag = 1; // 立即获取主锁
        m->guard = 0; // 释放守护锁
        ```
        
        线程成功获取主锁，然后释放`guard`锁，整个加锁过程迅速完成。这对应于**锁竞争不激烈**的理想情况。
        
    - ​**若主锁已被占用（`m->flag == 1`）​**​：
        
        ```
        queue_add(m->q, gettid()); // 将当前线程ID加入等待队列
        m->guard = 0; // 释放守护锁
        park(); // 当前线程挂起（休眠）
        ```
        
        线程将自己的ID加入等待队列，释放`guard`锁，然后调用`park()`将自身**挂起**​（阻塞）。这时线程会让出CPU，避免空转浪费资源。这是处理**锁竞争激烈**情况的关键优化。
        
    

#### ​**3. 解锁过程 (`unlock`)​**​

解锁操作同样在`guard`锁的保护下进行：

1. ​**获取守护锁**​：
    
    ```
    while (TestAndSet(&m->guard, 1) == 1)
        ; // 通过自旋获取guard锁
    ```
    
2. ​**决定下一步动作**​：
    
    - ​**若等待队列为空**​：
        
        ```
        m->flag = 0; // 直接释放主锁
        ```
        
        表示没有其他线程在等待，直接释放主锁即可。
        
    - ​**若等待队列非空**​：
        
        ```
        unpark(queue_remove(m->q)); // 从队列中取出一个线程并唤醒它
        // 注意：此时并不将m->flag置0！
        ```
        
        这表明有线程正在等待。解锁操作会从队列中取出下一个线程ID（通常是队首的线程），并调用`unpark()`唤醒它。​**关键点在于：这里并没有将主锁`flag`设置为0，而是直接将锁的所有权“传递”给了被唤醒的线程**。 这样做避免了唤醒过程中其他线程“插队”获取锁，保证了公平性。
        
    
3. ​**释放守护锁**​：
    
    ```
    m->guard = 0; // 最后总是释放守护锁
    ```
    

### ⚠️ 关键点与潜在问题

1. ​**​“守护锁”的双重角色**​：`guard`这个自旋锁保护的是对`flag`和队列`q`的修改。它确保了检查`flag`、操作队列、以及线程挂起/唤醒这一系列操作的**原子性**，防止出现竞态条件（例如，在判断`flag`为1后、执行`park()`前，解锁操作已经完成并执行了`unpark`，导致该线程可能永久休眠）。
    
2. ​**唤醒的公平性**​：使用FIFO队列管理等待线程，确保了线程获取锁的顺序与请求顺序一致，解决了纯自旋锁可能导致的**线程饥饿**问题。
    
3. ​**性能权衡**​：
    
    - ​**低竞争场景**​：线程可能直接通过`flag`获取锁，效率接近简单的自旋锁。
        
    - ​**高竞争场景**​：线程会挂起并放入队列，避免了大量CPU周期浪费在自旋上，提升了系统整体吞吐量。
        
    
4. ​**潜在问题：唤醒丢失**​
    
    代码中存在一个细微但关键的隐患。考虑以下时序：
    
    - ​**线程A**​ 调用`lock()`，发现`flag`为1，于是准备将自己加入队列并调用`park()`。
        
    - 就在**线程A**​ 执行完`m->guard = 0`后、但还未执行`park()`之前，CPU发生了切换。
        
    - ​**线程B**​ 调用`unlock()`，发现队列非空，便唤醒队首线程（恰好是线程A）。
        
    - 但此时**线程A**还未进入休眠状态（`park()`尚未执行），这个唤醒信号就“丢失”了。
        
    - 当**线程A**再次被调度并执行`park()`时，它可能会因为错过唤醒信号而**永久休眠**。
        
    
    解决这个问题通常需要在`park()`前再次检查某个条件，或者使用如[[futex]]这样的机制，它们内部通过维护一个状态来避免这种唤醒丢失。又或者使用Solaris [[setpark()]]。二者区别如下：[[​Solaris park和Linux futex区别]]
    

### 💎 总结

这段代码实现了一个**高效且公平的互斥锁**。它通过`guard`自旋锁保护关键操作，利用`flag`表示主锁状态，并使用队列管理等待线程。其核心思想是：​**在锁被占用时，让等待线程挂起而非忙等，从而在高竞争环境下显著提高CPU利用率；并通过队列保证先来先服务的公平性。​**​

希望这个逐行的解析能帮助你透彻理解这个锁机制的工作原理。