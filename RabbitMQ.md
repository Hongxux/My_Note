![[Pasted image 20251209215604.png]]

- 基础部件
	- **生产者（Publisher/Producer）**：发送消息的应用程序。它将消息发布到**交换器**。
	- **消费者（Consumer）**：接收和处理消息的应用程序。它从**队列**中获取消息。
	- **交换器（Exchange）**：消息的**路由中心**。生产者将消息发送到交换器，交换器负责根据特定规则将消息路由到一个或多个队列中。它本身不存储消息。
	- **队列（Queue）**：消息的**缓冲区**，本质上是一个存储消息的邮箱。队列遵循先进先出（FIFO）的原则。消费者从队列中获取消息进行处理。
	- **绑定（Binding）**：连接**交换器**和**队列**的规则。你可以理解为交换器和队列之间的“一座桥”。
	- **虚拟主机（Virtual Host）**：用于在同一个 RabbitMQ 服务器内进行**逻辑隔离**。可以将它类比为操作系统中的文件夹。不同的应用可以拥有独立的 vhost，其中的交换器、队列等互不干扰。
- 消息路由
	- 运作规律：生产者通过 Routing Key 给消息贴上一个“地址标签”，而 Binding Key 则是队列在交换机那里设置的“收件规则”。​ 当消息到达交换机后，交换机会将消息的“地址标签”（Routing Key）与每个队列设置的“收件规则”（Binding Key）进行比对。匹配成功的，消息就会被投递到对应的队列中。
	- **路由键（Routing Key）**：
		- 定义方：**生产者**​ 在发送消息时设定
		- 设定时机：消息发送时候
		- 作用：标识消息的路由目标
			- 交换器会根据这个键来决定消息的路由方向。
	- **绑定键（Binding Key）**：
		- 定义方：**消费者**（或管理员）在**绑定**队列到交换机时设定
		- 设定实际：建立绑定时候
		- 作用：定义队列接收消息的条件
			- 交换器会将消息的 **Routing Key**​ 与这个 **Binding Key**​ 进行匹配，从而决定消息应被路由到哪些队列
	- 二者匹配规则由交换器类型决定
- 四种交换器类型：不同的路由策略
  
| 交换器类型           | 路由规则                                                              | 典型应用场景                                             |
| --------------- | ----------------------------------------------------------------- | -------------------------------------------------- |
| **Direct（直连）**​ | 精准匹配：Routing Key 必须**完全等于**​ Binding Key，消息才会被路由到该队列              | 点对点精确发送，如将错误日志发送到特定的处理队列。                          |
| **Fanout（扇出）**​ | 忽略：交换机会**忽略**这两个Key，将消息**广播**到所有绑定到此交换机的队列                        | 广播消息，如新闻更新需要同时通知多个系统。                              |
| **Topic（主题）**​  | 模糊匹配：Binding Key 可使用通配符（`*`匹配一个词，`#`匹配零个或多个词）与 Routing Key 进行模式匹配 | 实现消息的灵活分类和订阅，如监听特定区域（如`usa.#`）或所有类型的新闻（如`#.news`）。 |
| **Headers（头）**​ | 不依赖 Routing Key，而是根据消息头（Headers）中的键值对进行匹配。                        | 基于复杂的多属性进行路由，但性能较差，使用较少。                           |
- 连接与信道：通信的桥梁
	- **连接（Connection）**：生产者/消费者与 RabbitMQ 服务器之间的一个 **TCP 连接**。建立连接的开销较大。
	- **信道（Channel）**：建立在 Connection 之上的**虚拟连接**。几乎所有的操作都在信道中进行。使用信道的好处是可以**复用**一个 TCP 连接，避免频繁创建和销毁 TCP 连接的巨大开销。
- 消息分发机制：
	-  **轮询分发（Round-Robin）**：这是默认策略。
		- 含义：它会将队列中的消息**依次、均匀地**分发给所有消费者，而不考虑每个消费者的处理能力
	    - 问题：这可能导致处理速度慢的消费者积压消息。
	- **公平分发（Fair Dispatch）**：为了解决轮询分发的缺陷，可以启用公平分发。
		- 开启方式：通过设置 `channel.basicQos(prefetchCount)`参数，可以限制每个消费者在未确认之前**最多能预取的消息数量**（通常设为1）。
		- 含义：只有在消费者处理完当前任务并发送确认（ACK）后，才会收到新的任务
		- 作用：确保了负载更加均衡
- [[Work  Queue模式]]
- 确保可靠性的关键机制
	- 消息丢失的三种可能
		- 发送消息的过程中丢失了，消息代理没有受到消息
		- 消息代理把消息弄丢了
		- 消费者把消息弄丢了
	- 发送者的可靠性
		- [[生产者连接MQ失败重连]]
		- [[生产者确认]]
	- MQ的可靠性
		- [[RabbitMQ持久化]]
		- [[Lazy Queue]]
	- 消费者的可靠性
		- [[消费者确认机制]]
			- 消费失败处理：移交死信队列，确保消息至少被消费一次，不会丢失
			- 业务幂等性：失败重试的基础
	- 延迟消息
- Spring AMQP[[SpringBoot中使用RabbitMQ]]
	- Spring AMQP对JAVA操作RabbitMQ做的一层封装
	- AMQP是消息队列的消息通信协议