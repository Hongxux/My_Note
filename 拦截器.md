![[Pasted image 20251110092230.png]]


### 一、 核心概念：什么是拦截器？

正如第一张图所述，**拦截器（Interceptor）** 是 Spring MVC 框架提供的一种机制，允许开发者在**请求到达控制器（Controller）之前**和**控制器处理完毕之后**以及**渲染完成之后** 这三个地方 ，插入自定义的处理逻辑。

**它的核心作用是实现对横切关注点（如日志、权限）的模块化处理，避免在每个控制器中重复编写相同代码。**

#### 与过滤器的关系与区别

图1明确指出，拦截器**类似于但不同于**过滤器。

- **相似点**：两者都用于在请求处理流程中插入预处理和后处理逻辑。
    
- **根本区别**：
    
    - **作用层面**：**过滤器（Filter）** 是 **Servlet 规范**的一部分，作用更底层，能过滤所有请求（包括静态资源）。**拦截器（Interceptor）** 是 **Spring MVC 框架**的一部分，只能拦截进入 `DispatcherServlet`的请求。
        
    - **依赖关系**：拦截器是 Spring 容器管理的 Bean，可以轻松注入 Spring 的其他服务（如 `Service`），而过滤器则不能。
        
    

---

### 二、 拦截器的三大方法及执行流程

1. **`preHandle`（前置处理）**：
    
    - **执行时机**：在**请求到达控制器方法之前**执行。
        
    - **返回值**：`boolean`类型。
        
        - 返回 `true`：放行请求，继续执行下一个拦截器或控制器。
            
        - 返回 `false`：中断请求，流程直接跳转到当前拦截器的 `afterCompletion`方法，不会执行控制器。
            
        
    
2. **`postHandle`（后置处理）**：
    
    - **执行时机**：在**控制器方法执行完毕后、视图渲染之前**执行。
        
    - **注意**：如果控制器方法执行出现异常，此方法**不会**被调用。
        
    
3. **`afterCompletion`（完成回调）**：
    
    - **执行时机**：在整个请求处理完成**之后**执行（包括视图渲染完毕）。
        
    - **特点**：无论请求是成功处理还是中途出现异常，此方法**都会**被调用。它类似于 `finally`代码块，非常适合进行资源清理、记录最终日志等操作。
        
    

#### 多拦截器的执行顺序

当存在多个拦截器时，它们的执行顺序遵循 **“先进后出”** 的栈式规则：

- **`preHandle`** 按配置的**正序**执行：`Interceptor1`-> `Interceptor2`。
    
- **`postHandle`** 按配置的**逆序**执行：`Interceptor2`-> `Interceptor1`。
    
- **`afterCompletion`** 按配置的**逆序**执行：`Interceptor2`-> `Interceptor1`。
    
#### [[ 拦截器顺序的源码解析]]

---


### 三、拦截器的定义和配置（Spring boot 和 Spring MVC对比）

这是一个非常好的问题。Spring Boot 和 Spring MVC 在拦截器的**核心机制**上**完全一致**，但在**配置方式**上，Spring Boot 做了极大的简化，遵循了“约定大于配置”的原则。

下面这张表格清晰地概括了它们的核心区别与联系：

|特性|Spring MVC|Spring Boot|
|---|---|---|
|**拦截器定义**|**完全相同**：实现 `HandlerInterceptor`接口，重写 `preHandle`, `postHandle`, `afterCompletion`方法。|**完全相同**|
|**核心配置方式**|在 **XML 文件**中配置 ``|使用 **Java 配置类**，实现 `WebMvcConfigurer`接口|
|**配置复杂度**|相对繁琐，需编写 XML|**极其简单**，使用纯 Java 代码，类型安全|
|**底层机制**|**完全相同**：依赖于 Spring MVC 的 `DispatcherServlet`和拦截器链机制。|**完全相同**|
|**主要区别**|**配置方式传统、繁琐**|**配置方式现代、简洁**|

---

#### Step1.定义拦截器（两者完全一样）： 核心机制完全相同

定义一个类，选择性实现 HandlerInterceptor的接口的三个方法，

```
// 这个拦截器类在Spring MVC和Spring Boot中通用，无需任何修改
@Component
public class MyCustomInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle 执行 - 在控制器方法之前");
        // 例如：登录校验、日志记录
        return true; // 只有返回true才会继续流程
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle 执行 - 在控制器方法之后，视图渲染之前");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion 执行 - 在整个请求完成之后");
    }
}
```

#### Step2：配置拦截器到框架中： 核心区别

最大的不同在于如何将拦截器“注册”到系统中，并指定它拦截哪些路径。

##### 1. Spring MVC 中的配置（主要使用 XML）

在传统的 Spring MVC 项目中，通常在 `spring-mvc.xml`等配置文件中使用 XML 来声明拦截器。

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="...">

    <!-- 1. 定义拦截器Bean -->
    <bean id="myInterceptor" class="com.example.MyCustomInterceptor"/>

    <!-- 2. 配置拦截器链 -->
    <mvc:interceptors>
        <!-- 可以配置多个拦截器 -->
        <mvc:interceptor>
            <!-- 指定要拦截的路径模式 -->
            <mvc:mapping path="/api/**"/>
            <!-- 指定要排除的路径 -->
            <mvc:exclude-mapping path="/api/public/**"/>
            <!-- 引用上面定义的拦截器Bean -->
            <ref bean="myInterceptor"/>
        </mvc:interceptor>
        
        <!-- 另一个拦截器 -->
        <!-- <mvc:interceptor> ... </mvc:interceptor> -->
    </mvc:interceptors>
</beans>
```

**缺点**：XML 配置较为冗长，不够灵活，且不是类型安全的（拼写错误可能在运行时才发现）。

##### 2. Spring Boot 中的配置（使用 Java Config - 更简洁）

在 Spring Boot 中，我们通过一个配置类来实现同样的功能，这种方式更加现代、简洁和强大。
- 该类为配置类@Configuration，被Spring扫描到
- 配置类实现 WebMvcConfigurer接口的addInterceptors
	- 在这方法中用registry配置拦截器
		- **加入拦截器**addInterceptor
		- 设置拦截器的**拦截路径** addPathPatterns
		- 设置拦截器的**不拦截路径**excludePathPatterns
		- 设置拦截器的**执行顺序** order

```
@Configuration
public class WebMvcConfig implements WebMvcConfigurer { // 实现此接口

    // 自动注入拦截器
    @Autowired
    private MyCustomInterceptor myCustomInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 将拦截器添加到Registry中，并配置拦截规则
        registry.addInterceptor(myCustomInterceptor)
                .addPathPatterns("/api/**")        // 拦截所有以 /api 开头的路径
                .excludePathPatterns("/api/login", "/api/register"); // 排除登录和注册接口

        // 可以继续添加更多拦截器，它们的执行顺序就是添加的顺序
        // registry.addInterceptor(new AnotherInterceptor())...
    }
}
```

**优势**：

- **类型安全**：使用 Java 代码和 IDE 的自动补全，避免拼写错误。
    
- **功能强大**：可以方便地使用循环、条件判断等 Java 特性来动态配置路径。
    
- **易于调试**：可以在配置逻辑中添加断点进行调试。
    

如果拦截器不需要任何自定义依赖（即不需要使用 `@Autowired`注入其他 Bean），你可以直接通过 `new`来创建实例，这使得配置更加简洁。

```
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 直接 new 一个实例，适用于无依赖的简单拦截器
        registry.addInterceptor(new MyCustomInterceptor())
                .addPathPatterns("/**"); // 拦截所有路径
    }
}
```

