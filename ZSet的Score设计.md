- 目标：实现按照多信息综合排序
	- 确保主排序因子占据高位，具有最高优先级；而次排序因子占据低位，只在主排序因子相同时起作用。
- 设计思路：
	- 固定小数位拼接方案
		```
		复合分数 = 主分数 + (1 - 归一化时间戳)
		```

		- 归一化时间戳的设计目的：
			- 确保时间部分足够“小”以至于永远不会影响整数部分（点赞数）的排序
				- 如果采用简单的字符串拼接（如 `"点赞数.时间戳"`）再转为 double，一旦拼接后的数字长度超过16位，时间戳部分就会丢失精度，导致排序错乱。
		- 实现方式：我们需要将一个足够大的数（例如 10¹³）作为分母。公式可以具体为：
			```
			复合分数 = 点赞数 + (1 - 创建时间戳 / 10^13)
			```

	- 动态小数位计算方案
		- 并发安全的实现：借助 Lua 脚本 在 Redis 服务端原子化地完成“查询-计算-写入”流程，以保证并发安全。
		- 工作模式：
			-  当一条点评首次达到某个点赞数（如100）时，将其 `score` 设置为 `100.9`。
			- 当第二条点评也达到100赞时，系统会查询当前ZSet中 `score` 在 `(100, 101)` 区间内的第一个成员及其分数。假设查到的分数是 `100.9`，则通过一个函数（如 `新小数 = 1 / (0.1 + 1/0.9)`）计算出一个更小的小数（如 `0.85`），然后将新成员的 `score` 设为 `100.85`。这样，后到的成员分数更小，排名自然靠后。
		- 更新的复杂度为O(logN)