---
aliases:
---
#### 1. 代理机制的限制

Spring的事务管理基于AOP的动态代理实现。这意味着调用事务方法时，需要经过Spring生成的代理对象，由它在方法执行前后加入事务管理逻辑（如开启、提交/回滚事务）。

- **非Public方法**：
	- 原因：Spring的AOP代理默认只能拦截`public`方法。如果将`@Transactional`注解应用于`protected`, `private`或包级权限的方法，代理对象无法为这些方法添加事务增强逻辑，导致事务失效。
	- 解决方案：**遵守方法可见性**
		- 始终将`@Transactional`注解用于`public`方法
    
- **同类方法自调用**：这是最常被忽略的问题之一。
	- 当一个类中的非事务方法A直接调用同一个类中的事务方法B时（例如通过`this.methodB()`），这个调用**绕过了代理对象**，直接作用于目标对象本身，因此事务拦截器不会生效。
	- 解决方案：**获取代理对象调用**
		- **（推荐）代码重构**：将需要事务管理的方法抽取到另一个独立的Service类中。这样通过依赖注入调用，自然经过代理对象
		- **获取代理对象调用**：在类中通过`@Autowired`或`ApplicationContext`注入自身的代理实例，然后通过这个实例调用事务方法。也可以配置`@EnableAspectJAutoProxy(exposeProxy = true)`，然后使用`(YourService) AopContext.currentProxy()`获取当前代理对象再调用
    
    。
#### 2. 异常处理不当

事务的回滚是由事务管理器捕获到特定异常来触发的。
- **默认回滚异常类型**：
	- 原因：`@Transactional`注解默认只在抛出**运行时异常（`RuntimeException`）** ​ 和**错误（`Error`）** 时回滚事务。如果方法抛出的是**受检异常（如`IOException`, `SQLException`）**，或者是你自定义的继承自`Exception`的异常，Spring默认会**提交事务**。
	- 解决方案：**显式指定回滚异常**
		- 根据业务需要，使用`@Transactional(rollbackFor = Exception.class)`来确保在抛出受检异常时也能触发回滚
    
- **异常被“吞掉”**：
	- 原因：如果在事务方法内部使用`try-catch`块捕获了异常，并且没有在`catch`块中重新抛出（无论是受检异常还是运行时异常），Spring事务管理器就无法感知到异常的发生，从而不会触发回滚。
	- 解决方案：**异常必须抛出**
		- 避免在事务方法内捕获并“消化”异常。
		- 如果必须捕获
			- 请在catch块中抛出运行时异常（如`throw new RuntimeException(e)`）
			- 或在注解中指定了回滚异常类型后直接抛出原异常
#### 3. 配置与环境问题

- **数据库引擎不支持事务**：最根本的原因。例如，如果你使用MySQL，但表使用的存储引擎是**MyISAM**（不支持事务），那么所有事务设置都会失效。务必确保使用支持事务的引擎，如**InnoDB。
    
- **Bean未被Spring容器管理**：如果你的类没有被Spring容器实例化为Bean（即没有添加`@Service`, `@Component`等注解），那么类中的`@Transactional`注解自然不会被扫描和处理。
    
- **多线程调用**：Spring通过`ThreadLocal`将数据库连接绑定到当前线程。如果在事务方法内启动新线程进行数据库操作，新线程拥有独立的`ThreadLocal`，其数据库操作将使用新的连接，处于不同的事务中，无法实现原子性。
    
- **事务传播行为设置错误**：`@Transactional`的`propagation`属性配置不当会导致意外。
	- 设置为`Propagation.NOT_SUPPORTED`会以非事务方式执行，挂起当前存在的事务；
	- 而`Propagation.REQUIRES_NEW`则会开启一个独立的新事务，其回滚和提交不受外部事务影响。