---
aliases:
  - Assertion
---


---

####  ​**一、断言诞生​历史背景和设计理念**

​ **断言的历史背景**：
1. ​**代码臃肿问题**​：开发者用大量`if`检查内部假设，但生产环境需手动删除
    
2. ​**性能损耗问题**​：用异常处理逻辑错误导致不必要的性能开销（[异常](app://obsidian.md/Java%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.md)处理成本是条件检查的**34倍**）
    
3. ​**语义混淆问题**​：异常机制混用处理外部错误和内部逻辑错误

**断言的核心设计理念**：**在开发阶段用低成本的方式保证代码质量**
1. ​**生命周期分离**​
    
    - 开发/测试阶段：启用断言，严格验证内部假设
        
    - 生产环境：默认禁用，零性能开销
	    - 断言代码**始终编译到字节码**中
		- 运行时通过J**VM参数控制是否执行**​（`-ea`启用/`-da`禁用）
		- 禁用时，JVM会跳过断言检查，**但字节码中依然存在该代码**
    
2. ​**错误责任明确划分:控制可控的，适应不可控的**​
    
    - 断言错误 → 程序员责任（代码缺陷）：**根因修复**​（修改代码）
        
    - 异常错误 → 环境/用户责任（外部因素）：**弹性设计**​（重试/降级）
        
3. ​**快速失败原则**​
    
    - 违反内部假设时立即终止，避免错误状态传播，污染环境
        
    - 提供清晰的错误上下文，加速问题定位
 
 **断言 vs 异常：定位差异**

|​**维度**​|断言（Assert）|异常（Exception）|
|---|---|---|
|​**目标场景**​|调试期参数/状态验证|生产环境可预见错误处理|
|​**性能影响**​|生产环境零开销|始终存在执行路径|
|​**错误类型**​|程序逻辑错误（Bug）|外部条件问题（如IO失败）|
|​**处理方式**​|立即崩溃（快速失败）|可捕获恢复|
|​**启用方式**​|JVM参数显式开启|始终生效|

> 黄金实践：用断言守卫**永不应发生**的条件（如算法前置条件），用异常处理**可能发生**的故障（如用户输入错误）

> 最好的文档不是写在注释里，而是写在可执行的断言中。
---

####  ​**二、断言语法双形态详解**​

​**形态1：布尔条件守卫**​

```
assert condition;
// 示例：验证非空
assert obj != null;
```

​**触发效果**​：条件为false时抛出无消息的`AssertionError`

​**形态2：诊断消息增强**​

```
assert condition : expression;
// 示例：带详细诊断
assert userId > 0 : "非法用户ID: " + userId;
```
**好的断言消息应包含：**
- 期望的条件描述
- 实际的运行时值
- 相关上下文信息
---

#### **三、字节码真相**​

```
// 编译后等效代码
if (!$assertionsDisabled && !condition) {
    throw new AssertionError(expressionResult); 
}
```

> `$assertionsDisabled`是编译器注入的常量，生产环境为true


---

####  ​**四、启用与禁用机制**​

​**运行时控制**​：
启用是ea，关闭是da
```
# 启用所有断言
java -ea MyApplication

# 启用特定包
java -ea:com.mycompany... MyApp

# 禁用特定类
java -ea -da:com.mycompany.Utils MyApp
```

​**编程式控制（罕见需求）​**​：

```
ClassLoader loader = Thread.currentThread().getContextClassLoader();
loader.setPackageAssertionStatus("com.mycompany", true);
```

---

