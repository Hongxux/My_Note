- 含义：MySQL 利用索引的有序性，只扫描每个分组对应的少量索引条目
- 好处：免了创建临时表和额外的排序操作，显著提升性能
- 对比：紧凑索引扫描，需要扫描所有满足条件的索引键
- 触发条件：
	- 查询基于单张表
	- 索引要求：
		- `GROUP BY`子句中指定的所有列必须是某个索引的**最左前缀**且**连续**的部分
			- 示例：索引是 `(c1, c2, c3)`，`GROUP BY c1, c2`符合，但 `GROUP BY c2, c3`或 `GROUP BY c1, c3`就不符合
		- 索引不能是**前缀索引**
	- 如果查询使用了聚合函数
		- 聚合函数要求：
			- 通常只能使用 **`MIN()`和 `MAX()`**
			- 从 MySQL 5.5 开始，也支持 `COUNT(DISTINCT col)`、`SUM(DISTINCT col)`、`AVG(DISTINCT col)`等特定形式
		- 作用的列要求：作用于索引中的列
	- 关于WHERE
		- 要求：​如果 `WHERE`子句中引用了 `GROUP BY`指定的列之外的索引其他部分，这些列必须以**常量形式**出现（等值条件）
		- 示例：有索引 `(c1, c2, c3)`，`WHERE c2 = 'a' GROUP BY c1, c3`是允许的，因为常量 `c2='a'`填补了索引前缀的"间隙"
- 基于此改造SQL：
	- **精心设计复合索引**：这是最根本的一点。根据你的高频 `GROUP BY`场景，创建合适的复合索引。例如，如果经常按 `region`和 `year`分组并计算 `sales`的极值，那么创建 `(region, year, sales)`这样的索引就非常合适。
	- **确保查询符合条件**：你的SQL语句需要满足一些严格条件，除了上述场景，还包括：
	    - 如果查询中有 `WHERE`条件，那么对于索引中那些不在 `GROUP BY`中的列，应以常量形式出现（例如 `WHERE other_indexed_column = 'constant'`）。
	    - 索引必须基于列的完整值，不能是前缀索引
- 判断方式：使用 `EXPLAIN`命令分析查询，**Extra**​ 列中看到了 **`Using index for group-by`**