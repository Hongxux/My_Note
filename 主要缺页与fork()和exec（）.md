主要缺页（Major Page Fault）的发生与 `exec()`和 `fork()`后的内存映射状态密切相关，但触发条件和具体原因略有不同。以下是详细分析：

---

### ​**1. `exec()`系统调用：加载新程序**​

- ​**发生了什么？​**​
    
    `exec()`会用新程序**完全替换**当前进程的地址空间：
    
    1. 销毁旧地址空间（清除页表映射）。
        
    2. 为新程序的代码段（`.text`）、初始化数据段（`.data`）、未初始化数据段（`.bss`）等建立**文件映射**。
        
        - 这些映射是**只读**​（代码段）或**可读写**​（数据段）的。
            
        - ​**关键点：此时仅建立了虚拟地址到磁盘文件的映射关系，物理内存中尚未加载任何内容！​**​
            
            页表项（PTE）的 ​**Present Bit = 0**，表示页面不在物理内存中。
            
        
    
- ​**何时触发主要缺页？​**​
    
    当进程**首次访问**这些映射区域的指令或数据时（例如执行第一条指令或读取全局变量）：
    
    1. CPU 访问虚拟地址 → MMU 查页表 → 发现 PTE 的 Present Bit = 0 → 触发缺页中断。
        
    2. 操作系统识别到这是一个**文件映射页**。
        
    3. 分配物理页帧，从磁盘上的**程序文件**中读取所需页面的内容到该页帧。
        
    4. 更新 PTE：设置 Present Bit = 1，填入物理页帧号 → ​**建立实质的物理内存映射**。
        
    5. 恢复进程执行 → 指令/访问成功。
        
    
- ​**结论：​**​
    
    ​**`exec()`后首次访问程序代码或数据，必然触发主要缺页**，因为内容尚未加载到内存。
    

---

### ​**2. `fork()`系统调用：创建子进程**​

- ​**发生了什么？​**​
    
    `fork()`创建子进程时，采用**写时复制（Copy-on-Write, COW）​**​ 策略：
    
    1. 子进程**继承父进程的整个地址空间**​（复制页表）。
        
    2. 操作系统将父子进程所有**可写页面**的 PTE 标记为 ​**只读（Read-Only）​**。
        
    3. 共享的**只读页面**​（如代码段）保持原权限。
        
    4. ​**关键点：此时父子进程共享相同的物理页帧！物理内存中已有内容，但可写页的权限被降级。​**​
        
    
- ​**何时触发主要缺页？​**​
    
    当**任一进程（父或子）尝试写入**一个被标记为 COW 的共享页面时：
    
    1. CPU 执行写指令 → MMU 查页表 → 发现权限冲突（尝试写只读页）→ 触发缺页中断。
        
    2. 操作系统识别到这是 ​**COW 场景**。
        
    3. 分配一个**新的物理页帧**。
        
    4. ​**复制原共享页的内容**到新页帧。
        
    5. 更新**当前进程**的 PTE：指向新页帧，并恢复**可写权限**。
        
    6. 恢复进程执行 → 写操作成功。
        
        ​**注意：此过程是 Minor Fault（不涉及磁盘I/O），因为数据已在内存！​**​
        
    
- ​**何时会触发 _主要_缺页？​**​
    
    如果**原共享的物理页已被换出到磁盘**​（例如系统内存紧张时）：
    
    1. 进程尝试写 COW 页 → 触发缺页中断。
        
    2. 操作系统发现原页不在内存（其 PTE 的 Present Bit = 0）。
        
    3. 需要先将原页**从磁盘（交换区）换入内存**​（触发一次磁盘I/O）。
        
    4. 然后再执行 COW 复制到新页帧。
        
    5. 此时整个流程涉及磁盘I/O，​**构成一次主要缺页**。
        
    
- ​**结论：​**​
    
    `fork()`本身通常**不直接导致主要缺页**。
    
    - 首次写入 COW 页通常触发 ​**Minor Fault**​（内存复制）。
        
    - 仅当**原共享页已被换出**时，写入才会触发 ​**Major Fault**​（需从磁盘换入）。
        
    

---

### ​**总结：主要缺页的核心触发条件**​

|​**系统调用**​|​**典型场景**​|​**是否触发 Major Fault?​**​|​**原因**​|
|---|---|---|---|
|​**`exec()`**​|首次访问代码/数据|​**是**​|内容尚未从程序文件加载到内存（需磁盘I/O）|
|​**`fork()`**​|首次写入共享页（原页在内存）|​**否**​ (Minor Fault)|权限冲突，需内存复制（COW）|
|​**`fork()`**​|首次写入共享页（原页已被换出）|​**是**​|需先将原页从磁盘换入，再执行 COW（需磁盘I/O）|

​**核心本质：​**​

主要缺页发生的根本原因是 ​**​“需要从磁盘加载数据到物理内存”​**。`exec()`后首次访问必然满足此条件；`fork()`后的 COW 写入仅在原页被换出时才满足此条件。