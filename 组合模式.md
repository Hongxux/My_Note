## 具体实现解析

### 1. 传统继承方式的问题

```
class Employee implements Comparable<Employee> {
    // 固定实现一种比较逻辑
    public int compareTo(Employee other) {
        return Double.compare(this.salary, other.salary);
    }
}

// 问题：无法按姓名排序，除非修改类本身
```

### 2. 组合模式解决方案

```
// 步骤1：定义比较器接口
interface Comparator<T> {
    int compare(T o1, T o2);
}

// 步骤2：实现多种比较策略
class SalaryComparator implements Comparator<Employee> {
    public int compare(Employee e1, Employee e2) {
        return Double.compare(e1.getSalary(), e2.getSalary());
    }
}

class NameComparator implements Comparator<Employee> {
    public int compare(Employee e1, Employee e2) {
        return e1.getName().compareTo(e2.getName());
    }
}

// 步骤3：在排序时组合使用
public void sortEmployees(List<Employee> staff, Comparator<Employee> comp) {
    // 使用传入的比较器进行排序
    // ...
}
```

## 组合模式的优势

### 1. 解耦类与比较逻辑

```
classDiagram
    class Employee
    class Comparator {
        <<interface>>
        compare()
    }
    class SalaryComparator
    class NameComparator
    
    Employee <-- Comparator : 被比较
    Comparator <|.. SalaryComparator
    Comparator <|.. NameComparator
```

- Employee类不再需要实现Comparable
    
- 比较逻辑完全由外部Comparator控制
    

### 2. 运行时动态切换策略

```
// 根据不同场景使用不同比较器
if (sortBySalary) {
    sorter.sort(employees, new SalaryComparator());
} else {
    sorter.sort(employees, new NameComparator());
}
```

### 3. 支持无限扩展

```
// 新增比较策略无需修改已有类
class SeniorityComparator implements Comparator<Employee> {
    public int compare(Employee e1, Employee e2) {
        return e1.getHireDate().compareTo(e2.getHireDate());
    }
}
```

## 组合模式在Java中的应用

Java标准库中的实际应用：

```
// 使用匿名内部类实现
Collections.sort(employees, new Comparator<Employee>() {
    public int compare(Employee e1, Employee e2) {
        return e1.getDepartment().compareTo(e2.getDepartment());
    }
});

// Lambda表达式简化
Collections.sort(employees, 
    (e1, e2) -> e1.getDepartment().compareTo(e2.getDepartment()));
```

## 组合模式 vs 继承方式

|特性|继承方式 (Comparable)|组合方式 (Comparator)|
|---|---|---|
|比较策略|固定（类内部实现）|灵活（外部注入）|
|扩展性|修改类本身|新增Comparator实现|
|多策略支持|困难（需修改类）|天然支持|
|类职责|过重（包含业务+比较）|单一（仅业务）|
|测试难度|高（需构造完整对象）|低（可单独测试比较器）|

## 真实场景案例

假设需要支持多种排序方式：

```
// 创建比较器集合
Map<String, Comparator<Employee>> comparators = new HashMap<>();
comparators.put("salary", new SalaryComparator());
comparators.put("name", new NameComparator());
comparators.put("department", new DepartmentComparator());

// 根据用户选择使用不同比较器
public void sortEmployees(String sortField) {
    Comparator<Employee> comp = comparators.get(sortField);
    if (comp != null) {
        employees.sort(comp);
    }
}
```

​**组合模式的核心价值**​：将**比较算法**这个易变的部分从稳定的业务对象中分离出来，通过组合的方式实现动态行为配置，符合开闭原则（对扩展开放，对修改关闭）。