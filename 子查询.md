
### 基本概念

​**子查询**​：在SQL语句中嵌套的SELECT查询语句

```
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```
##### 关键注意事项

1. ​**子查询必须用括号包围**​
    
2. ​**FROM后的子查询必须指定别名**​
    
3. ​**确保子查询返回的结果类型与外部查询匹配**​
    
4. ​**合理使用EXISTS/NOT EXISTS优化性能**
### 子查询分类

#### 按结果类型分类

|类型|结果特征|使用场景|
|---|---|---|
|​**标量子查询**​|返回单个值（一行一列）|与比较运算符（=, >, <等）配合使用|
|​**列子查询**​|返回一列数据（一列多行）|与IN、ANY/SOME、ALL等运算符配合|
|​**行子查询**​|返回一行数据（一行多列）|需要同时比较多个字段时使用|
|​**表子查询**​|返回多行多列结果集|作为临时表参与查询|

#### 按位置分类

|位置|语法示例|说明|
|---|---|---|
|​**WHERE之后**​|`SELECT ... WHERE col = (子查询)`|作为过滤条件|
|​**FROM之后**​|`SELECT ... FROM (子查询) AS tmp`|作为派生表（必须别名）|
|​**SELECT之后**​|`SELECT col, (子查询) FROM ...`|作为查询结果的列|

### 分类

#### 标量子查询（单个值）

```
-- 查询工资高于平均工资的员工
SELECT name, salary 
FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);
```

标量子查询是指子查询返回的结果是单个值（一行一列）的查询形式。这种子查询的结果可以是数字、字符串或日期等简单值。

常用操作符包括：`=`、`<>`、`>`、`>=`、`<`、`<=`。

​**示例：​**​

```
-- 查询工资高于平均工资的员工
SELECT name, salary 
FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 查询与指定员工薪资相同的员工信息
SELECT name, position 
FROM employees 
WHERE salary = (SELECT salary FROM employees WHERE id = 1001);
```

​**关键点：​**​

- 子查询必须放在括号内
    
- 子查询结果必须是单个值
    
- 通常与比较运算符配合使用
    
- 可出现在SELECT、WHERE、HAVING子句中
 
#### 列子查询（一列多行）
子查询得到的那一列可以看做列表如（2,3,4）

```
-- 查询在特定部门的员工
SELECT name 
FROM employees 
WHERE dept_id IN (SELECT id FROM departments WHERE name LIKE '销售%');
```
列子查询是指子查询返回的结果是一列数据（可以包含多行记录），常用于过滤条件中。常用的操作符包括：

| 操作符    | 描述                       |
| ------ | ------------------------ |
| IN     | 在指定的集合范围之内，多选一           |
| NOT IN | 不在指定的集合范围之内              |
| ANY    | 子查询返回列表中，有任意一个满足即可       |
| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |
| ALL    | 子查询返回列表的所有值都必须满足         |
列子查询是指子查询返回的结果是一列数据（可以包含多行记录），常用于过滤条件中。常用的操作符包括：

|操作符|描述|
|---|---|
|IN|在指定的集合范围之内，多选一|
|NOT IN|不在指定的集合范围之内|
|ANY|子查询返回列表中，有任意一个满足即可|
|SOME|与ANY等同，使用SOME的地方都可以使用ANY|
|ALL|子查询返回列表的所有值都必须满足|

| 操作符组合    | 等价含义                  | 实际效果        |     |
| -------- | --------------------- | ----------- | --- |
| `= ANY`  | `IN`                  | 等于子查询中的任意值  |     |
| `<> ALL` | `NOT IN`              | 不等于子查询中的所有值 |     |
| `> ANY`  | `> (SELECT MIN(...))` | 大于最小值       |     |
| `> ALL`  | `> (SELECT MAX(...))` | 大于最大值       |     |
| `< ANY`  | `< (SELECT MAX(...))` | 小于最大值       |     |
| `< ALL`  | `< (SELECT MIN(...))` | 小于最小值       | ​   |
**具体使用示例：​**​

```
-- IN操作符：查询在销售部或技术部的员工
SELECT name FROM employees 
WHERE dept_id IN (SELECT id FROM departments WHERE name IN ('销售部', '技术部'));

-- NOT IN操作符：查询不在管理层的员工
SELECT name FROM employees 
WHERE id NOT IN (SELECT manager_id FROM departments WHERE manager_id IS NOT NULL);

-- ANY操作符：查询工资高于任意一个经理的员工
SELECT name FROM employees 
WHERE salary > ANY (SELECT salary FROM managers);

-- ALL操作符：查询工资高于所有经理的员工
SELECT name FROM employees 
WHERE salary > ALL (SELECT salary FROM managers);
```

#### 行子查询（一行多列）
要进行多个条件判断
```
-- 查询与指定员工职位和薪资相同的员工
SELECT name, job_title, salary
FROM employees
WHERE (job_title, salary) = (SELECT job_title, salary FROM employees WHERE id = 1001);
```

#### 表子查询（多行多列）

```
-- 将子查询结果作为临时表
SELECT e.name, d.dept_name
FROM employees e
JOIN (SELECT id, name AS dept_name FROM departments WHERE status = 'active') d 
ON e.dept_id = d.id;
```

表子查询是指子查询返回的结果是多行多列的完整结果集，通常作为临时表参与查询。

|操作方式|语法结构|功能描述|注意事项|
|---|---|---|---|
|​**FROM子句中的表子查询**​|`SELECT ... FROM (subquery) AS alias`|将子查询结果作为临时派生表|必须使用别名|
|​**JOIN操作中的表子查询**​|`SELECT ... JOIN (subquery) AS alias ON ...`|将子查询结果作为连接表|别名必须，可建立索引优化|
|​**INSERT操作中的表子查询**​|`INSERT INTO table SELECT ... FROM ...`|将查询结果插入目标表|字段结构和数量必须匹配|
|​**CREATE TABLE中的表子查询**​|`CREATE TABLE new_table AS SELECT ...`|根据查询结果创建新表|可复制表结构和数据|

​**具体使用示例：​**​

```
-- FROM子句中的表子查询：查询部门平均工资高于公司平均工资的部门
SELECT dept_name, avg_salary 
FROM (SELECT d.name as dept_name, AVG(e.salary) as avg_salary 
      FROM departments d 
      JOIN employees e ON d.id = e.dept_id 
      GROUP BY d.id) AS dept_stats 
WHERE avg_salary > (SELECT AVG(salary) FROM employees);

-- JOIN操作中的表子查询：连接经过筛选的临时表
SELECT e.name, d.dept_name, d.employee_count
FROM employees e
JOIN (SELECT dept_id, COUNT(*) as employee_count 
      FROM employees 
      GROUP BY dept_id 
      HAVING COUNT(*) > 5) AS d 
ON e.dept_id = d.dept_id;

-- INSERT操作中的表子查询：将查询结果插入新表
INSERT INTO high_salary_employees 
SELECT id, name, salary 
FROM employees 
WHERE salary > 10000;

-- CREATE TABLE中的表子查询：创建部门统计表
CREATE TABLE dept_summary AS 
SELECT d.id, d.name, COUNT(e.id) as emp_count, AVG(e.salary) as avg_salary
FROM departments d 
LEFT JOIN employees e ON d.id = e.dept_id 
GROUP BY d.id, d.name;
```

​**性能优化建议：​**​

- 为派生表的关键字段创建索引
    
- 避免在子查询中使用ORDER BY（除非必要）
    
- 考虑使用临时表替代复杂嵌套查询
    
- 使用EXPLAIN分析查询执行计划