---
aliases:
  - 异常
  - Exception
---
**退出操作**### [[JAVA异常体系]]
用户输入/设备错误常属**外部可控问题**​（可恢复），代码错误多属**内部逻辑缺陷**​（需修复代码）。物理限制则介于两者之间。对于前三种利用异常机制处理（重试或者降级），对于最后一种则是修改代码。
- **用户输入错误 (User Input Errors)​**：用户输入不符合预期格式或业务规则（如非法URL、非数字字符、越界值）。
- **设备错误 (Device Errors)​**：外部设备不可用或操作中断（打印机缺纸、网络中断）。
- **物理限制 (Physical Limitations)**：系统资源耗尽（磁盘满、内存不足、线程池枯竭）
- **代码错误 (Code Errors)​**：程序逻辑缺陷导致运行时状态异常（空指针、越界、状态冲突）。​
---
### **错误处理的方式**

#### 错误处理：

- **错误处理的理想方式：** 程序在运行时应能优雅应对错误，
	- **恢复到安全状态并继续**​：适用于可恢复的错误。
	- **允许保存工作并优雅终止**​：适用于不可恢复的严重错误。
　
- ​**传统错误代码的局限性**​：
    - **性能开销：** 错误码需每次调用后检查（冗余`if`），异常虽高效但**栈回溯有性能开销**
    - **返回值语义的二义性**：当**错误码与正常返回值域重叠**时（如返回整数的方法中，`-1`既是错误码又是有效结果），调用方无法区分成功与失败。​
- ​**Java异常机制的引入**​：作为替代方案，异常通过抛出对象封装错误信息，实现控制流的转移，重点在于其解决了错误代码的歧义性问题，并增强了代码可维护性。
    - 异常处理机制的核心使命：​**将程序控制权从错误发生点转移到能够妥善处理该错误的上下文**。
    - 控制权转移的具体过程是**沿调用栈向上回溯**​：
		1. 立即终止当前方法；
		2. 依次检查调用栈中是否存在匹配的`catch`块；
		3. 若找到则执行处理逻辑，否则线程终止。
		    → 这体现了**责任链模式**，而非简单跳转。
---

### [[声明异常]]
- **方法签名中`throws`子句的正确用法
- **什么时候必须声明异常，什么时候不应该声明。**
- **继承和异常的关系**
想象这样一个困境：你调用了一个读取文件的方法，但该方法没有声明可能抛出`IOException`。当文件不存在时，程序直接崩溃，你却完全不知道问题出在哪里。学习了这一节，你就会明白为什么规范地声明异常如此重要——它就像方法的"安全说明书"，**让调用者提前做好准备。**

---

### [[抛出异常]]

嗨！现在我们要解锁Java异常处理的主动技能——**如何抛出异常**。想象一下，当程序遇到无法处理的异常情况时，你不再是被动等待系统报错，而是能主动"举手示意"问题所在。这就像给你的代码装上警报系统，让错误处理更精准可控！

对于"抛出异常"（throw）这个新概念，我来帮你厘清：

- ​**解决的问题**​：当程序遇到无法继续执行的异常状态时（如文件头声明长度1024但实际只读到733字节），需要中断当前流程并通知调用者
    
- ​**副作用与解决**​：过度抛出可能导致调用链复杂化（副作用），可通过合理设计异常层次结构（如自定义业务异常）来优化
    
- ​**易混淆点**​：`throw`（主动抛出异常动作） vs `throws`（声明可能抛出的异常类型）
    

思考这个现实困境：你开发的文件解析工具遇到数据不完整时，如果只是默默返回错误码，调用者可能忽略异常继续处理，导致生成错误结果。**学会主动抛出异常后，你能强制中断流程并传递精确错误信息，避免隐蔽的数据污染问题。**

---

### 创建自己的业务异常类
- **创建动因**​：当标准异常类无法精确描述特定领域错误时（如业务规则违规、专用协议解析失败），需通过继承`Exception`或其子类（如`IOException`）实现语义扩展。
	- 例如电商系统的`InventoryShortageException`（库存不足），比通用`IllegalStateException`更能直接反映业务问题本质。
    
- ​**实现规范**​：
    
    1. ​**命名规范**​：使用`XXXException`后缀（如`FileFormatException`）
        - 继承`Exception`（受检异常）：需调用方强制处理的严重业务错误（如支付失败）
        
	    - 继承`RuntimeException`（非受检）：程序逻辑应预防的错误（如参数校验失败）
        
	        核心标准是：该错误是否应通过改进代码逻辑避免。
        
    2. ​**构造函数**​：必须提供默认构造器及带详细消息的构造器（`super(gripe)`传递消息）
	    - **默认构造器**支持快速抛出（`throw new MyException()`）
		- **带消息构造器**允许附加诊断信息（`throw new MyException("ID:123 校验失败")`）。这是Java异常体系的通用规范，确保与`printStackTrace()`等工具兼容。
    3. ​**消息机制**​：通过`getMessage()`可获取构造时传入的诊断信息
        
    
- ​**设计哲学**​：自定义异常是领域模型的一部分，应反映业务特有的错误语义，而非技术底层错误。
    

​**重点内容：​**​

1. ​**构造函数标准化**​：双构造器模式（无参+带消息）是Java异常体系的通用约定，确保与`Throwable`的消息机制兼容
    
2. ​**继承层级选择**​：根据错误性质选择合理基类（如网络相关继承`IOException`），维持异常分类体系的一致性
    
3. ​**异常轻量化**​：避免在异常中添加业务逻辑，专注错误信息传递

---
### [[捕获异常]]

- ​**解决的问题**​：防止未处理异常导致程序崩溃（如GUI程序中文件读取失败时保持界面响应）
    
- ​**副作用与解决**​：过度捕获可能掩盖真正问题（副作用），可通过精确匹配异常类型和层级控制
    
- ​**易混淆点**​：`catch`（捕获处理） vs `throws`（声明传播）
    

思考这个经典困境：你开发的文本编辑器遇到文件损坏时，如果直接崩溃，用户未保存的数据将永久丢失。但若用`try-catch`捕获异常，你既能记录错误信息，又能提示用户保存其他文件——这就是健壮性设计的魅力！

#### [[多重异常捕获]]

- ​**解决的问题**​：避免为**相似处理逻辑的异常**编写重复的catch块（代码冗余），增强可读性，提高效率。
    
- ​**副作用与解决**​：过度合并可能降低错误定位精度（副作用），可通过合理分组（相关异常合并）来平衡
    
- ​**易混淆点**​：多重捕获（同类处理合并）vs 异常继承（父子类捕获关系）

#### **[[重新抛出异常和异常链]]**

你的程序就像一个精密的传送带系统，当某个环节出现问题时，你不仅要**标记问题**，还要**保留原始故障信息**，让后续处理环节能够精准定位根源。这就是异常链技术的魅力所在！
	思考这个典型困境：你开发的数据访问层捕获了SQLException，但直接抛出SQLException会让业务层与数据库细节耦合。如果简单转换为自定义的DataAccessException，又丢失了具体的SQL错误信息。异常链技术正是解决这个两难问题的金钥匙！

- ​**解决的问题**​：在子系统封装时，既想抛出高层抽象异常，又不想丢失底层详细错误信息
    
- ​**易混淆点**​：重新抛出（原样抛出）vs 异常链（包装后抛出）
---
    
### [[资源安全保障机制]]——`finally`子句
**重点：资源清理的确定性执行逻辑**，防止异常导致资源未释放（如文件句柄/数据库连接泄漏）
**易混淆点**​：`finally`（必然执行） vs `catch`（仅异常时执行）

思考这个惊悚困境：你的服务器程序在读取百万级文件时频繁崩溃，最终发现是未关闭的文件句柄耗尽系统资源——而`finally`子句正是避免这种“灾难级BUG”的终极防线！

---
### **[[堆栈跟踪分析]]**
- ​**解决的问题**​：快速定位异常发生位置（替代了繁琐的日志埋点）
    
- ​**副作用与解决**​：传统方式性能差（捕获整个堆栈），被**StackWalker的懒加载**解决
    
- ​**易混淆点**​：`StackTraceElement`（老式API） vs `StackWalker.StackFrame`（现代API）
---
### [[异常处理准则]]