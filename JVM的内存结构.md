- 组成成分：
	- 程序计数器 Program Counter Register：
		- 作用:记住线程下一条jvm字节码指令的执行地址
			- 完成代码的流程控制，例如顺序执行、分支、循环、异常处理、线程恢复等基础功能
		- 实现方式：使用cpu寄存器
			- 存储的是偏移地址
		- 特点：
			- 线程私有的
			- 唯一一个不会出现内存溢出的区域
	- 栈：
		- 虚拟机栈：服务对象为JAVA方法
		- 本地方法栈：服务对象为[[本地方法 ]]
			- 本地方法运行环境（如调用约定、栈帧结构）与Java方法不同，需要有专门的空间来管理其执行状态
	- 堆：
		- 创建时间：JVM启动时创建
		- 功能：存储几乎所有的对象实例和数组，包括静态变量
		- 分类：
			- 分类目的：优化GC性能
			- 分类思想：绝大多数新创建的对象都是“朝生夕死”的，而存活下来的对象则会倾向于存活更久。
			- 具体分类：
				- 新生代​ ：新对象诞生后存放的场所
				- 老年代：长期存活对象的存放场所
		- 特点：
			- 线程共享，是JVM中最大且最重要的线程共享区域
			- 空间最大，大小可调节
			- 是垃圾回收（GC） 的主要场所
		- 配置：
			- 设置堆大小：通常建议将 -Xms和 -Xmx设置为相同值，以避免堆在运行时动态调整带来的性能开销
				- -Xms：设置堆的初始大小（如 -Xms512m）。
				- -Xmx：设置堆的最大大小（如 -Xmx1024m）。
			- 设置新生代比例
				- -XX:NewRatio：设置老年代与新生代的比例
					- 如 -XX:NewRatio=2表示老年代:新生代=2:1
				- -XX:SurvivorRatio：设置Eden区与一个Survivor区的比例（
					- 如 -XX:SurvivorRatio=8表示Eden:Survivor=8:1
			
		- 异常：[[堆内存溢出]]
			- 当内存不足且无法再扩展时，抛出 `OutOfMemoryError: Java heap space`
	- 方法区：
		- 含义：概念上是一个新的内存区域，逻辑上是堆的一部分，具体实现不一样![[Pasted image 20251205152212.png]]
			- JDK8以前，HotSpot是将其作为一个永生代，是堆内存的一部分
			- JDK8以后，将其变成元空间，是操作系统的内存一部分
		- 创建时间：运行时创建
		- 内容：
			- 类型信息：对每个加载的类、接口、枚举、注解
				- 全限定名（如 `java.lang.String`）
				- 直接父类的全限定名
				- 实现的接口的有序列表
				- 修饰符（如 `public`, `abstract`）
			- 域（Field）信息：类的字段信息，并记录声明的顺序
				- 字段名称
				- 类型（如 `int`, `String`）
				- 修饰符（如 `private`, `static`）
			- 方法信息：`abstract`和 `native`方法除外，包括构造方法
				- 方法名
				- 返回类型
				- 参数列表（数量和类型）
				- 修饰符
				- 关键的**字节码**
				- 操作数栈
				- 局部变量
			- 运行时常量池：
				- 编译期生成的各种**字面量**（如直接写的数字、字符串）和**符号引用**（对类、字段、方法的引用），
				- 具备动态性：可以在运行时通过 `String.intern()`方法添加字符串常量
		- 特点：
			- 线程间共享的
		- 异常：
			- 当JVM加载的类信息容量超过了方法区（元空间）的最大限制时，就会抛出 `OutOfMemoryError: Metaspace`