**需求背景：​**​

在软件开发中，经常需要创建一些**内容固定、大小固定**的集合（如列表、集合、映射）。这些集合通常用于表示：

1. ​**配置信息：​**​ 一组固定的配置项或枚举值。
    
2. ​**常量集合：​**​ 一组不会改变的常量值。
    
3. ​**方法参数或返回值：​**​ 需要传递一组固定值，且不希望调用者修改它们。
    
4. ​**内部数据结构：​**​ 作为类内部使用的、不应被外部修改的固定数据。
    
5. ​**线程安全：​**​ 不可变集合天生是线程安全的，无需同步。
    

在这些场景下，使用可变集合不仅**没有必要**，还可能带来**风险**​：

- ​**意外修改：​**​ 代码的其他部分可能错误地修改了集合内容，导致难以追踪的 Bug。
    
- ​**安全性：​**​ 如果集合暴露给外部代码（如作为 API 的一部分），不可变性可以防止外部代码破坏内部状态。
    
- ​**性能：​**​ 对于小型固定集合，不可变集合在创建和访问时可能具有性能优势（无需考虑并发控制、哈希表扩容等）。
    
- ​**清晰性：​**​ 明确地向代码阅读者传达“这个集合的内容是固定的”这一意图。
    

因此，需要一个简洁、高效且安全的方式来创建这些**小型**的、**内容不可变**的集合。

​**解决方法：​**​

现代编程语言（尤其是 Java 9 及以后版本）提供了专门的**工厂方法**来创建小型不可变集合：

**替代**了之前不够安全或不够简洁的创建方式（如 `Arrays.asList`提供的伪不可变性和 `Collections.unmodifiableXxx`的间接性），​**补充**了创建空集合和通过流创建不可变集合的能力，并在很大程度上**增强**了标准库对不可变集合的原生支持，同时也可以视为对优秀第三方实践（如 Guava）在标准库中的**实现和补充**

---

### 一、核心技能
从 Java 9 开始，可以使用 `List.of()`, `Set.of()`, `Map.of()`等静态工厂方法快速创建小集合。

​**1. 如何使用？*

```
// 创建不可变列表
List<String> list = List.of("A", "B", "C");
// 创建不可变集合
Set<String> set = Set.of("A", "B", "C");
// 创建不可变映射（键值对交替列出）
Map<String, Integer> map = Map.of("A", 1, "B", 2, "C", 3);
// 创建更多键值对的映射，使用 ofEntries
Map<String, Integer> map2 = Map.ofEntries(
        Map.entry("A", 1),
        Map.entry("B", 2),
        Map.entry("C", 3)
);
```

​**2. 三大关键特性**​

- ​**特性一：不可修改 (Unmodifiable)​**​
    
    这是最重要的特性！用这些方法创建的集合是**只读**的。任何尝试修改（如 `add`, `remove`, `set`）的操作都会抛出 `UnsupportedOperationException`异常。
    
    ```
    list.add("D"); // 错误！运行时抛出 UnsupportedOperationException
    ```
    
- ​**特性二：禁止空值和重复键**​
    
    - ​**元素/键/值不能为 `null`**。
        
    - ​**Set 的元素、Map 的键不能重复**。
        
        违反以上规则会在创建时直接抛出异常。
        
    
    ```
    List.of("A", null); // 错误！不能有 null
    Set.of("A", "A");   // 错误！元素重复
    Map.of("A", 1, "A", 2); // 错误！键 "A" 重复
    ```
    
- ​**特性三：顺序无保证 (No Guaranteed Order)​**​
    
    对于 `Set`和 `Map`，​**不要依赖**它们遍历（迭代）时的顺序。JVM 为了性能等原因可能会打乱顺序。你的程序不应该假设它们一定是某种顺序。
    

​**3. 如何得到可变集合？​**​

如果你需要一个可以修改的集合，很简单，将这些不可变集合作为参数传给一个可变集合的构造函数（这是一种常用模式）。

```
// 先创建一个不可变集合作为“模板”
List<String> immutableList = List.of("A", "B", "C");
// 再基于它创建一个可变的 ArrayList
List<String> mutableList = new ArrayList<>(immutableList);
mutableList.add("D"); // 现在可以正常添加了
```

---


    
### 二、拓展


##### **of方法重载**​
    
- `List`和 `Set`接口的 `of`方法有 11 个重载版本：从 0 个参数（创建空集合）到 10 个参数，外加一个可变参数（varargs）版本。
	
- ​**目的:​**​ 提供固定参数版本是为了效率（避免创建可变参数数组）。
	

##### **Map.ofEntries 方法**​
    
- ​**问题:​**​ `Map`接口无法直接提供可变参数的 `of`方法，因为键和值的类型是交替出现的。
	
- ​**解决方案:​**​ 提供了静态方法 `Map.ofEntries(...)`，它接受任意数量的 `Map.Entry<K, V>`对象。
	
- ​**创建 Entry:​**​ 可以使用静态方法 `Map.entry(key, value)`方便地创建 `Map.Entry`对象。
	
- ​**示例 (Example):​**​
	
	```
	import static java.util.Map.*; // 静态导入 entry 和 ofEntries
	...
	Map<String, Integer> scores = ofEntries(
		entry("Peter", 2),
		entry("Paul", 3),
		entry("Mary", 5)
	);
	```

##### ​**Collections.nCopies 方法 (Collections.nCopies Method):​**​
    
- ​**功能:​**​ `Collections.nCopies(n, anObject)`返回一个实现了 `List`接口的**不可变**对象。
	
- ​**行为:​**​ 它给人一种拥有 `n`个元素的假象，每个元素都表现为 `anObject`。
	
- ​**存储优势:​**​ 存储成本极低——`anObject`只存储一次。
	
- ​**示例 (Example):​**​
	
	```
	List<String> settings = Collections.nCopies(100, "DEFAULT"); // 包含 100 个 "DEFAULT" 的不可变列表
	```
        
##### pair的替代品​​
    
- Java 标准库没有 `Pair`类。
	
- 一些程序员使用 `Map.Entry`作为简易的 Pair 替代品。
	
	- ​**Java 9 之前:​**​ 创建 `Map.Entry`很麻烦：`new AbstractMap.SimpleImmutableEntry<>(first, second)`。
		
	- ​**Java 9 及以后:​**​ 可以使用便捷方法 `Map.entry(first, second)`创建不可变的 `Map.Entry`。
	        
    

