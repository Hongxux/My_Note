
---

### ​**一、声明异常的目的与基本语法**​

​**1. 目的**​
**明确声明了“本方法可能不成功，调用方必须做好准备。**
	方法声明中的 `throws`子句的核心目的是：​**建立方法契约**。一个方法不仅告诉编译器它会返回什么值，也告诉编译器**执行过程中可能发生哪些可预见的错误**​（特指受检异常）。

​**2. 基本语法**​

```
accessModifier returnType methodName(parameterList) throws ExceptionType1, ExceptionType2, ... {
    // 方法体
}
```

- `throws`是关键字。
    
- `ExceptionType1, ExceptionType2, ...`是该方法可能抛出的**受检异常**的类名列表，多个异常用逗号分隔。
    

​**示例：​**​

```
// 该方法声明它可能抛出两种受检异常
public void openFile(String filename) throws FileNotFoundException, SecurityException {
    // ... 方法逻辑
}
```
**3.处理流程**
当声明的异常真的发生时，运行时系统会开始**沿着调用栈向上寻找**知道如何处理该异常（`catch`该异常）的异常处理器。

---

### ​**二、必须throws的两种异常**​

1. ​**调用了抛出受检异常的方法**​：你调用的另一个方法在签名中声明了 `throws SomeCheckedException`，而你在本方法内没有捕获它。
    
    ```
    public void readConfig() throws IOException { // 必须声明，因为 Files.readString 会抛出 IOException
        String content = Files.readString(Path.of("config.txt"));
    }
    ```
    
2. ​**使用 `throw`语句抛出一个受检异常**​：你通过 `throw`关键字主动抛出一个受检异常对象。
    
    ```
    public void setAge(int age) throws IllegalArgumentException { // 虽然通常是RuntimeException，但如果是自定义的受检异常，则需声明
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        this.age = age;
    }
    ```
    

---

### ​**三、继承和方法重写时的特殊规则（子类异常声明的限制）​**​

在面向对象的继承中，子类重写超类方法时，其 `throws`子句受到**​“子类型替换原则”​**的约束，具体规则如下：

​**规则：子类重写方法声明的受检异常不能比超类方法声明的更通用（即异常类型范围不能扩大）。​**​

这意味着：

1. ​**可以抛出更具体的异常**​：子类方法可以声明抛出超类方法所声明异常的子类。
    
2. ​**可以不抛出任何异常**​：子类方法可以选择不抛出任何受检异常。
    
3. ​**绝不能抛出更通用的异常**​：子类方法不能声明抛出超类方法未声明的新受检异常，或者超类方法所声明异常的父类。
    

​**特例：如果超类方法没有声明任何受检异常，那么子类重写方法也绝不能声明任何受检异常。​**​

​**示例：​**​

```
class SuperClass {
    public void method() throws IOException {
        // ...
    }
}

class SubClass extends SuperClass {
    // ✅ 合法：抛出更具体的异常 (FileNotFoundException 是 IOException 的子类)
    @Override
    public void method() throws FileNotFoundException { ... }

    // ✅ 合法：不抛出任何异常
    @Override
    public void method() { ... }

    // ❌ 非法：抛出更通用的异常 (Exception 是 IOException 的父类)
    // @Override
    // public void method() throws Exception { ... }

    // ❌ 非法：抛出新的受检异常 (SQLException 是新的受检异常)
    // @Override
    // public void method() throws IOException, SQLException { ... }
}
```

​**设计原理：​**​ 这一规则确保了**多态**的安全性。一个使用 `SuperClass`引用的客户端代码，在捕获 `IOException`时，必须能确信无论实际对象是超类还是子类实例，所抛出的异常都不会超出 `IOException`的范围。这维护了里氏替换原则。