
### 核心定义

​**GDB**，全称 ​**GNU Debugger**，是 GNU 开源组织发布的一个强大的、面向命令行的程序调试工具。它主要用于调试用 C 和 C++ 编写的程序，但也支持其他多种编程语言（如 Go、Rust、D、Fortran 等）。

---

### 为什么需要 GDB？


GDB 可以帮助你：

- ​**暂停程序**​：在任意点暂停程序的执行。
    
- ​**单步执行**​：一行一行地执行代码，观察程序流程。
    
- ​**检查变量**​：在程序暂停时，查看变量的值是否符合预期。
    
- ​**分析调用栈**​：当程序崩溃时，查看函数调用链，定位崩溃位置。
    
- ​**修改环境**​：动态改变变量值或程序执行流程，进行测试。
    
- ​**分析核心转储**​：程序崩溃后，分析其留下的“核心转储”文件，找出崩溃原因。
    

---

### GDB 的主要功能和使用场景

#### 1. 启动和加载程序

你可以直接在命令行启动 GDB 并加载要调试的可执行文件。

```
gdb ./your_program
```

#### 2. 设置断点

这是最常用的功能。你可以在特定的函数、行号或条件下设置断点，让程序运行到那里时自动暂停。

```
(gdb) break main         # 在 main 函数入口处设置断点
(gdb) break file.c:10   # 在 file.c 文件的第 10 行设置断点
(gdb) break 15 if i==5  # 当变量 i 等于 5 时，在第 15 行暂停
```

#### 3. 运行程序

在 GDB 环境中启动你的程序。

```
(gdb) run
```

你也可以在后面带上原本需要传递给程序的命令行参数。

```
(gdb) run arg1 arg2
```

#### 4. 控制程序执行

当程序在断点处暂停后，你可以精细地控制它的执行：

- `next`：执行下一行代码（**不会**进入函数内部）。
    
- `step`：执行下一行代码（**会**进入函数内部）。
    
- `continue`：继续运行程序，直到下一个断点或程序结束。
    
- `finish`：继续运行，直到当前函数返回。
    

#### 5. 检查程序状态

程序暂停时，你可以检查各种信息：

- `print variable`：打印变量的值。`print ++variable`甚至可以修改值。
    
- `backtrace`：显示当前的函数调用栈（非常有用！用于看程序是如何一步步走到这里的）。
    
- `info locals`：显示当前函数的局部变量。
    
- `info breakpoints`：显示所有已设置的断点。
    

#### 6. 检查核心转储

当程序发生段错误等严重错误而崩溃时，系统可能会生成一个核心转储文件（core dump）。GDB 可以加载这个文件和原始程序，让你看到程序崩溃时的确切状态。

```
gdb ./your_program core
```

加载后，使用 `backtrace`命令就能立刻看到崩溃时的调用栈，极大地简化了调试过程。

---

### 一个简单的例子

假设我们有一个简单的 C 程序 `hello.c`，它有一个小错误：

```
#include <stdio.h>

int main() {
    int i = 10;
    int j = 0;
    printf("%d / %d = %d\n", i, j, i/j); // 错误：除零错误
    return 0;
}
```

编译它（**注意：编译时要加上 `-g`选项以加入调试信息**，否则 GDB 无法显示行号和变量名）：

```
gcc -g hello.c -o hello
```

使用 GDB 进行调试：

```
$ gdb ./hello
(gdb) break main    # 在 main 函数入口设断点
(gdb) run           # 运行程序
Starting program: /tmp/hello

Breakpoint 1, main () at hello.c:4
4           int i = 10;
(gdb) next          # 执行下一行
5           int j = 0;
(gdb) next
6           printf("%d / %d = %d\n", i, j, i/j); # 即将发生错误
(gdb) print j       # 查看 j 的值，发现是 0
$1 = 0
(gdb) next          # 执行这行错误代码

Program received signal SIGFPE, Arithmetic exception.
0x0000555555555159 in main () at hello.c:6
6           printf("%d / %d = %d\n", i, j, i/j);
```

GDB 准确地告诉我们，程序在第 6 行收到了一个算术异常（SIGFPE），原因是除零。

---

### 现代替代品和前端

虽然 GDB 本身是命令行工具，学习曲线较陡，但其核心调试引擎非常强大。因此，许多现代集成开发环境（IDE）如 ​**CLion、VS Code、Eclipse**​ 等，实际上都是将 GDB 作为其后端调试引擎，并为其提供了友好的图形化界面（GUI）。

这些 GUI 前端让你可以通过点击代码左侧来设置断点，在窗口中以更直观的方式查看变量和调用栈，大大降低了使用难度。
