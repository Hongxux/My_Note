- 设计思想：“按需优化”，以实现启动速度与长期运行效率的平衡
	- 绝大多数代码先由解释器快速执行，
	- 对少量热点代码则由 JIT 编译器深度优化
- 实现基础：
	- Profiling：在程序运行时收集反映其执行状态数据的过程
		- 基础 Profiling：主要记录方法调用次数和循环回边次数，用于初步判断热点代码
		- 完全 Profiling：会收集更细致的数据，例如：
		    - 分支 Profiling：记录 `if-else`等条件跳转的分支走向概率。
			    - 如果发现某个 `if`分支几乎总是被执行，就可以**裁剪掉**未执行的分支
		    - 类型 Profiling：记录方法调用的实际接收者类型（如 `obj.method()`中 `obj`的具体类型）
			    - 如果发现某个虚方法调用 99% 的情况下都是同一个具体类型，就可以进行**去虚拟化**甚至**内联**。
- 运行机制：分层编译
	- **协作流程**：
		1. 一个方法通常从第 0 层开始解释执行。
		2. 当调用次数达到阈值，它第 1 层或第 3 层（C1 编译）。
		3. 如果该方法持续是热点，并且收集到的 `Profiling`数据足够，C2 编译器就会介入，利用这些数据进行深度优化，生成高度优化的本地代码（第 4 层）来替换掉之前的版本

| 层级     | 执行引擎                         | 信息收集 (Profiling)     | 角色与目标                              |
| ------ | ---------------------------- | -------------------- | ---------------------------------- |
| **0**​ | 解释器 (Interpreter)            | 无                    | **快速启动**。所有代码最初都由此开始执行，速度最快。       |
| **1**​ | [[C1 编译器]] (Client Compiler) | 无                    | **轻量编译**。进行一些基础优化（如方法内联），编译速度快。    |
| **2**​ | C1 编译器 (Client Compiler)     | **基础 Profiling**​    | **收集数据**。收集方法调用次数、循环次数等基本信息。       |
| **3**​ | C1 编译器 (Client Compiler)     | **完全 Profiling**​    | **深度分析**。收集更详细的数据，如分支跳转频率、类型信息等。   |
| **4**​ | [[C2 编译器 ]](Server Compiler) | 利用下层收集的 Profiling 数据 | **激进优化**。基于丰富的数据进行大胆且深度的优化，追求最高性能。 |
- [[即时编译器优化手段]]

	