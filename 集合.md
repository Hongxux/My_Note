
### ​**一、接口与实现分离的设计思想**​

#### 1. ​**设计目的**​

将接口规范与具体实现解耦，使使用者**仅依赖接口定义的方法规范**，而非绑定特定实现类。

_示例：_

```
Queue<String> expressLane = new CircularArrayQueue<>();  // 依赖接口声明
```

后续可替换实现类而无需修改接口调用代码。

#### 2. ​**灵活性提升体现**​

通过接口隔离，​**更换实现类仅需修改对象构造代码**​：

```
// 原实现
Queue<String> expressLane = new CircularArrayQueue<>();
// 替换实现（仅修改构造器）
Queue<String> expressLane = new LinkedListQueue<>();
```

​**优势：​**​

- 业务逻辑代码无需调整
    
- 支持**运行时动态切换实现**（如根据数据量选择高效数据结构）
    
- 降低代码耦合度，符合开闭原则
    

---

### ​**二、Abstract抽象类的核心用途**​

#### 1. ​**目标开发者群体**​

主要服务于需要**实现自定义集合类**的开发者（如扩展特定数据结构）。

#### 2. ​**相比直接实现接口的优势**​

​**场景对比：​**​

|​**实现方式**​|​**开发复杂度**​|
|---|---|
|直接实现接口|需重写所有接口方法（即使部分方法逻辑重复）|
|继承Abstract抽象类|仅需实现核心方法，复用通用逻辑|

​**核心优势：​**​

- ​**减少模板代码**​：抽象类提供通用方法的默认实现（如`AbstractQueue`已实现部分Queue接口方法）
    
- ​**聚焦核心逻辑**​：开发者只需重写关键方法（如队列的入队/出队操作）
    
- ​**降低错误风险**​：避免遗漏接口方法的实现
    
- ​**扩展友好**​：符合模板方法模式，便于维护自定义实现
    

#### 3. ​**典型应用示例**​

```
// 自定义队列通过继承AbstractQueue简化开发
class CustomQueue extends AbstractQueue<String> {
    @Override
    public boolean offer(String e) { /* 只需实现核心方法 */ }
    @Override
    public String poll() { /* 自定义出队逻辑 */ }
    // 其他方法如iterator()已由抽象类提供默认实现
}
```

> ​**设计哲学总结**​：
> 
> 接口定义行为规范 → 抽象类提供实现骨架 → 具体类完成核心逻辑，形成**​「接口-抽象-具体」三级扩展体系**，最大化平衡灵活性与开发效率。

---
### 三、集合类的根接口

#### 1.Collection
`Collection`的子接口是`List`、`Set`、`Queue`
两个基础方法：add()和iterator()
![[Pasted image 20251026191735.png]]
- **add()方法**：
	- 返回值明确操作是否实际生效
		- 返回值为true，代表添加操作改变了集合;false表示没有改变集合
		- 对不允许重复的`Set`，添加重复元素时返回`false`，让调用者知晓操作无效，避免隐性失败。
	- **`add`方法在哪些集合中可能抛出异常？​**​
		**答**​：
		- ​**不可变集合**​（如`Collections.unmodifiableSet`）会抛`UnsupportedOperationException`。
		- ​**有界队列满时**​（如`ArrayBlockingQueue`已满）抛`IllegalStateException`。
- **iterator()：**
	- 返回一个实现了Iterator接口的对象，可以利用这个对象一个个访问集合元素

#### 2.[[Iterator]]
**Java迭代器的独特设计**​：

- ​**与传统迭代器区别**​：Java将"元素访问"和"位置移动"绑定（调用`next()`才移动并返回元素），而C++等语言可分离操作。
    
- ​**位置概念**​：迭代器位于元素之间（如图9.3），调用`next()`是"跳过"下一个元素并返回它。

#### [[泛型工具方法]]

---
### 四、具体集合的选择

#### 一、核心思维导图：两大门派

首先，记住 Java 集合框架主要分为两大接口：`Collection`和 `Map`。

- ​**`Collection`**​： 存储单个对象的集合。
    
    - `List`： 有序、可重复。
        
    - `Set`： 无序、不可重复。
        
    - `Queue`： 队列，先进先出（FIFO）或优先级出队。
        
    
- ​**`Map`**​： 存储键值对（Key-Value）的集合。
    

---

#### 二、`Collection`接口下的选择

##### 1. `List`的选择：有序可重复

当你需要保持元素的添加顺序，或者需要通过索引来访问元素时，使用 `List`。

| 实现类                          | 特点                                                                                      | 适用场景                                                                                                       |
| ---------------------------- | --------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| ​**`ArrayList`**​            | ​**基于动态数组**。​**查询快**​（通过索引，时间复杂度 O(1)），​**增删慢**​（需要移动元素，平均复杂度 O(n)）。线程不安全。              | ​**最常用的 `List`**。适用于需要频繁查询、遍历，但增删操作较少的场景。例如，从数据库查出的商品列表。                                                   |
| ​**[[Linked Lists]]**​       | ​**基于双向链表**。​**增删快**​（只需要修改指针，时间复杂度 O(1)），​**查询慢**​（需要遍历链表，平均复杂度 O(n)）。同时实现了 `Deque`接口。 | 适用于需要频繁在头尾进行插入、删除操作的场景，可以作为栈、队列或双向队列使用。                                                                    |
| ​**`Vector`**​               | 和 `ArrayList`类似，但是**线程安全**的。其方法大多用 `synchronized`修饰，因此性能较差。                             | 由于性能问题，​**已过时**。不推荐在新代码中使用。如果需要线程安全的 List，可以用 `Collections.synchronizedList(...)`或 `CopyOnWriteArrayList`。 |
| ​**`CopyOnWriteArrayList`**​ | ​**线程安全**的 List。读操作无锁，性能极高。写操作时复制整个底层数组，成本高。​**弱一致性**​（迭代器遍历的是创建迭代器时的快照）。               | 读多写少，且能容忍短暂数据不一致的场景。例如，监听器列表、缓存。                                                                           |

​**选择口诀：查多用 `ArrayList`，增删多用 `LinkedList`，线程安全找 `CopyOnWriteArrayList`。​**​

##### 2. `Set`的选择：无序不可重复

核心功能是**去重**。判断重复的依据是 `equals()`和 `hashCode()`方法。

| 实现类                   | 特点                                                                                    | 适用场景                                    |
| --------------------- | ------------------------------------------------------------------------------------- | --------------------------------------- |
| ​**[[Hash Sets]]**​   | ​**基于 `HashMap`实现**。​**无序**​（不保证插入顺序）。查询、插入、删除的速度都很快（时间复杂度接近 O(1)）。线程不安全。             | ​**最常用的 `Set`**。用于快速去重，且不关心元素顺序的场景。     |
| ​**`LinkedHashSet`**​ | ​**基于 `LinkedHashMap`实现**。是 `HashSet`的子类。​**维护元素的插入顺序或访问顺序**。性能略低于 `HashSet`。         | 既需要去重，又需要保证元素的遍历顺序与插入顺序一致的场景。例如，缓存系统。   |
| ​**[[Tree Sets]]**​   | ​**基于红黑树（自平衡二叉查找树）实现**。元素会自动按照自然顺序或指定的 `Comparator`进行**排序**。插入、删除、查询的时间复杂度为 O(log n)。 | 需要去重，并且要求元素有序的场景。例如，存储一个按分数排序的学生 ID 集合。 |

​**选择口诀：只要去重用 `HashSet`， 要保序用 `LinkedHashSet`，要排序用 `TreeSet`。​**​

##### 3. `Queue`的选择：队列

| 实现类                    | 特点                                              | 适用场景               |
| ---------------------- | ----------------------------------------------- | ------------------ |
| ​**[[Linked Lists]]**​ | 也实现了 `Deque`接口，可作双向队列。                          | 简单的队列需求。           |
| ​**`PriorityQueue`**​  | ​**优先级队列**。出队顺序由元素优先级决定（自然顺序或 Comparator）。底层是堆。 | 任务调度、有优先级的处理系统。    |
| ​**`ArrayDeque`**​     | ​**基于可扩容数组的双向队列**。效率比 `LinkedList`更高。           | 作为栈或队列使用的首选（官方推荐）。 |

---

#### 三、`Map`接口下的选择

存储键值对，核心是**通过键（Key）来操作值（Value）​**。Key 不能重复。

| 实现类                       | 特点                                                                                | 适用场景                                    |
| ------------------------- | --------------------------------------------------------------------------------- | --------------------------------------- |
| ​**`HashMap`**​           | ​**基于哈希表**。​**无序**。查询、插入、删除的速度极快（平均 O(1)）。允许 key 和 value 为 `null`。线程不安全。          | ​**最常用的 `Map`**。绝大多数键值对存储的场景。           |
| ​**`LinkedHashMap`**​     | ​**维护元素的插入顺序或访问顺序**。是 `HashMap`的子类。                                               | 需要保证元素的遍历顺序与插入顺序一致，或需要实现 LRU（最近最少使用）缓存。 |
| ​**`TreeMap`**​           | ​**基于红黑树**。Key 会自动按照自然顺序或指定的 `Comparator`进行**排序**。                                | 需要 Key 有序的场景。例如，按字典序存储配置项。              |
| ​**`Hashtable`**​         | 和 `HashMap`类似，但是**线程安全**的。性能差，​**已过时**。不允许 `null`。                                | 不推荐使用。                                  |
| ​**`ConcurrentHashMap`**​ | ​**高效的线程安全 Map**。采用分段锁（JDK7）或 CAS + synchronized（JDK8+）实现高并发读写。性能远高于 `Hashtable`。 | ​**高并发环境下替换 `HashMap`的首选**。             |

​**选择口诀：大部分情况用 `HashMap`， 要保序用 `LinkedHashMap`，要排序用 `TreeMap`，高并发用 `ConcurrentHashMap`。​**​

---

#### 四、速查表与总结

|你的需求|首选|备选/说明|
|---|---|---|
|​**存储单个元素，需要有序、可重复，且查询多**​|`ArrayList`||
|​**存储单个元素，需要有序、可重复，且频繁在中间插入/删除**​|`LinkedList`|或者重新评估数据结构|
|​**存储单个元素，只需要去重，不关心顺序**​|`HashSet`||
|​**存储单个元素，需要去重，且保持插入顺序**​|`LinkedHashSet`||
|​**存储单个元素，需要去重，且自动排序**​|`TreeSet`||
|​**存储键值对，大部分情况**​|`HashMap`||
|​**存储键值对，需要保持插入顺序**​|`LinkedHashMap`|或实现 LRU 缓存|
|​**存储键值对，需要 Key 自动排序**​|`TreeMap`||
|​**多线程环境，需要线程安全的 List**​|`CopyOnWriteArrayList`|(读极多写极少) 或 `Collections.synchronizedList`|
|​**多线程环境，需要线程安全的 Map**​|`ConcurrentHashMap`|​**绝对不要用 `Hashtable`**​|
|​**实现栈（Stack）或队列（Queue）​**​|`ArrayDeque`|官方推荐，性能优于 `Stack`和 `LinkedList`|
|​**需要优先级处理**​|`PriorityQueue`||

#### 五、最终建议

1. ​**默认选择**​：单线程下，`ArrayList`和 `HashMap`是“万金油”，在大多数情况下表现良好，优先考虑它们。
    
2. ​**权衡性能**​：没有完美的数据结构，只有最适合场景的数据结构。明确你的核心操作是查询、插入、删除还是排序。
    
3. ​**理解线程安全**​：清楚你的代码运行在单线程还是多线程环境。`Vector`和 `Hashtable`是遗留类，不要再使用。
    
4. ​**重视 `equals()`和 `hashCode()`**​：所有基于哈希的集合（`HashMap`, `HashSet`）和排序集合（`TreeMap`, `TreeSet`）都严重依赖这两个方法的正确实现。

##### 1. [[ Linked Lists]]（链表）

- ​**核心思想**​：元素（节点）通过指针相互链接，在物理内存中不要求连续存储。
    
- ​**初学者重点**​：
    
    - ​**优势**​：在列表**中间进行频繁的插入和删除**操作效率极高（O(1)，如果已知位置）。
        
    - ​**劣势**​：​**随机访问**​（根据索引获取元素）性能差（O(n)），需要从头遍历。
        
    - ​**类比**​：像一列火车，每节车厢连接下一节，但你要找第100节车厢，必须从头数过去。
        
    - ​**适用场景**​：需要实现频繁增删的队列、栈，或需要频繁在中间位置修改数据的场景。
        
    

##### 2.  Array Lists（数组列表）

- ​**核心思想**​：基于**动态扩容的数组**实现。元素在内存中连续存储。
    
- ​**初学者重点**​：
    
    - ​**优势**​：​**随机访问**性能极佳（O(1)），因为可以通过索引直接计算内存地址。
        
    - ​**劣势**​：在列表中间进行插入或删除可能导致大量元素移动，效率较低（平均O(n)）。列表容量不足时需要触发扩容，带来额外开销。
        
    - ​**类比**​：像一个电影院，拿着票（索引）可以立刻找到座位，但如果中间来了一个人，后面所有人都得挪一个位置。
        
    - ​**适用场景**​：需要频繁按索引查询、遍历，但较少在中间进行增删的场景。
        
    

##### 3.  Hash Sets（哈希集合） & 4. Tree Sets（树集合）

这两者都是`Set`接口的实现，核心特征是**不允许重复元素**。

- ​ **[[Hash Sets]]（哈希集合）​**
    
    - ​**核心思想**​：基于**哈希表**实现。使用哈希函数将元素映射到数组的某个位置。
        
    - ​**初学者重点**​：
        
        - ​**性能**​：添加、删除、查找（检查是否存在）的**平均**时间复杂度为O(1)，性能非常高。
            
        - ​**无序性**​：集合中的元素是**无序**的，不保证任何特定的遍历顺序。
            
        - ​**关键点**​：哈希函数的质量对性能至关重要。需要为存储的对象正确重写`hashCode()`和`equals()`方法。
            [[重写Object的hashcode()方法]]
            [[重写Object的equals()方法]]
        
    
##### - ​**[[Tree Sets]]（树集合）​**​
    
    - ​**核心思想**​：基于**红黑树**​（一种自平衡的二叉搜索树）实现。
        
    - ​**初学者重点**​：
        
        - ​**性能**​：添加、删除、查找的**最坏情况**时间复杂度也为O(log n)，非常稳定。
            
        - ​**有序性**​：集合中的元素是**自动排序**的（自然顺序或自定义比较器顺序）。
            
        - ​**适用场景**​：需要**元素始终保持有序**，或需要频繁进行**范围查询（如找子集）** 的场景。
            
        
    

##### 5.  Queues and Deques（队列和双端队列）

- ​**核心思想**​：表示一个等待序列，遵循“先进先出”（FIFO）或更灵活的规则。
    
- ​**初学者重点**​：
    
    - ​**Queue（队列）​**​：标准FIFO结构。重点操作：`offer`（添加队尾）、`poll`（移除队首）、`peek`（查看队首）。
        
    - ​**Deque（双端队列）​**​：允许在两端进行添加和移除。既可作FIFO队列，也可作LIFO栈（后进先出）。
        
    - ​**适用场景**​：任务调度、消息传递、广度优先搜索（BFS）、实现栈。
        
    ![[Pasted image 20251026214805.png]]
    ![[Pasted image 20251026214819.png]]
    

##### 6.  Priority Queues（优先队列）

- ​**核心思想**​：基于**堆**​（通常是二叉堆）实现。元素出队顺序不是按进入的先后，而是由**优先级**决定（通常是最小或最大元素先出）。
    
- ​**初学者重点**​：
    
    - ​**无序性**​：内部存储不一定有序，但出队操作（`poll`）总能得到当前优先级最高的元素。
        
    - ​**性能**​：入队（`offer`）和出队（`poll`）的时间复杂度为O(log n)。
        
    - ​**适用场景**​：任务调度（优先级高的先执行）、哈夫曼编码、求Top K问题等。

---
### 五、[[副本与视图]]

 副本和视图的存在让数据操作更加灵活：

- ​**视图**提供了高效的数据访问方式，适合只读操作和临时分析
    
- ​**副本**确保了数据操作的独立性，适合需要修改数据的场景

​
- **​“副本”和“视图”​**​ 的根本区别
- 四种核心视图的**特性、行为差异和适用场景**，
- 牢记 ​**​“可选操作”​**​ 这一潜在风险。
---

### 六、[[通用算法]]
**通用地操作这些数据结构**的工具方法

Java集合框架提供了一系列静态工具方法（主要位于`Collections`类中），这些方法被称为“通用算法”，因为它们可以应用于不同类型的集合，实现了代码的重用和高效开发。

利用这些现成的、高度优化的算法来完成像排序、搜索、批量填充、找极值等常见任务，从而避免开发者“重复造轮子”。