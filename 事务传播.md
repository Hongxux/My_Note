传播行为定义了**多个事务方法相互调用时，事务如何传播**的规则。

|传播行为|值|说明|适用场景|
|---|---|---|---|
|**REQUIRED**|0|默认。当前有事务就加入，没有就新建|最常见的选择|
|**SUPPORTS**|1|当前有事务就加入，没有就以非事务运行|查询方法，可有可无|
|**MANDATORY**|2|当前必须有事务，否则抛异常|必须在外层事务中调用|
|**REQUIRES_NEW**|3|新建独立事务，挂起当前事务|日志记录、次要操作|
|**NOT_SUPPORTED**|4|以非事务方式执行，挂起当前事务|不支持事务的存储|
|**NEVER**|5|以非事务方式执行，有事务则抛异常|强制非事务环境|
|**NESTED**|6|嵌套事务，MySQL不支持|复杂业务子操作|

**经典示例**：

```
@Service
public class OrderService {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void placeOrder(Order order) {
        // 主事务：订单创建
        orderDao.save(order);
        
        // 独立事务：日志记录（即使订单失败，日志也要记录）
        logService.recordOrderLog(order);
        
        // 同一事务：库存扣减（与订单同生共死）
        inventoryService.deductStock(order);
    }
}

@Service
class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void recordOrderLog(Order order) {
        // 独立事务，不受主事务回滚影响
    }
}

@Service
class InventoryService {
    @Transactional(propagation = Propagation.MANDATORY)
    public void deductStock(Order order) {
        // 必须在事务中调用
    }
}
```