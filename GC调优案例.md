### 案例1 Full GC 和 Minor GC频繁
- 原因一：新生代内存设置太小
	- 问题逻辑链：
		- 发生频繁的 [[minor GC]]
		- 幸存区空间紧张，对象过早晋升到老年代
			- 导致老年代空间紧张，引发[[Full GC]]
	- 解决措施：增大新生代内存空间，幸存区内存空间，晋升阈值
- 原因二：对象分配速率过高
	- 应用中存在大量临时对象创建，如循环内拼接字符串、频繁的日志输出（未使用占位符）
	- 解决措施：[[避免浪费堆内存]]
- 原因三：内存泄漏
- 原因四：缓存失控
	- 原因：使用了没有大小限制或淘汰策略的缓存（如简单的 `HashMap`或 `ConcurrentHashMap`），导致缓存对象无限增长
	- 优化方案：使用专业的缓存库（如 **Caffeine**、Guava Cache），并设置合理的最大容量和过期时间
### 案例2 请求高峰期发生 Full GC，单次暂停时间特别长(CMS)
- 分析哪个阶段耗时最长
	- 往往初始标记和并发标记快
	- 重新标记阶段耗时长：扫描整个堆内存
		- 业务高峰期，新生代对象多，扫描耗时长
- 解决措施：在重新标记前，先对新生代进行一次垃圾清理，减少存活对象
	- `-XX:+CMSScavengeBeforeRemark`
### 案例3 老年代充裕情况下，发生 FullGC (CMS 1.7)
- 由于永久代（堆内内存）内存空间不足，会导致Full GC
- 解决措施：
	- 增大永久代空间