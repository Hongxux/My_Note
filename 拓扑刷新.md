**拓扑刷新**是 Redis 集群客户端（如 Redisson、Lettuce）的一个关键功能，它**自动检测和更新客户端内部维护的 Redis 集群节点和槽位映射信息**。

## 🔄 拓扑刷新的工作原理

### 1. **什么是 Redis 集群拓扑？**

Redis 集群将数据分布在多个节点上，每个节点负责一部分**哈希槽**（0-16383）。集群拓扑就是这些节点与槽位的映射关系：

```
节点A: 192.168.1.101:6379 → 槽位 0-5460
节点B: 192.168.1.102:6379 → 槽位 5461-10922  
节点C: 192.168.1.103:6379 → 槽位 10923-16383
```

### 2. **为什么需要拓扑刷新？**

|场景|问题描述|拓扑刷新的作用|
|---|---|---|
|**节点故障转移**​|主节点宕机，从节点晋升|客户端自动发现新主节点地址|
|**集群扩容**​|新增节点，槽位重新分配|客户端获取新的槽位映射关系|
|**集群缩容**​|节点下线，槽位迁移|避免向已下线节点发送请求|
|**网络分区恢复**​|临时网络问题后节点恢复|重新建立与恢复节点的连接|

## ⚙️ 拓扑刷新的配置方式

### **Redisson 配置示例**

```
spring:
  redis:
    redisson:
      config: |
        clusterServersConfig:
          nodeAddresses:
            - "redis://192.168.1.101:6379"
            - "redis://192.168.1.102:6379"
          scanInterval: 5000           # 拓扑刷新间隔(毫秒)
          retryAttempts: 3             # 命令重试次数
          failedSlaveCheckInterval: 60000 # 故障节点检查间隔
```

### **Lettuce (Spring Boot) 配置示例**

```
spring:
  redis:
    lettuce:
      cluster:
        refresh:
          adaptive: true              # 自适应刷新(推荐)
          period: 2000                # 固定间隔刷新(毫秒)
        max-redirects: 3              # 最大重定向次数
```

## 🎯 拓扑刷新的工作模式

### 1. **定期刷新模式**

```
// 每5秒主动查询集群状态
config.setScanInterval(5000);
```

**适用场景**：集群稳定，变化不频繁的环境。

### 2. **自适应刷新模式（推荐）**

```
spring:
  redis:
    lettuce:
      cluster:
        refresh:
          adaptive: true    # 仅在需要时刷新
          period: 30000     # 最长刷新间隔(保底)
```

**工作逻辑**：

- 正常情况：不主动刷新，节省资源
    
- 收到 `MOVED`重定向：立即触发拓扑刷新
    
- 网络异常：按保底间隔定期检查
    

### 3. **事件驱动刷新**

```
// 监听集群变化事件
clusterClient.addListener(new RedisClusterClient.Listener() {
    @Override
    public void onTopologyRefresh() {
        System.out.println("检测到集群拓扑变化，正在刷新...");
    }
});
```

## 💡 为什么必须设置拓扑刷新？

### **避免 MOVED 重定向循环**

您遇到的错误正是因为没有正确配置拓扑刷新：

```
graph TD
    A[客户端请求 Key] --> B[根据旧拓扑路由到节点A]
    B --> C[节点A返回MOVED重定向<br>指示应访问节点B]
    C --> D[客户端仍使用旧拓扑<br>再次尝试节点A]
    D --> E[产生重定向循环<br>MOVED redirection loop detected]
    
    F[正确流程] --> G[客户端收到MOVED响应]
    G --> H[立即触发拓扑刷新]
    H --> I[更新槽位映射关系]
    I --> J[后续请求正确路由到节点B]
```

### **生产环境配置建议**

```
spring:
  redis:
    lettuce:
      cluster:
        refresh:
          adaptive: true           # 开启自适应刷新
          period: 30000            # 最大间隔30秒
          dynamic-refresh-sources: true  # 动态发现新节点
      pool:
        max-active: 16
        timeout: 2000ms
```

## 🚨 常见配置误区

### **错误配置**

```
# ❌ 错误：刷新间隔过长或关闭刷新
spring:
  redis:
    lettuce:
      cluster:
        refresh:
          adaptive: false    # 关闭自适应
          period: 300000     # 5分钟太长！
```

### **正确配置**

```
# ✅ 正确：合理的刷新策略
spring:
  redis:
    lettuce:
      cluster:
        refresh:
          adaptive: true     # 智能刷新
          period: 30000      # 30秒保底
        max-redirects: 5     # 允许合理重定向
```

## 📊 拓扑刷新性能影响

|刷新策略|网络开销|响应延迟|资源消耗|适用场景|
|---|---|---|---|---|
|**关闭刷新**​|无|高（频繁MOVED）|低|测试环境|
|**自适应刷新**​|低|低|中|**生产推荐**​|
|**频繁刷新**​|高|极低|高|高频变更集群|

## 🔧 故障排查命令

```
# 1. 检查集群当前拓扑
redis-cli -h 192.168.1.101 -p 6379 CLUSTER NODES

# 2. 查看槽位分布
redis-cli -h 192.168.1.101 -p 6379 CLUSTER SLOTS

# 3. 手动触发客户端刷新（Redisson）
RedissonClient client = ...;
client.getClusterNodesGroup().getNodes().forEach(node -> {
    node.clusterInfo();
});
```

## 💎 总结

**拓扑刷新是 Redis 集群客户端的"导航系统"**：

- 🧭 **作用**：保持客户端与集群实际状态的同步
    
- ⚡ **必要性**：避免重定向循环，提高请求效率
    
- 🎯 **推荐配置**：自适应刷新模式 + 合理超时时间
    
- 📈 **价值**：保障集群弹性伸缩和高可用性
    

正确配置拓扑刷新后，您的 `MOVED redirection loop`错误应该能够得到解决。