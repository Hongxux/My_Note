
---

### ​**虚拟内存的根本目标**​

为每个进程提供一个独立的、连续的、远超物理内存容量的[[Address spaces|虚拟地址空间]]，同时实现高效的内存利用、进程隔离和共享。

---

### ​**问题与解决方案的演变历程**​

虚拟内存技术的演进，围绕以下几个核心问题展开，其发展历程如下图所示：

#### ​**1. 核心问题：地址空间的隔离与重定位**​

- ​**问题描述**​：
    
    - 在早期系统中，进程直接访问物理内存。多个进程在内存中难以共存，容易相互覆盖。
        
    - 进程加载时需要知道具体的物理地址，难以实现灵活的内存分配。
        
    
- ​**解决方案：动态重定位（基址-界限寄存器）​**​
    
    - ​**思想**​：引入一个中间层。CPU 发出**逻辑地址**，由硬件（MMU）将其转换为**物理地址**。
        
    - ​**实现**​：每个进程配备一对**基址寄存器**和**界限寄存器**。
        
        - `物理地址 = 逻辑地址 + 基址`
            
        - ​**界限寄存器**用于检查地址是否越界，提供保护。
            
        
    - ​**优点**​：实现了进程隔离，进程可以加载到任何物理位置。
        
    - ​**缺点**​：
        
        - ​**外部碎片**​：进程必须分配连续的内存空间，导致内存中出现许多无法利用的小空闲块。
            
        - ​**粒度粗**​：无法实现更细粒度的共享（如共享库）。
            
        
    

#### ​2. 核心问题：如何更自然地管理内存？—— 引入[[Base and Bounds 和Segmentation|分段]]

- ​**问题描述**​：程序本身由逻辑上独立的段组成（代码、数据、堆、栈）。基址-界限模型将整个进程视为一个整体，不够灵活。
    
- ​**解决方案：分段**​
    
    - ​**思想**​：将地址空间划分为多个逻辑段，每个段独立管理，拥有自己的基址和界限寄存器。
        
    - ​**实现**​：逻辑地址变为 ​**​（段号，段内偏移）​**。操作系统维护一个**段表**。
        
    - ​**优点**​：
        
        - 更符合程序逻辑视图。
            
        - 允许代码段共享（多个进程的段表指向同一基址）。
            
        - 每个段可以独立增长。
            
        
    - ​**缺点**​：
        
        - ​**外部碎片更严重**​：每个段需要连续的物理内存，段的大小各异，导致内存中产生大量不规则的小空闲块。虽然可以通过**内存紧缩**解决，但代价高昂。
            
        
    

#### ​3. 革命性解决方案：消除外部碎片 —— [[page  table 页表|分页]] 

- ​**问题描述**​：分段带来的外部碎片问题严重限制了内存的利用率。
    
- ​**解决方案：分页**​
    
    - ​**思想**​：将物理内存和虚拟地址空间都划分为固定大小的单元（物理内存叫**页帧**，虚拟内存叫**页面**）。页面可以映射到任意的页帧。
        
    - ​**实现**​：通过**页表**实现虚拟页号到物理页帧号的映射。
        
    - ​**优点**​：
        
        - ​**彻底消除外部碎片**​：因为页帧是固定大小的，任何空闲页帧都可以分配给任何需要的页面。内部碎片虽然存在，但仅限于每个页的最后一小部分，平均下来可接受。
            
        - ​**支持非连续分配**​：进程的虚拟页面可以映射到物理内存中任何离散的页帧。
            
        
    - ​**新问题**​：
        
        - ​**页表规模巨大**​：例如，32位地址空间（4GB）使用4KB页，需要 2^20（约100万）个页表项。每个进程一个页表，占用大量内存。
            
        - ​**性能开销**​：每次内存访问都需要先查页表（一次访存变为两次），速度减半。
            
        
    

#### ​**4. 核心问题：巨大的页表开销**​

[[页表过大问题]]
#### ​**5. 核心问题：地址转换的性能瓶颈**​

- ​**解决方案：转换后备缓冲器（[[TLB]]）​**​
    
    - ​**思想**​：利用**局部性原理**，在CPU芯片内建立一个小的、高速的硬件缓存，用于存放最近使用过的虚拟页到物理页帧的映射。
        
    - ​**工作流程**​：MMU先查TLB，若命中则直接获得物理地址；若未命中（TLB Miss），才去走查页表的慢路径，并将新映射填入TLB。
        
    - ​**意义**​：TLB是虚拟内存能够实用化的关键，它将绝大多数地址转换的开销降到了近乎为零。
        
    

#### ​**6. 核心问题：[[页面置换策略]]与系统抖动**​

- ​**问题描述**​：当物理内存不足时[[Beyond Physical Memory]]，需要将一些页面换出到磁盘。选择换出哪个页面至关重要。糟糕的算法（如FIFO）会导致**抖动**​：系统花费大量时间在页面换入换出上，而实际工作效率极低。
[[​主动内存回收机制​（Proactive Memory Reclaim）]]]

#### 7.[[Free-Space Management空闲空间管理]]
#### ​**8. 其他重要优化**​

- ​**写时复制**​：在`fork()`创建子进程时，不立即复制父进程的地址空间，而是共享页面，并标记为只读。只有当任一进程尝试写入时，才复制该页。这极大地提高了进程创建效率。
    
- ​**按需调页**​：程序启动时并不全部加载到内存，而是只加载必要的部分，后续在缺页中断的驱动下按需加载。
    
- ​**预取**​：根据访问模式，预测并提前加载可能被访问的页面。
    

---

### ​**总结：现代虚拟内存系统的全貌**​

现代操作系统（如 Linux， Windows）的虚拟内存系统是一个高度复杂的综合体，它融合了多种技术：

|​**核心问题**​|​**最终采用的主流解决方案**​|​**设计思想**​|
|---|---|---|
|​**隔离与重定位**​|​**分页**​ 作为基础机制|引入间接层|
|​**外部碎片**​|​**分页**​（固定大小页面）|将内存单元化|
|​**大地址空间管理**​|​**多级页表**​|按需分配，树状结构|
|​**转换速度**​|​**TLB**​ + ​**多级页表**​|缓存加速，空间换时间|
|​**置换效率**​|​**Clock等LRU近似算法**​|基于访问历史，逼近最优|
|​**内存共享与快速创建**​|​**写时复制**​|延迟操作，共享优先|
|​**高效加载**​|​**按需调页**​|懒加载，按需分配|

虚拟内存的演变史，是计算机科学家和工程师们面对硬件限制，不断提出巧妙的抽象和折中方案的历史。理解这个过程，对于你深入掌握操作系统乃至整个计算机系统的工作原理至关重要。