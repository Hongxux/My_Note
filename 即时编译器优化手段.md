### 方法内联
- 优化方式：将**目标方法的方法体"复制"到调用方方法中**，从而消除方法调用的开销 。
- 优化原理：
	- 一次普通的方法调用涉及参数压栈、栈帧创建、执行地址跳转、结果返回、栈帧销毁等一系列操作。对于 `getter`/`setter`这种简单方法，调用开销可能比方法本身执行的开销还大 。
	- 内联后，这些方法调用被替换为直接的字段访问或简单操作，消除了调用开销，并且为后续更激进的优化（如常量传播、死代码消除）创造了条件 。
- 内联条件
	1. 方法热度：必须是热点方法（执行次数达到阈值，Client 模式约1500次，Server 模式约10000次）。
	2. 方法体积：有大小限制。热点方法体默认小于 325 字节，非热点方法默认小于 **35 字节**​ 才可能被内联。
- 为内联优化代码：
	- 保持方法小巧简洁：这是帮助 JVM 进行内联的最有效方式。
	- 审慎使用 `final`/`private`/`static`：这些修饰符的方法由于不可被重写，JVM 在编译时就能确定调用的具体方法，内联决策更简单、安全。但不要为了优化而破坏设计，仅在设计本身要求如此时才使用它们 。

###  基于逃逸分析的优化

逃逸分析的结果会直接驱动以下几项重要的优化措施。

#### 1. 标量替换 
这是逃逸分析带来的**最重要、最有效**的优化。
- 优化前提：一个对象被分析为**不逃逸**
- 优化方式：JVM 就可能选择**根本不创建这个完整的对象**，而是将其**分解**成一个个独立的、不能再分解的**标量**（如 `int`, `char`, `对象引用`等），然后将这些标量当作局部变量存储在**栈上或 CPU 寄存器**中使用 。
	```
	// 优化前：创建 Point 对象
	public void someMethod() {
	    Point p = new Point(10, 20); // 不逃逸的对象
	    System.out.println(p.x + p.y);
	}
	
	// JVM 可能进行标量替换后，等效于：
	public void someMethod() {
	    int x = 10; // 标量 x，存储在栈上
	    int y = 20; // 标量 y，存储在栈上
	    System.out.println(x + y);
	}
	```
- -优化原理：完全避免了在堆上分配对象的内存开销和后续的垃圾回收压力，尤其对于在循环中频繁创建的临时对象，性能提升显著 。
#### 2. 栈上分配
- 优化前提：一个对象被分析为**不逃逸**
- 优化方式：JVM 可以选择将其直接分配在**当前线程的 Java 虚拟机栈**上，而不是在共享的堆上。这样，当方法调用结束时，栈帧弹出，对象内存自动回收，无需垃圾回收器介入 。

**栈上分配 vs 标量替换**：
- 栈上分配依然是一个**完整的对象**在栈上。
- 标量替换则是将对象**分解**成多个独立的标量（基本类型或引用），甚至可能直接使用寄存器，是更彻底的优化。
- 现代 JVM（如 HotSpot）**更倾向于使用标量替换**作为主要的优化手段。
    

#### 3. 同步消除 
- 优化前提：
	- 一个对象被分析为**不逃逸**
	- 一个对象被分析为方法逃逸但确认是**线程局部**的（即不会被多个线程同时访问）
- 优化方式： JVM 会**一个对象被分析为**（如 `synchronized`块） 。
**示例：**
```
public void safeMethod() {
    Object lock = new Object(); // lock 对象不逃逸，只会被当前线程访问
    synchronized(lock) { // 同步锁会被 JVM 移除
        // 一些操作
    }
}
```
